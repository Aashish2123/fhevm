/**

Generated by the following Solidity interface...
```solidity
interface KmsContexts {
    type ContextStatus is uint8;
    struct DecryptionThresholds {
        uint256 publicDecryptionThreshold;
        uint256 userDecryptionThreshold;
    }
    struct KmsBlockPeriods {
        uint256 preActivationBlockPeriod;
        uint256 generationBlockPeriod;
        uint256 suspensionBlockPeriod;
    }
    struct KmsContext {
        uint256 contextId;
        uint256 previousContextId;
        bytes8 softwareVersion;
        uint256 mpcThreshold;
        KmsNode[] kmsNodes;
    }
    struct KmsNode {
        string name;
        address signerAddress;
        address txSenderAddress;
        uint256 partyId;
        bytes backupEncryptionKey;
        string externalUrl;
        string publicStorageUrl;
        bytes tlsCertificate;
    }

    error AddressEmptyCode(address target);
    error CompromiseActiveKmsContextNotAllowed(uint256 contextId);
    error ContextAlreadyExists(uint256 contextId);
    error ContextNotActive(uint256 contextId);
    error ContextNotActiveOrSuspended(uint256 contextId);
    error ContextNotGenerated(uint256 contextId);
    error ContextNotInitializedOrIsGenerating(uint256 contextId);
    error ContextNotPreActivatedOrSuspended(uint256 contextId);
    error DestroyActiveKmsContextNotAllowed(uint256 contextId);
    error ECDSAInvalidSignature();
    error ECDSAInvalidSignatureLength(uint256 length);
    error ECDSAInvalidSignatureS(bytes32 s);
    error ERC1967InvalidImplementation(address implementation);
    error ERC1967NonPayable();
    error EmptyKmsNodes();
    error EnforcedPause();
    error ExpectedPause();
    error FailedCall();
    error InvalidHighMpcThreshold(uint256 contextId, uint256 mpcThreshold, uint256 nKmsNodes);
    error InvalidHighPublicDecryptionThreshold(uint256 publicDecryptionThreshold, uint256 nKmsNodes);
    error InvalidHighUserDecryptionThreshold(uint256 userDecryptionThreshold, uint256 nKmsNodes);
    error InvalidInitialization();
    error InvalidNullContextId();
    error InvalidNullPublicDecryptionThreshold();
    error InvalidNullUserDecryptionThreshold();
    error KmsContextNotGenerating(uint256 contextId);
    error KmsContextNotInitialized(uint256 contextId);
    error KmsNodeAlreadyValidatedKeyResharing(uint256 contextId, address kmsSigner);
    error NoSuspendedKmsContext();
    error NotInitializing();
    error NotKmsNodeFromContext(uint256 contextId, address kmsTxSenderAddress);
    error NotKmsSignerFromContext(uint256 contextId, address signerAddress);
    error NotKmsTxSenderFromContext(uint256 contextId, address txSenderAddress);
    error NotOwnerOrPauser(address notOwnerOrPauser);
    error NumberOfKmsNodesChanged(uint256 activeKmsNodesLength, uint256 newKmsNodesLength);
    error OwnableInvalidOwner(address owner);
    error OwnableUnauthorizedAccount(address account);
    error SuspendedKmsContextOngoing(uint256 suspendedContextId);
    error UUPSUnauthorizedCallContext();
    error UUPSUnsupportedProxiableUUID(bytes32 slot);

    event ActivateKmsContext(uint256 contextId);
    event CompromiseKmsContext(uint256 contextId);
    event DeactivateKmsContext(uint256 contextId);
    event DestroyKmsContext(uint256 contextId);
    event EIP712DomainChanged();
    event Initialization(DecryptionThresholds decryptionThresholds, KmsBlockPeriods blockPeriods, bytes8 softwareVersion, uint256 mpcThreshold, KmsNode[] kmsNodes);
    event Initialized(uint64 version);
    event InvalidateKeyResharing(uint256 contextId);
    event NewKmsContext(KmsContext activeKmsContext, KmsContext newKmsContext);
    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event Paused(address account);
    event PreActivateKmsContext(KmsContext newKmsContext, uint256 preActivationBlockNumber);
    event StartKeyResharing(KmsContext activeKmsContext, KmsContext newKmsContext, uint256 generationBlockNumber);
    event SuspendKmsContext(uint256 contextId);
    event Unpaused(address account);
    event UpdateKmsContextGenerationBlockPeriod(uint256 newKmsContextGenerationBlockPeriod);
    event UpdateKmsContextSuspensionBlockPeriod(uint256 newKmsContextSuspensionBlockPeriod);
    event UpdatePublicDecryptionThreshold(uint256 newPublicDecryptionThreshold);
    event UpdateUserDecryptionThreshold(uint256 newUserDecryptionThreshold);
    event Upgraded(address indexed implementation);
    event ValidateKeyResharing(KmsContext newKmsContext);

    constructor();

    function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
    function acceptOwnership() external;
    function addKmsContext(uint256 preActivationBlockPeriod, bytes8 softwareVersion, bool reshareKeys, uint256 mpcThreshold, KmsNode[] memory kmsNodes, DecryptionThresholds memory decryptionThresholds) external;
    function checkIsKmsSignerFromContext(uint256 contextId, address signerAddress) external view;
    function checkIsKmsTxSenderFromContext(uint256 contextId, address txSenderAddress) external view;
    function compromiseKmsContext(uint256 contextId) external;
    function destroyKmsContext(uint256 contextId) external;
    function eip712Domain() external view returns (bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] memory extensions);
    function getActiveKmsContext() external view returns (KmsContext memory);
    function getActiveKmsContextId() external view returns (uint256);
    function getKmsContextGenerationBlockPeriod() external view returns (uint256);
    function getKmsContextStatus(uint256 contextId) external view returns (ContextStatus);
    function getKmsContextSuspensionBlockPeriod() external view returns (uint256);
    function getKmsNode(address kmsTxSenderAddress) external view returns (KmsNode memory);
    function getKmsNodes() external view returns (KmsNode[] memory);
    function getKmsSigners() external view returns (address[] memory);
    function getKmsTxSenders() external view returns (address[] memory);
    function getPublicDecryptionThresholdFromContext(uint256 contextId) external view returns (uint256);
    function getSuspendedKmsContextId() external view returns (uint256);
    function getUserDecryptionThresholdFromContext(uint256 contextId) external view returns (uint256);
    function getVersion() external pure returns (string memory);
    function initialize(DecryptionThresholds memory initialDecryptionThresholds, KmsBlockPeriods memory initialBlockPeriods, bytes8 initialSoftwareVersion, uint256 initialMpcThreshold, KmsNode[] memory initialKmsNodes) external;
    function moveSuspendedKmsContextToActive() external;
    function owner() external view returns (address);
    function pause() external;
    function paused() external view returns (bool);
    function pendingOwner() external view returns (address);
    function proxiableUUID() external view returns (bytes32);
    function refreshKmsContextStatuses() external;
    function renounceOwnership() external;
    function transferOwnership(address newOwner) external;
    function unpause() external;
    function updateKmsContextGenerationBlockPeriod(uint256 newKmsContextGenerationBlockPeriod) external;
    function updateKmsContextSuspensionBlockPeriod(uint256 newKmsContextSuspensionBlockPeriod) external;
    function updatePublicDecryptionThreshold(uint256 newPublicDecryptionThreshold) external;
    function updateUserDecryptionThreshold(uint256 newUserDecryptionThreshold) external;
    function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
    function validateKeyResharing(uint256 contextId, bytes memory signature) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "UPGRADE_INTERFACE_VERSION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "acceptOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "addKmsContext",
    "inputs": [
      {
        "name": "preActivationBlockPeriod",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "softwareVersion",
        "type": "bytes8",
        "internalType": "bytes8"
      },
      {
        "name": "reshareKeys",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "mpcThreshold",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "kmsNodes",
        "type": "tuple[]",
        "internalType": "struct KmsNode[]",
        "components": [
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "partyId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "backupEncryptionKey",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "externalUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "publicStorageUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "tlsCertificate",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      },
      {
        "name": "decryptionThresholds",
        "type": "tuple",
        "internalType": "struct DecryptionThresholds",
        "components": [
          {
            "name": "publicDecryptionThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "userDecryptionThreshold",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkIsKmsSignerFromContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "signerAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "checkIsKmsTxSenderFromContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "txSenderAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "compromiseKmsContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "destroyKmsContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "eip712Domain",
    "inputs": [],
    "outputs": [
      {
        "name": "fields",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "version",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "verifyingContract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "salt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "extensions",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getActiveKmsContext",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct KmsContext",
        "components": [
          {
            "name": "contextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "previousContextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "softwareVersion",
            "type": "bytes8",
            "internalType": "bytes8"
          },
          {
            "name": "mpcThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "kmsNodes",
            "type": "tuple[]",
            "internalType": "struct KmsNode[]",
            "components": [
              {
                "name": "name",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "signerAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "txSenderAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "partyId",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "backupEncryptionKey",
                "type": "bytes",
                "internalType": "bytes"
              },
              {
                "name": "externalUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "publicStorageUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "tlsCertificate",
                "type": "bytes",
                "internalType": "bytes"
              }
            ]
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getActiveKmsContextId",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsContextGenerationBlockPeriod",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsContextStatus",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "enum ContextStatus"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsContextSuspensionBlockPeriod",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsNode",
    "inputs": [
      {
        "name": "kmsTxSenderAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct KmsNode",
        "components": [
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "partyId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "backupEncryptionKey",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "externalUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "publicStorageUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "tlsCertificate",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsNodes",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "tuple[]",
        "internalType": "struct KmsNode[]",
        "components": [
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "partyId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "backupEncryptionKey",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "externalUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "publicStorageUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "tlsCertificate",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsSigners",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsTxSenders",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPublicDecryptionThresholdFromContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getSuspendedKmsContextId",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getUserDecryptionThresholdFromContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getVersion",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "initialize",
    "inputs": [
      {
        "name": "initialDecryptionThresholds",
        "type": "tuple",
        "internalType": "struct DecryptionThresholds",
        "components": [
          {
            "name": "publicDecryptionThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "userDecryptionThreshold",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      },
      {
        "name": "initialBlockPeriods",
        "type": "tuple",
        "internalType": "struct KmsBlockPeriods",
        "components": [
          {
            "name": "preActivationBlockPeriod",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "generationBlockPeriod",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "suspensionBlockPeriod",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      },
      {
        "name": "initialSoftwareVersion",
        "type": "bytes8",
        "internalType": "bytes8"
      },
      {
        "name": "initialMpcThreshold",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "initialKmsNodes",
        "type": "tuple[]",
        "internalType": "struct KmsNode[]",
        "components": [
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "partyId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "backupEncryptionKey",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "externalUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "publicStorageUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "tlsCertificate",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "moveSuspendedKmsContextToActive",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "paused",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pendingOwner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "proxiableUUID",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "refreshKmsContextStatuses",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "unpause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateKmsContextGenerationBlockPeriod",
    "inputs": [
      {
        "name": "newKmsContextGenerationBlockPeriod",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateKmsContextSuspensionBlockPeriod",
    "inputs": [
      {
        "name": "newKmsContextSuspensionBlockPeriod",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updatePublicDecryptionThreshold",
    "inputs": [
      {
        "name": "newPublicDecryptionThreshold",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateUserDecryptionThreshold",
    "inputs": [
      {
        "name": "newUserDecryptionThreshold",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "upgradeToAndCall",
    "inputs": [
      {
        "name": "newImplementation",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "validateKeyResharing",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "signature",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "ActivateKmsContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "CompromiseKmsContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DeactivateKmsContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DestroyKmsContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EIP712DomainChanged",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialization",
    "inputs": [
      {
        "name": "decryptionThresholds",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct DecryptionThresholds",
        "components": [
          {
            "name": "publicDecryptionThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "userDecryptionThreshold",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      },
      {
        "name": "blockPeriods",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct KmsBlockPeriods",
        "components": [
          {
            "name": "preActivationBlockPeriod",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "generationBlockPeriod",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "suspensionBlockPeriod",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      },
      {
        "name": "softwareVersion",
        "type": "bytes8",
        "indexed": false,
        "internalType": "bytes8"
      },
      {
        "name": "mpcThreshold",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "kmsNodes",
        "type": "tuple[]",
        "indexed": false,
        "internalType": "struct KmsNode[]",
        "components": [
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "partyId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "backupEncryptionKey",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "externalUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "publicStorageUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "tlsCertificate",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      {
        "name": "version",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "InvalidateKeyResharing",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "NewKmsContext",
    "inputs": [
      {
        "name": "activeKmsContext",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct KmsContext",
        "components": [
          {
            "name": "contextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "previousContextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "softwareVersion",
            "type": "bytes8",
            "internalType": "bytes8"
          },
          {
            "name": "mpcThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "kmsNodes",
            "type": "tuple[]",
            "internalType": "struct KmsNode[]",
            "components": [
              {
                "name": "name",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "signerAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "txSenderAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "partyId",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "backupEncryptionKey",
                "type": "bytes",
                "internalType": "bytes"
              },
              {
                "name": "externalUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "publicStorageUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "tlsCertificate",
                "type": "bytes",
                "internalType": "bytes"
              }
            ]
          }
        ]
      },
      {
        "name": "newKmsContext",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct KmsContext",
        "components": [
          {
            "name": "contextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "previousContextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "softwareVersion",
            "type": "bytes8",
            "internalType": "bytes8"
          },
          {
            "name": "mpcThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "kmsNodes",
            "type": "tuple[]",
            "internalType": "struct KmsNode[]",
            "components": [
              {
                "name": "name",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "signerAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "txSenderAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "partyId",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "backupEncryptionKey",
                "type": "bytes",
                "internalType": "bytes"
              },
              {
                "name": "externalUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "publicStorageUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "tlsCertificate",
                "type": "bytes",
                "internalType": "bytes"
              }
            ]
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferStarted",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Paused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "PreActivateKmsContext",
    "inputs": [
      {
        "name": "newKmsContext",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct KmsContext",
        "components": [
          {
            "name": "contextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "previousContextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "softwareVersion",
            "type": "bytes8",
            "internalType": "bytes8"
          },
          {
            "name": "mpcThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "kmsNodes",
            "type": "tuple[]",
            "internalType": "struct KmsNode[]",
            "components": [
              {
                "name": "name",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "signerAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "txSenderAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "partyId",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "backupEncryptionKey",
                "type": "bytes",
                "internalType": "bytes"
              },
              {
                "name": "externalUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "publicStorageUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "tlsCertificate",
                "type": "bytes",
                "internalType": "bytes"
              }
            ]
          }
        ]
      },
      {
        "name": "preActivationBlockNumber",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "StartKeyResharing",
    "inputs": [
      {
        "name": "activeKmsContext",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct KmsContext",
        "components": [
          {
            "name": "contextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "previousContextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "softwareVersion",
            "type": "bytes8",
            "internalType": "bytes8"
          },
          {
            "name": "mpcThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "kmsNodes",
            "type": "tuple[]",
            "internalType": "struct KmsNode[]",
            "components": [
              {
                "name": "name",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "signerAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "txSenderAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "partyId",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "backupEncryptionKey",
                "type": "bytes",
                "internalType": "bytes"
              },
              {
                "name": "externalUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "publicStorageUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "tlsCertificate",
                "type": "bytes",
                "internalType": "bytes"
              }
            ]
          }
        ]
      },
      {
        "name": "newKmsContext",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct KmsContext",
        "components": [
          {
            "name": "contextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "previousContextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "softwareVersion",
            "type": "bytes8",
            "internalType": "bytes8"
          },
          {
            "name": "mpcThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "kmsNodes",
            "type": "tuple[]",
            "internalType": "struct KmsNode[]",
            "components": [
              {
                "name": "name",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "signerAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "txSenderAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "partyId",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "backupEncryptionKey",
                "type": "bytes",
                "internalType": "bytes"
              },
              {
                "name": "externalUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "publicStorageUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "tlsCertificate",
                "type": "bytes",
                "internalType": "bytes"
              }
            ]
          }
        ]
      },
      {
        "name": "generationBlockNumber",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SuspendKmsContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Unpaused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "UpdateKmsContextGenerationBlockPeriod",
    "inputs": [
      {
        "name": "newKmsContextGenerationBlockPeriod",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "UpdateKmsContextSuspensionBlockPeriod",
    "inputs": [
      {
        "name": "newKmsContextSuspensionBlockPeriod",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "UpdatePublicDecryptionThreshold",
    "inputs": [
      {
        "name": "newPublicDecryptionThreshold",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "UpdateUserDecryptionThreshold",
    "inputs": [
      {
        "name": "newUserDecryptionThreshold",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Upgraded",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ValidateKeyResharing",
    "inputs": [
      {
        "name": "newKmsContext",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct KmsContext",
        "components": [
          {
            "name": "contextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "previousContextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "softwareVersion",
            "type": "bytes8",
            "internalType": "bytes8"
          },
          {
            "name": "mpcThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "kmsNodes",
            "type": "tuple[]",
            "internalType": "struct KmsNode[]",
            "components": [
              {
                "name": "name",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "signerAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "txSenderAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "partyId",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "backupEncryptionKey",
                "type": "bytes",
                "internalType": "bytes"
              },
              {
                "name": "externalUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "publicStorageUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "tlsCertificate",
                "type": "bytes",
                "internalType": "bytes"
              }
            ]
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AddressEmptyCode",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "CompromiseActiveKmsContextNotAllowed",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ContextAlreadyExists",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ContextNotActive",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ContextNotActiveOrSuspended",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ContextNotGenerated",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ContextNotInitializedOrIsGenerating",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ContextNotPreActivatedOrSuspended",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "DestroyActiveKmsContextNotAllowed",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignature",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureLength",
    "inputs": [
      {
        "name": "length",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureS",
    "inputs": [
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1967InvalidImplementation",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1967NonPayable",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyKmsNodes",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EnforcedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ExpectedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FailedCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidHighMpcThreshold",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "mpcThreshold",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nKmsNodes",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidHighPublicDecryptionThreshold",
    "inputs": [
      {
        "name": "publicDecryptionThreshold",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nKmsNodes",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidHighUserDecryptionThreshold",
    "inputs": [
      {
        "name": "userDecryptionThreshold",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nKmsNodes",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidInitialization",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidNullContextId",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidNullPublicDecryptionThreshold",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidNullUserDecryptionThreshold",
    "inputs": []
  },
  {
    "type": "error",
    "name": "KmsContextNotGenerating",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "KmsContextNotInitialized",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "KmsNodeAlreadyValidatedKeyResharing",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "kmsSigner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NoSuspendedKmsContext",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotInitializing",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotKmsNodeFromContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "kmsTxSenderAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotKmsSignerFromContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "signerAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotKmsTxSenderFromContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "txSenderAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotOwnerOrPauser",
    "inputs": [
      {
        "name": "notOwnerOrPauser",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NumberOfKmsNodesChanged",
    "inputs": [
      {
        "name": "activeKmsNodesLength",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "newKmsNodesLength",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "OwnableInvalidOwner",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "OwnableUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "SuspendedKmsContextOngoing",
    "inputs": [
      {
        "name": "suspendedContextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "UUPSUnauthorizedCallContext",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UUPSUnsupportedProxiableUUID",
    "inputs": [
      {
        "name": "slot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod KmsContexts {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a06040523073ffffffffffffffffffffffffffffffffffffffff1660809073ffffffffffffffffffffffffffffffffffffffff1681525034801562000043575f80fd5b50620000546200005a60201b60201c565b620001c4565b5f6200006b6200015e60201b60201c565b9050805f0160089054906101000a900460ff1615620000b6576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b67ffffffffffffffff8016815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff16146200015b5767ffffffffffffffff815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d267ffffffffffffffff604051620001529190620001a9565b60405180910390a15b50565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b5f67ffffffffffffffff82169050919050565b620001a38162000185565b82525050565b5f602082019050620001be5f83018462000198565b92915050565b608051617624620001eb5f395f8181613bb201528181613c070152613dc101526176245ff3fe608060405260043610610224575f3560e01c806384b0196e11610122578063defba06a116100aa578063e72ee9911161006e578063e72ee9911461075c578063eb843cf614610786578063edc44f19146107ae578063f27cb957146107d6578063f2fde38b146107ec57610224565b8063defba06a1461067e578063dfe36aee146106a6578063e24ba4e5146106ce578063e30c3978146106f6578063e3b2a8741461072057610224565b8063ad3cb1cc116100f1578063ad3cb1cc1461059e578063b8715d4d146105c8578063c0ae64f714610604578063c1c8b7251461062c578063d8e3ae011461065457610224565b806384b0196e146105065780638cb96751146105365780638da5cb5b1461054c5780639ee77af31461057657610224565b80634d694260116101b0578063715018a611610174578063715018a6146104705780637420f3d41461048657806379ba5097146104b05780637eaac8f2146104c65780638456cb59146104f057610224565b80634d694260146103885780634f1ef286146103c457806352d1902d146103e05780635c975abb1461040a57806364b00cc51461043457610224565b8063169cac14116101f7578063169cac14146102ce5780632e2d3a82146102f65780633f4ba83a1461031e57806343e37e8a146103345780634965e4551461035e57610224565b80630a50e318146102285780630d8e6e2c146102525780630dd486c01461027c5780631079ebeb146102a6575b5f80fd5b348015610233575f80fd5b5061023c610814565b60405161024991906155b2565b60405180910390f35b34801561025d575f80fd5b5061026661082d565b6040516102739190615655565b60405180910390f35b348015610287575f80fd5b506102906108a8565b60405161029d919061598e565b60405180910390f35b3480156102b1575f80fd5b506102cc60048036038101906102c79190615a4a565b610d34565b005b3480156102d9575f80fd5b506102f460048036038101906102ef9190615b7d565b6112f1565b005b348015610301575f80fd5b5061031c60048036038101906103179190615c27565b6114ba565b005b348015610329575f80fd5b50610332611523565b005b34801561033f575f80fd5b50610348611535565b60405161035591906155b2565b60405180910390f35b348015610369575f80fd5b5061037261154e565b60405161037f91906155b2565b60405180910390f35b348015610393575f80fd5b506103ae60048036038101906103a99190615c27565b611565565b6040516103bb9190615cc5565b60405180910390f35b6103de60048036038101906103d99190615e30565b611585565b005b3480156103eb575f80fd5b506103f46115a4565b6040516104019190615ea2565b60405180910390f35b348015610415575f80fd5b5061041e6115d5565b60405161042b9190615eca565b60405180910390f35b34801561043f575f80fd5b5061045a60048036038101906104559190615c27565b6115f7565b60405161046791906155b2565b60405180910390f35b34801561047b575f80fd5b50610484611686565b005b348015610491575f80fd5b5061049a611699565b6040516104a79190615f8b565b60405180910390f35b3480156104bb575f80fd5b506104c461174d565b005b3480156104d1575f80fd5b506104da6117db565b6040516104e79190615f8b565b60405180910390f35b3480156104fb575f80fd5b5061050461188f565b005b348015610511575f80fd5b5061051a6119ca565b60405161052d979695949392919061609c565b60405180910390f35b348015610541575f80fd5b5061054a611ad3565b005b348015610557575f80fd5b50610560611cc5565b60405161056d919061611e565b60405180910390f35b348015610581575f80fd5b5061059c60048036038101906105979190615c27565b611cfa565b005b3480156105a9575f80fd5b506105b2611e09565b6040516105bf9190615655565b60405180910390f35b3480156105d3575f80fd5b506105ee60048036038101906105e99190615c27565b611e42565b6040516105fb91906155b2565b60405180910390f35b34801561060f575f80fd5b5061062a60048036038101906106259190615c27565b611ed1565b005b348015610637575f80fd5b50610652600480360381019061064d9190615c27565b611fe0565b005b34801561065f575f80fd5b5061066861203f565b60405161067591906155b2565b60405180910390f35b348015610689575f80fd5b506106a4600480360381019061069f9190616137565b612056565b005b3480156106b1575f80fd5b506106cc60048036038101906106c79190616137565b61216b565b005b3480156106d9575f80fd5b506106f460048036038101906106ef9190615c27565b612280565b005b348015610701575f80fd5b5061070a6122df565b604051610717919061611e565b60405180910390f35b34801561072b575f80fd5b5061074660048036038101906107419190616175565b612314565b6040516107539190616269565b60405180910390f35b348015610767575f80fd5b50610770612793565b60405161077d919061630c565b60405180910390f35b348015610791575f80fd5b506107ac60048036038101906107a79190615c27565b6127a6565b005b3480156107b9575f80fd5b506107d460048036038101906107cf919061634a565b61280f565b005b3480156107e1575f80fd5b506107ea612a41565b005b3480156107f7575f80fd5b50610812600480360381019061080d9190616175565b612b2e565b005b5f8061081e612be7565b9050805f016004015491505090565b60606040518060400160405280600b81526020017f4b6d73436f6e746578747300000000000000000000000000000000000000000081525061086e5f612c0e565b6108786001612c0e565b6108815f612c0e565b60405160200161089494939291906164af565b604051602081830303815290604052905090565b6108b06154e6565b5f6108b9612be7565b90505f6108c4611535565b9050816008015f8281526020019081526020015f206040518060a00160405290815f820154815260200160018201548152602001600282015f9054906101000a900460c01b77ffffffffffffffffffffffffffffffffffffffffffffffff191677ffffffffffffffffffffffffffffffffffffffffffffffff191681526020016003820154815260200160048201805480602002602001604051908101604052809291908181526020015f905b82821015610d25578382905f5260205f209060080201604051806101000160405290815f820180546109a29061653a565b80601f01602080910402602001604051908101604052809291908181526020018280546109ce9061653a565b8015610a195780601f106109f057610100808354040283529160200191610a19565b820191905f5260205f20905b8154815290600101906020018083116109fc57829003601f168201915b50505050508152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200160038201548152602001600482018054610ae69061653a565b80601f0160208091040260200160405190810160405280929190818152602001828054610b129061653a565b8015610b5d5780601f10610b3457610100808354040283529160200191610b5d565b820191905f5260205f20905b815481529060010190602001808311610b4057829003601f168201915b50505050508152602001600582018054610b769061653a565b80601f0160208091040260200160405190810160405280929190818152602001828054610ba29061653a565b8015610bed5780601f10610bc457610100808354040283529160200191610bed565b820191905f5260205f20905b815481529060010190602001808311610bd057829003601f168201915b50505050508152602001600682018054610c069061653a565b80601f0160208091040260200160405190810160405280929190818152602001828054610c329061653a565b8015610c7d5780601f10610c5457610100808354040283529160200191610c7d565b820191905f5260205f20905b815481529060010190602001808311610c6057829003601f168201915b50505050508152602001600782018054610c969061653a565b80601f0160208091040260200160405190810160405280929190818152602001828054610cc29061653a565b8015610d0d5780601f10610ce457610100808354040283529160200191610d0d565b820191905f5260205f20905b815481529060010190602001808311610cf057829003601f168201915b50505050508152505081526020019060010190610971565b50505050815250509250505090565b610d3e8333612056565b5f610d47612be7565b9050610d55815f0185612cd8565b610d9657836040517f5e51a2e1000000000000000000000000000000000000000000000000000000008152600401610d8d91906155b2565b60405180910390fd5b5f60405180602001604052808681525090505f610db282612d27565b9050610dc086828787612d82565b5f83600c015f8881526020019081526020015f20905080868690918060018154018082558091505060019003905f5260205f20015f909192909192909192909192509182610e0f929190616711565b505f846008015f8981526020019081526020015f206040518060a00160405290815f820154815260200160018201548152602001600282015f9054906101000a900460c01b77ffffffffffffffffffffffffffffffffffffffffffffffff191677ffffffffffffffffffffffffffffffffffffffffffffffff191681526020016003820154815260200160048201805480602002602001604051908101604052809291908181526020015f905b82821015611270578382905f5260205f209060080201604051806101000160405290815f82018054610eed9061653a565b80601f0160208091040260200160405190810160405280929190818152602001828054610f199061653a565b8015610f645780601f10610f3b57610100808354040283529160200191610f64565b820191905f5260205f20905b815481529060010190602001808311610f4757829003601f168201915b50505050508152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600382015481526020016004820180546110319061653a565b80601f016020809104026020016040519081016040528092919081815260200182805461105d9061653a565b80156110a85780601f1061107f576101008083540402835291602001916110a8565b820191905f5260205f20905b81548152906001019060200180831161108b57829003601f168201915b505050505081526020016005820180546110c19061653a565b80601f01602080910402602001604051908101604052809291908181526020018280546110ed9061653a565b80156111385780601f1061110f57610100808354040283529160200191611138565b820191905f5260205f20905b81548152906001019060200180831161111b57829003601f168201915b505050505081526020016006820180546111519061653a565b80601f016020809104026020016040519081016040528092919081815260200182805461117d9061653a565b80156111c85780601f1061119f576101008083540402835291602001916111c8565b820191905f5260205f20905b8154815290600101906020018083116111ab57829003601f168201915b505050505081526020016007820180546111e19061653a565b80601f016020809104026020016040519081016040528092919081815260200182805461120d9061653a565b80156112585780601f1061122f57610100808354040283529160200191611258565b820191905f5260205f20905b81548152906001019060200180831161123b57829003601f168201915b50505050508152505081526020019060010190610ebc565b50505050815250509050611288818380549050612ef4565b156112e7575f856006015f8a81526020019081526020015f205490506112ae8282612f0b565b7f68898a98936bf23a56e8ed4b23dcc98cef926bd9ac2ce522f1f9423e3864f2f5826040516112dd919061598e565b60405180910390a1505b5050505050505050565b6112f9612f8e565b5f611302612be7565b90505f61130d6108a8565b90505f81608001515190505f8686905090508181146113655781816040517fd595a96200000000000000000000000000000000000000000000000000000000815260040161135c9291906167de565b60405180910390fd5b5f61136e610814565b90505f81146113b457806040517f7623d3570000000000000000000000000000000000000000000000000000000081526004016113ab91906155b2565b60405180910390fd5b5f6113c6855f01518d8c8c8c8c613015565b90507f3662ec316d76e6a75eb7c45001a8ad74c3eb943e8778111c0225f2a9fd5e00e685826040516113f9929190616805565b60405180910390a1611410865f01825f0151613963565b8a156114a0578c866006015f835f015181526020019081526020015f20819055505f8660050154436114429190616867565b905080876012015f845f015181526020019081526020015f20819055507f5dc601065a035d78305cd9ef27c91a009cd8d37297e43bb76319490895a0d0588683836040516114929392919061689a565b60405180910390a1506114ab565b6114aa818e612f0b565b5b50505050505050505050505050565b6114c2612f8e565b6114ca613a30565b5f6114d36108a8565b90506114e8815f015183836080015151613a71565b7fe41802af725729adcb8c151e2937380a25c69155757e3af5d3979adab50358008260405161151791906155b2565b60405180910390a15050565b61152b612f8e565b611533613b1a565b565b5f8061153f612be7565b9050805f016003015491505090565b5f80611558612be7565b9050806005015491505090565b5f8061156f612be7565b905061157d815f0184613b88565b915050919050565b61158d613bb0565b61159682613c96565b6115a08282613ca1565b5050565b5f6115ad613dbf565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b905090565b5f806115df613e46565b9050805f015f9054906101000a900460ff1691505090565b5f815f611602612be7565b90505f816008015f8481526020019081526020015f205f01540361165d57816040517f82b1fbda00000000000000000000000000000000000000000000000000000000815260040161165491906155b2565b60405180910390fd5b5f611666612be7565b9050806016015f8681526020019081526020015f20549350505050919050565b61168e612f8e565b6116975f613e6d565b565b60605f6116a4611535565b90505f6116af612be7565b9050806010015f8381526020019081526020015f2080548060200260200160405190810160405280929190818152602001828054801561174157602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190600101908083116116f8575b50505050509250505090565b5f611756613eaa565b90508073ffffffffffffffffffffffffffffffffffffffff166117776122df565b73ffffffffffffffffffffffffffffffffffffffff16146117cf57806040517f118cdaa70000000000000000000000000000000000000000000000000000000081526004016117c6919061611e565b60405180910390fd5b6117d881613e6d565b50565b60605f6117e6611535565b90505f6117f1612be7565b9050806011015f8381526020019081526020015f2080548060200260200160405190810160405280929190818152602001828054801561188357602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001906001019080831161183a575b50505050509250505090565b611897611cc5565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415801561197e575073c7d45661a345ec5ca0e8521cfef7e32fda0daa6873ffffffffffffffffffffffffffffffffffffffff16637008b5486040518163ffffffff1660e01b8152600401602060405180830381865afa15801561192a573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061194e91906168f1565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614155b156119c057336040517f46c0d9af0000000000000000000000000000000000000000000000000000000081526004016119b7919061611e565b60405180910390fd5b6119c8613eb1565b565b5f6060805f805f60605f6119dc613f20565b90505f801b815f01541480156119f757505f801b8160010154145b611a36576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611a2d90616966565b60405180910390fd5b611a3e613f47565b611a46613fe5565b46305f801b5f67ffffffffffffffff811115611a6557611a64615d0c565b5b604051908082528060200260200182016040528015611a935781602001602082028036833780820191505090505b507f0f0000000000000000000000000000000000000000000000000000000000000095949392919097509750975097509750975097505090919293949596565b611adb613a30565b5f611ae4612be7565b90505f815f016001015490505f8114611b8d57816012015f8281526020019081526020015f2054431115611b8c577e9fe8f0db45996decf7b06fc7b6ec5f887d5f04db2e0c4ad7f4e4ee5eefc5a381604051611b4091906155b2565b60405180910390a1611b54825f0182614083565b7f3e8f02dc7af6e3a67f3af0bc99bcf11b4deb46105e9ba7f1ac6da82322e9025e81604051611b8391906155b2565b60405180910390a15b5b5f825f016002015490505f8114611c4d57826013015f8281526020019081526020015f2054431115611c4c575f611bc2611535565b9050611bd0845f0182614150565b7f851a08c16b15959c338ac4b56466d06c9f9d5ff8d715168aa125d5ccaf53832081604051611bff91906155b2565b60405180910390a1611c13845f0183614226565b7f4f54a6ac981cc8dc83142b3eb4d120be7c70fc5de6477a14eae3e9ca647644bc82604051611c4291906155b2565b60405180910390a1505b5b5f611c56610814565b90505f8114611cbf57836014015f8281526020019081526020015f2054431115611cbe57611c86845f0182614321565b7f8fb75858a565aee117342d93196a7f0b54c1c8519885eddda6a01f477359b36381604051611cb591906155b2565b60405180910390a15b5b50505050565b5f80611ccf614423565b9050805f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b611d02612f8e565b805f611d0c612be7565b90505f816008015f8481526020019081526020015f205f015403611d6757816040517f82b1fbda000000000000000000000000000000000000000000000000000000008152600401611d5e91906155b2565b60405180910390fd5b5f611d70612be7565b9050611d7e815f018561444a565b15611dc057836040517f77d05ea7000000000000000000000000000000000000000000000000000000008152600401611db791906155b2565b60405180910390fd5b611dcc815f0185614499565b7fbc1114fa9a77648cd097ee6cf149c344fa278b9b983f30dd65b6fd6a9d464a0784604051611dfb91906155b2565b60405180910390a150505050565b6040518060400160405280600581526020017f352e302e3000000000000000000000000000000000000000000000000000000081525081565b5f815f611e4d612be7565b90505f816008015f8481526020019081526020015f205f015403611ea857816040517f82b1fbda000000000000000000000000000000000000000000000000000000008152600401611e9f91906155b2565b60405180910390fd5b5f611eb1612be7565b9050806015015f8681526020019081526020015f20549350505050919050565b611ed9612f8e565b805f611ee3612be7565b90505f816008015f8481526020019081526020015f205f015403611f3e57816040517f82b1fbda000000000000000000000000000000000000000000000000000000008152600401611f3591906155b2565b60405180910390fd5b5f611f47612be7565b9050611f55815f018561444a565b15611f9757836040517fb25e4eb3000000000000000000000000000000000000000000000000000000008152600401611f8e91906155b2565b60405180910390fd5b611fa3815f0185614083565b7f3e8f02dc7af6e3a67f3af0bc99bcf11b4deb46105e9ba7f1ac6da82322e9025e84604051611fd291906155b2565b60405180910390a150505050565b611fe8612f8e565b611ff0613a30565b5f611ff9612be7565b90508181600701819055507f3ad5c22724afab8ed2b578fb9b160c7f65f5abd0aad105752b7ba4e068a3e0218260405161203391906155b2565b60405180910390a15050565b5f80612049612be7565b9050806007015491505090565b815f612060612be7565b90505f816008015f8481526020019081526020015f205f0154036120bb57816040517f82b1fbda0000000000000000000000000000000000000000000000000000000081526004016120b291906155b2565b60405180910390fd5b5f6120c4612be7565b905080600e015f8681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff166121645784846040517ffdf8a05d00000000000000000000000000000000000000000000000000000000815260040161215b929190616984565b60405180910390fd5b5050505050565b815f612175612be7565b90505f816008015f8481526020019081526020015f205f0154036121d057816040517f82b1fbda0000000000000000000000000000000000000000000000000000000081526004016121c791906155b2565b60405180910390fd5b5f6121d9612be7565b905080600f015f8681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff166122795784846040517f89b45e5d000000000000000000000000000000000000000000000000000000008152600401612270929190616984565b60405180910390fd5b5050505050565b612288612f8e565b612290613a30565b5f612299612be7565b90508181600501819055507f53cb968d31c28c6504a6e73d9908db6e1c1a386b66dcacec1a0117752c5ab986826040516122d391906155b2565b60405180910390a15050565b5f806122e96145ae565b9050805f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b61231c61552c565b5f612325611535565b90505f612330612be7565b90505f81600d015f8481526020019081526020015f205f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20604051806101000160405290815f8201805461239c9061653a565b80601f01602080910402602001604051908101604052809291908181526020018280546123c89061653a565b80156124135780601f106123ea57610100808354040283529160200191612413565b820191905f5260205f20905b8154815290600101906020018083116123f657829003601f168201915b50505050508152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600382015481526020016004820180546124e09061653a565b80601f016020809104026020016040519081016040528092919081815260200182805461250c9061653a565b80156125575780601f1061252e57610100808354040283529160200191612557565b820191905f5260205f20905b81548152906001019060200180831161253a57829003601f168201915b505050505081526020016005820180546125709061653a565b80601f016020809104026020016040519081016040528092919081815260200182805461259c9061653a565b80156125e75780601f106125be576101008083540402835291602001916125e7565b820191905f5260205f20905b8154815290600101906020018083116125ca57829003601f168201915b505050505081526020016006820180546126009061653a565b80601f016020809104026020016040519081016040528092919081815260200182805461262c9061653a565b80156126775780601f1061264e57610100808354040283529160200191612677565b820191905f5260205f20905b81548152906001019060200180831161265a57829003601f168201915b505050505081526020016007820180546126909061653a565b80601f01602080910402602001604051908101604052809291908181526020018280546126bc9061653a565b80156127075780601f106126de57610100808354040283529160200191612707565b820191905f5260205f20905b8154815290600101906020018083116126ea57829003601f168201915b50505050508152505090505f73ffffffffffffffffffffffffffffffffffffffff16816040015173ffffffffffffffffffffffffffffffffffffffff16036127885782856040517f0494d3c000000000000000000000000000000000000000000000000000000000815260040161277f929190616984565b60405180910390fd5b809350505050919050565b606061279d6108a8565b60800151905090565b6127ae612f8e565b6127b6613a30565b5f6127bf6108a8565b90506127d4815f0151838360800151516145d5565b7f837e0a6528dadfa2dc792692c5182e52a9f5bbdeed7b2372927a26c6958396138260405161280391906155b2565b60405180910390a15050565b60025f61281a61467e565b9050805f0160089054906101000a900460ff168061286257508167ffffffffffffffff16815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff1610155b15612899576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055506001815f0160086101000a81548160ff0219169083151502179055506129526040518060400160405280600b81526020017f4b6d73436f6e74657874730000000000000000000000000000000000000000008152506040518060400160405280600181526020017f31000000000000000000000000000000000000000000000000000000000000008152506146a5565b61296261295d611cc5565b6146bb565b61296a6146cf565b5f6129795f888888888e613015565b90505f612984612be7565b9050612995815f01835f0151614226565b6129a289835f01516146e1565b7f016ee9c16213ed67f33222abad4dfe46eb951ead30a10a1a72db3316ffb664e08a8a8a8a8a8a6040516129db96959493929190616d78565b60405180910390a150505f815f0160086101000a81548160ff0219169083151502179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d282604051612a2f9190616df5565b60405180910390a15050505050505050565b612a49612f8e565b5f612a52612be7565b90505f612a5d610814565b90505f8103612a98576040517f207ea3f300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f612aa1611535565b9050612aaf835f0182614321565b7f8fb75858a565aee117342d93196a7f0b54c1c8519885eddda6a01f477359b36381604051612ade91906155b2565b60405180910390a1612af2835f0183614226565b7f4f54a6ac981cc8dc83142b3eb4d120be7c70fc5de6477a14eae3e9ca647644bc82604051612b2191906155b2565b60405180910390a1505050565b612b36612f8e565b5f612b3f6145ae565b905081815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff16612ba1611cc5565b73ffffffffffffffffffffffffffffffffffffffff167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a35050565b5f7f7d8159810a7ebf944e8fa93cc4fbd1cade6c71f8b0b86b37187ac7991777b100905090565b60605f6001612c1c84614726565b0190505f8167ffffffffffffffff811115612c3a57612c39615d0c565b5b6040519080825280601f01601f191660200182016040528015612c6c5781602001600182028036833780820191505090505b5090505f82602001820190505b600115612ccd578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a8581612cc257612cc1616e0e565b5b0494505f8503612c79575b819350505050919050565b5f60016007811115612ced57612cec615c52565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115612d1e57612d1d615c52565b5b14905092915050565b5f612d7b6040518060600160405280602b81526020016175f9602b913980519060200120835f0151604051602001612d60929190616e3b565b60405160208183030381529060405280519060200120614877565b9050919050565b5f612d8b612be7565b90505f612ddb8585858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f81840152601f19601f82011690508083019250505050505050614890565b9050612de7868261216b565b81600a015f8781526020019081526020015f205f8273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff1615612e865785816040517f99b158c1000000000000000000000000000000000000000000000000000000008152600401612e7d929190616984565b60405180910390fd5b600182600a015f8881526020019081526020015f205f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550505050505050565b5f8083608001515190508083101591505092915050565b5f612f14612be7565b9050612f25815f01845f01516148ba565b5f8243612f329190616867565b905080826013015f865f015181526020019081526020015f20819055507f4540f7808fcaec86c376a89d2c0c93a5056c21680db54332c7f2959d87fefc8b8482604051612f80929190616e62565b60405180910390a150505050565b612f96613eaa565b73ffffffffffffffffffffffffffffffffffffffff16612fb4611cc5565b73ffffffffffffffffffffffffffffffffffffffff161461301357612fd7613eaa565b6040517f118cdaa700000000000000000000000000000000000000000000000000000000815260040161300a919061611e565b60405180910390fd5b565b61301d6154e6565b5f613026612be7565b90505f8585905003613064576040517f068c8d4000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b806009015f81548092919061307890616e90565b91905055505f8160090154905080826008015f8381526020019081526020015f205f018190555088826008015f8381526020019081526020015f206001018190555087826008015f8381526020019081526020015f206002015f6101000a81548167ffffffffffffffff021916908360c01c02179055506130fd818888889050614990565b5f5b8686905081101561318657826008015f8381526020019081526020015f2060040187878381811061313357613132616ed7565b5b90506020028101906131459190616f10565b908060018154018082558091505060019003905f5260205f2090600802015f9091909190915081816131779190617392565b505080806001019150506130ff565b505f5b868690508110156134df578686828181106131a7576131a6616ed7565b5b90506020028101906131b99190616f10565b83600d015f8481526020019081526020015f205f8989858181106131e0576131df616ed7565b5b90506020028101906131f29190616f10565b60400160208101906132049190616175565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2081816132499190617392565b905050600183600e015f8481526020019081526020015f205f89898581811061327557613274616ed7565b5b90506020028101906132879190616f10565b60400160208101906132999190616175565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550826010015f8381526020019081526020015f2087878381811061330e5761330d616ed7565b5b90506020028101906133209190616f10565b60400160208101906133329190616175565b908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600183600f015f8481526020019081526020015f205f8989858181106133b8576133b7616ed7565b5b90506020028101906133ca9190616f10565b60200160208101906133dc9190616175565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550826011015f8381526020019081526020015f2087878381811061345157613450616ed7565b5b90506020028101906134639190616f10565b60200160208101906134759190616175565b908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508080600101915050613189565b506134ee818588889050614a04565b816008015f8281526020019081526020015f206040518060a00160405290815f820154815260200160018201548152602001600282015f9054906101000a900460c01b77ffffffffffffffffffffffffffffffffffffffffffffffff191677ffffffffffffffffffffffffffffffffffffffffffffffff191681526020016003820154815260200160048201805480602002602001604051908101604052809291908181526020015f905b8282101561394d578382905f5260205f209060080201604051806101000160405290815f820180546135ca9061653a565b80601f01602080910402602001604051908101604052809291908181526020018280546135f69061653a565b80156136415780601f1061361857610100808354040283529160200191613641565b820191905f5260205f20905b81548152906001019060200180831161362457829003601f168201915b50505050508152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020016003820154815260200160048201805461370e9061653a565b80601f016020809104026020016040519081016040528092919081815260200182805461373a9061653a565b80156137855780601f1061375c57610100808354040283529160200191613785565b820191905f5260205f20905b81548152906001019060200180831161376857829003601f168201915b5050505050815260200160058201805461379e9061653a565b80601f01602080910402602001604051908101604052809291908181526020018280546137ca9061653a565b80156138155780601f106137ec57610100808354040283529160200191613815565b820191905f5260205f20905b8154815290600101906020018083116137f857829003601f168201915b5050505050815260200160068201805461382e9061653a565b80601f016020809104026020016040519081016040528092919081815260200182805461385a9061653a565b80156138a55780601f1061387c576101008083540402835291602001916138a5565b820191905f5260205f20905b81548152906001019060200180831161388857829003601f168201915b505050505081526020016007820180546138be9061653a565b80601f01602080910402602001604051908101604052809291908181526020018280546138ea9061653a565b80156139355780601f1061390c57610100808354040283529160200191613935565b820191905f5260205f20905b81548152906001019060200180831161391857829003601f168201915b50505050508152505081526020019060010190613599565b5050505081525050925050509695505050505050565b805f810361399d576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6139a78383614a26565b6139e857816040517f6653f6d70000000000000000000000000000000000000000000000000000000081526004016139df91906155b2565b60405180910390fd5b6001835f015f8481526020019081526020015f205f6101000a81548160ff02191690836007811115613a1d57613a1c615c52565b5b0217905550818360010181905550505050565b613a386115d5565b15613a6f576040517fd93c066500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f613a7a612be7565b90505f8303613ab5576040517fb1ae92ea00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81831115613afc5782826040517f84208f23000000000000000000000000000000000000000000000000000000008152600401613af39291906167de565b60405180910390fd5b82816015015f8681526020019081526020015f208190555050505050565b613b22614a74565b5f613b2b613e46565b90505f815f015f6101000a81548160ff0219169083151502179055507f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa613b70613eaa565b604051613b7d919061611e565b60405180910390a150565b5f825f015f8381526020019081526020015f205f9054906101000a900460ff16905092915050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff161480613c5d57507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16613c44614ab4565b73ffffffffffffffffffffffffffffffffffffffff1614155b15613c94576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b613c9e612f8e565b50565b8173ffffffffffffffffffffffffffffffffffffffff166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015613d0957506040513d601f19601f82011682018060405250810190613d0691906173ca565b60015b613d4a57816040517f4c9c8ce3000000000000000000000000000000000000000000000000000000008152600401613d41919061611e565b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b8114613db057806040517faa1d49a4000000000000000000000000000000000000000000000000000000008152600401613da79190615ea2565b60405180910390fd5b613dba8383614b07565b505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614613e44576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f7fcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300905090565b5f613e766145ae565b9050805f015f6101000a81549073ffffffffffffffffffffffffffffffffffffffff0219169055613ea682614b79565b5050565b5f33905090565b613eb9613a30565b5f613ec2613e46565b90506001815f015f6101000a81548160ff0219169083151502179055507f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258613f08613eaa565b604051613f15919061611e565b60405180910390a150565b5f7fa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100905090565b60605f613f52613f20565b9050806002018054613f639061653a565b80601f0160208091040260200160405190810160405280929190818152602001828054613f8f9061653a565b8015613fda5780601f10613fb157610100808354040283529160200191613fda565b820191905f5260205f20905b815481529060010190602001808311613fbd57829003601f168201915b505050505091505090565b60605f613ff0613f20565b90508060030180546140019061653a565b80601f016020809104026020016040519081016040528092919081815260200182805461402d9061653a565b80156140785780601f1061404f57610100808354040283529160200191614078565b820191905f5260205f20905b81548152906001019060200180831161405b57829003601f168201915b505050505091505090565b805f81036140bd576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6007835f015f8481526020019081526020015f205f6101000a81548160ff021916908360078111156140f2576140f1615c52565b5b02179055508183600101540361410c575f83600101819055505b81836002015403614121575f83600201819055505b81836003015403614136575f83600301819055505b8183600401540361414b575f83600401819055505b505050565b805f810361418a576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b614194838361444a565b6141d557816040517f331486b30000000000000000000000000000000000000000000000000000000081526004016141cc91906155b2565b60405180910390fd5b6004835f015f8481526020019081526020015f205f6101000a81548160ff0219169083600781111561420a57614209615c52565b5b02179055508183600401819055505f8360030181905550505050565b805f8103614260576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61426a8383614c4a565b15801561427e575061427c8383614c99565b155b801561428e57505f836003015414155b156142d057816040517f12b49e3d0000000000000000000000000000000000000000000000000000000081526004016142c791906155b2565b60405180910390fd5b6003835f015f8481526020019081526020015f205f6101000a81548160ff0219169083600781111561430557614304615c52565b5b02179055508183600301819055505f8360020181905550505050565b805f810361435b576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b614365838361444a565b158061437857506143768383614c99565b155b156143ba57816040517f2b3652d10000000000000000000000000000000000000000000000000000000081526004016143b191906155b2565b60405180910390fd5b6005835f015f8481526020019081526020015f205f6101000a81548160ff021916908360078111156143ef576143ee615c52565b5b021790555081836003015403614409575f83600301819055505b8183600401540361441e575f83600401819055505b505050565b5f7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300905090565b5f6003600781111561445f5761445e615c52565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff1660078111156144905761448f615c52565b5b14905092915050565b805f81036144d3576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6144dd8383614a26565b806144ee57506144ed8383612cd8565b5b1561453057816040517fb0c5151d00000000000000000000000000000000000000000000000000000000815260040161452791906155b2565b60405180910390fd5b6006835f015f8481526020019081526020015f205f6101000a81548160ff0219169083600781111561456557614564615c52565b5b02179055508183600201540361457f575f83600201819055505b81836003015403614594575f83600301819055505b818360040154036145a9575f83600401819055505b505050565b5f7f237e158222e3e6968b72b9db0d8043aacf074ad9f650f0d1606b4d82ee432c00905090565b5f6145de612be7565b90505f8303614619576040517fe60a727100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b818311156146605782826040517fd2535e110000000000000000000000000000000000000000000000000000000081526004016146579291906167de565b60405180910390fd5b82816016015f8681526020019081526020015f208190555050505050565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b6146ad614ce8565b6146b78282614d28565b5050565b6146c3614ce8565b6146cc81614d79565b50565b6146d7614ce8565b6146df614dfd565b565b5f6146ea612be7565b9050825f0135816006015f8481526020019081526020015f20819055508260200135816005018190555082604001358160070181905550505050565b5f805f90507a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008310614782577a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000838161477857614777616e0e565b5b0492506040810190505b6d04ee2d6d415b85acef810000000083106147bf576d04ee2d6d415b85acef810000000083816147b5576147b4616e0e565b5b0492506020810190505b662386f26fc1000083106147ee57662386f26fc1000083816147e4576147e3616e0e565b5b0492506010810190505b6305f5e1008310614817576305f5e100838161480d5761480c616e0e565b5b0492506008810190505b612710831061483c57612710838161483257614831616e0e565b5b0492506004810190505b6064831061485f576064838161485557614854616e0e565b5b0492506002810190505b600a831061486e576001810190505b80915050919050565b5f614889614883614e2d565b83614e3b565b9050919050565b5f805f8061489e8686614e7b565b9250925092506148ae8282614ed0565b82935050505092915050565b805f81036148f4576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6148fe8383612cd8565b61493f57816040517fc0b5ee6600000000000000000000000000000000000000000000000000000000815260040161493691906155b2565b60405180910390fd5b6002835f015f8481526020019081526020015f205f6101000a81548160ff0219169083600781111561497457614973615c52565b5b02179055508183600201819055505f8360010181905550505050565b5f614999612be7565b90508183106149e3578383836040517f8789a6ca0000000000000000000000000000000000000000000000000000000081526004016149da939291906173f5565b60405180910390fd5b82816008015f8681526020019081526020015f206003018190555050505050565b614a1283835f013583613a71565b614a21838360200135836145d5565b505050565b5f806007811115614a3a57614a39615c52565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115614a6b57614a6a615c52565b5b14905092915050565b614a7c6115d5565b614ab2576040517f8dfc202b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f614ae07f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b615032565b5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b614b108261503b565b8173ffffffffffffffffffffffffffffffffffffffff167fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b60405160405180910390a25f81511115614b6c57614b668282615104565b50614b75565b614b74615184565b5b5050565b5f614b82614423565b90505f815f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905082825f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a3505050565b5f60026007811115614c5f57614c5e615c52565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115614c9057614c8f615c52565b5b14905092915050565b5f60046007811115614cae57614cad615c52565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115614cdf57614cde615c52565b5b14905092915050565b614cf06151c0565b614d26576040517fd7e6bcf800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b614d30614ce8565b5f614d39613f20565b905082816002019081614d4c919061742a565b5081816003019081614d5e919061742a565b505f801b815f01819055505f801b8160010181905550505050565b614d81614ce8565b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603614df1575f6040517f1e4fbdf7000000000000000000000000000000000000000000000000000000008152600401614de8919061611e565b60405180910390fd5b614dfa81613e6d565b50565b614e05614ce8565b5f614e0e613e46565b90505f815f015f6101000a81548160ff02191690831515021790555050565b5f614e366151de565b905090565b5f6040517f190100000000000000000000000000000000000000000000000000000000000081528360028201528260228201526042812091505092915050565b5f805f6041845103614ebb575f805f602087015192506040870151915060608701515f1a9050614ead88828585615241565b955095509550505050614ec9565b5f600285515f1b9250925092505b9250925092565b5f6003811115614ee357614ee2615c52565b5b826003811115614ef657614ef5615c52565b5b031561502e5760016003811115614f1057614f0f615c52565b5b826003811115614f2357614f22615c52565b5b03614f5a576040517ff645eedf00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60026003811115614f6e57614f6d615c52565b5b826003811115614f8157614f80615c52565b5b03614fc557805f1c6040517ffce698f7000000000000000000000000000000000000000000000000000000008152600401614fbc91906155b2565b60405180910390fd5b600380811115614fd857614fd7615c52565b5b826003811115614feb57614fea615c52565b5b0361502d57806040517fd78bce0c0000000000000000000000000000000000000000000000000000000081526004016150249190615ea2565b60405180910390fd5b5b5050565b5f819050919050565b5f8173ffffffffffffffffffffffffffffffffffffffff163b0361509657806040517f4c9c8ce300000000000000000000000000000000000000000000000000000000815260040161508d919061611e565b60405180910390fd5b806150c27f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b615032565b5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60605f808473ffffffffffffffffffffffffffffffffffffffff168460405161512d9190617533565b5f60405180830381855af49150503d805f8114615165576040519150601f19603f3d011682016040523d82523d5f602084013e61516a565b606091505b509150915061517a858383615328565b9250505092915050565b5f3411156151be576040517fb398979f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f6151c961467e565b5f0160089054906101000a900460ff16905090565b5f7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f6152086153b5565b61521061542b565b4630604051602001615226959493929190617549565b60405160208183030381529060405280519060200120905090565b5f805f7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0845f1c111561527d575f60038592509250925061531e565b5f6001888888886040515f81526020016040526040516152a094939291906175b5565b6020604051602081039080840390855afa1580156152c0573d5f803e3d5ffd5b5050506020604051035190505f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603615311575f60015f801b9350935093505061531e565b805f805f1b935093509350505b9450945094915050565b60608261533d57615338826154a2565b6153ad565b5f825114801561536357505f8473ffffffffffffffffffffffffffffffffffffffff163b145b156153a557836040517f9996b31500000000000000000000000000000000000000000000000000000000815260040161539c919061611e565b60405180910390fd5b8190506153ae565b5b9392505050565b5f806153bf613f20565b90505f6153ca613f47565b90505f815111156153e657808051906020012092505050615428565b5f825f015490505f801b811461540157809350505050615428565b7fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a47093505050505b90565b5f80615435613f20565b90505f615440613fe5565b90505f8151111561545c5780805190602001209250505061549f565b5f826001015490505f801b81146154785780935050505061549f565b7fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a47093505050505b90565b5f815111156154b45780518082602001fd5b6040517fd6bda27500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040518060a001604052805f81526020015f81526020015f77ffffffffffffffffffffffffffffffffffffffffffffffff191681526020015f8152602001606081525090565b604051806101000160405280606081526020015f73ffffffffffffffffffffffffffffffffffffffff1681526020015f73ffffffffffffffffffffffffffffffffffffffff1681526020015f8152602001606081526020016060815260200160608152602001606081525090565b5f819050919050565b6155ac8161559a565b82525050565b5f6020820190506155c55f8301846155a3565b92915050565b5f81519050919050565b5f82825260208201905092915050565b5f5b838110156156025780820151818401526020810190506155e7565b5f8484015250505050565b5f601f19601f8301169050919050565b5f615627826155cb565b61563181856155d5565b93506156418185602086016155e5565b61564a8161560d565b840191505092915050565b5f6020820190508181035f83015261566d818461561d565b905092915050565b61567e8161559a565b82525050565b5f7fffffffffffffffff00000000000000000000000000000000000000000000000082169050919050565b6156b881615684565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f82825260208201905092915050565b5f615701826155cb565b61570b81856156e7565b935061571b8185602086016155e5565b6157248161560d565b840191505092915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6157588261572f565b9050919050565b6157688161574e565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f6157928261576e565b61579c8185615778565b93506157ac8185602086016155e5565b6157b58161560d565b840191505092915050565b5f61010083015f8301518482035f8601526157db82826156f7565b91505060208301516157f0602086018261575f565b506040830151615803604086018261575f565b5060608301516158166060860182615675565b506080830151848203608086015261582e8282615788565b91505060a083015184820360a086015261584882826156f7565b91505060c083015184820360c086015261586282826156f7565b91505060e083015184820360e086015261587c8282615788565b9150508091505092915050565b5f61589483836157c0565b905092915050565b5f602082019050919050565b5f6158b2826156be565b6158bc81856156c8565b9350836020820285016158ce856156d8565b805f5b8581101561590957848403895281516158ea8582615889565b94506158f58361589c565b925060208a019950506001810190506158d1565b50829750879550505050505092915050565b5f60a083015f8301516159305f860182615675565b5060208301516159436020860182615675565b50604083015161595660408601826156af565b5060608301516159696060860182615675565b506080830151848203608086015261598182826158a8565b9150508091505092915050565b5f6020820190508181035f8301526159a6818461591b565b905092915050565b5f604051905090565b5f80fd5b5f80fd5b6159c88161559a565b81146159d2575f80fd5b50565b5f813590506159e3816159bf565b92915050565b5f80fd5b5f80fd5b5f80fd5b5f8083601f840112615a0a57615a096159e9565b5b8235905067ffffffffffffffff811115615a2757615a266159ed565b5b602083019150836001820283011115615a4357615a426159f1565b5b9250929050565b5f805f60408486031215615a6157615a606159b7565b5b5f615a6e868287016159d5565b935050602084013567ffffffffffffffff811115615a8f57615a8e6159bb565b5b615a9b868287016159f5565b92509250509250925092565b615ab081615684565b8114615aba575f80fd5b50565b5f81359050615acb81615aa7565b92915050565b5f8115159050919050565b615ae581615ad1565b8114615aef575f80fd5b50565b5f81359050615b0081615adc565b92915050565b5f8083601f840112615b1b57615b1a6159e9565b5b8235905067ffffffffffffffff811115615b3857615b376159ed565b5b602083019150836020820283011115615b5457615b536159f1565b5b9250929050565b5f80fd5b5f60408284031215615b7457615b73615b5b565b5b81905092915050565b5f805f805f805f60e0888a031215615b9857615b976159b7565b5b5f615ba58a828b016159d5565b9750506020615bb68a828b01615abd565b9650506040615bc78a828b01615af2565b9550506060615bd88a828b016159d5565b945050608088013567ffffffffffffffff811115615bf957615bf86159bb565b5b615c058a828b01615b06565b935093505060a0615c188a828b01615b5f565b91505092959891949750929550565b5f60208284031215615c3c57615c3b6159b7565b5b5f615c49848285016159d5565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b60088110615c9057615c8f615c52565b5b50565b5f819050615ca082615c7f565b919050565b5f615caf82615c93565b9050919050565b615cbf81615ca5565b82525050565b5f602082019050615cd85f830184615cb6565b92915050565b615ce78161574e565b8114615cf1575f80fd5b50565b5f81359050615d0281615cde565b92915050565b5f80fd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b615d428261560d565b810181811067ffffffffffffffff82111715615d6157615d60615d0c565b5b80604052505050565b5f615d736159ae565b9050615d7f8282615d39565b919050565b5f67ffffffffffffffff821115615d9e57615d9d615d0c565b5b615da78261560d565b9050602081019050919050565b828183375f83830152505050565b5f615dd4615dcf84615d84565b615d6a565b905082815260208101848484011115615df057615def615d08565b5b615dfb848285615db4565b509392505050565b5f82601f830112615e1757615e166159e9565b5b8135615e27848260208601615dc2565b91505092915050565b5f8060408385031215615e4657615e456159b7565b5b5f615e5385828601615cf4565b925050602083013567ffffffffffffffff811115615e7457615e736159bb565b5b615e8085828601615e03565b9150509250929050565b5f819050919050565b615e9c81615e8a565b82525050565b5f602082019050615eb55f830184615e93565b92915050565b615ec481615ad1565b82525050565b5f602082019050615edd5f830184615ebb565b92915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f615f17838361575f565b60208301905092915050565b5f602082019050919050565b5f615f3982615ee3565b615f438185615eed565b9350615f4e83615efd565b805f5b83811015615f7e578151615f658882615f0c565b9750615f7083615f23565b925050600181019050615f51565b5085935050505092915050565b5f6020820190508181035f830152615fa38184615f2f565b905092915050565b5f7fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b615fdf81615fab565b82525050565b615fee8161574e565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f6160288383615675565b60208301905092915050565b5f602082019050919050565b5f61604a82615ff4565b6160548185615ffe565b935061605f8361600e565b805f5b8381101561608f578151616076888261601d565b975061608183616034565b925050600181019050616062565b5085935050505092915050565b5f60e0820190506160af5f83018a615fd6565b81810360208301526160c1818961561d565b905081810360408301526160d5818861561d565b90506160e460608301876155a3565b6160f16080830186615fe5565b6160fe60a0830185615e93565b81810360c08301526161108184616040565b905098975050505050505050565b5f6020820190506161315f830184615fe5565b92915050565b5f806040838503121561614d5761614c6159b7565b5b5f61615a858286016159d5565b925050602061616b85828601615cf4565b9150509250929050565b5f6020828403121561618a576161896159b7565b5b5f61619784828501615cf4565b91505092915050565b5f61010083015f8301518482035f8601526161bb82826156f7565b91505060208301516161d0602086018261575f565b5060408301516161e3604086018261575f565b5060608301516161f66060860182615675565b506080830151848203608086015261620e8282615788565b91505060a083015184820360a086015261622882826156f7565b91505060c083015184820360c086015261624282826156f7565b91505060e083015184820360e086015261625c8282615788565b9150508091505092915050565b5f6020820190508181035f83015261628181846161a0565b905092915050565b5f82825260208201905092915050565b5f6162a3826156be565b6162ad8185616289565b9350836020820285016162bf856156d8565b805f5b858110156162fa57848403895281516162db8582615889565b94506162e68361589c565b925060208a019950506001810190506162c2565b50829750879550505050505092915050565b5f6020820190508181035f8301526163248184616299565b905092915050565b5f6060828403121561634157616340615b5b565b5b81905092915050565b5f805f805f806101008789031215616365576163646159b7565b5b5f61637289828a01615b5f565b965050604061638389828a0161632c565b95505060a061639489828a01615abd565b94505060c06163a589828a016159d5565b93505060e087013567ffffffffffffffff8111156163c6576163c56159bb565b5b6163d289828a01615b06565b92509250509295509295509295565b5f81905092915050565b5f6163f5826155cb565b6163ff81856163e1565b935061640f8185602086016155e5565b80840191505092915050565b7f20760000000000000000000000000000000000000000000000000000000000005f82015250565b5f61644f6002836163e1565b915061645a8261641b565b600282019050919050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f6164996001836163e1565b91506164a482616465565b600182019050919050565b5f6164ba82876163eb565b91506164c582616443565b91506164d182866163eb565b91506164dc8261648d565b91506164e882856163eb565b91506164f38261648d565b91506164ff82846163eb565b915081905095945050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f600282049050600182168061655157607f821691505b6020821081036165645761656361650d565b5b50919050565b5f82905092915050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026165d07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82616595565b6165da8683616595565b95508019841693508086168417925050509392505050565b5f819050919050565b5f61661561661061660b8461559a565b6165f2565b61559a565b9050919050565b5f819050919050565b61662e836165fb565b61664261663a8261661c565b8484546165a1565b825550505050565b5f90565b61665661664a565b616661818484616625565b505050565b5b81811015616684576166795f8261664e565b600181019050616667565b5050565b601f8211156166c95761669a81616574565b6166a384616586565b810160208510156166b2578190505b6166c66166be85616586565b830182616666565b50505b505050565b5f82821c905092915050565b5f6166e95f19846008026166ce565b1980831691505092915050565b5f61670183836166da565b9150826002028217905092915050565b61671b838361656a565b67ffffffffffffffff81111561673457616733615d0c565b5b61673e825461653a565b616749828285616688565b5f601f831160018114616776575f8415616764578287013590505b61676e85826166f6565b8655506167d5565b601f19841661678486616574565b5f5b828110156167ab57848901358255600182019150602085019450602081019050616786565b868310156167c857848901356167c4601f8916826166da565b8355505b6001600288020188555050505b50505050505050565b5f6040820190506167f15f8301856155a3565b6167fe60208301846155a3565b9392505050565b5f6040820190508181035f83015261681d818561591b565b90508181036020830152616831818461591b565b90509392505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6168718261559a565b915061687c8361559a565b92508282019050808211156168945761689361683a565b5b92915050565b5f6060820190508181035f8301526168b2818661591b565b905081810360208301526168c6818561591b565b90506168d560408301846155a3565b949350505050565b5f815190506168eb81615cde565b92915050565b5f60208284031215616906576169056159b7565b5b5f616913848285016168dd565b91505092915050565b7f4549503731323a20556e696e697469616c697a656400000000000000000000005f82015250565b5f6169506015836155d5565b915061695b8261691c565b602082019050919050565b5f6020820190508181035f83015261697d81616944565b9050919050565b5f6040820190506169975f8301856155a3565b6169a46020830184615fe5565b9392505050565b5f6169b960208401846159d5565b905092915050565b604082016169d15f8301836169ab565b6169dd5f850182615675565b506169eb60208301836169ab565b6169f86020850182615675565b50505050565b60608201616a0e5f8301836169ab565b616a1a5f850182615675565b50616a2860208301836169ab565b616a356020850182615675565b50616a4360408301836169ab565b616a506040850182615675565b50505050565b616a5f81615684565b82525050565b5f819050919050565b5f80fd5b5f80fd5b5f80fd5b5f8083356001602003843603038112616a9657616a95616a76565b5b83810192508235915060208301925067ffffffffffffffff821115616abe57616abd616a6e565b5b600182023603831315616ad457616ad3616a72565b5b509250929050565b5f616ae783856156e7565b9350616af4838584615db4565b616afd8361560d565b840190509392505050565b5f616b166020840184615cf4565b905092915050565b5f8083356001602003843603038112616b3a57616b39616a76565b5b83810192508235915060208301925067ffffffffffffffff821115616b6257616b61616a6e565b5b600182023603831315616b7857616b77616a72565b5b509250929050565b5f616b8b8385615778565b9350616b98838584615db4565b616ba18361560d565b840190509392505050565b5f6101008301616bbe5f840184616a7a565b8583035f870152616bd0838284616adc565b92505050616be16020840184616b08565b616bee602086018261575f565b50616bfc6040840184616b08565b616c09604086018261575f565b50616c1760608401846169ab565b616c246060860182615675565b50616c326080840184616b1e565b8583036080870152616c45838284616b80565b92505050616c5660a0840184616a7a565b85830360a0870152616c69838284616adc565b92505050616c7a60c0840184616a7a565b85830360c0870152616c8d838284616adc565b92505050616c9e60e0840184616b1e565b85830360e0870152616cb1838284616b80565b925050508091505092915050565b5f616cca8383616bac565b905092915050565b5f8235600161010003833603038112616cee57616ced616a76565b5b82810191505092915050565b5f602082019050919050565b5f616d118385616289565b935083602084028501616d2384616a65565b805f5b87811015616d66578484038952616d3d8284616cd2565b616d478582616cbf565b9450616d5283616cfa565b925060208a01995050600181019050616d26565b50829750879450505050509392505050565b5f61010082019050616d8c5f8301896169c1565b616d9960408301886169fe565b616da660a0830187616a56565b616db360c08301866155a3565b81810360e0830152616dc6818486616d06565b9050979650505050505050565b5f67ffffffffffffffff82169050919050565b616def81616dd3565b82525050565b5f602082019050616e085f830184616de6565b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f604082019050616e4e5f830185615e93565b616e5b60208301846155a3565b9392505050565b5f6040820190508181035f830152616e7a818561591b565b9050616e8960208301846155a3565b9392505050565b5f616e9a8261559a565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203616ecc57616ecb61683a565b5b600182019050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f80fd5b5f80fd5b5f80fd5b5f8235600161010003833603038112616f2c57616f2b616f04565b5b80830191505092915050565b5f8083356001602003843603038112616f5457616f53616f04565b5b80840192508235915067ffffffffffffffff821115616f7657616f75616f08565b5b602083019250600182023603831315616f9257616f91616f0c565b5b509250929050565b5f82905092915050565b5f819050815f5260205f209050919050565b601f821115616ff757616fc881616fa4565b616fd184616586565b81016020851015616fe0578190505b616ff4616fec85616586565b830182616666565b50505b505050565b6170068383616f9a565b67ffffffffffffffff81111561701f5761701e615d0c565b5b617029825461653a565b617034828285616fb6565b5f601f831160018114617061575f841561704f578287013590505b61705985826166f6565b8655506170c0565b601f19841661706f86616fa4565b5f5b8281101561709657848901358255600182019150602085019450602081019050617071565b868310156170b357848901356170af601f8916826166da565b8355505b6001600288020188555050505b50505050505050565b6170d4838383616ffc565b505050565b5f81356170e581615cde565b80915050919050565b5f815f1b9050919050565b5f73ffffffffffffffffffffffffffffffffffffffff617118846170ee565b9350801983169250808416831791505092915050565b5f61714861714361713e8461572f565b6165f2565b61572f565b9050919050565b5f6171598261712e565b9050919050565b5f61716a8261714f565b9050919050565b5f819050919050565b61718382617160565b61719661718f82617171565b83546170f9565b8255505050565b5f81356171a9816159bf565b80915050919050565b5f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6171dd846170ee565b9350801983169250808416831791505092915050565b6171fc826165fb565b61720f6172088261661c565b83546171b2565b8255505050565b5f808335600160200384360303811261723257617231616f04565b5b80840192508235915067ffffffffffffffff82111561725457617253616f08565b5b6020830192506001820236038313156172705761726f616f0c565b5b509250929050565b617283838383616711565b505050565b5f81015f83016172988185616f38565b6172a38183866170c9565b505050506001810160208301806172b9816170d9565b90506172c5818461717a565b5050506002810160408301806172da816170d9565b90506172e6818461717a565b5050506003810160608301806172fb8161719d565b905061730781846171f3565b505050600481016080830161731c8185617216565b617327818386617278565b505050506005810160a0830161733d8185616f38565b6173488183866170c9565b505050506006810160c0830161735e8185616f38565b6173698183866170c9565b505050506007810160e0830161737f8185617216565b61738a818386617278565b505050505050565b61739c8282617288565b5050565b6173a981615e8a565b81146173b3575f80fd5b50565b5f815190506173c4816173a0565b92915050565b5f602082840312156173df576173de6159b7565b5b5f6173ec848285016173b6565b91505092915050565b5f6060820190506174085f8301866155a3565b61741560208301856155a3565b61742260408301846155a3565b949350505050565b617433826155cb565b67ffffffffffffffff81111561744c5761744b615d0c565b5b617456825461653a565b617461828285616fb6565b5f60209050601f831160018114617492575f8415617480578287015190505b61748a85826166f6565b8655506174f1565b601f1984166174a086616fa4565b5f5b828110156174c7578489015182556001820191506020850194506020810190506174a2565b868310156174e457848901516174e0601f8916826166da565b8355505b6001600288020188555050505b505050505050565b5f81905092915050565b5f61750d8261576e565b61751781856174f9565b93506175278185602086016155e5565b80840191505092915050565b5f61753e8284617503565b915081905092915050565b5f60a08201905061755c5f830188615e93565b6175696020830187615e93565b6175766040830186615e93565b61758360608301856155a3565b6175906080830184615fe5565b9695505050505050565b5f60ff82169050919050565b6175af8161759a565b82525050565b5f6080820190506175c85f830187615e93565b6175d560208301866175a6565b6175e26040830185615e93565b6175ef6060830184615e93565b9594505050505056fe4b6579526573686172696e67566572696669636174696f6e2875696e7432353620636f6e74657874496429
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0`@R0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x80\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP4\x80\x15b\0\0CW_\x80\xFD[Pb\0\0Tb\0\0Z` \x1B` \x1CV[b\0\x01\xC4V[_b\0\0kb\0\x01^` \x1B` \x1CV[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15b\0\0\xB6W`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14b\0\x01[Wg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@Qb\0\x01R\x91\x90b\0\x01\xA9V[`@Q\x80\x91\x03\x90\xA1[PV[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[b\0\x01\xA3\x81b\0\x01\x85V[\x82RPPV[_` \x82\x01\x90Pb\0\x01\xBE_\x83\x01\x84b\0\x01\x98V[\x92\x91PPV[`\x80Qav$b\0\x01\xEB_9_\x81\x81a;\xB2\x01R\x81\x81a<\x07\x01Ra=\xC1\x01Rav$_\xF3\xFE`\x80`@R`\x046\x10a\x02$W_5`\xE0\x1C\x80c\x84\xB0\x19n\x11a\x01\"W\x80c\xDE\xFB\xA0j\x11a\0\xAAW\x80c\xE7.\xE9\x91\x11a\0nW\x80c\xE7.\xE9\x91\x14a\x07\\W\x80c\xEB\x84<\xF6\x14a\x07\x86W\x80c\xED\xC4O\x19\x14a\x07\xAEW\x80c\xF2|\xB9W\x14a\x07\xD6W\x80c\xF2\xFD\xE3\x8B\x14a\x07\xECWa\x02$V[\x80c\xDE\xFB\xA0j\x14a\x06~W\x80c\xDF\xE3j\xEE\x14a\x06\xA6W\x80c\xE2K\xA4\xE5\x14a\x06\xCEW\x80c\xE3\x0C9x\x14a\x06\xF6W\x80c\xE3\xB2\xA8t\x14a\x07 Wa\x02$V[\x80c\xAD<\xB1\xCC\x11a\0\xF1W\x80c\xAD<\xB1\xCC\x14a\x05\x9EW\x80c\xB8q]M\x14a\x05\xC8W\x80c\xC0\xAEd\xF7\x14a\x06\x04W\x80c\xC1\xC8\xB7%\x14a\x06,W\x80c\xD8\xE3\xAE\x01\x14a\x06TWa\x02$V[\x80c\x84\xB0\x19n\x14a\x05\x06W\x80c\x8C\xB9gQ\x14a\x056W\x80c\x8D\xA5\xCB[\x14a\x05LW\x80c\x9E\xE7z\xF3\x14a\x05vWa\x02$V[\x80cMiB`\x11a\x01\xB0W\x80cqP\x18\xA6\x11a\x01tW\x80cqP\x18\xA6\x14a\x04pW\x80ct \xF3\xD4\x14a\x04\x86W\x80cy\xBAP\x97\x14a\x04\xB0W\x80c~\xAA\xC8\xF2\x14a\x04\xC6W\x80c\x84V\xCBY\x14a\x04\xF0Wa\x02$V[\x80cMiB`\x14a\x03\x88W\x80cO\x1E\xF2\x86\x14a\x03\xC4W\x80cR\xD1\x90-\x14a\x03\xE0W\x80c\\\x97Z\xBB\x14a\x04\nW\x80cd\xB0\x0C\xC5\x14a\x044Wa\x02$V[\x80c\x16\x9C\xAC\x14\x11a\x01\xF7W\x80c\x16\x9C\xAC\x14\x14a\x02\xCEW\x80c.-:\x82\x14a\x02\xF6W\x80c?K\xA8:\x14a\x03\x1EW\x80cC\xE3~\x8A\x14a\x034W\x80cIe\xE4U\x14a\x03^Wa\x02$V[\x80c\nP\xE3\x18\x14a\x02(W\x80c\r\x8En,\x14a\x02RW\x80c\r\xD4\x86\xC0\x14a\x02|W\x80c\x10y\xEB\xEB\x14a\x02\xA6W[_\x80\xFD[4\x80\x15a\x023W_\x80\xFD[Pa\x02<a\x08\x14V[`@Qa\x02I\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02]W_\x80\xFD[Pa\x02fa\x08-V[`@Qa\x02s\x91\x90aVUV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\x87W_\x80\xFD[Pa\x02\x90a\x08\xA8V[`@Qa\x02\x9D\x91\x90aY\x8EV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xB1W_\x80\xFD[Pa\x02\xCC`\x04\x806\x03\x81\x01\x90a\x02\xC7\x91\x90aZJV[a\r4V[\0[4\x80\x15a\x02\xD9W_\x80\xFD[Pa\x02\xF4`\x04\x806\x03\x81\x01\x90a\x02\xEF\x91\x90a[}V[a\x12\xF1V[\0[4\x80\x15a\x03\x01W_\x80\xFD[Pa\x03\x1C`\x04\x806\x03\x81\x01\x90a\x03\x17\x91\x90a\\'V[a\x14\xBAV[\0[4\x80\x15a\x03)W_\x80\xFD[Pa\x032a\x15#V[\0[4\x80\x15a\x03?W_\x80\xFD[Pa\x03Ha\x155V[`@Qa\x03U\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03iW_\x80\xFD[Pa\x03ra\x15NV[`@Qa\x03\x7F\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x93W_\x80\xFD[Pa\x03\xAE`\x04\x806\x03\x81\x01\x90a\x03\xA9\x91\x90a\\'V[a\x15eV[`@Qa\x03\xBB\x91\x90a\\\xC5V[`@Q\x80\x91\x03\x90\xF3[a\x03\xDE`\x04\x806\x03\x81\x01\x90a\x03\xD9\x91\x90a^0V[a\x15\x85V[\0[4\x80\x15a\x03\xEBW_\x80\xFD[Pa\x03\xF4a\x15\xA4V[`@Qa\x04\x01\x91\x90a^\xA2V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x15W_\x80\xFD[Pa\x04\x1Ea\x15\xD5V[`@Qa\x04+\x91\x90a^\xCAV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04?W_\x80\xFD[Pa\x04Z`\x04\x806\x03\x81\x01\x90a\x04U\x91\x90a\\'V[a\x15\xF7V[`@Qa\x04g\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04{W_\x80\xFD[Pa\x04\x84a\x16\x86V[\0[4\x80\x15a\x04\x91W_\x80\xFD[Pa\x04\x9Aa\x16\x99V[`@Qa\x04\xA7\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xBBW_\x80\xFD[Pa\x04\xC4a\x17MV[\0[4\x80\x15a\x04\xD1W_\x80\xFD[Pa\x04\xDAa\x17\xDBV[`@Qa\x04\xE7\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xFBW_\x80\xFD[Pa\x05\x04a\x18\x8FV[\0[4\x80\x15a\x05\x11W_\x80\xFD[Pa\x05\x1Aa\x19\xCAV[`@Qa\x05-\x97\x96\x95\x94\x93\x92\x91\x90a`\x9CV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05AW_\x80\xFD[Pa\x05Ja\x1A\xD3V[\0[4\x80\x15a\x05WW_\x80\xFD[Pa\x05`a\x1C\xC5V[`@Qa\x05m\x91\x90aa\x1EV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\x81W_\x80\xFD[Pa\x05\x9C`\x04\x806\x03\x81\x01\x90a\x05\x97\x91\x90a\\'V[a\x1C\xFAV[\0[4\x80\x15a\x05\xA9W_\x80\xFD[Pa\x05\xB2a\x1E\tV[`@Qa\x05\xBF\x91\x90aVUV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xD3W_\x80\xFD[Pa\x05\xEE`\x04\x806\x03\x81\x01\x90a\x05\xE9\x91\x90a\\'V[a\x1EBV[`@Qa\x05\xFB\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\x0FW_\x80\xFD[Pa\x06*`\x04\x806\x03\x81\x01\x90a\x06%\x91\x90a\\'V[a\x1E\xD1V[\0[4\x80\x15a\x067W_\x80\xFD[Pa\x06R`\x04\x806\x03\x81\x01\x90a\x06M\x91\x90a\\'V[a\x1F\xE0V[\0[4\x80\x15a\x06_W_\x80\xFD[Pa\x06ha ?V[`@Qa\x06u\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\x89W_\x80\xFD[Pa\x06\xA4`\x04\x806\x03\x81\x01\x90a\x06\x9F\x91\x90aa7V[a VV[\0[4\x80\x15a\x06\xB1W_\x80\xFD[Pa\x06\xCC`\x04\x806\x03\x81\x01\x90a\x06\xC7\x91\x90aa7V[a!kV[\0[4\x80\x15a\x06\xD9W_\x80\xFD[Pa\x06\xF4`\x04\x806\x03\x81\x01\x90a\x06\xEF\x91\x90a\\'V[a\"\x80V[\0[4\x80\x15a\x07\x01W_\x80\xFD[Pa\x07\na\"\xDFV[`@Qa\x07\x17\x91\x90aa\x1EV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07+W_\x80\xFD[Pa\x07F`\x04\x806\x03\x81\x01\x90a\x07A\x91\x90aauV[a#\x14V[`@Qa\x07S\x91\x90abiV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07gW_\x80\xFD[Pa\x07pa'\x93V[`@Qa\x07}\x91\x90ac\x0CV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\x91W_\x80\xFD[Pa\x07\xAC`\x04\x806\x03\x81\x01\x90a\x07\xA7\x91\x90a\\'V[a'\xA6V[\0[4\x80\x15a\x07\xB9W_\x80\xFD[Pa\x07\xD4`\x04\x806\x03\x81\x01\x90a\x07\xCF\x91\x90acJV[a(\x0FV[\0[4\x80\x15a\x07\xE1W_\x80\xFD[Pa\x07\xEAa*AV[\0[4\x80\x15a\x07\xF7W_\x80\xFD[Pa\x08\x12`\x04\x806\x03\x81\x01\x90a\x08\r\x91\x90aauV[a+.V[\0[_\x80a\x08\x1Ea+\xE7V[\x90P\x80_\x01`\x04\x01T\x91PP\x90V[```@Q\x80`@\x01`@R\x80`\x0B\x81R` \x01\x7FKmsContexts\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa\x08n_a,\x0EV[a\x08x`\x01a,\x0EV[a\x08\x81_a,\x0EV[`@Q` \x01a\x08\x94\x94\x93\x92\x91\x90ad\xAFV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P\x90V[a\x08\xB0aT\xE6V[_a\x08\xB9a+\xE7V[\x90P_a\x08\xC4a\x155V[\x90P\x81`\x08\x01_\x82\x81R` \x01\x90\x81R` \x01_ `@Q\x80`\xA0\x01`@R\x90\x81_\x82\x01T\x81R` \x01`\x01\x82\x01T\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04`\xC0\x1Bw\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01_\x90[\x82\x82\x10\x15a\r%W\x83\x82\x90_R` _ \x90`\x08\x02\x01`@Q\x80a\x01\0\x01`@R\x90\x81_\x82\x01\x80Ta\t\xA2\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\t\xCE\x90ae:V[\x80\x15a\n\x19W\x80`\x1F\x10a\t\xF0Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\n\x19V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\t\xFCW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80Ta\n\xE6\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0B\x12\x90ae:V[\x80\x15a\x0B]W\x80`\x1F\x10a\x0B4Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0B]V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0B@W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta\x0Bv\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0B\xA2\x90ae:V[\x80\x15a\x0B\xEDW\x80`\x1F\x10a\x0B\xC4Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0B\xEDV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0B\xD0W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x06\x82\x01\x80Ta\x0C\x06\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0C2\x90ae:V[\x80\x15a\x0C}W\x80`\x1F\x10a\x0CTWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0C}V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0C`W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x07\x82\x01\x80Ta\x0C\x96\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0C\xC2\x90ae:V[\x80\x15a\r\rW\x80`\x1F\x10a\x0C\xE4Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\r\rV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0C\xF0W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x81R` \x01\x90`\x01\x01\x90a\tqV[PPPP\x81RPP\x92PPP\x90V[a\r>\x833a VV[_a\rGa+\xE7V[\x90Pa\rU\x81_\x01\x85a,\xD8V[a\r\x96W\x83`@Q\x7F^Q\xA2\xE1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\r\x8D\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[_`@Q\x80` \x01`@R\x80\x86\x81RP\x90P_a\r\xB2\x82a-'V[\x90Pa\r\xC0\x86\x82\x87\x87a-\x82V[_\x83`\x0C\x01_\x88\x81R` \x01\x90\x81R` \x01_ \x90P\x80\x86\x86\x90\x91\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x92\x90\x91\x92\x90\x91\x92\x90\x91\x92P\x91\x82a\x0E\x0F\x92\x91\x90ag\x11V[P_\x84`\x08\x01_\x89\x81R` \x01\x90\x81R` \x01_ `@Q\x80`\xA0\x01`@R\x90\x81_\x82\x01T\x81R` \x01`\x01\x82\x01T\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04`\xC0\x1Bw\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01_\x90[\x82\x82\x10\x15a\x12pW\x83\x82\x90_R` _ \x90`\x08\x02\x01`@Q\x80a\x01\0\x01`@R\x90\x81_\x82\x01\x80Ta\x0E\xED\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0F\x19\x90ae:V[\x80\x15a\x0FdW\x80`\x1F\x10a\x0F;Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0FdV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0FGW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80Ta\x101\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x10]\x90ae:V[\x80\x15a\x10\xA8W\x80`\x1F\x10a\x10\x7FWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x10\xA8V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x10\x8BW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta\x10\xC1\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x10\xED\x90ae:V[\x80\x15a\x118W\x80`\x1F\x10a\x11\x0FWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x118V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x11\x1BW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x06\x82\x01\x80Ta\x11Q\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x11}\x90ae:V[\x80\x15a\x11\xC8W\x80`\x1F\x10a\x11\x9FWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x11\xC8V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x11\xABW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x07\x82\x01\x80Ta\x11\xE1\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x12\r\x90ae:V[\x80\x15a\x12XW\x80`\x1F\x10a\x12/Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x12XV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x12;W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x81R` \x01\x90`\x01\x01\x90a\x0E\xBCV[PPPP\x81RPP\x90Pa\x12\x88\x81\x83\x80T\x90Pa.\xF4V[\x15a\x12\xE7W_\x85`\x06\x01_\x8A\x81R` \x01\x90\x81R` \x01_ T\x90Pa\x12\xAE\x82\x82a/\x0BV[\x7Fh\x89\x8A\x98\x93k\xF2:V\xE8\xEDK#\xDC\xC9\x8C\xEF\x92k\xD9\xAC,\xE5\"\xF1\xF9B>8d\xF2\xF5\x82`@Qa\x12\xDD\x91\x90aY\x8EV[`@Q\x80\x91\x03\x90\xA1P[PPPPPPPPV[a\x12\xF9a/\x8EV[_a\x13\x02a+\xE7V[\x90P_a\x13\ra\x08\xA8V[\x90P_\x81`\x80\x01QQ\x90P_\x86\x86\x90P\x90P\x81\x81\x14a\x13eW\x81\x81`@Q\x7F\xD5\x95\xA9b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\\\x92\x91\x90ag\xDEV[`@Q\x80\x91\x03\x90\xFD[_a\x13na\x08\x14V[\x90P_\x81\x14a\x13\xB4W\x80`@Q\x7Fv#\xD3W\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\xAB\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[_a\x13\xC6\x85_\x01Q\x8D\x8C\x8C\x8C\x8Ca0\x15V[\x90P\x7F6b\xEC1mv\xE6\xA7^\xB7\xC4P\x01\xA8\xADt\xC3\xEB\x94>\x87x\x11\x1C\x02%\xF2\xA9\xFD^\0\xE6\x85\x82`@Qa\x13\xF9\x92\x91\x90ah\x05V[`@Q\x80\x91\x03\x90\xA1a\x14\x10\x86_\x01\x82_\x01Qa9cV[\x8A\x15a\x14\xA0W\x8C\x86`\x06\x01_\x83_\x01Q\x81R` \x01\x90\x81R` \x01_ \x81\x90UP_\x86`\x05\x01TCa\x14B\x91\x90ahgV[\x90P\x80\x87`\x12\x01_\x84_\x01Q\x81R` \x01\x90\x81R` \x01_ \x81\x90UP\x7F]\xC6\x01\x06Z\x03]x0\\\xD9\xEF'\xC9\x1A\0\x9C\xD8\xD3r\x97\xE4;\xB7c\x19I\x08\x95\xA0\xD0X\x86\x83\x83`@Qa\x14\x92\x93\x92\x91\x90ah\x9AV[`@Q\x80\x91\x03\x90\xA1Pa\x14\xABV[a\x14\xAA\x81\x8Ea/\x0BV[[PPPPPPPPPPPPPV[a\x14\xC2a/\x8EV[a\x14\xCAa:0V[_a\x14\xD3a\x08\xA8V[\x90Pa\x14\xE8\x81_\x01Q\x83\x83`\x80\x01QQa:qV[\x7F\xE4\x18\x02\xAFrW)\xAD\xCB\x8C\x15\x1E)78\n%\xC6\x91Uu~:\xF5\xD3\x97\x9A\xDA\xB5\x03X\0\x82`@Qa\x15\x17\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1PPV[a\x15+a/\x8EV[a\x153a;\x1AV[V[_\x80a\x15?a+\xE7V[\x90P\x80_\x01`\x03\x01T\x91PP\x90V[_\x80a\x15Xa+\xE7V[\x90P\x80`\x05\x01T\x91PP\x90V[_\x80a\x15oa+\xE7V[\x90Pa\x15}\x81_\x01\x84a;\x88V[\x91PP\x91\x90PV[a\x15\x8Da;\xB0V[a\x15\x96\x82a<\x96V[a\x15\xA0\x82\x82a<\xA1V[PPV[_a\x15\xADa=\xBFV[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x90P\x90V[_\x80a\x15\xDFa>FV[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x91PP\x90V[_\x81_a\x16\x02a+\xE7V[\x90P_\x81`\x08\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a\x16]W\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x16T\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[_a\x16fa+\xE7V[\x90P\x80`\x16\x01_\x86\x81R` \x01\x90\x81R` \x01_ T\x93PPPP\x91\x90PV[a\x16\x8Ea/\x8EV[a\x16\x97_a>mV[V[``_a\x16\xA4a\x155V[\x90P_a\x16\xAFa+\xE7V[\x90P\x80`\x10\x01_\x83\x81R` \x01\x90\x81R` \x01_ \x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x17AW` \x02\x82\x01\x91\x90_R` _ \x90[\x81_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x16\xF8W[PPPPP\x92PPP\x90V[_a\x17Va>\xAAV[\x90P\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x17wa\"\xDFV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x17\xCFW\x80`@Q\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x17\xC6\x91\x90aa\x1EV[`@Q\x80\x91\x03\x90\xFD[a\x17\xD8\x81a>mV[PV[``_a\x17\xE6a\x155V[\x90P_a\x17\xF1a+\xE7V[\x90P\x80`\x11\x01_\x83\x81R` \x01\x90\x81R` \x01_ \x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x18\x83W` \x02\x82\x01\x91\x90_R` _ \x90[\x81_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x18:W[PPPPP\x92PPP\x90V[a\x18\x97a\x1C\xC5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15\x80\x15a\x19~WPs\xC7\xD4Va\xA3E\xEC\\\xA0\xE8R\x1C\xFE\xF7\xE3/\xDA\r\xAAhs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cp\x08\xB5H`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x19*W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x19N\x91\x90ah\xF1V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15a\x19\xC0W3`@Q\x7FF\xC0\xD9\xAF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x19\xB7\x91\x90aa\x1EV[`@Q\x80\x91\x03\x90\xFD[a\x19\xC8a>\xB1V[V[_``\x80_\x80_``_a\x19\xDCa? V[\x90P_\x80\x1B\x81_\x01T\x14\x80\x15a\x19\xF7WP_\x80\x1B\x81`\x01\x01T\x14[a\x1A6W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1A-\x90aifV[`@Q\x80\x91\x03\x90\xFD[a\x1A>a?GV[a\x1AFa?\xE5V[F0_\x80\x1B_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1AeWa\x1Ada]\x0CV[[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x1A\x93W\x81` \x01` \x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x7F\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x95\x94\x93\x92\x91\x90\x97P\x97P\x97P\x97P\x97P\x97P\x97PP\x90\x91\x92\x93\x94\x95\x96V[a\x1A\xDBa:0V[_a\x1A\xE4a+\xE7V[\x90P_\x81_\x01`\x01\x01T\x90P_\x81\x14a\x1B\x8DW\x81`\x12\x01_\x82\x81R` \x01\x90\x81R` \x01_ TC\x11\x15a\x1B\x8CW~\x9F\xE8\xF0\xDBE\x99m\xEC\xF7\xB0o\xC7\xB6\xEC_\x88}_\x04\xDB.\x0CJ\xD7\xF4\xE4\xEE^\xEF\xC5\xA3\x81`@Qa\x1B@\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1a\x1BT\x82_\x01\x82a@\x83V[\x7F>\x8F\x02\xDCz\xF6\xE3\xA6\x7F:\xF0\xBC\x99\xBC\xF1\x1BM\xEBF\x10^\x9B\xA7\xF1\xACm\xA8#\"\xE9\x02^\x81`@Qa\x1B\x83\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1[[_\x82_\x01`\x02\x01T\x90P_\x81\x14a\x1CMW\x82`\x13\x01_\x82\x81R` \x01\x90\x81R` \x01_ TC\x11\x15a\x1CLW_a\x1B\xC2a\x155V[\x90Pa\x1B\xD0\x84_\x01\x82aAPV[\x7F\x85\x1A\x08\xC1k\x15\x95\x9C3\x8A\xC4\xB5df\xD0l\x9F\x9D_\xF8\xD7\x15\x16\x8A\xA1%\xD5\xCC\xAFS\x83 \x81`@Qa\x1B\xFF\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1a\x1C\x13\x84_\x01\x83aB&V[\x7FOT\xA6\xAC\x98\x1C\xC8\xDC\x83\x14+>\xB4\xD1 \xBE|p\xFC]\xE6Gz\x14\xEA\xE3\xE9\xCAdvD\xBC\x82`@Qa\x1CB\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1P[[_a\x1CVa\x08\x14V[\x90P_\x81\x14a\x1C\xBFW\x83`\x14\x01_\x82\x81R` \x01\x90\x81R` \x01_ TC\x11\x15a\x1C\xBEWa\x1C\x86\x84_\x01\x82aC!V[\x7F\x8F\xB7XX\xA5e\xAE\xE1\x174-\x93\x19j\x7F\x0BT\xC1\xC8Q\x98\x85\xED\xDD\xA6\xA0\x1FGsY\xB3c\x81`@Qa\x1C\xB5\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1[[PPPPV[_\x80a\x1C\xCFaD#V[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x90V[a\x1D\x02a/\x8EV[\x80_a\x1D\x0Ca+\xE7V[\x90P_\x81`\x08\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a\x1DgW\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1D^\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[_a\x1Dpa+\xE7V[\x90Pa\x1D~\x81_\x01\x85aDJV[\x15a\x1D\xC0W\x83`@Q\x7Fw\xD0^\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1D\xB7\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[a\x1D\xCC\x81_\x01\x85aD\x99V[\x7F\xBC\x11\x14\xFA\x9Awd\x8C\xD0\x97\xEEl\xF1I\xC3D\xFA'\x8B\x9B\x98?0\xDDe\xB6\xFDj\x9DFJ\x07\x84`@Qa\x1D\xFB\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1PPPPV[`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x81V[_\x81_a\x1EMa+\xE7V[\x90P_\x81`\x08\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a\x1E\xA8W\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1E\x9F\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[_a\x1E\xB1a+\xE7V[\x90P\x80`\x15\x01_\x86\x81R` \x01\x90\x81R` \x01_ T\x93PPPP\x91\x90PV[a\x1E\xD9a/\x8EV[\x80_a\x1E\xE3a+\xE7V[\x90P_\x81`\x08\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a\x1F>W\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1F5\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[_a\x1FGa+\xE7V[\x90Pa\x1FU\x81_\x01\x85aDJV[\x15a\x1F\x97W\x83`@Q\x7F\xB2^N\xB3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1F\x8E\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[a\x1F\xA3\x81_\x01\x85a@\x83V[\x7F>\x8F\x02\xDCz\xF6\xE3\xA6\x7F:\xF0\xBC\x99\xBC\xF1\x1BM\xEBF\x10^\x9B\xA7\xF1\xACm\xA8#\"\xE9\x02^\x84`@Qa\x1F\xD2\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1PPPPV[a\x1F\xE8a/\x8EV[a\x1F\xF0a:0V[_a\x1F\xF9a+\xE7V[\x90P\x81\x81`\x07\x01\x81\x90UP\x7F:\xD5\xC2'$\xAF\xAB\x8E\xD2\xB5x\xFB\x9B\x16\x0C\x7Fe\xF5\xAB\xD0\xAA\xD1\x05u+{\xA4\xE0h\xA3\xE0!\x82`@Qa 3\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1PPV[_\x80a Ia+\xE7V[\x90P\x80`\x07\x01T\x91PP\x90V[\x81_a `a+\xE7V[\x90P_\x81`\x08\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a \xBBW\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a \xB2\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[_a \xC4a+\xE7V[\x90P\x80`\x0E\x01_\x86\x81R` \x01\x90\x81R` \x01_ _\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a!dW\x84\x84`@Q\x7F\xFD\xF8\xA0]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a![\x92\x91\x90ai\x84V[`@Q\x80\x91\x03\x90\xFD[PPPPPV[\x81_a!ua+\xE7V[\x90P_\x81`\x08\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a!\xD0W\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a!\xC7\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[_a!\xD9a+\xE7V[\x90P\x80`\x0F\x01_\x86\x81R` \x01\x90\x81R` \x01_ _\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\"yW\x84\x84`@Q\x7F\x89\xB4^]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\"p\x92\x91\x90ai\x84V[`@Q\x80\x91\x03\x90\xFD[PPPPPV[a\"\x88a/\x8EV[a\"\x90a:0V[_a\"\x99a+\xE7V[\x90P\x81\x81`\x05\x01\x81\x90UP\x7FS\xCB\x96\x8D1\xC2\x8Ce\x04\xA6\xE7=\x99\x08\xDBn\x1C\x1A8kf\xDC\xAC\xEC\x1A\x01\x17u,Z\xB9\x86\x82`@Qa\"\xD3\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1PPV[_\x80a\"\xE9aE\xAEV[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x90V[a#\x1CaU,V[_a#%a\x155V[\x90P_a#0a+\xE7V[\x90P_\x81`\r\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `@Q\x80a\x01\0\x01`@R\x90\x81_\x82\x01\x80Ta#\x9C\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta#\xC8\x90ae:V[\x80\x15a$\x13W\x80`\x1F\x10a#\xEAWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a$\x13V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a#\xF6W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80Ta$\xE0\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta%\x0C\x90ae:V[\x80\x15a%WW\x80`\x1F\x10a%.Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a%WV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a%:W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta%p\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta%\x9C\x90ae:V[\x80\x15a%\xE7W\x80`\x1F\x10a%\xBEWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a%\xE7V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a%\xCAW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x06\x82\x01\x80Ta&\0\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta&,\x90ae:V[\x80\x15a&wW\x80`\x1F\x10a&NWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a&wV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a&ZW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x07\x82\x01\x80Ta&\x90\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta&\xBC\x90ae:V[\x80\x15a'\x07W\x80`\x1F\x10a&\xDEWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a'\x07V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a&\xEAW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x90P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81`@\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a'\x88W\x82\x85`@Q\x7F\x04\x94\xD3\xC0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a'\x7F\x92\x91\x90ai\x84V[`@Q\x80\x91\x03\x90\xFD[\x80\x93PPPP\x91\x90PV[``a'\x9Da\x08\xA8V[`\x80\x01Q\x90P\x90V[a'\xAEa/\x8EV[a'\xB6a:0V[_a'\xBFa\x08\xA8V[\x90Pa'\xD4\x81_\x01Q\x83\x83`\x80\x01QQaE\xD5V[\x7F\x83~\ne(\xDA\xDF\xA2\xDCy&\x92\xC5\x18.R\xA9\xF5\xBB\xDE\xED{#r\x92z&\xC6\x95\x83\x96\x13\x82`@Qa(\x03\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1PPV[`\x02_a(\x1AaF~V[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a(bWP\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15[\x15a(\x99W`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPa)R`@Q\x80`@\x01`@R\x80`\x0B\x81R` \x01\x7FKmsContexts\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP`@Q\x80`@\x01`@R\x80`\x01\x81R` \x01\x7F1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPaF\xA5V[a)ba)]a\x1C\xC5V[aF\xBBV[a)jaF\xCFV[_a)y_\x88\x88\x88\x88\x8Ea0\x15V[\x90P_a)\x84a+\xE7V[\x90Pa)\x95\x81_\x01\x83_\x01QaB&V[a)\xA2\x89\x83_\x01QaF\xE1V[\x7F\x01n\xE9\xC1b\x13\xEDg\xF32\"\xAB\xADM\xFEF\xEB\x95\x1E\xAD0\xA1\n\x1Ar\xDB3\x16\xFF\xB6d\xE0\x8A\x8A\x8A\x8A\x8A\x8A`@Qa)\xDB\x96\x95\x94\x93\x92\x91\x90amxV[`@Q\x80\x91\x03\x90\xA1PP_\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x82`@Qa*/\x91\x90am\xF5V[`@Q\x80\x91\x03\x90\xA1PPPPPPPPV[a*Ia/\x8EV[_a*Ra+\xE7V[\x90P_a*]a\x08\x14V[\x90P_\x81\x03a*\x98W`@Q\x7F ~\xA3\xF3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a*\xA1a\x155V[\x90Pa*\xAF\x83_\x01\x82aC!V[\x7F\x8F\xB7XX\xA5e\xAE\xE1\x174-\x93\x19j\x7F\x0BT\xC1\xC8Q\x98\x85\xED\xDD\xA6\xA0\x1FGsY\xB3c\x81`@Qa*\xDE\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1a*\xF2\x83_\x01\x83aB&V[\x7FOT\xA6\xAC\x98\x1C\xC8\xDC\x83\x14+>\xB4\xD1 \xBE|p\xFC]\xE6Gz\x14\xEA\xE3\xE9\xCAdvD\xBC\x82`@Qa+!\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1PPPV[a+6a/\x8EV[_a+?aE\xAEV[\x90P\x81\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a+\xA1a\x1C\xC5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F8\xD1k\x8C\xAC\"\xD9\x9F\xC7\xC1$\xB9\xCD\r\xE2\xD3\xFA\x1F\xAE\xF4 \xBF\xE7\x91\xD8\xC3b\xD7e\xE2'\0`@Q`@Q\x80\x91\x03\x90\xA3PPV[_\x7F}\x81Y\x81\n~\xBF\x94N\x8F\xA9<\xC4\xFB\xD1\xCA\xDElq\xF8\xB0\xB8k7\x18z\xC7\x99\x17w\xB1\0\x90P\x90V[``_`\x01a,\x1C\x84aG&V[\x01\x90P_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a,:Wa,9a]\x0CV[[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a,lW\x81` \x01`\x01\x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x90P_\x82` \x01\x82\x01\x90P[`\x01\x15a,\xCDW\x80\x80`\x01\x90\x03\x91PP\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\n\x86\x06\x1A\x81S`\n\x85\x81a,\xC2Wa,\xC1an\x0EV[[\x04\x94P_\x85\x03a,yW[\x81\x93PPPP\x91\x90PV[_`\x01`\x07\x81\x11\x15a,\xEDWa,\xECa\\RV[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15a-\x1EWa-\x1Da\\RV[[\x14\x90P\x92\x91PPV[_a-{`@Q\x80``\x01`@R\x80`+\x81R` \x01au\xF9`+\x919\x80Q\x90` \x01 \x83_\x01Q`@Q` \x01a-`\x92\x91\x90an;V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 aHwV[\x90P\x91\x90PV[_a-\x8Ba+\xE7V[\x90P_a-\xDB\x85\x85\x85\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x81\x84\x01R`\x1F\x19`\x1F\x82\x01\x16\x90P\x80\x83\x01\x92PPPPPPPaH\x90V[\x90Pa-\xE7\x86\x82a!kV[\x81`\n\x01_\x87\x81R` \x01\x90\x81R` \x01_ _\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a.\x86W\x85\x81`@Q\x7F\x99\xB1X\xC1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a.}\x92\x91\x90ai\x84V[`@Q\x80\x91\x03\x90\xFD[`\x01\x82`\n\x01_\x88\x81R` \x01\x90\x81R` \x01_ _\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPPPPPPPV[_\x80\x83`\x80\x01QQ\x90P\x80\x83\x10\x15\x91PP\x92\x91PPV[_a/\x14a+\xE7V[\x90Pa/%\x81_\x01\x84_\x01QaH\xBAV[_\x82Ca/2\x91\x90ahgV[\x90P\x80\x82`\x13\x01_\x86_\x01Q\x81R` \x01\x90\x81R` \x01_ \x81\x90UP\x7FE@\xF7\x80\x8F\xCA\xEC\x86\xC3v\xA8\x9D,\x0C\x93\xA5\x05l!h\r\xB5C2\xC7\xF2\x95\x9D\x87\xFE\xFC\x8B\x84\x82`@Qa/\x80\x92\x91\x90anbV[`@Q\x80\x91\x03\x90\xA1PPPPV[a/\x96a>\xAAV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a/\xB4a\x1C\xC5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a0\x13Wa/\xD7a>\xAAV[`@Q\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a0\n\x91\x90aa\x1EV[`@Q\x80\x91\x03\x90\xFD[V[a0\x1DaT\xE6V[_a0&a+\xE7V[\x90P_\x85\x85\x90P\x03a0dW`@Q\x7F\x06\x8C\x8D@\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80`\t\x01_\x81T\x80\x92\x91\x90a0x\x90an\x90V[\x91\x90PUP_\x81`\t\x01T\x90P\x80\x82`\x08\x01_\x83\x81R` \x01\x90\x81R` \x01_ _\x01\x81\x90UP\x88\x82`\x08\x01_\x83\x81R` \x01\x90\x81R` \x01_ `\x01\x01\x81\x90UP\x87\x82`\x08\x01_\x83\x81R` \x01\x90\x81R` \x01_ `\x02\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83`\xC0\x1C\x02\x17\x90UPa0\xFD\x81\x88\x88\x88\x90PaI\x90V[_[\x86\x86\x90P\x81\x10\x15a1\x86W\x82`\x08\x01_\x83\x81R` \x01\x90\x81R` \x01_ `\x04\x01\x87\x87\x83\x81\x81\x10a13Wa12an\xD7V[[\x90P` \x02\x81\x01\x90a1E\x91\x90ao\x10V[\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x08\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a1w\x91\x90as\x92V[PP\x80\x80`\x01\x01\x91PPa0\xFFV[P_[\x86\x86\x90P\x81\x10\x15a4\xDFW\x86\x86\x82\x81\x81\x10a1\xA7Wa1\xA6an\xD7V[[\x90P` \x02\x81\x01\x90a1\xB9\x91\x90ao\x10V[\x83`\r\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x89\x89\x85\x81\x81\x10a1\xE0Wa1\xDFan\xD7V[[\x90P` \x02\x81\x01\x90a1\xF2\x91\x90ao\x10V[`@\x01` \x81\x01\x90a2\x04\x91\x90aauV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ \x81\x81a2I\x91\x90as\x92V[\x90PP`\x01\x83`\x0E\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x89\x89\x85\x81\x81\x10a2uWa2tan\xD7V[[\x90P` \x02\x81\x01\x90a2\x87\x91\x90ao\x10V[`@\x01` \x81\x01\x90a2\x99\x91\x90aauV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x82`\x10\x01_\x83\x81R` \x01\x90\x81R` \x01_ \x87\x87\x83\x81\x81\x10a3\x0EWa3\ran\xD7V[[\x90P` \x02\x81\x01\x90a3 \x91\x90ao\x10V[`@\x01` \x81\x01\x90a32\x91\x90aauV[\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x83`\x0F\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x89\x89\x85\x81\x81\x10a3\xB8Wa3\xB7an\xD7V[[\x90P` \x02\x81\x01\x90a3\xCA\x91\x90ao\x10V[` \x01` \x81\x01\x90a3\xDC\x91\x90aauV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x82`\x11\x01_\x83\x81R` \x01\x90\x81R` \x01_ \x87\x87\x83\x81\x81\x10a4QWa4Pan\xD7V[[\x90P` \x02\x81\x01\x90a4c\x91\x90ao\x10V[` \x01` \x81\x01\x90a4u\x91\x90aauV[\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x80\x80`\x01\x01\x91PPa1\x89V[Pa4\xEE\x81\x85\x88\x88\x90PaJ\x04V[\x81`\x08\x01_\x82\x81R` \x01\x90\x81R` \x01_ `@Q\x80`\xA0\x01`@R\x90\x81_\x82\x01T\x81R` \x01`\x01\x82\x01T\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04`\xC0\x1Bw\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01_\x90[\x82\x82\x10\x15a9MW\x83\x82\x90_R` _ \x90`\x08\x02\x01`@Q\x80a\x01\0\x01`@R\x90\x81_\x82\x01\x80Ta5\xCA\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta5\xF6\x90ae:V[\x80\x15a6AW\x80`\x1F\x10a6\x18Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a6AV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a6$W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80Ta7\x0E\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta7:\x90ae:V[\x80\x15a7\x85W\x80`\x1F\x10a7\\Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a7\x85V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a7hW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta7\x9E\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta7\xCA\x90ae:V[\x80\x15a8\x15W\x80`\x1F\x10a7\xECWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a8\x15V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a7\xF8W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x06\x82\x01\x80Ta8.\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta8Z\x90ae:V[\x80\x15a8\xA5W\x80`\x1F\x10a8|Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a8\xA5V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a8\x88W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x07\x82\x01\x80Ta8\xBE\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta8\xEA\x90ae:V[\x80\x15a95W\x80`\x1F\x10a9\x0CWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a95V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a9\x18W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x81R` \x01\x90`\x01\x01\x90a5\x99V[PPPP\x81RPP\x92PPP\x96\x95PPPPPPV[\x80_\x81\x03a9\x9DW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a9\xA7\x83\x83aJ&V[a9\xE8W\x81`@Q\x7FfS\xF6\xD7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a9\xDF\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[`\x01\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15a:\x1DWa:\x1Ca\\RV[[\x02\x17\x90UP\x81\x83`\x01\x01\x81\x90UPPPPV[a:8a\x15\xD5V[\x15a:oW`@Q\x7F\xD9<\x06e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_a:za+\xE7V[\x90P_\x83\x03a:\xB5W`@Q\x7F\xB1\xAE\x92\xEA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x83\x11\x15a:\xFCW\x82\x82`@Q\x7F\x84 \x8F#\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a:\xF3\x92\x91\x90ag\xDEV[`@Q\x80\x91\x03\x90\xFD[\x82\x81`\x15\x01_\x86\x81R` \x01\x90\x81R` \x01_ \x81\x90UPPPPPV[a;\"aJtV[_a;+a>FV[\x90P_\x81_\x01_a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAAa;pa>\xAAV[`@Qa;}\x91\x90aa\x1EV[`@Q\x80\x91\x03\x90\xA1PV[_\x82_\x01_\x83\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x90P\x92\x91PPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x80a<]WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a<DaJ\xB4V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15a<\x94W`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[a<\x9Ea/\x8EV[PV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cR\xD1\x90-`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15a=\tWP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a=\x06\x91\x90as\xCAV[`\x01[a=JW\x81`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a=A\x91\x90aa\x1EV[`@Q\x80\x91\x03\x90\xFD[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x81\x14a=\xB0W\x80`@Q\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a=\xA7\x91\x90a^\xA2V[`@Q\x80\x91\x03\x90\xFD[a=\xBA\x83\x83aK\x07V[PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a>DW`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_\x7F\xCD^\xD1\\n\x18~w\xE9\xAE\xE8\x81\x84\xC2\x1FO!\x82\xABX'\xCB;~\x07\xFB\xED\xCDc\xF03\0\x90P\x90V[_a>vaE\xAEV[\x90P\x80_\x01_a\x01\0\n\x81T\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90Ua>\xA6\x82aKyV[PPV[_3\x90P\x90V[a>\xB9a:0V[_a>\xC2a>FV[\x90P`\x01\x81_\x01_a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2Xa?\x08a>\xAAV[`@Qa?\x15\x91\x90aa\x1EV[`@Q\x80\x91\x03\x90\xA1PV[_\x7F\xA1jF\xD9Ba\xC7Q|\xC8\xFF\x89\xF6\x1C\x0C\xE95\x98\xE3\xC8I\x80\x10\x11\xDE\xE6I\xA6\xA5W\xD1\0\x90P\x90V[``_a?Ra? V[\x90P\x80`\x02\x01\x80Ta?c\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta?\x8F\x90ae:V[\x80\x15a?\xDAW\x80`\x1F\x10a?\xB1Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a?\xDAV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a?\xBDW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x91PP\x90V[``_a?\xF0a? V[\x90P\x80`\x03\x01\x80Ta@\x01\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta@-\x90ae:V[\x80\x15a@xW\x80`\x1F\x10a@OWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a@xV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a@[W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x91PP\x90V[\x80_\x81\x03a@\xBDW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x07\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15a@\xF2Wa@\xF1a\\RV[[\x02\x17\x90UP\x81\x83`\x01\x01T\x03aA\x0CW_\x83`\x01\x01\x81\x90UP[\x81\x83`\x02\x01T\x03aA!W_\x83`\x02\x01\x81\x90UP[\x81\x83`\x03\x01T\x03aA6W_\x83`\x03\x01\x81\x90UP[\x81\x83`\x04\x01T\x03aAKW_\x83`\x04\x01\x81\x90UP[PPPV[\x80_\x81\x03aA\x8AW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aA\x94\x83\x83aDJV[aA\xD5W\x81`@Q\x7F3\x14\x86\xB3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aA\xCC\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[`\x04\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aB\nWaB\ta\\RV[[\x02\x17\x90UP\x81\x83`\x04\x01\x81\x90UP_\x83`\x03\x01\x81\x90UPPPPV[\x80_\x81\x03aB`W`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aBj\x83\x83aLJV[\x15\x80\x15aB~WPaB|\x83\x83aL\x99V[\x15[\x80\x15aB\x8EWP_\x83`\x03\x01T\x14\x15[\x15aB\xD0W\x81`@Q\x7F\x12\xB4\x9E=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aB\xC7\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[`\x03\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aC\x05WaC\x04a\\RV[[\x02\x17\x90UP\x81\x83`\x03\x01\x81\x90UP_\x83`\x02\x01\x81\x90UPPPPV[\x80_\x81\x03aC[W`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aCe\x83\x83aDJV[\x15\x80aCxWPaCv\x83\x83aL\x99V[\x15[\x15aC\xBAW\x81`@Q\x7F+6R\xD1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aC\xB1\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[`\x05\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aC\xEFWaC\xEEa\\RV[[\x02\x17\x90UP\x81\x83`\x03\x01T\x03aD\tW_\x83`\x03\x01\x81\x90UP[\x81\x83`\x04\x01T\x03aD\x1EW_\x83`\x04\x01\x81\x90UP[PPPV[_\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0\x90P\x90V[_`\x03`\x07\x81\x11\x15aD_WaD^a\\RV[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15aD\x90WaD\x8Fa\\RV[[\x14\x90P\x92\x91PPV[\x80_\x81\x03aD\xD3W`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aD\xDD\x83\x83aJ&V[\x80aD\xEEWPaD\xED\x83\x83a,\xD8V[[\x15aE0W\x81`@Q\x7F\xB0\xC5\x15\x1D\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aE'\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[`\x06\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aEeWaEda\\RV[[\x02\x17\x90UP\x81\x83`\x02\x01T\x03aE\x7FW_\x83`\x02\x01\x81\x90UP[\x81\x83`\x03\x01T\x03aE\x94W_\x83`\x03\x01\x81\x90UP[\x81\x83`\x04\x01T\x03aE\xA9W_\x83`\x04\x01\x81\x90UP[PPPV[_\x7F#~\x15\x82\"\xE3\xE6\x96\x8Br\xB9\xDB\r\x80C\xAA\xCF\x07J\xD9\xF6P\xF0\xD1`kM\x82\xEEC,\0\x90P\x90V[_aE\xDEa+\xE7V[\x90P_\x83\x03aF\x19W`@Q\x7F\xE6\nrq\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x83\x11\x15aF`W\x82\x82`@Q\x7F\xD2S^\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aFW\x92\x91\x90ag\xDEV[`@Q\x80\x91\x03\x90\xFD[\x82\x81`\x16\x01_\x86\x81R` \x01\x90\x81R` \x01_ \x81\x90UPPPPPV[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[aF\xADaL\xE8V[aF\xB7\x82\x82aM(V[PPV[aF\xC3aL\xE8V[aF\xCC\x81aMyV[PV[aF\xD7aL\xE8V[aF\xDFaM\xFDV[V[_aF\xEAa+\xE7V[\x90P\x82_\x015\x81`\x06\x01_\x84\x81R` \x01\x90\x81R` \x01_ \x81\x90UP\x82` \x015\x81`\x05\x01\x81\x90UP\x82`@\x015\x81`\x07\x01\x81\x90UPPPPV[_\x80_\x90Pz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x10aG\x82Wz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x81aGxWaGwan\x0EV[[\x04\x92P`@\x81\x01\x90P[m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x10aG\xBFWm\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x81aG\xB5WaG\xB4an\x0EV[[\x04\x92P` \x81\x01\x90P[f#\x86\xF2o\xC1\0\0\x83\x10aG\xEEWf#\x86\xF2o\xC1\0\0\x83\x81aG\xE4WaG\xE3an\x0EV[[\x04\x92P`\x10\x81\x01\x90P[c\x05\xF5\xE1\0\x83\x10aH\x17Wc\x05\xF5\xE1\0\x83\x81aH\rWaH\x0Can\x0EV[[\x04\x92P`\x08\x81\x01\x90P[a'\x10\x83\x10aH<Wa'\x10\x83\x81aH2WaH1an\x0EV[[\x04\x92P`\x04\x81\x01\x90P[`d\x83\x10aH_W`d\x83\x81aHUWaHTan\x0EV[[\x04\x92P`\x02\x81\x01\x90P[`\n\x83\x10aHnW`\x01\x81\x01\x90P[\x80\x91PP\x91\x90PV[_aH\x89aH\x83aN-V[\x83aN;V[\x90P\x91\x90PV[_\x80_\x80aH\x9E\x86\x86aN{V[\x92P\x92P\x92PaH\xAE\x82\x82aN\xD0V[\x82\x93PPPP\x92\x91PPV[\x80_\x81\x03aH\xF4W`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aH\xFE\x83\x83a,\xD8V[aI?W\x81`@Q\x7F\xC0\xB5\xEEf\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aI6\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[`\x02\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aItWaIsa\\RV[[\x02\x17\x90UP\x81\x83`\x02\x01\x81\x90UP_\x83`\x01\x01\x81\x90UPPPPV[_aI\x99a+\xE7V[\x90P\x81\x83\x10aI\xE3W\x83\x83\x83`@Q\x7F\x87\x89\xA6\xCA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aI\xDA\x93\x92\x91\x90as\xF5V[`@Q\x80\x91\x03\x90\xFD[\x82\x81`\x08\x01_\x86\x81R` \x01\x90\x81R` \x01_ `\x03\x01\x81\x90UPPPPPV[aJ\x12\x83\x83_\x015\x83a:qV[aJ!\x83\x83` \x015\x83aE\xD5V[PPPV[_\x80`\x07\x81\x11\x15aJ:WaJ9a\\RV[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15aJkWaJja\\RV[[\x14\x90P\x92\x91PPV[aJ|a\x15\xD5V[aJ\xB2W`@Q\x7F\x8D\xFC +\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_aJ\xE0\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1BaP2V[_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[aK\x10\x82aP;V[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;`@Q`@Q\x80\x91\x03\x90\xA2_\x81Q\x11\x15aKlWaKf\x82\x82aQ\x04V[PaKuV[aKtaQ\x84V[[PPV[_aK\x82aD#V[\x90P_\x81_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x82\x82_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPPV[_`\x02`\x07\x81\x11\x15aL_WaL^a\\RV[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15aL\x90WaL\x8Fa\\RV[[\x14\x90P\x92\x91PPV[_`\x04`\x07\x81\x11\x15aL\xAEWaL\xADa\\RV[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15aL\xDFWaL\xDEa\\RV[[\x14\x90P\x92\x91PPV[aL\xF0aQ\xC0V[aM&W`@Q\x7F\xD7\xE6\xBC\xF8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[aM0aL\xE8V[_aM9a? V[\x90P\x82\x81`\x02\x01\x90\x81aML\x91\x90at*V[P\x81\x81`\x03\x01\x90\x81aM^\x91\x90at*V[P_\x80\x1B\x81_\x01\x81\x90UP_\x80\x1B\x81`\x01\x01\x81\x90UPPPPV[aM\x81aL\xE8V[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03aM\xF1W_`@Q\x7F\x1EO\xBD\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aM\xE8\x91\x90aa\x1EV[`@Q\x80\x91\x03\x90\xFD[aM\xFA\x81a>mV[PV[aN\x05aL\xE8V[_aN\x0Ea>FV[\x90P_\x81_\x01_a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPPV[_aN6aQ\xDEV[\x90P\x90V[_`@Q\x7F\x19\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x83`\x02\x82\x01R\x82`\"\x82\x01R`B\x81 \x91PP\x92\x91PPV[_\x80_`A\x84Q\x03aN\xBBW_\x80_` \x87\x01Q\x92P`@\x87\x01Q\x91P``\x87\x01Q_\x1A\x90PaN\xAD\x88\x82\x85\x85aRAV[\x95P\x95P\x95PPPPaN\xC9V[_`\x02\x85Q_\x1B\x92P\x92P\x92P[\x92P\x92P\x92V[_`\x03\x81\x11\x15aN\xE3WaN\xE2a\\RV[[\x82`\x03\x81\x11\x15aN\xF6WaN\xF5a\\RV[[\x03\x15aP.W`\x01`\x03\x81\x11\x15aO\x10WaO\x0Fa\\RV[[\x82`\x03\x81\x11\x15aO#WaO\"a\\RV[[\x03aOZW`@Q\x7F\xF6E\xEE\xDF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02`\x03\x81\x11\x15aOnWaOma\\RV[[\x82`\x03\x81\x11\x15aO\x81WaO\x80a\\RV[[\x03aO\xC5W\x80_\x1C`@Q\x7F\xFC\xE6\x98\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aO\xBC\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[`\x03\x80\x81\x11\x15aO\xD8WaO\xD7a\\RV[[\x82`\x03\x81\x11\x15aO\xEBWaO\xEAa\\RV[[\x03aP-W\x80`@Q\x7F\xD7\x8B\xCE\x0C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aP$\x91\x90a^\xA2V[`@Q\x80\x91\x03\x90\xFD[[PPV[_\x81\x90P\x91\x90PV[_\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x03aP\x96W\x80`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aP\x8D\x91\x90aa\x1EV[`@Q\x80\x91\x03\x90\xFD[\x80aP\xC2\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1BaP2V[_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[``_\x80\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84`@QaQ-\x91\x90au3V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14aQeW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>aQjV[``\x91P[P\x91P\x91PaQz\x85\x83\x83aS(V[\x92PPP\x92\x91PPV[_4\x11\x15aQ\xBEW`@Q\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_aQ\xC9aF~V[_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x90P\x90V[_\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0FaR\x08aS\xB5V[aR\x10aT+V[F0`@Q` \x01aR&\x95\x94\x93\x92\x91\x90auIV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x90V[_\x80_\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0\x84_\x1C\x11\x15aR}W_`\x03\x85\x92P\x92P\x92PaS\x1EV[_`\x01\x88\x88\x88\x88`@Q_\x81R` \x01`@R`@QaR\xA0\x94\x93\x92\x91\x90au\xB5V[` `@Q` \x81\x03\x90\x80\x84\x03\x90\x85Z\xFA\x15\x80\x15aR\xC0W=_\x80>=_\xFD[PPP` `@Q\x03Q\x90P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03aS\x11W_`\x01_\x80\x1B\x93P\x93P\x93PPaS\x1EV[\x80_\x80_\x1B\x93P\x93P\x93PP[\x94P\x94P\x94\x91PPV[``\x82aS=WaS8\x82aT\xA2V[aS\xADV[_\x82Q\x14\x80\x15aScWP_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x14[\x15aS\xA5W\x83`@Q\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aS\x9C\x91\x90aa\x1EV[`@Q\x80\x91\x03\x90\xFD[\x81\x90PaS\xAEV[[\x93\x92PPPV[_\x80aS\xBFa? V[\x90P_aS\xCAa?GV[\x90P_\x81Q\x11\x15aS\xE6W\x80\x80Q\x90` \x01 \x92PPPaT(V[_\x82_\x01T\x90P_\x80\x1B\x81\x14aT\x01W\x80\x93PPPPaT(V[\x7F\xC5\xD2F\x01\x86\xF7#<\x92~}\xB2\xDC\xC7\x03\xC0\xE5\0\xB6S\xCA\x82';{\xFA\xD8\x04]\x85\xA4p\x93PPPP[\x90V[_\x80aT5a? V[\x90P_aT@a?\xE5V[\x90P_\x81Q\x11\x15aT\\W\x80\x80Q\x90` \x01 \x92PPPaT\x9FV[_\x82`\x01\x01T\x90P_\x80\x1B\x81\x14aTxW\x80\x93PPPPaT\x9FV[\x7F\xC5\xD2F\x01\x86\xF7#<\x92~}\xB2\xDC\xC7\x03\xC0\xE5\0\xB6S\xCA\x82';{\xFA\xD8\x04]\x85\xA4p\x93PPPP[\x90V[_\x81Q\x11\x15aT\xB4W\x80Q\x80\x82` \x01\xFD[`@Q\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Q\x80`\xA0\x01`@R\x80_\x81R` \x01_\x81R` \x01_w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01_\x81R` \x01``\x81RP\x90V[`@Q\x80a\x01\0\x01`@R\x80``\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_\x81R` \x01``\x81R` \x01``\x81R` \x01``\x81R` \x01``\x81RP\x90V[_\x81\x90P\x91\x90PV[aU\xAC\x81aU\x9AV[\x82RPPV[_` \x82\x01\x90PaU\xC5_\x83\x01\x84aU\xA3V[\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_[\x83\x81\x10\x15aV\x02W\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90PaU\xE7V[_\x84\x84\x01RPPPPV[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[_aV'\x82aU\xCBV[aV1\x81\x85aU\xD5V[\x93PaVA\x81\x85` \x86\x01aU\xE5V[aVJ\x81aV\rV[\x84\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01RaVm\x81\x84aV\x1DV[\x90P\x92\x91PPV[aV~\x81aU\x9AV[\x82RPPV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[aV\xB8\x81aV\x84V[\x82RPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_aW\x01\x82aU\xCBV[aW\x0B\x81\x85aV\xE7V[\x93PaW\x1B\x81\x85` \x86\x01aU\xE5V[aW$\x81aV\rV[\x84\x01\x91PP\x92\x91PPV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_aWX\x82aW/V[\x90P\x91\x90PV[aWh\x81aWNV[\x82RPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_aW\x92\x82aWnV[aW\x9C\x81\x85aWxV[\x93PaW\xAC\x81\x85` \x86\x01aU\xE5V[aW\xB5\x81aV\rV[\x84\x01\x91PP\x92\x91PPV[_a\x01\0\x83\x01_\x83\x01Q\x84\x82\x03_\x86\x01RaW\xDB\x82\x82aV\xF7V[\x91PP` \x83\x01QaW\xF0` \x86\x01\x82aW_V[P`@\x83\x01QaX\x03`@\x86\x01\x82aW_V[P``\x83\x01QaX\x16``\x86\x01\x82aVuV[P`\x80\x83\x01Q\x84\x82\x03`\x80\x86\x01RaX.\x82\x82aW\x88V[\x91PP`\xA0\x83\x01Q\x84\x82\x03`\xA0\x86\x01RaXH\x82\x82aV\xF7V[\x91PP`\xC0\x83\x01Q\x84\x82\x03`\xC0\x86\x01RaXb\x82\x82aV\xF7V[\x91PP`\xE0\x83\x01Q\x84\x82\x03`\xE0\x86\x01RaX|\x82\x82aW\x88V[\x91PP\x80\x91PP\x92\x91PPV[_aX\x94\x83\x83aW\xC0V[\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_aX\xB2\x82aV\xBEV[aX\xBC\x81\x85aV\xC8V[\x93P\x83` \x82\x02\x85\x01aX\xCE\x85aV\xD8V[\x80_[\x85\x81\x10\x15aY\tW\x84\x84\x03\x89R\x81QaX\xEA\x85\x82aX\x89V[\x94PaX\xF5\x83aX\x9CV[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90PaX\xD1V[P\x82\x97P\x87\x95PPPPPP\x92\x91PPV[_`\xA0\x83\x01_\x83\x01QaY0_\x86\x01\x82aVuV[P` \x83\x01QaYC` \x86\x01\x82aVuV[P`@\x83\x01QaYV`@\x86\x01\x82aV\xAFV[P``\x83\x01QaYi``\x86\x01\x82aVuV[P`\x80\x83\x01Q\x84\x82\x03`\x80\x86\x01RaY\x81\x82\x82aX\xA8V[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01RaY\xA6\x81\x84aY\x1BV[\x90P\x92\x91PPV[_`@Q\x90P\x90V[_\x80\xFD[_\x80\xFD[aY\xC8\x81aU\x9AV[\x81\x14aY\xD2W_\x80\xFD[PV[_\x815\x90PaY\xE3\x81aY\xBFV[\x92\x91PPV[_\x80\xFD[_\x80\xFD[_\x80\xFD[_\x80\x83`\x1F\x84\x01\x12aZ\nWaZ\taY\xE9V[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aZ'WaZ&aY\xEDV[[` \x83\x01\x91P\x83`\x01\x82\x02\x83\x01\x11\x15aZCWaZBaY\xF1V[[\x92P\x92\x90PV[_\x80_`@\x84\x86\x03\x12\x15aZaWaZ`aY\xB7V[[_aZn\x86\x82\x87\x01aY\xD5V[\x93PP` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aZ\x8FWaZ\x8EaY\xBBV[[aZ\x9B\x86\x82\x87\x01aY\xF5V[\x92P\x92PP\x92P\x92P\x92V[aZ\xB0\x81aV\x84V[\x81\x14aZ\xBAW_\x80\xFD[PV[_\x815\x90PaZ\xCB\x81aZ\xA7V[\x92\x91PPV[_\x81\x15\x15\x90P\x91\x90PV[aZ\xE5\x81aZ\xD1V[\x81\x14aZ\xEFW_\x80\xFD[PV[_\x815\x90Pa[\0\x81aZ\xDCV[\x92\x91PPV[_\x80\x83`\x1F\x84\x01\x12a[\x1BWa[\x1AaY\xE9V[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a[8Wa[7aY\xEDV[[` \x83\x01\x91P\x83` \x82\x02\x83\x01\x11\x15a[TWa[SaY\xF1V[[\x92P\x92\x90PV[_\x80\xFD[_`@\x82\x84\x03\x12\x15a[tWa[sa[[V[[\x81\x90P\x92\x91PPV[_\x80_\x80_\x80_`\xE0\x88\x8A\x03\x12\x15a[\x98Wa[\x97aY\xB7V[[_a[\xA5\x8A\x82\x8B\x01aY\xD5V[\x97PP` a[\xB6\x8A\x82\x8B\x01aZ\xBDV[\x96PP`@a[\xC7\x8A\x82\x8B\x01aZ\xF2V[\x95PP``a[\xD8\x8A\x82\x8B\x01aY\xD5V[\x94PP`\x80\x88\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a[\xF9Wa[\xF8aY\xBBV[[a\\\x05\x8A\x82\x8B\x01a[\x06V[\x93P\x93PP`\xA0a\\\x18\x8A\x82\x8B\x01a[_V[\x91PP\x92\x95\x98\x91\x94\x97P\x92\x95PV[_` \x82\x84\x03\x12\x15a\\<Wa\\;aY\xB7V[[_a\\I\x84\x82\x85\x01aY\xD5V[\x91PP\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`!`\x04R`$_\xFD[`\x08\x81\x10a\\\x90Wa\\\x8Fa\\RV[[PV[_\x81\x90Pa\\\xA0\x82a\\\x7FV[\x91\x90PV[_a\\\xAF\x82a\\\x93V[\x90P\x91\x90PV[a\\\xBF\x81a\\\xA5V[\x82RPPV[_` \x82\x01\x90Pa\\\xD8_\x83\x01\x84a\\\xB6V[\x92\x91PPV[a\\\xE7\x81aWNV[\x81\x14a\\\xF1W_\x80\xFD[PV[_\x815\x90Pa]\x02\x81a\\\xDEV[\x92\x91PPV[_\x80\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[a]B\x82aV\rV[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a]aWa]`a]\x0CV[[\x80`@RPPPV[_a]saY\xAEV[\x90Pa]\x7F\x82\x82a]9V[\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a]\x9EWa]\x9Da]\x0CV[[a]\xA7\x82aV\rV[\x90P` \x81\x01\x90P\x91\x90PV[\x82\x81\x837_\x83\x83\x01RPPPV[_a]\xD4a]\xCF\x84a]\x84V[a]jV[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a]\xF0Wa]\xEFa]\x08V[[a]\xFB\x84\x82\x85a]\xB4V[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a^\x17Wa^\x16aY\xE9V[[\x815a^'\x84\x82` \x86\x01a]\xC2V[\x91PP\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15a^FWa^EaY\xB7V[[_a^S\x85\x82\x86\x01a\\\xF4V[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a^tWa^saY\xBBV[[a^\x80\x85\x82\x86\x01a^\x03V[\x91PP\x92P\x92\x90PV[_\x81\x90P\x91\x90PV[a^\x9C\x81a^\x8AV[\x82RPPV[_` \x82\x01\x90Pa^\xB5_\x83\x01\x84a^\x93V[\x92\x91PPV[a^\xC4\x81aZ\xD1V[\x82RPPV[_` \x82\x01\x90Pa^\xDD_\x83\x01\x84a^\xBBV[\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_a_\x17\x83\x83aW_V[` \x83\x01\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_a_9\x82a^\xE3V[a_C\x81\x85a^\xEDV[\x93Pa_N\x83a^\xFDV[\x80_[\x83\x81\x10\x15a_~W\x81Qa_e\x88\x82a_\x0CV[\x97Pa_p\x83a_#V[\x92PP`\x01\x81\x01\x90Pa_QV[P\x85\x93PPPP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra_\xA3\x81\x84a_/V[\x90P\x92\x91PPV[_\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[a_\xDF\x81a_\xABV[\x82RPPV[a_\xEE\x81aWNV[\x82RPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_a`(\x83\x83aVuV[` \x83\x01\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_a`J\x82a_\xF4V[a`T\x81\x85a_\xFEV[\x93Pa`_\x83a`\x0EV[\x80_[\x83\x81\x10\x15a`\x8FW\x81Qa`v\x88\x82a`\x1DV[\x97Pa`\x81\x83a`4V[\x92PP`\x01\x81\x01\x90Pa`bV[P\x85\x93PPPP\x92\x91PPV[_`\xE0\x82\x01\x90Pa`\xAF_\x83\x01\x8Aa_\xD6V[\x81\x81\x03` \x83\x01Ra`\xC1\x81\x89aV\x1DV[\x90P\x81\x81\x03`@\x83\x01Ra`\xD5\x81\x88aV\x1DV[\x90Pa`\xE4``\x83\x01\x87aU\xA3V[a`\xF1`\x80\x83\x01\x86a_\xE5V[a`\xFE`\xA0\x83\x01\x85a^\x93V[\x81\x81\x03`\xC0\x83\x01Raa\x10\x81\x84a`@V[\x90P\x98\x97PPPPPPPPV[_` \x82\x01\x90Paa1_\x83\x01\x84a_\xE5V[\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15aaMWaaLaY\xB7V[[_aaZ\x85\x82\x86\x01aY\xD5V[\x92PP` aak\x85\x82\x86\x01a\\\xF4V[\x91PP\x92P\x92\x90PV[_` \x82\x84\x03\x12\x15aa\x8AWaa\x89aY\xB7V[[_aa\x97\x84\x82\x85\x01a\\\xF4V[\x91PP\x92\x91PPV[_a\x01\0\x83\x01_\x83\x01Q\x84\x82\x03_\x86\x01Raa\xBB\x82\x82aV\xF7V[\x91PP` \x83\x01Qaa\xD0` \x86\x01\x82aW_V[P`@\x83\x01Qaa\xE3`@\x86\x01\x82aW_V[P``\x83\x01Qaa\xF6``\x86\x01\x82aVuV[P`\x80\x83\x01Q\x84\x82\x03`\x80\x86\x01Rab\x0E\x82\x82aW\x88V[\x91PP`\xA0\x83\x01Q\x84\x82\x03`\xA0\x86\x01Rab(\x82\x82aV\xF7V[\x91PP`\xC0\x83\x01Q\x84\x82\x03`\xC0\x86\x01RabB\x82\x82aV\xF7V[\x91PP`\xE0\x83\x01Q\x84\x82\x03`\xE0\x86\x01Rab\\\x82\x82aW\x88V[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Rab\x81\x81\x84aa\xA0V[\x90P\x92\x91PPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_ab\xA3\x82aV\xBEV[ab\xAD\x81\x85ab\x89V[\x93P\x83` \x82\x02\x85\x01ab\xBF\x85aV\xD8V[\x80_[\x85\x81\x10\x15ab\xFAW\x84\x84\x03\x89R\x81Qab\xDB\x85\x82aX\x89V[\x94Pab\xE6\x83aX\x9CV[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90Pab\xC2V[P\x82\x97P\x87\x95PPPPPP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Rac$\x81\x84ab\x99V[\x90P\x92\x91PPV[_``\x82\x84\x03\x12\x15acAWac@a[[V[[\x81\x90P\x92\x91PPV[_\x80_\x80_\x80a\x01\0\x87\x89\x03\x12\x15aceWacdaY\xB7V[[_acr\x89\x82\x8A\x01a[_V[\x96PP`@ac\x83\x89\x82\x8A\x01ac,V[\x95PP`\xA0ac\x94\x89\x82\x8A\x01aZ\xBDV[\x94PP`\xC0ac\xA5\x89\x82\x8A\x01aY\xD5V[\x93PP`\xE0\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ac\xC6Wac\xC5aY\xBBV[[ac\xD2\x89\x82\x8A\x01a[\x06V[\x92P\x92PP\x92\x95P\x92\x95P\x92\x95V[_\x81\x90P\x92\x91PPV[_ac\xF5\x82aU\xCBV[ac\xFF\x81\x85ac\xE1V[\x93Pad\x0F\x81\x85` \x86\x01aU\xE5V[\x80\x84\x01\x91PP\x92\x91PPV[\x7F v\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_adO`\x02\x83ac\xE1V[\x91PadZ\x82ad\x1BV[`\x02\x82\x01\x90P\x91\x90PV[\x7F.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_ad\x99`\x01\x83ac\xE1V[\x91Pad\xA4\x82adeV[`\x01\x82\x01\x90P\x91\x90PV[_ad\xBA\x82\x87ac\xEBV[\x91Pad\xC5\x82adCV[\x91Pad\xD1\x82\x86ac\xEBV[\x91Pad\xDC\x82ad\x8DV[\x91Pad\xE8\x82\x85ac\xEBV[\x91Pad\xF3\x82ad\x8DV[\x91Pad\xFF\x82\x84ac\xEBV[\x91P\x81\x90P\x95\x94PPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\"`\x04R`$_\xFD[_`\x02\x82\x04\x90P`\x01\x82\x16\x80aeQW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03aedWaecae\rV[[P\x91\x90PV[_\x82\x90P\x92\x91PPV[_\x81\x90P\x81_R` _ \x90P\x91\x90PV[_` `\x1F\x83\x01\x04\x90P\x91\x90PV[_\x82\x82\x1B\x90P\x92\x91PPV[_`\x08\x83\x02ae\xD0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82ae\x95V[ae\xDA\x86\x83ae\x95V[\x95P\x80\x19\x84\x16\x93P\x80\x86\x16\x84\x17\x92PPP\x93\x92PPPV[_\x81\x90P\x91\x90PV[_af\x15af\x10af\x0B\x84aU\x9AV[ae\xF2V[aU\x9AV[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[af.\x83ae\xFBV[afBaf:\x82af\x1CV[\x84\x84Tae\xA1V[\x82UPPPPV[_\x90V[afVafJV[afa\x81\x84\x84af%V[PPPV[[\x81\x81\x10\x15af\x84Wafy_\x82afNV[`\x01\x81\x01\x90PafgV[PPV[`\x1F\x82\x11\x15af\xC9Waf\x9A\x81aetV[af\xA3\x84ae\x86V[\x81\x01` \x85\x10\x15af\xB2W\x81\x90P[af\xC6af\xBE\x85ae\x86V[\x83\x01\x82affV[PP[PPPV[_\x82\x82\x1C\x90P\x92\x91PPV[_af\xE9_\x19\x84`\x08\x02af\xCEV[\x19\x80\x83\x16\x91PP\x92\x91PPV[_ag\x01\x83\x83af\xDAV[\x91P\x82`\x02\x02\x82\x17\x90P\x92\x91PPV[ag\x1B\x83\x83aejV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ag4Wag3a]\x0CV[[ag>\x82Tae:V[agI\x82\x82\x85af\x88V[_`\x1F\x83\x11`\x01\x81\x14agvW_\x84\x15agdW\x82\x87\x015\x90P[agn\x85\x82af\xF6V[\x86UPag\xD5V[`\x1F\x19\x84\x16ag\x84\x86aetV[_[\x82\x81\x10\x15ag\xABW\x84\x89\x015\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Pag\x86V[\x86\x83\x10\x15ag\xC8W\x84\x89\x015ag\xC4`\x1F\x89\x16\x82af\xDAV[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPPV[_`@\x82\x01\x90Pag\xF1_\x83\x01\x85aU\xA3V[ag\xFE` \x83\x01\x84aU\xA3V[\x93\x92PPPV[_`@\x82\x01\x90P\x81\x81\x03_\x83\x01Rah\x1D\x81\x85aY\x1BV[\x90P\x81\x81\x03` \x83\x01Rah1\x81\x84aY\x1BV[\x90P\x93\x92PPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_ahq\x82aU\x9AV[\x91Pah|\x83aU\x9AV[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15ah\x94Wah\x93ah:V[[\x92\x91PPV[_``\x82\x01\x90P\x81\x81\x03_\x83\x01Rah\xB2\x81\x86aY\x1BV[\x90P\x81\x81\x03` \x83\x01Rah\xC6\x81\x85aY\x1BV[\x90Pah\xD5`@\x83\x01\x84aU\xA3V[\x94\x93PPPPV[_\x81Q\x90Pah\xEB\x81a\\\xDEV[\x92\x91PPV[_` \x82\x84\x03\x12\x15ai\x06Wai\x05aY\xB7V[[_ai\x13\x84\x82\x85\x01ah\xDDV[\x91PP\x92\x91PPV[\x7FEIP712: Uninitialized\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_aiP`\x15\x83aU\xD5V[\x91Pai[\x82ai\x1CV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Rai}\x81aiDV[\x90P\x91\x90PV[_`@\x82\x01\x90Pai\x97_\x83\x01\x85aU\xA3V[ai\xA4` \x83\x01\x84a_\xE5V[\x93\x92PPPV[_ai\xB9` \x84\x01\x84aY\xD5V[\x90P\x92\x91PPV[`@\x82\x01ai\xD1_\x83\x01\x83ai\xABV[ai\xDD_\x85\x01\x82aVuV[Pai\xEB` \x83\x01\x83ai\xABV[ai\xF8` \x85\x01\x82aVuV[PPPPV[``\x82\x01aj\x0E_\x83\x01\x83ai\xABV[aj\x1A_\x85\x01\x82aVuV[Paj(` \x83\x01\x83ai\xABV[aj5` \x85\x01\x82aVuV[PajC`@\x83\x01\x83ai\xABV[ajP`@\x85\x01\x82aVuV[PPPPV[aj_\x81aV\x84V[\x82RPPV[_\x81\x90P\x91\x90PV[_\x80\xFD[_\x80\xFD[_\x80\xFD[_\x80\x835`\x01` \x03\x846\x03\x03\x81\x12aj\x96Waj\x95ajvV[[\x83\x81\x01\x92P\x825\x91P` \x83\x01\x92Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15aj\xBEWaj\xBDajnV[[`\x01\x82\x026\x03\x83\x13\x15aj\xD4Waj\xD3ajrV[[P\x92P\x92\x90PV[_aj\xE7\x83\x85aV\xE7V[\x93Paj\xF4\x83\x85\x84a]\xB4V[aj\xFD\x83aV\rV[\x84\x01\x90P\x93\x92PPPV[_ak\x16` \x84\x01\x84a\\\xF4V[\x90P\x92\x91PPV[_\x80\x835`\x01` \x03\x846\x03\x03\x81\x12ak:Wak9ajvV[[\x83\x81\x01\x92P\x825\x91P` \x83\x01\x92Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15akbWakaajnV[[`\x01\x82\x026\x03\x83\x13\x15akxWakwajrV[[P\x92P\x92\x90PV[_ak\x8B\x83\x85aWxV[\x93Pak\x98\x83\x85\x84a]\xB4V[ak\xA1\x83aV\rV[\x84\x01\x90P\x93\x92PPPV[_a\x01\0\x83\x01ak\xBE_\x84\x01\x84ajzV[\x85\x83\x03_\x87\x01Rak\xD0\x83\x82\x84aj\xDCV[\x92PPPak\xE1` \x84\x01\x84ak\x08V[ak\xEE` \x86\x01\x82aW_V[Pak\xFC`@\x84\x01\x84ak\x08V[al\t`@\x86\x01\x82aW_V[Pal\x17``\x84\x01\x84ai\xABV[al$``\x86\x01\x82aVuV[Pal2`\x80\x84\x01\x84ak\x1EV[\x85\x83\x03`\x80\x87\x01RalE\x83\x82\x84ak\x80V[\x92PPPalV`\xA0\x84\x01\x84ajzV[\x85\x83\x03`\xA0\x87\x01Rali\x83\x82\x84aj\xDCV[\x92PPPalz`\xC0\x84\x01\x84ajzV[\x85\x83\x03`\xC0\x87\x01Ral\x8D\x83\x82\x84aj\xDCV[\x92PPPal\x9E`\xE0\x84\x01\x84ak\x1EV[\x85\x83\x03`\xE0\x87\x01Ral\xB1\x83\x82\x84ak\x80V[\x92PPP\x80\x91PP\x92\x91PPV[_al\xCA\x83\x83ak\xACV[\x90P\x92\x91PPV[_\x825`\x01a\x01\0\x03\x836\x03\x03\x81\x12al\xEEWal\xEDajvV[[\x82\x81\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_am\x11\x83\x85ab\x89V[\x93P\x83` \x84\x02\x85\x01am#\x84ajeV[\x80_[\x87\x81\x10\x15amfW\x84\x84\x03\x89Ram=\x82\x84al\xD2V[amG\x85\x82al\xBFV[\x94PamR\x83al\xFAV[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90Pam&V[P\x82\x97P\x87\x94PPPPP\x93\x92PPPV[_a\x01\0\x82\x01\x90Pam\x8C_\x83\x01\x89ai\xC1V[am\x99`@\x83\x01\x88ai\xFEV[am\xA6`\xA0\x83\x01\x87ajVV[am\xB3`\xC0\x83\x01\x86aU\xA3V[\x81\x81\x03`\xE0\x83\x01Ram\xC6\x81\x84\x86am\x06V[\x90P\x97\x96PPPPPPPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[am\xEF\x81am\xD3V[\x82RPPV[_` \x82\x01\x90Pan\x08_\x83\x01\x84am\xE6V[\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_`@\x82\x01\x90PanN_\x83\x01\x85a^\x93V[an[` \x83\x01\x84aU\xA3V[\x93\x92PPPV[_`@\x82\x01\x90P\x81\x81\x03_\x83\x01Ranz\x81\x85aY\x1BV[\x90Pan\x89` \x83\x01\x84aU\xA3V[\x93\x92PPPV[_an\x9A\x82aU\x9AV[\x91P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03an\xCCWan\xCBah:V[[`\x01\x82\x01\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[_\x80\xFD[_\x80\xFD[_\x80\xFD[_\x825`\x01a\x01\0\x03\x836\x03\x03\x81\x12ao,Wao+ao\x04V[[\x80\x83\x01\x91PP\x92\x91PPV[_\x80\x835`\x01` \x03\x846\x03\x03\x81\x12aoTWaoSao\x04V[[\x80\x84\x01\x92P\x825\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15aovWaouao\x08V[[` \x83\x01\x92P`\x01\x82\x026\x03\x83\x13\x15ao\x92Wao\x91ao\x0CV[[P\x92P\x92\x90PV[_\x82\x90P\x92\x91PPV[_\x81\x90P\x81_R` _ \x90P\x91\x90PV[`\x1F\x82\x11\x15ao\xF7Wao\xC8\x81ao\xA4V[ao\xD1\x84ae\x86V[\x81\x01` \x85\x10\x15ao\xE0W\x81\x90P[ao\xF4ao\xEC\x85ae\x86V[\x83\x01\x82affV[PP[PPPV[ap\x06\x83\x83ao\x9AV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ap\x1FWap\x1Ea]\x0CV[[ap)\x82Tae:V[ap4\x82\x82\x85ao\xB6V[_`\x1F\x83\x11`\x01\x81\x14apaW_\x84\x15apOW\x82\x87\x015\x90P[apY\x85\x82af\xF6V[\x86UPap\xC0V[`\x1F\x19\x84\x16apo\x86ao\xA4V[_[\x82\x81\x10\x15ap\x96W\x84\x89\x015\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90PapqV[\x86\x83\x10\x15ap\xB3W\x84\x89\x015ap\xAF`\x1F\x89\x16\x82af\xDAV[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPPV[ap\xD4\x83\x83\x83ao\xFCV[PPPV[_\x815ap\xE5\x81a\\\xDEV[\x80\x91PP\x91\x90PV[_\x81_\x1B\x90P\x91\x90PV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFaq\x18\x84ap\xEEV[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[_aqHaqCaq>\x84aW/V[ae\xF2V[aW/V[\x90P\x91\x90PV[_aqY\x82aq.V[\x90P\x91\x90PV[_aqj\x82aqOV[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[aq\x83\x82aq`V[aq\x96aq\x8F\x82aqqV[\x83Tap\xF9V[\x82UPPPV[_\x815aq\xA9\x81aY\xBFV[\x80\x91PP\x91\x90PV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFaq\xDD\x84ap\xEEV[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[aq\xFC\x82ae\xFBV[ar\x0Far\x08\x82af\x1CV[\x83Taq\xB2V[\x82UPPPV[_\x80\x835`\x01` \x03\x846\x03\x03\x81\x12ar2War1ao\x04V[[\x80\x84\x01\x92P\x825\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15arTWarSao\x08V[[` \x83\x01\x92P`\x01\x82\x026\x03\x83\x13\x15arpWaroao\x0CV[[P\x92P\x92\x90PV[ar\x83\x83\x83\x83ag\x11V[PPPV[_\x81\x01_\x83\x01ar\x98\x81\x85ao8V[ar\xA3\x81\x83\x86ap\xC9V[PPPP`\x01\x81\x01` \x83\x01\x80ar\xB9\x81ap\xD9V[\x90Par\xC5\x81\x84aqzV[PPP`\x02\x81\x01`@\x83\x01\x80ar\xDA\x81ap\xD9V[\x90Par\xE6\x81\x84aqzV[PPP`\x03\x81\x01``\x83\x01\x80ar\xFB\x81aq\x9DV[\x90Pas\x07\x81\x84aq\xF3V[PPP`\x04\x81\x01`\x80\x83\x01as\x1C\x81\x85ar\x16V[as'\x81\x83\x86arxV[PPPP`\x05\x81\x01`\xA0\x83\x01as=\x81\x85ao8V[asH\x81\x83\x86ap\xC9V[PPPP`\x06\x81\x01`\xC0\x83\x01as^\x81\x85ao8V[asi\x81\x83\x86ap\xC9V[PPPP`\x07\x81\x01`\xE0\x83\x01as\x7F\x81\x85ar\x16V[as\x8A\x81\x83\x86arxV[PPPPPPV[as\x9C\x82\x82ar\x88V[PPV[as\xA9\x81a^\x8AV[\x81\x14as\xB3W_\x80\xFD[PV[_\x81Q\x90Pas\xC4\x81as\xA0V[\x92\x91PPV[_` \x82\x84\x03\x12\x15as\xDFWas\xDEaY\xB7V[[_as\xEC\x84\x82\x85\x01as\xB6V[\x91PP\x92\x91PPV[_``\x82\x01\x90Pat\x08_\x83\x01\x86aU\xA3V[at\x15` \x83\x01\x85aU\xA3V[at\"`@\x83\x01\x84aU\xA3V[\x94\x93PPPPV[at3\x82aU\xCBV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15atLWatKa]\x0CV[[atV\x82Tae:V[ata\x82\x82\x85ao\xB6V[_` \x90P`\x1F\x83\x11`\x01\x81\x14at\x92W_\x84\x15at\x80W\x82\x87\x01Q\x90P[at\x8A\x85\x82af\xF6V[\x86UPat\xF1V[`\x1F\x19\x84\x16at\xA0\x86ao\xA4V[_[\x82\x81\x10\x15at\xC7W\x84\x89\x01Q\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Pat\xA2V[\x86\x83\x10\x15at\xE4W\x84\x89\x01Qat\xE0`\x1F\x89\x16\x82af\xDAV[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPV[_\x81\x90P\x92\x91PPV[_au\r\x82aWnV[au\x17\x81\x85at\xF9V[\x93Pau'\x81\x85` \x86\x01aU\xE5V[\x80\x84\x01\x91PP\x92\x91PPV[_au>\x82\x84au\x03V[\x91P\x81\x90P\x92\x91PPV[_`\xA0\x82\x01\x90Pau\\_\x83\x01\x88a^\x93V[aui` \x83\x01\x87a^\x93V[auv`@\x83\x01\x86a^\x93V[au\x83``\x83\x01\x85aU\xA3V[au\x90`\x80\x83\x01\x84a_\xE5V[\x96\x95PPPPPPV[_`\xFF\x82\x16\x90P\x91\x90PV[au\xAF\x81au\x9AV[\x82RPPV[_`\x80\x82\x01\x90Pau\xC8_\x83\x01\x87a^\x93V[au\xD5` \x83\x01\x86au\xA6V[au\xE2`@\x83\x01\x85a^\x93V[au\xEF``\x83\x01\x84a^\x93V[\x95\x94PPPPPV\xFEKeyResharingVerification(uint256 contextId)",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405260043610610224575f3560e01c806384b0196e11610122578063defba06a116100aa578063e72ee9911161006e578063e72ee9911461075c578063eb843cf614610786578063edc44f19146107ae578063f27cb957146107d6578063f2fde38b146107ec57610224565b8063defba06a1461067e578063dfe36aee146106a6578063e24ba4e5146106ce578063e30c3978146106f6578063e3b2a8741461072057610224565b8063ad3cb1cc116100f1578063ad3cb1cc1461059e578063b8715d4d146105c8578063c0ae64f714610604578063c1c8b7251461062c578063d8e3ae011461065457610224565b806384b0196e146105065780638cb96751146105365780638da5cb5b1461054c5780639ee77af31461057657610224565b80634d694260116101b0578063715018a611610174578063715018a6146104705780637420f3d41461048657806379ba5097146104b05780637eaac8f2146104c65780638456cb59146104f057610224565b80634d694260146103885780634f1ef286146103c457806352d1902d146103e05780635c975abb1461040a57806364b00cc51461043457610224565b8063169cac14116101f7578063169cac14146102ce5780632e2d3a82146102f65780633f4ba83a1461031e57806343e37e8a146103345780634965e4551461035e57610224565b80630a50e318146102285780630d8e6e2c146102525780630dd486c01461027c5780631079ebeb146102a6575b5f80fd5b348015610233575f80fd5b5061023c610814565b60405161024991906155b2565b60405180910390f35b34801561025d575f80fd5b5061026661082d565b6040516102739190615655565b60405180910390f35b348015610287575f80fd5b506102906108a8565b60405161029d919061598e565b60405180910390f35b3480156102b1575f80fd5b506102cc60048036038101906102c79190615a4a565b610d34565b005b3480156102d9575f80fd5b506102f460048036038101906102ef9190615b7d565b6112f1565b005b348015610301575f80fd5b5061031c60048036038101906103179190615c27565b6114ba565b005b348015610329575f80fd5b50610332611523565b005b34801561033f575f80fd5b50610348611535565b60405161035591906155b2565b60405180910390f35b348015610369575f80fd5b5061037261154e565b60405161037f91906155b2565b60405180910390f35b348015610393575f80fd5b506103ae60048036038101906103a99190615c27565b611565565b6040516103bb9190615cc5565b60405180910390f35b6103de60048036038101906103d99190615e30565b611585565b005b3480156103eb575f80fd5b506103f46115a4565b6040516104019190615ea2565b60405180910390f35b348015610415575f80fd5b5061041e6115d5565b60405161042b9190615eca565b60405180910390f35b34801561043f575f80fd5b5061045a60048036038101906104559190615c27565b6115f7565b60405161046791906155b2565b60405180910390f35b34801561047b575f80fd5b50610484611686565b005b348015610491575f80fd5b5061049a611699565b6040516104a79190615f8b565b60405180910390f35b3480156104bb575f80fd5b506104c461174d565b005b3480156104d1575f80fd5b506104da6117db565b6040516104e79190615f8b565b60405180910390f35b3480156104fb575f80fd5b5061050461188f565b005b348015610511575f80fd5b5061051a6119ca565b60405161052d979695949392919061609c565b60405180910390f35b348015610541575f80fd5b5061054a611ad3565b005b348015610557575f80fd5b50610560611cc5565b60405161056d919061611e565b60405180910390f35b348015610581575f80fd5b5061059c60048036038101906105979190615c27565b611cfa565b005b3480156105a9575f80fd5b506105b2611e09565b6040516105bf9190615655565b60405180910390f35b3480156105d3575f80fd5b506105ee60048036038101906105e99190615c27565b611e42565b6040516105fb91906155b2565b60405180910390f35b34801561060f575f80fd5b5061062a60048036038101906106259190615c27565b611ed1565b005b348015610637575f80fd5b50610652600480360381019061064d9190615c27565b611fe0565b005b34801561065f575f80fd5b5061066861203f565b60405161067591906155b2565b60405180910390f35b348015610689575f80fd5b506106a4600480360381019061069f9190616137565b612056565b005b3480156106b1575f80fd5b506106cc60048036038101906106c79190616137565b61216b565b005b3480156106d9575f80fd5b506106f460048036038101906106ef9190615c27565b612280565b005b348015610701575f80fd5b5061070a6122df565b604051610717919061611e565b60405180910390f35b34801561072b575f80fd5b5061074660048036038101906107419190616175565b612314565b6040516107539190616269565b60405180910390f35b348015610767575f80fd5b50610770612793565b60405161077d919061630c565b60405180910390f35b348015610791575f80fd5b506107ac60048036038101906107a79190615c27565b6127a6565b005b3480156107b9575f80fd5b506107d460048036038101906107cf919061634a565b61280f565b005b3480156107e1575f80fd5b506107ea612a41565b005b3480156107f7575f80fd5b50610812600480360381019061080d9190616175565b612b2e565b005b5f8061081e612be7565b9050805f016004015491505090565b60606040518060400160405280600b81526020017f4b6d73436f6e746578747300000000000000000000000000000000000000000081525061086e5f612c0e565b6108786001612c0e565b6108815f612c0e565b60405160200161089494939291906164af565b604051602081830303815290604052905090565b6108b06154e6565b5f6108b9612be7565b90505f6108c4611535565b9050816008015f8281526020019081526020015f206040518060a00160405290815f820154815260200160018201548152602001600282015f9054906101000a900460c01b77ffffffffffffffffffffffffffffffffffffffffffffffff191677ffffffffffffffffffffffffffffffffffffffffffffffff191681526020016003820154815260200160048201805480602002602001604051908101604052809291908181526020015f905b82821015610d25578382905f5260205f209060080201604051806101000160405290815f820180546109a29061653a565b80601f01602080910402602001604051908101604052809291908181526020018280546109ce9061653a565b8015610a195780601f106109f057610100808354040283529160200191610a19565b820191905f5260205f20905b8154815290600101906020018083116109fc57829003601f168201915b50505050508152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200160038201548152602001600482018054610ae69061653a565b80601f0160208091040260200160405190810160405280929190818152602001828054610b129061653a565b8015610b5d5780601f10610b3457610100808354040283529160200191610b5d565b820191905f5260205f20905b815481529060010190602001808311610b4057829003601f168201915b50505050508152602001600582018054610b769061653a565b80601f0160208091040260200160405190810160405280929190818152602001828054610ba29061653a565b8015610bed5780601f10610bc457610100808354040283529160200191610bed565b820191905f5260205f20905b815481529060010190602001808311610bd057829003601f168201915b50505050508152602001600682018054610c069061653a565b80601f0160208091040260200160405190810160405280929190818152602001828054610c329061653a565b8015610c7d5780601f10610c5457610100808354040283529160200191610c7d565b820191905f5260205f20905b815481529060010190602001808311610c6057829003601f168201915b50505050508152602001600782018054610c969061653a565b80601f0160208091040260200160405190810160405280929190818152602001828054610cc29061653a565b8015610d0d5780601f10610ce457610100808354040283529160200191610d0d565b820191905f5260205f20905b815481529060010190602001808311610cf057829003601f168201915b50505050508152505081526020019060010190610971565b50505050815250509250505090565b610d3e8333612056565b5f610d47612be7565b9050610d55815f0185612cd8565b610d9657836040517f5e51a2e1000000000000000000000000000000000000000000000000000000008152600401610d8d91906155b2565b60405180910390fd5b5f60405180602001604052808681525090505f610db282612d27565b9050610dc086828787612d82565b5f83600c015f8881526020019081526020015f20905080868690918060018154018082558091505060019003905f5260205f20015f909192909192909192909192509182610e0f929190616711565b505f846008015f8981526020019081526020015f206040518060a00160405290815f820154815260200160018201548152602001600282015f9054906101000a900460c01b77ffffffffffffffffffffffffffffffffffffffffffffffff191677ffffffffffffffffffffffffffffffffffffffffffffffff191681526020016003820154815260200160048201805480602002602001604051908101604052809291908181526020015f905b82821015611270578382905f5260205f209060080201604051806101000160405290815f82018054610eed9061653a565b80601f0160208091040260200160405190810160405280929190818152602001828054610f199061653a565b8015610f645780601f10610f3b57610100808354040283529160200191610f64565b820191905f5260205f20905b815481529060010190602001808311610f4757829003601f168201915b50505050508152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600382015481526020016004820180546110319061653a565b80601f016020809104026020016040519081016040528092919081815260200182805461105d9061653a565b80156110a85780601f1061107f576101008083540402835291602001916110a8565b820191905f5260205f20905b81548152906001019060200180831161108b57829003601f168201915b505050505081526020016005820180546110c19061653a565b80601f01602080910402602001604051908101604052809291908181526020018280546110ed9061653a565b80156111385780601f1061110f57610100808354040283529160200191611138565b820191905f5260205f20905b81548152906001019060200180831161111b57829003601f168201915b505050505081526020016006820180546111519061653a565b80601f016020809104026020016040519081016040528092919081815260200182805461117d9061653a565b80156111c85780601f1061119f576101008083540402835291602001916111c8565b820191905f5260205f20905b8154815290600101906020018083116111ab57829003601f168201915b505050505081526020016007820180546111e19061653a565b80601f016020809104026020016040519081016040528092919081815260200182805461120d9061653a565b80156112585780601f1061122f57610100808354040283529160200191611258565b820191905f5260205f20905b81548152906001019060200180831161123b57829003601f168201915b50505050508152505081526020019060010190610ebc565b50505050815250509050611288818380549050612ef4565b156112e7575f856006015f8a81526020019081526020015f205490506112ae8282612f0b565b7f68898a98936bf23a56e8ed4b23dcc98cef926bd9ac2ce522f1f9423e3864f2f5826040516112dd919061598e565b60405180910390a1505b5050505050505050565b6112f9612f8e565b5f611302612be7565b90505f61130d6108a8565b90505f81608001515190505f8686905090508181146113655781816040517fd595a96200000000000000000000000000000000000000000000000000000000815260040161135c9291906167de565b60405180910390fd5b5f61136e610814565b90505f81146113b457806040517f7623d3570000000000000000000000000000000000000000000000000000000081526004016113ab91906155b2565b60405180910390fd5b5f6113c6855f01518d8c8c8c8c613015565b90507f3662ec316d76e6a75eb7c45001a8ad74c3eb943e8778111c0225f2a9fd5e00e685826040516113f9929190616805565b60405180910390a1611410865f01825f0151613963565b8a156114a0578c866006015f835f015181526020019081526020015f20819055505f8660050154436114429190616867565b905080876012015f845f015181526020019081526020015f20819055507f5dc601065a035d78305cd9ef27c91a009cd8d37297e43bb76319490895a0d0588683836040516114929392919061689a565b60405180910390a1506114ab565b6114aa818e612f0b565b5b50505050505050505050505050565b6114c2612f8e565b6114ca613a30565b5f6114d36108a8565b90506114e8815f015183836080015151613a71565b7fe41802af725729adcb8c151e2937380a25c69155757e3af5d3979adab50358008260405161151791906155b2565b60405180910390a15050565b61152b612f8e565b611533613b1a565b565b5f8061153f612be7565b9050805f016003015491505090565b5f80611558612be7565b9050806005015491505090565b5f8061156f612be7565b905061157d815f0184613b88565b915050919050565b61158d613bb0565b61159682613c96565b6115a08282613ca1565b5050565b5f6115ad613dbf565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b905090565b5f806115df613e46565b9050805f015f9054906101000a900460ff1691505090565b5f815f611602612be7565b90505f816008015f8481526020019081526020015f205f01540361165d57816040517f82b1fbda00000000000000000000000000000000000000000000000000000000815260040161165491906155b2565b60405180910390fd5b5f611666612be7565b9050806016015f8681526020019081526020015f20549350505050919050565b61168e612f8e565b6116975f613e6d565b565b60605f6116a4611535565b90505f6116af612be7565b9050806010015f8381526020019081526020015f2080548060200260200160405190810160405280929190818152602001828054801561174157602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190600101908083116116f8575b50505050509250505090565b5f611756613eaa565b90508073ffffffffffffffffffffffffffffffffffffffff166117776122df565b73ffffffffffffffffffffffffffffffffffffffff16146117cf57806040517f118cdaa70000000000000000000000000000000000000000000000000000000081526004016117c6919061611e565b60405180910390fd5b6117d881613e6d565b50565b60605f6117e6611535565b90505f6117f1612be7565b9050806011015f8381526020019081526020015f2080548060200260200160405190810160405280929190818152602001828054801561188357602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001906001019080831161183a575b50505050509250505090565b611897611cc5565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415801561197e575073c7d45661a345ec5ca0e8521cfef7e32fda0daa6873ffffffffffffffffffffffffffffffffffffffff16637008b5486040518163ffffffff1660e01b8152600401602060405180830381865afa15801561192a573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061194e91906168f1565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614155b156119c057336040517f46c0d9af0000000000000000000000000000000000000000000000000000000081526004016119b7919061611e565b60405180910390fd5b6119c8613eb1565b565b5f6060805f805f60605f6119dc613f20565b90505f801b815f01541480156119f757505f801b8160010154145b611a36576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611a2d90616966565b60405180910390fd5b611a3e613f47565b611a46613fe5565b46305f801b5f67ffffffffffffffff811115611a6557611a64615d0c565b5b604051908082528060200260200182016040528015611a935781602001602082028036833780820191505090505b507f0f0000000000000000000000000000000000000000000000000000000000000095949392919097509750975097509750975097505090919293949596565b611adb613a30565b5f611ae4612be7565b90505f815f016001015490505f8114611b8d57816012015f8281526020019081526020015f2054431115611b8c577e9fe8f0db45996decf7b06fc7b6ec5f887d5f04db2e0c4ad7f4e4ee5eefc5a381604051611b4091906155b2565b60405180910390a1611b54825f0182614083565b7f3e8f02dc7af6e3a67f3af0bc99bcf11b4deb46105e9ba7f1ac6da82322e9025e81604051611b8391906155b2565b60405180910390a15b5b5f825f016002015490505f8114611c4d57826013015f8281526020019081526020015f2054431115611c4c575f611bc2611535565b9050611bd0845f0182614150565b7f851a08c16b15959c338ac4b56466d06c9f9d5ff8d715168aa125d5ccaf53832081604051611bff91906155b2565b60405180910390a1611c13845f0183614226565b7f4f54a6ac981cc8dc83142b3eb4d120be7c70fc5de6477a14eae3e9ca647644bc82604051611c4291906155b2565b60405180910390a1505b5b5f611c56610814565b90505f8114611cbf57836014015f8281526020019081526020015f2054431115611cbe57611c86845f0182614321565b7f8fb75858a565aee117342d93196a7f0b54c1c8519885eddda6a01f477359b36381604051611cb591906155b2565b60405180910390a15b5b50505050565b5f80611ccf614423565b9050805f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b611d02612f8e565b805f611d0c612be7565b90505f816008015f8481526020019081526020015f205f015403611d6757816040517f82b1fbda000000000000000000000000000000000000000000000000000000008152600401611d5e91906155b2565b60405180910390fd5b5f611d70612be7565b9050611d7e815f018561444a565b15611dc057836040517f77d05ea7000000000000000000000000000000000000000000000000000000008152600401611db791906155b2565b60405180910390fd5b611dcc815f0185614499565b7fbc1114fa9a77648cd097ee6cf149c344fa278b9b983f30dd65b6fd6a9d464a0784604051611dfb91906155b2565b60405180910390a150505050565b6040518060400160405280600581526020017f352e302e3000000000000000000000000000000000000000000000000000000081525081565b5f815f611e4d612be7565b90505f816008015f8481526020019081526020015f205f015403611ea857816040517f82b1fbda000000000000000000000000000000000000000000000000000000008152600401611e9f91906155b2565b60405180910390fd5b5f611eb1612be7565b9050806015015f8681526020019081526020015f20549350505050919050565b611ed9612f8e565b805f611ee3612be7565b90505f816008015f8481526020019081526020015f205f015403611f3e57816040517f82b1fbda000000000000000000000000000000000000000000000000000000008152600401611f3591906155b2565b60405180910390fd5b5f611f47612be7565b9050611f55815f018561444a565b15611f9757836040517fb25e4eb3000000000000000000000000000000000000000000000000000000008152600401611f8e91906155b2565b60405180910390fd5b611fa3815f0185614083565b7f3e8f02dc7af6e3a67f3af0bc99bcf11b4deb46105e9ba7f1ac6da82322e9025e84604051611fd291906155b2565b60405180910390a150505050565b611fe8612f8e565b611ff0613a30565b5f611ff9612be7565b90508181600701819055507f3ad5c22724afab8ed2b578fb9b160c7f65f5abd0aad105752b7ba4e068a3e0218260405161203391906155b2565b60405180910390a15050565b5f80612049612be7565b9050806007015491505090565b815f612060612be7565b90505f816008015f8481526020019081526020015f205f0154036120bb57816040517f82b1fbda0000000000000000000000000000000000000000000000000000000081526004016120b291906155b2565b60405180910390fd5b5f6120c4612be7565b905080600e015f8681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff166121645784846040517ffdf8a05d00000000000000000000000000000000000000000000000000000000815260040161215b929190616984565b60405180910390fd5b5050505050565b815f612175612be7565b90505f816008015f8481526020019081526020015f205f0154036121d057816040517f82b1fbda0000000000000000000000000000000000000000000000000000000081526004016121c791906155b2565b60405180910390fd5b5f6121d9612be7565b905080600f015f8681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff166122795784846040517f89b45e5d000000000000000000000000000000000000000000000000000000008152600401612270929190616984565b60405180910390fd5b5050505050565b612288612f8e565b612290613a30565b5f612299612be7565b90508181600501819055507f53cb968d31c28c6504a6e73d9908db6e1c1a386b66dcacec1a0117752c5ab986826040516122d391906155b2565b60405180910390a15050565b5f806122e96145ae565b9050805f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b61231c61552c565b5f612325611535565b90505f612330612be7565b90505f81600d015f8481526020019081526020015f205f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20604051806101000160405290815f8201805461239c9061653a565b80601f01602080910402602001604051908101604052809291908181526020018280546123c89061653a565b80156124135780601f106123ea57610100808354040283529160200191612413565b820191905f5260205f20905b8154815290600101906020018083116123f657829003601f168201915b50505050508152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600382015481526020016004820180546124e09061653a565b80601f016020809104026020016040519081016040528092919081815260200182805461250c9061653a565b80156125575780601f1061252e57610100808354040283529160200191612557565b820191905f5260205f20905b81548152906001019060200180831161253a57829003601f168201915b505050505081526020016005820180546125709061653a565b80601f016020809104026020016040519081016040528092919081815260200182805461259c9061653a565b80156125e75780601f106125be576101008083540402835291602001916125e7565b820191905f5260205f20905b8154815290600101906020018083116125ca57829003601f168201915b505050505081526020016006820180546126009061653a565b80601f016020809104026020016040519081016040528092919081815260200182805461262c9061653a565b80156126775780601f1061264e57610100808354040283529160200191612677565b820191905f5260205f20905b81548152906001019060200180831161265a57829003601f168201915b505050505081526020016007820180546126909061653a565b80601f01602080910402602001604051908101604052809291908181526020018280546126bc9061653a565b80156127075780601f106126de57610100808354040283529160200191612707565b820191905f5260205f20905b8154815290600101906020018083116126ea57829003601f168201915b50505050508152505090505f73ffffffffffffffffffffffffffffffffffffffff16816040015173ffffffffffffffffffffffffffffffffffffffff16036127885782856040517f0494d3c000000000000000000000000000000000000000000000000000000000815260040161277f929190616984565b60405180910390fd5b809350505050919050565b606061279d6108a8565b60800151905090565b6127ae612f8e565b6127b6613a30565b5f6127bf6108a8565b90506127d4815f0151838360800151516145d5565b7f837e0a6528dadfa2dc792692c5182e52a9f5bbdeed7b2372927a26c6958396138260405161280391906155b2565b60405180910390a15050565b60025f61281a61467e565b9050805f0160089054906101000a900460ff168061286257508167ffffffffffffffff16815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff1610155b15612899576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055506001815f0160086101000a81548160ff0219169083151502179055506129526040518060400160405280600b81526020017f4b6d73436f6e74657874730000000000000000000000000000000000000000008152506040518060400160405280600181526020017f31000000000000000000000000000000000000000000000000000000000000008152506146a5565b61296261295d611cc5565b6146bb565b61296a6146cf565b5f6129795f888888888e613015565b90505f612984612be7565b9050612995815f01835f0151614226565b6129a289835f01516146e1565b7f016ee9c16213ed67f33222abad4dfe46eb951ead30a10a1a72db3316ffb664e08a8a8a8a8a8a6040516129db96959493929190616d78565b60405180910390a150505f815f0160086101000a81548160ff0219169083151502179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d282604051612a2f9190616df5565b60405180910390a15050505050505050565b612a49612f8e565b5f612a52612be7565b90505f612a5d610814565b90505f8103612a98576040517f207ea3f300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f612aa1611535565b9050612aaf835f0182614321565b7f8fb75858a565aee117342d93196a7f0b54c1c8519885eddda6a01f477359b36381604051612ade91906155b2565b60405180910390a1612af2835f0183614226565b7f4f54a6ac981cc8dc83142b3eb4d120be7c70fc5de6477a14eae3e9ca647644bc82604051612b2191906155b2565b60405180910390a1505050565b612b36612f8e565b5f612b3f6145ae565b905081815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff16612ba1611cc5565b73ffffffffffffffffffffffffffffffffffffffff167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a35050565b5f7f7d8159810a7ebf944e8fa93cc4fbd1cade6c71f8b0b86b37187ac7991777b100905090565b60605f6001612c1c84614726565b0190505f8167ffffffffffffffff811115612c3a57612c39615d0c565b5b6040519080825280601f01601f191660200182016040528015612c6c5781602001600182028036833780820191505090505b5090505f82602001820190505b600115612ccd578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a8581612cc257612cc1616e0e565b5b0494505f8503612c79575b819350505050919050565b5f60016007811115612ced57612cec615c52565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115612d1e57612d1d615c52565b5b14905092915050565b5f612d7b6040518060600160405280602b81526020016175f9602b913980519060200120835f0151604051602001612d60929190616e3b565b60405160208183030381529060405280519060200120614877565b9050919050565b5f612d8b612be7565b90505f612ddb8585858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f81840152601f19601f82011690508083019250505050505050614890565b9050612de7868261216b565b81600a015f8781526020019081526020015f205f8273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff1615612e865785816040517f99b158c1000000000000000000000000000000000000000000000000000000008152600401612e7d929190616984565b60405180910390fd5b600182600a015f8881526020019081526020015f205f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550505050505050565b5f8083608001515190508083101591505092915050565b5f612f14612be7565b9050612f25815f01845f01516148ba565b5f8243612f329190616867565b905080826013015f865f015181526020019081526020015f20819055507f4540f7808fcaec86c376a89d2c0c93a5056c21680db54332c7f2959d87fefc8b8482604051612f80929190616e62565b60405180910390a150505050565b612f96613eaa565b73ffffffffffffffffffffffffffffffffffffffff16612fb4611cc5565b73ffffffffffffffffffffffffffffffffffffffff161461301357612fd7613eaa565b6040517f118cdaa700000000000000000000000000000000000000000000000000000000815260040161300a919061611e565b60405180910390fd5b565b61301d6154e6565b5f613026612be7565b90505f8585905003613064576040517f068c8d4000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b806009015f81548092919061307890616e90565b91905055505f8160090154905080826008015f8381526020019081526020015f205f018190555088826008015f8381526020019081526020015f206001018190555087826008015f8381526020019081526020015f206002015f6101000a81548167ffffffffffffffff021916908360c01c02179055506130fd818888889050614990565b5f5b8686905081101561318657826008015f8381526020019081526020015f2060040187878381811061313357613132616ed7565b5b90506020028101906131459190616f10565b908060018154018082558091505060019003905f5260205f2090600802015f9091909190915081816131779190617392565b505080806001019150506130ff565b505f5b868690508110156134df578686828181106131a7576131a6616ed7565b5b90506020028101906131b99190616f10565b83600d015f8481526020019081526020015f205f8989858181106131e0576131df616ed7565b5b90506020028101906131f29190616f10565b60400160208101906132049190616175565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2081816132499190617392565b905050600183600e015f8481526020019081526020015f205f89898581811061327557613274616ed7565b5b90506020028101906132879190616f10565b60400160208101906132999190616175565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550826010015f8381526020019081526020015f2087878381811061330e5761330d616ed7565b5b90506020028101906133209190616f10565b60400160208101906133329190616175565b908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600183600f015f8481526020019081526020015f205f8989858181106133b8576133b7616ed7565b5b90506020028101906133ca9190616f10565b60200160208101906133dc9190616175565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550826011015f8381526020019081526020015f2087878381811061345157613450616ed7565b5b90506020028101906134639190616f10565b60200160208101906134759190616175565b908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508080600101915050613189565b506134ee818588889050614a04565b816008015f8281526020019081526020015f206040518060a00160405290815f820154815260200160018201548152602001600282015f9054906101000a900460c01b77ffffffffffffffffffffffffffffffffffffffffffffffff191677ffffffffffffffffffffffffffffffffffffffffffffffff191681526020016003820154815260200160048201805480602002602001604051908101604052809291908181526020015f905b8282101561394d578382905f5260205f209060080201604051806101000160405290815f820180546135ca9061653a565b80601f01602080910402602001604051908101604052809291908181526020018280546135f69061653a565b80156136415780601f1061361857610100808354040283529160200191613641565b820191905f5260205f20905b81548152906001019060200180831161362457829003601f168201915b50505050508152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020016003820154815260200160048201805461370e9061653a565b80601f016020809104026020016040519081016040528092919081815260200182805461373a9061653a565b80156137855780601f1061375c57610100808354040283529160200191613785565b820191905f5260205f20905b81548152906001019060200180831161376857829003601f168201915b5050505050815260200160058201805461379e9061653a565b80601f01602080910402602001604051908101604052809291908181526020018280546137ca9061653a565b80156138155780601f106137ec57610100808354040283529160200191613815565b820191905f5260205f20905b8154815290600101906020018083116137f857829003601f168201915b5050505050815260200160068201805461382e9061653a565b80601f016020809104026020016040519081016040528092919081815260200182805461385a9061653a565b80156138a55780601f1061387c576101008083540402835291602001916138a5565b820191905f5260205f20905b81548152906001019060200180831161388857829003601f168201915b505050505081526020016007820180546138be9061653a565b80601f01602080910402602001604051908101604052809291908181526020018280546138ea9061653a565b80156139355780601f1061390c57610100808354040283529160200191613935565b820191905f5260205f20905b81548152906001019060200180831161391857829003601f168201915b50505050508152505081526020019060010190613599565b5050505081525050925050509695505050505050565b805f810361399d576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6139a78383614a26565b6139e857816040517f6653f6d70000000000000000000000000000000000000000000000000000000081526004016139df91906155b2565b60405180910390fd5b6001835f015f8481526020019081526020015f205f6101000a81548160ff02191690836007811115613a1d57613a1c615c52565b5b0217905550818360010181905550505050565b613a386115d5565b15613a6f576040517fd93c066500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f613a7a612be7565b90505f8303613ab5576040517fb1ae92ea00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81831115613afc5782826040517f84208f23000000000000000000000000000000000000000000000000000000008152600401613af39291906167de565b60405180910390fd5b82816015015f8681526020019081526020015f208190555050505050565b613b22614a74565b5f613b2b613e46565b90505f815f015f6101000a81548160ff0219169083151502179055507f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa613b70613eaa565b604051613b7d919061611e565b60405180910390a150565b5f825f015f8381526020019081526020015f205f9054906101000a900460ff16905092915050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff161480613c5d57507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16613c44614ab4565b73ffffffffffffffffffffffffffffffffffffffff1614155b15613c94576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b613c9e612f8e565b50565b8173ffffffffffffffffffffffffffffffffffffffff166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015613d0957506040513d601f19601f82011682018060405250810190613d0691906173ca565b60015b613d4a57816040517f4c9c8ce3000000000000000000000000000000000000000000000000000000008152600401613d41919061611e565b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b8114613db057806040517faa1d49a4000000000000000000000000000000000000000000000000000000008152600401613da79190615ea2565b60405180910390fd5b613dba8383614b07565b505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614613e44576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f7fcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300905090565b5f613e766145ae565b9050805f015f6101000a81549073ffffffffffffffffffffffffffffffffffffffff0219169055613ea682614b79565b5050565b5f33905090565b613eb9613a30565b5f613ec2613e46565b90506001815f015f6101000a81548160ff0219169083151502179055507f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258613f08613eaa565b604051613f15919061611e565b60405180910390a150565b5f7fa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100905090565b60605f613f52613f20565b9050806002018054613f639061653a565b80601f0160208091040260200160405190810160405280929190818152602001828054613f8f9061653a565b8015613fda5780601f10613fb157610100808354040283529160200191613fda565b820191905f5260205f20905b815481529060010190602001808311613fbd57829003601f168201915b505050505091505090565b60605f613ff0613f20565b90508060030180546140019061653a565b80601f016020809104026020016040519081016040528092919081815260200182805461402d9061653a565b80156140785780601f1061404f57610100808354040283529160200191614078565b820191905f5260205f20905b81548152906001019060200180831161405b57829003601f168201915b505050505091505090565b805f81036140bd576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6007835f015f8481526020019081526020015f205f6101000a81548160ff021916908360078111156140f2576140f1615c52565b5b02179055508183600101540361410c575f83600101819055505b81836002015403614121575f83600201819055505b81836003015403614136575f83600301819055505b8183600401540361414b575f83600401819055505b505050565b805f810361418a576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b614194838361444a565b6141d557816040517f331486b30000000000000000000000000000000000000000000000000000000081526004016141cc91906155b2565b60405180910390fd5b6004835f015f8481526020019081526020015f205f6101000a81548160ff0219169083600781111561420a57614209615c52565b5b02179055508183600401819055505f8360030181905550505050565b805f8103614260576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61426a8383614c4a565b15801561427e575061427c8383614c99565b155b801561428e57505f836003015414155b156142d057816040517f12b49e3d0000000000000000000000000000000000000000000000000000000081526004016142c791906155b2565b60405180910390fd5b6003835f015f8481526020019081526020015f205f6101000a81548160ff0219169083600781111561430557614304615c52565b5b02179055508183600301819055505f8360020181905550505050565b805f810361435b576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b614365838361444a565b158061437857506143768383614c99565b155b156143ba57816040517f2b3652d10000000000000000000000000000000000000000000000000000000081526004016143b191906155b2565b60405180910390fd5b6005835f015f8481526020019081526020015f205f6101000a81548160ff021916908360078111156143ef576143ee615c52565b5b021790555081836003015403614409575f83600301819055505b8183600401540361441e575f83600401819055505b505050565b5f7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300905090565b5f6003600781111561445f5761445e615c52565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff1660078111156144905761448f615c52565b5b14905092915050565b805f81036144d3576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6144dd8383614a26565b806144ee57506144ed8383612cd8565b5b1561453057816040517fb0c5151d00000000000000000000000000000000000000000000000000000000815260040161452791906155b2565b60405180910390fd5b6006835f015f8481526020019081526020015f205f6101000a81548160ff0219169083600781111561456557614564615c52565b5b02179055508183600201540361457f575f83600201819055505b81836003015403614594575f83600301819055505b818360040154036145a9575f83600401819055505b505050565b5f7f237e158222e3e6968b72b9db0d8043aacf074ad9f650f0d1606b4d82ee432c00905090565b5f6145de612be7565b90505f8303614619576040517fe60a727100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b818311156146605782826040517fd2535e110000000000000000000000000000000000000000000000000000000081526004016146579291906167de565b60405180910390fd5b82816016015f8681526020019081526020015f208190555050505050565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b6146ad614ce8565b6146b78282614d28565b5050565b6146c3614ce8565b6146cc81614d79565b50565b6146d7614ce8565b6146df614dfd565b565b5f6146ea612be7565b9050825f0135816006015f8481526020019081526020015f20819055508260200135816005018190555082604001358160070181905550505050565b5f805f90507a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008310614782577a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000838161477857614777616e0e565b5b0492506040810190505b6d04ee2d6d415b85acef810000000083106147bf576d04ee2d6d415b85acef810000000083816147b5576147b4616e0e565b5b0492506020810190505b662386f26fc1000083106147ee57662386f26fc1000083816147e4576147e3616e0e565b5b0492506010810190505b6305f5e1008310614817576305f5e100838161480d5761480c616e0e565b5b0492506008810190505b612710831061483c57612710838161483257614831616e0e565b5b0492506004810190505b6064831061485f576064838161485557614854616e0e565b5b0492506002810190505b600a831061486e576001810190505b80915050919050565b5f614889614883614e2d565b83614e3b565b9050919050565b5f805f8061489e8686614e7b565b9250925092506148ae8282614ed0565b82935050505092915050565b805f81036148f4576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6148fe8383612cd8565b61493f57816040517fc0b5ee6600000000000000000000000000000000000000000000000000000000815260040161493691906155b2565b60405180910390fd5b6002835f015f8481526020019081526020015f205f6101000a81548160ff0219169083600781111561497457614973615c52565b5b02179055508183600201819055505f8360010181905550505050565b5f614999612be7565b90508183106149e3578383836040517f8789a6ca0000000000000000000000000000000000000000000000000000000081526004016149da939291906173f5565b60405180910390fd5b82816008015f8681526020019081526020015f206003018190555050505050565b614a1283835f013583613a71565b614a21838360200135836145d5565b505050565b5f806007811115614a3a57614a39615c52565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115614a6b57614a6a615c52565b5b14905092915050565b614a7c6115d5565b614ab2576040517f8dfc202b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f614ae07f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b615032565b5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b614b108261503b565b8173ffffffffffffffffffffffffffffffffffffffff167fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b60405160405180910390a25f81511115614b6c57614b668282615104565b50614b75565b614b74615184565b5b5050565b5f614b82614423565b90505f815f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905082825f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a3505050565b5f60026007811115614c5f57614c5e615c52565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115614c9057614c8f615c52565b5b14905092915050565b5f60046007811115614cae57614cad615c52565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115614cdf57614cde615c52565b5b14905092915050565b614cf06151c0565b614d26576040517fd7e6bcf800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b614d30614ce8565b5f614d39613f20565b905082816002019081614d4c919061742a565b5081816003019081614d5e919061742a565b505f801b815f01819055505f801b8160010181905550505050565b614d81614ce8565b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603614df1575f6040517f1e4fbdf7000000000000000000000000000000000000000000000000000000008152600401614de8919061611e565b60405180910390fd5b614dfa81613e6d565b50565b614e05614ce8565b5f614e0e613e46565b90505f815f015f6101000a81548160ff02191690831515021790555050565b5f614e366151de565b905090565b5f6040517f190100000000000000000000000000000000000000000000000000000000000081528360028201528260228201526042812091505092915050565b5f805f6041845103614ebb575f805f602087015192506040870151915060608701515f1a9050614ead88828585615241565b955095509550505050614ec9565b5f600285515f1b9250925092505b9250925092565b5f6003811115614ee357614ee2615c52565b5b826003811115614ef657614ef5615c52565b5b031561502e5760016003811115614f1057614f0f615c52565b5b826003811115614f2357614f22615c52565b5b03614f5a576040517ff645eedf00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60026003811115614f6e57614f6d615c52565b5b826003811115614f8157614f80615c52565b5b03614fc557805f1c6040517ffce698f7000000000000000000000000000000000000000000000000000000008152600401614fbc91906155b2565b60405180910390fd5b600380811115614fd857614fd7615c52565b5b826003811115614feb57614fea615c52565b5b0361502d57806040517fd78bce0c0000000000000000000000000000000000000000000000000000000081526004016150249190615ea2565b60405180910390fd5b5b5050565b5f819050919050565b5f8173ffffffffffffffffffffffffffffffffffffffff163b0361509657806040517f4c9c8ce300000000000000000000000000000000000000000000000000000000815260040161508d919061611e565b60405180910390fd5b806150c27f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b615032565b5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60605f808473ffffffffffffffffffffffffffffffffffffffff168460405161512d9190617533565b5f60405180830381855af49150503d805f8114615165576040519150601f19603f3d011682016040523d82523d5f602084013e61516a565b606091505b509150915061517a858383615328565b9250505092915050565b5f3411156151be576040517fb398979f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f6151c961467e565b5f0160089054906101000a900460ff16905090565b5f7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f6152086153b5565b61521061542b565b4630604051602001615226959493929190617549565b60405160208183030381529060405280519060200120905090565b5f805f7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0845f1c111561527d575f60038592509250925061531e565b5f6001888888886040515f81526020016040526040516152a094939291906175b5565b6020604051602081039080840390855afa1580156152c0573d5f803e3d5ffd5b5050506020604051035190505f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603615311575f60015f801b9350935093505061531e565b805f805f1b935093509350505b9450945094915050565b60608261533d57615338826154a2565b6153ad565b5f825114801561536357505f8473ffffffffffffffffffffffffffffffffffffffff163b145b156153a557836040517f9996b31500000000000000000000000000000000000000000000000000000000815260040161539c919061611e565b60405180910390fd5b8190506153ae565b5b9392505050565b5f806153bf613f20565b90505f6153ca613f47565b90505f815111156153e657808051906020012092505050615428565b5f825f015490505f801b811461540157809350505050615428565b7fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a47093505050505b90565b5f80615435613f20565b90505f615440613fe5565b90505f8151111561545c5780805190602001209250505061549f565b5f826001015490505f801b81146154785780935050505061549f565b7fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a47093505050505b90565b5f815111156154b45780518082602001fd5b6040517fd6bda27500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040518060a001604052805f81526020015f81526020015f77ffffffffffffffffffffffffffffffffffffffffffffffff191681526020015f8152602001606081525090565b604051806101000160405280606081526020015f73ffffffffffffffffffffffffffffffffffffffff1681526020015f73ffffffffffffffffffffffffffffffffffffffff1681526020015f8152602001606081526020016060815260200160608152602001606081525090565b5f819050919050565b6155ac8161559a565b82525050565b5f6020820190506155c55f8301846155a3565b92915050565b5f81519050919050565b5f82825260208201905092915050565b5f5b838110156156025780820151818401526020810190506155e7565b5f8484015250505050565b5f601f19601f8301169050919050565b5f615627826155cb565b61563181856155d5565b93506156418185602086016155e5565b61564a8161560d565b840191505092915050565b5f6020820190508181035f83015261566d818461561d565b905092915050565b61567e8161559a565b82525050565b5f7fffffffffffffffff00000000000000000000000000000000000000000000000082169050919050565b6156b881615684565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f82825260208201905092915050565b5f615701826155cb565b61570b81856156e7565b935061571b8185602086016155e5565b6157248161560d565b840191505092915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6157588261572f565b9050919050565b6157688161574e565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f6157928261576e565b61579c8185615778565b93506157ac8185602086016155e5565b6157b58161560d565b840191505092915050565b5f61010083015f8301518482035f8601526157db82826156f7565b91505060208301516157f0602086018261575f565b506040830151615803604086018261575f565b5060608301516158166060860182615675565b506080830151848203608086015261582e8282615788565b91505060a083015184820360a086015261584882826156f7565b91505060c083015184820360c086015261586282826156f7565b91505060e083015184820360e086015261587c8282615788565b9150508091505092915050565b5f61589483836157c0565b905092915050565b5f602082019050919050565b5f6158b2826156be565b6158bc81856156c8565b9350836020820285016158ce856156d8565b805f5b8581101561590957848403895281516158ea8582615889565b94506158f58361589c565b925060208a019950506001810190506158d1565b50829750879550505050505092915050565b5f60a083015f8301516159305f860182615675565b5060208301516159436020860182615675565b50604083015161595660408601826156af565b5060608301516159696060860182615675565b506080830151848203608086015261598182826158a8565b9150508091505092915050565b5f6020820190508181035f8301526159a6818461591b565b905092915050565b5f604051905090565b5f80fd5b5f80fd5b6159c88161559a565b81146159d2575f80fd5b50565b5f813590506159e3816159bf565b92915050565b5f80fd5b5f80fd5b5f80fd5b5f8083601f840112615a0a57615a096159e9565b5b8235905067ffffffffffffffff811115615a2757615a266159ed565b5b602083019150836001820283011115615a4357615a426159f1565b5b9250929050565b5f805f60408486031215615a6157615a606159b7565b5b5f615a6e868287016159d5565b935050602084013567ffffffffffffffff811115615a8f57615a8e6159bb565b5b615a9b868287016159f5565b92509250509250925092565b615ab081615684565b8114615aba575f80fd5b50565b5f81359050615acb81615aa7565b92915050565b5f8115159050919050565b615ae581615ad1565b8114615aef575f80fd5b50565b5f81359050615b0081615adc565b92915050565b5f8083601f840112615b1b57615b1a6159e9565b5b8235905067ffffffffffffffff811115615b3857615b376159ed565b5b602083019150836020820283011115615b5457615b536159f1565b5b9250929050565b5f80fd5b5f60408284031215615b7457615b73615b5b565b5b81905092915050565b5f805f805f805f60e0888a031215615b9857615b976159b7565b5b5f615ba58a828b016159d5565b9750506020615bb68a828b01615abd565b9650506040615bc78a828b01615af2565b9550506060615bd88a828b016159d5565b945050608088013567ffffffffffffffff811115615bf957615bf86159bb565b5b615c058a828b01615b06565b935093505060a0615c188a828b01615b5f565b91505092959891949750929550565b5f60208284031215615c3c57615c3b6159b7565b5b5f615c49848285016159d5565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b60088110615c9057615c8f615c52565b5b50565b5f819050615ca082615c7f565b919050565b5f615caf82615c93565b9050919050565b615cbf81615ca5565b82525050565b5f602082019050615cd85f830184615cb6565b92915050565b615ce78161574e565b8114615cf1575f80fd5b50565b5f81359050615d0281615cde565b92915050565b5f80fd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b615d428261560d565b810181811067ffffffffffffffff82111715615d6157615d60615d0c565b5b80604052505050565b5f615d736159ae565b9050615d7f8282615d39565b919050565b5f67ffffffffffffffff821115615d9e57615d9d615d0c565b5b615da78261560d565b9050602081019050919050565b828183375f83830152505050565b5f615dd4615dcf84615d84565b615d6a565b905082815260208101848484011115615df057615def615d08565b5b615dfb848285615db4565b509392505050565b5f82601f830112615e1757615e166159e9565b5b8135615e27848260208601615dc2565b91505092915050565b5f8060408385031215615e4657615e456159b7565b5b5f615e5385828601615cf4565b925050602083013567ffffffffffffffff811115615e7457615e736159bb565b5b615e8085828601615e03565b9150509250929050565b5f819050919050565b615e9c81615e8a565b82525050565b5f602082019050615eb55f830184615e93565b92915050565b615ec481615ad1565b82525050565b5f602082019050615edd5f830184615ebb565b92915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f615f17838361575f565b60208301905092915050565b5f602082019050919050565b5f615f3982615ee3565b615f438185615eed565b9350615f4e83615efd565b805f5b83811015615f7e578151615f658882615f0c565b9750615f7083615f23565b925050600181019050615f51565b5085935050505092915050565b5f6020820190508181035f830152615fa38184615f2f565b905092915050565b5f7fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b615fdf81615fab565b82525050565b615fee8161574e565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f6160288383615675565b60208301905092915050565b5f602082019050919050565b5f61604a82615ff4565b6160548185615ffe565b935061605f8361600e565b805f5b8381101561608f578151616076888261601d565b975061608183616034565b925050600181019050616062565b5085935050505092915050565b5f60e0820190506160af5f83018a615fd6565b81810360208301526160c1818961561d565b905081810360408301526160d5818861561d565b90506160e460608301876155a3565b6160f16080830186615fe5565b6160fe60a0830185615e93565b81810360c08301526161108184616040565b905098975050505050505050565b5f6020820190506161315f830184615fe5565b92915050565b5f806040838503121561614d5761614c6159b7565b5b5f61615a858286016159d5565b925050602061616b85828601615cf4565b9150509250929050565b5f6020828403121561618a576161896159b7565b5b5f61619784828501615cf4565b91505092915050565b5f61010083015f8301518482035f8601526161bb82826156f7565b91505060208301516161d0602086018261575f565b5060408301516161e3604086018261575f565b5060608301516161f66060860182615675565b506080830151848203608086015261620e8282615788565b91505060a083015184820360a086015261622882826156f7565b91505060c083015184820360c086015261624282826156f7565b91505060e083015184820360e086015261625c8282615788565b9150508091505092915050565b5f6020820190508181035f83015261628181846161a0565b905092915050565b5f82825260208201905092915050565b5f6162a3826156be565b6162ad8185616289565b9350836020820285016162bf856156d8565b805f5b858110156162fa57848403895281516162db8582615889565b94506162e68361589c565b925060208a019950506001810190506162c2565b50829750879550505050505092915050565b5f6020820190508181035f8301526163248184616299565b905092915050565b5f6060828403121561634157616340615b5b565b5b81905092915050565b5f805f805f806101008789031215616365576163646159b7565b5b5f61637289828a01615b5f565b965050604061638389828a0161632c565b95505060a061639489828a01615abd565b94505060c06163a589828a016159d5565b93505060e087013567ffffffffffffffff8111156163c6576163c56159bb565b5b6163d289828a01615b06565b92509250509295509295509295565b5f81905092915050565b5f6163f5826155cb565b6163ff81856163e1565b935061640f8185602086016155e5565b80840191505092915050565b7f20760000000000000000000000000000000000000000000000000000000000005f82015250565b5f61644f6002836163e1565b915061645a8261641b565b600282019050919050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f6164996001836163e1565b91506164a482616465565b600182019050919050565b5f6164ba82876163eb565b91506164c582616443565b91506164d182866163eb565b91506164dc8261648d565b91506164e882856163eb565b91506164f38261648d565b91506164ff82846163eb565b915081905095945050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f600282049050600182168061655157607f821691505b6020821081036165645761656361650d565b5b50919050565b5f82905092915050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026165d07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82616595565b6165da8683616595565b95508019841693508086168417925050509392505050565b5f819050919050565b5f61661561661061660b8461559a565b6165f2565b61559a565b9050919050565b5f819050919050565b61662e836165fb565b61664261663a8261661c565b8484546165a1565b825550505050565b5f90565b61665661664a565b616661818484616625565b505050565b5b81811015616684576166795f8261664e565b600181019050616667565b5050565b601f8211156166c95761669a81616574565b6166a384616586565b810160208510156166b2578190505b6166c66166be85616586565b830182616666565b50505b505050565b5f82821c905092915050565b5f6166e95f19846008026166ce565b1980831691505092915050565b5f61670183836166da565b9150826002028217905092915050565b61671b838361656a565b67ffffffffffffffff81111561673457616733615d0c565b5b61673e825461653a565b616749828285616688565b5f601f831160018114616776575f8415616764578287013590505b61676e85826166f6565b8655506167d5565b601f19841661678486616574565b5f5b828110156167ab57848901358255600182019150602085019450602081019050616786565b868310156167c857848901356167c4601f8916826166da565b8355505b6001600288020188555050505b50505050505050565b5f6040820190506167f15f8301856155a3565b6167fe60208301846155a3565b9392505050565b5f6040820190508181035f83015261681d818561591b565b90508181036020830152616831818461591b565b90509392505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6168718261559a565b915061687c8361559a565b92508282019050808211156168945761689361683a565b5b92915050565b5f6060820190508181035f8301526168b2818661591b565b905081810360208301526168c6818561591b565b90506168d560408301846155a3565b949350505050565b5f815190506168eb81615cde565b92915050565b5f60208284031215616906576169056159b7565b5b5f616913848285016168dd565b91505092915050565b7f4549503731323a20556e696e697469616c697a656400000000000000000000005f82015250565b5f6169506015836155d5565b915061695b8261691c565b602082019050919050565b5f6020820190508181035f83015261697d81616944565b9050919050565b5f6040820190506169975f8301856155a3565b6169a46020830184615fe5565b9392505050565b5f6169b960208401846159d5565b905092915050565b604082016169d15f8301836169ab565b6169dd5f850182615675565b506169eb60208301836169ab565b6169f86020850182615675565b50505050565b60608201616a0e5f8301836169ab565b616a1a5f850182615675565b50616a2860208301836169ab565b616a356020850182615675565b50616a4360408301836169ab565b616a506040850182615675565b50505050565b616a5f81615684565b82525050565b5f819050919050565b5f80fd5b5f80fd5b5f80fd5b5f8083356001602003843603038112616a9657616a95616a76565b5b83810192508235915060208301925067ffffffffffffffff821115616abe57616abd616a6e565b5b600182023603831315616ad457616ad3616a72565b5b509250929050565b5f616ae783856156e7565b9350616af4838584615db4565b616afd8361560d565b840190509392505050565b5f616b166020840184615cf4565b905092915050565b5f8083356001602003843603038112616b3a57616b39616a76565b5b83810192508235915060208301925067ffffffffffffffff821115616b6257616b61616a6e565b5b600182023603831315616b7857616b77616a72565b5b509250929050565b5f616b8b8385615778565b9350616b98838584615db4565b616ba18361560d565b840190509392505050565b5f6101008301616bbe5f840184616a7a565b8583035f870152616bd0838284616adc565b92505050616be16020840184616b08565b616bee602086018261575f565b50616bfc6040840184616b08565b616c09604086018261575f565b50616c1760608401846169ab565b616c246060860182615675565b50616c326080840184616b1e565b8583036080870152616c45838284616b80565b92505050616c5660a0840184616a7a565b85830360a0870152616c69838284616adc565b92505050616c7a60c0840184616a7a565b85830360c0870152616c8d838284616adc565b92505050616c9e60e0840184616b1e565b85830360e0870152616cb1838284616b80565b925050508091505092915050565b5f616cca8383616bac565b905092915050565b5f8235600161010003833603038112616cee57616ced616a76565b5b82810191505092915050565b5f602082019050919050565b5f616d118385616289565b935083602084028501616d2384616a65565b805f5b87811015616d66578484038952616d3d8284616cd2565b616d478582616cbf565b9450616d5283616cfa565b925060208a01995050600181019050616d26565b50829750879450505050509392505050565b5f61010082019050616d8c5f8301896169c1565b616d9960408301886169fe565b616da660a0830187616a56565b616db360c08301866155a3565b81810360e0830152616dc6818486616d06565b9050979650505050505050565b5f67ffffffffffffffff82169050919050565b616def81616dd3565b82525050565b5f602082019050616e085f830184616de6565b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f604082019050616e4e5f830185615e93565b616e5b60208301846155a3565b9392505050565b5f6040820190508181035f830152616e7a818561591b565b9050616e8960208301846155a3565b9392505050565b5f616e9a8261559a565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203616ecc57616ecb61683a565b5b600182019050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f80fd5b5f80fd5b5f80fd5b5f8235600161010003833603038112616f2c57616f2b616f04565b5b80830191505092915050565b5f8083356001602003843603038112616f5457616f53616f04565b5b80840192508235915067ffffffffffffffff821115616f7657616f75616f08565b5b602083019250600182023603831315616f9257616f91616f0c565b5b509250929050565b5f82905092915050565b5f819050815f5260205f209050919050565b601f821115616ff757616fc881616fa4565b616fd184616586565b81016020851015616fe0578190505b616ff4616fec85616586565b830182616666565b50505b505050565b6170068383616f9a565b67ffffffffffffffff81111561701f5761701e615d0c565b5b617029825461653a565b617034828285616fb6565b5f601f831160018114617061575f841561704f578287013590505b61705985826166f6565b8655506170c0565b601f19841661706f86616fa4565b5f5b8281101561709657848901358255600182019150602085019450602081019050617071565b868310156170b357848901356170af601f8916826166da565b8355505b6001600288020188555050505b50505050505050565b6170d4838383616ffc565b505050565b5f81356170e581615cde565b80915050919050565b5f815f1b9050919050565b5f73ffffffffffffffffffffffffffffffffffffffff617118846170ee565b9350801983169250808416831791505092915050565b5f61714861714361713e8461572f565b6165f2565b61572f565b9050919050565b5f6171598261712e565b9050919050565b5f61716a8261714f565b9050919050565b5f819050919050565b61718382617160565b61719661718f82617171565b83546170f9565b8255505050565b5f81356171a9816159bf565b80915050919050565b5f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6171dd846170ee565b9350801983169250808416831791505092915050565b6171fc826165fb565b61720f6172088261661c565b83546171b2565b8255505050565b5f808335600160200384360303811261723257617231616f04565b5b80840192508235915067ffffffffffffffff82111561725457617253616f08565b5b6020830192506001820236038313156172705761726f616f0c565b5b509250929050565b617283838383616711565b505050565b5f81015f83016172988185616f38565b6172a38183866170c9565b505050506001810160208301806172b9816170d9565b90506172c5818461717a565b5050506002810160408301806172da816170d9565b90506172e6818461717a565b5050506003810160608301806172fb8161719d565b905061730781846171f3565b505050600481016080830161731c8185617216565b617327818386617278565b505050506005810160a0830161733d8185616f38565b6173488183866170c9565b505050506006810160c0830161735e8185616f38565b6173698183866170c9565b505050506007810160e0830161737f8185617216565b61738a818386617278565b505050505050565b61739c8282617288565b5050565b6173a981615e8a565b81146173b3575f80fd5b50565b5f815190506173c4816173a0565b92915050565b5f602082840312156173df576173de6159b7565b5b5f6173ec848285016173b6565b91505092915050565b5f6060820190506174085f8301866155a3565b61741560208301856155a3565b61742260408301846155a3565b949350505050565b617433826155cb565b67ffffffffffffffff81111561744c5761744b615d0c565b5b617456825461653a565b617461828285616fb6565b5f60209050601f831160018114617492575f8415617480578287015190505b61748a85826166f6565b8655506174f1565b601f1984166174a086616fa4565b5f5b828110156174c7578489015182556001820191506020850194506020810190506174a2565b868310156174e457848901516174e0601f8916826166da565b8355505b6001600288020188555050505b505050505050565b5f81905092915050565b5f61750d8261576e565b61751781856174f9565b93506175278185602086016155e5565b80840191505092915050565b5f61753e8284617503565b915081905092915050565b5f60a08201905061755c5f830188615e93565b6175696020830187615e93565b6175766040830186615e93565b61758360608301856155a3565b6175906080830184615fe5565b9695505050505050565b5f60ff82169050919050565b6175af8161759a565b82525050565b5f6080820190506175c85f830187615e93565b6175d560208301866175a6565b6175e26040830185615e93565b6175ef6060830184615e93565b9594505050505056fe4b6579526573686172696e67566572696669636174696f6e2875696e7432353620636f6e74657874496429
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10a\x02$W_5`\xE0\x1C\x80c\x84\xB0\x19n\x11a\x01\"W\x80c\xDE\xFB\xA0j\x11a\0\xAAW\x80c\xE7.\xE9\x91\x11a\0nW\x80c\xE7.\xE9\x91\x14a\x07\\W\x80c\xEB\x84<\xF6\x14a\x07\x86W\x80c\xED\xC4O\x19\x14a\x07\xAEW\x80c\xF2|\xB9W\x14a\x07\xD6W\x80c\xF2\xFD\xE3\x8B\x14a\x07\xECWa\x02$V[\x80c\xDE\xFB\xA0j\x14a\x06~W\x80c\xDF\xE3j\xEE\x14a\x06\xA6W\x80c\xE2K\xA4\xE5\x14a\x06\xCEW\x80c\xE3\x0C9x\x14a\x06\xF6W\x80c\xE3\xB2\xA8t\x14a\x07 Wa\x02$V[\x80c\xAD<\xB1\xCC\x11a\0\xF1W\x80c\xAD<\xB1\xCC\x14a\x05\x9EW\x80c\xB8q]M\x14a\x05\xC8W\x80c\xC0\xAEd\xF7\x14a\x06\x04W\x80c\xC1\xC8\xB7%\x14a\x06,W\x80c\xD8\xE3\xAE\x01\x14a\x06TWa\x02$V[\x80c\x84\xB0\x19n\x14a\x05\x06W\x80c\x8C\xB9gQ\x14a\x056W\x80c\x8D\xA5\xCB[\x14a\x05LW\x80c\x9E\xE7z\xF3\x14a\x05vWa\x02$V[\x80cMiB`\x11a\x01\xB0W\x80cqP\x18\xA6\x11a\x01tW\x80cqP\x18\xA6\x14a\x04pW\x80ct \xF3\xD4\x14a\x04\x86W\x80cy\xBAP\x97\x14a\x04\xB0W\x80c~\xAA\xC8\xF2\x14a\x04\xC6W\x80c\x84V\xCBY\x14a\x04\xF0Wa\x02$V[\x80cMiB`\x14a\x03\x88W\x80cO\x1E\xF2\x86\x14a\x03\xC4W\x80cR\xD1\x90-\x14a\x03\xE0W\x80c\\\x97Z\xBB\x14a\x04\nW\x80cd\xB0\x0C\xC5\x14a\x044Wa\x02$V[\x80c\x16\x9C\xAC\x14\x11a\x01\xF7W\x80c\x16\x9C\xAC\x14\x14a\x02\xCEW\x80c.-:\x82\x14a\x02\xF6W\x80c?K\xA8:\x14a\x03\x1EW\x80cC\xE3~\x8A\x14a\x034W\x80cIe\xE4U\x14a\x03^Wa\x02$V[\x80c\nP\xE3\x18\x14a\x02(W\x80c\r\x8En,\x14a\x02RW\x80c\r\xD4\x86\xC0\x14a\x02|W\x80c\x10y\xEB\xEB\x14a\x02\xA6W[_\x80\xFD[4\x80\x15a\x023W_\x80\xFD[Pa\x02<a\x08\x14V[`@Qa\x02I\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02]W_\x80\xFD[Pa\x02fa\x08-V[`@Qa\x02s\x91\x90aVUV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\x87W_\x80\xFD[Pa\x02\x90a\x08\xA8V[`@Qa\x02\x9D\x91\x90aY\x8EV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xB1W_\x80\xFD[Pa\x02\xCC`\x04\x806\x03\x81\x01\x90a\x02\xC7\x91\x90aZJV[a\r4V[\0[4\x80\x15a\x02\xD9W_\x80\xFD[Pa\x02\xF4`\x04\x806\x03\x81\x01\x90a\x02\xEF\x91\x90a[}V[a\x12\xF1V[\0[4\x80\x15a\x03\x01W_\x80\xFD[Pa\x03\x1C`\x04\x806\x03\x81\x01\x90a\x03\x17\x91\x90a\\'V[a\x14\xBAV[\0[4\x80\x15a\x03)W_\x80\xFD[Pa\x032a\x15#V[\0[4\x80\x15a\x03?W_\x80\xFD[Pa\x03Ha\x155V[`@Qa\x03U\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03iW_\x80\xFD[Pa\x03ra\x15NV[`@Qa\x03\x7F\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x93W_\x80\xFD[Pa\x03\xAE`\x04\x806\x03\x81\x01\x90a\x03\xA9\x91\x90a\\'V[a\x15eV[`@Qa\x03\xBB\x91\x90a\\\xC5V[`@Q\x80\x91\x03\x90\xF3[a\x03\xDE`\x04\x806\x03\x81\x01\x90a\x03\xD9\x91\x90a^0V[a\x15\x85V[\0[4\x80\x15a\x03\xEBW_\x80\xFD[Pa\x03\xF4a\x15\xA4V[`@Qa\x04\x01\x91\x90a^\xA2V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x15W_\x80\xFD[Pa\x04\x1Ea\x15\xD5V[`@Qa\x04+\x91\x90a^\xCAV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04?W_\x80\xFD[Pa\x04Z`\x04\x806\x03\x81\x01\x90a\x04U\x91\x90a\\'V[a\x15\xF7V[`@Qa\x04g\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04{W_\x80\xFD[Pa\x04\x84a\x16\x86V[\0[4\x80\x15a\x04\x91W_\x80\xFD[Pa\x04\x9Aa\x16\x99V[`@Qa\x04\xA7\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xBBW_\x80\xFD[Pa\x04\xC4a\x17MV[\0[4\x80\x15a\x04\xD1W_\x80\xFD[Pa\x04\xDAa\x17\xDBV[`@Qa\x04\xE7\x91\x90a_\x8BV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xFBW_\x80\xFD[Pa\x05\x04a\x18\x8FV[\0[4\x80\x15a\x05\x11W_\x80\xFD[Pa\x05\x1Aa\x19\xCAV[`@Qa\x05-\x97\x96\x95\x94\x93\x92\x91\x90a`\x9CV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05AW_\x80\xFD[Pa\x05Ja\x1A\xD3V[\0[4\x80\x15a\x05WW_\x80\xFD[Pa\x05`a\x1C\xC5V[`@Qa\x05m\x91\x90aa\x1EV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\x81W_\x80\xFD[Pa\x05\x9C`\x04\x806\x03\x81\x01\x90a\x05\x97\x91\x90a\\'V[a\x1C\xFAV[\0[4\x80\x15a\x05\xA9W_\x80\xFD[Pa\x05\xB2a\x1E\tV[`@Qa\x05\xBF\x91\x90aVUV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xD3W_\x80\xFD[Pa\x05\xEE`\x04\x806\x03\x81\x01\x90a\x05\xE9\x91\x90a\\'V[a\x1EBV[`@Qa\x05\xFB\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\x0FW_\x80\xFD[Pa\x06*`\x04\x806\x03\x81\x01\x90a\x06%\x91\x90a\\'V[a\x1E\xD1V[\0[4\x80\x15a\x067W_\x80\xFD[Pa\x06R`\x04\x806\x03\x81\x01\x90a\x06M\x91\x90a\\'V[a\x1F\xE0V[\0[4\x80\x15a\x06_W_\x80\xFD[Pa\x06ha ?V[`@Qa\x06u\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\x89W_\x80\xFD[Pa\x06\xA4`\x04\x806\x03\x81\x01\x90a\x06\x9F\x91\x90aa7V[a VV[\0[4\x80\x15a\x06\xB1W_\x80\xFD[Pa\x06\xCC`\x04\x806\x03\x81\x01\x90a\x06\xC7\x91\x90aa7V[a!kV[\0[4\x80\x15a\x06\xD9W_\x80\xFD[Pa\x06\xF4`\x04\x806\x03\x81\x01\x90a\x06\xEF\x91\x90a\\'V[a\"\x80V[\0[4\x80\x15a\x07\x01W_\x80\xFD[Pa\x07\na\"\xDFV[`@Qa\x07\x17\x91\x90aa\x1EV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07+W_\x80\xFD[Pa\x07F`\x04\x806\x03\x81\x01\x90a\x07A\x91\x90aauV[a#\x14V[`@Qa\x07S\x91\x90abiV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07gW_\x80\xFD[Pa\x07pa'\x93V[`@Qa\x07}\x91\x90ac\x0CV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\x91W_\x80\xFD[Pa\x07\xAC`\x04\x806\x03\x81\x01\x90a\x07\xA7\x91\x90a\\'V[a'\xA6V[\0[4\x80\x15a\x07\xB9W_\x80\xFD[Pa\x07\xD4`\x04\x806\x03\x81\x01\x90a\x07\xCF\x91\x90acJV[a(\x0FV[\0[4\x80\x15a\x07\xE1W_\x80\xFD[Pa\x07\xEAa*AV[\0[4\x80\x15a\x07\xF7W_\x80\xFD[Pa\x08\x12`\x04\x806\x03\x81\x01\x90a\x08\r\x91\x90aauV[a+.V[\0[_\x80a\x08\x1Ea+\xE7V[\x90P\x80_\x01`\x04\x01T\x91PP\x90V[```@Q\x80`@\x01`@R\x80`\x0B\x81R` \x01\x7FKmsContexts\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa\x08n_a,\x0EV[a\x08x`\x01a,\x0EV[a\x08\x81_a,\x0EV[`@Q` \x01a\x08\x94\x94\x93\x92\x91\x90ad\xAFV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P\x90V[a\x08\xB0aT\xE6V[_a\x08\xB9a+\xE7V[\x90P_a\x08\xC4a\x155V[\x90P\x81`\x08\x01_\x82\x81R` \x01\x90\x81R` \x01_ `@Q\x80`\xA0\x01`@R\x90\x81_\x82\x01T\x81R` \x01`\x01\x82\x01T\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04`\xC0\x1Bw\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01_\x90[\x82\x82\x10\x15a\r%W\x83\x82\x90_R` _ \x90`\x08\x02\x01`@Q\x80a\x01\0\x01`@R\x90\x81_\x82\x01\x80Ta\t\xA2\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\t\xCE\x90ae:V[\x80\x15a\n\x19W\x80`\x1F\x10a\t\xF0Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\n\x19V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\t\xFCW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80Ta\n\xE6\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0B\x12\x90ae:V[\x80\x15a\x0B]W\x80`\x1F\x10a\x0B4Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0B]V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0B@W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta\x0Bv\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0B\xA2\x90ae:V[\x80\x15a\x0B\xEDW\x80`\x1F\x10a\x0B\xC4Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0B\xEDV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0B\xD0W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x06\x82\x01\x80Ta\x0C\x06\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0C2\x90ae:V[\x80\x15a\x0C}W\x80`\x1F\x10a\x0CTWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0C}V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0C`W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x07\x82\x01\x80Ta\x0C\x96\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0C\xC2\x90ae:V[\x80\x15a\r\rW\x80`\x1F\x10a\x0C\xE4Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\r\rV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0C\xF0W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x81R` \x01\x90`\x01\x01\x90a\tqV[PPPP\x81RPP\x92PPP\x90V[a\r>\x833a VV[_a\rGa+\xE7V[\x90Pa\rU\x81_\x01\x85a,\xD8V[a\r\x96W\x83`@Q\x7F^Q\xA2\xE1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\r\x8D\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[_`@Q\x80` \x01`@R\x80\x86\x81RP\x90P_a\r\xB2\x82a-'V[\x90Pa\r\xC0\x86\x82\x87\x87a-\x82V[_\x83`\x0C\x01_\x88\x81R` \x01\x90\x81R` \x01_ \x90P\x80\x86\x86\x90\x91\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x92\x90\x91\x92\x90\x91\x92\x90\x91\x92P\x91\x82a\x0E\x0F\x92\x91\x90ag\x11V[P_\x84`\x08\x01_\x89\x81R` \x01\x90\x81R` \x01_ `@Q\x80`\xA0\x01`@R\x90\x81_\x82\x01T\x81R` \x01`\x01\x82\x01T\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04`\xC0\x1Bw\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01_\x90[\x82\x82\x10\x15a\x12pW\x83\x82\x90_R` _ \x90`\x08\x02\x01`@Q\x80a\x01\0\x01`@R\x90\x81_\x82\x01\x80Ta\x0E\xED\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0F\x19\x90ae:V[\x80\x15a\x0FdW\x80`\x1F\x10a\x0F;Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0FdV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0FGW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80Ta\x101\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x10]\x90ae:V[\x80\x15a\x10\xA8W\x80`\x1F\x10a\x10\x7FWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x10\xA8V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x10\x8BW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta\x10\xC1\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x10\xED\x90ae:V[\x80\x15a\x118W\x80`\x1F\x10a\x11\x0FWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x118V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x11\x1BW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x06\x82\x01\x80Ta\x11Q\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x11}\x90ae:V[\x80\x15a\x11\xC8W\x80`\x1F\x10a\x11\x9FWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x11\xC8V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x11\xABW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x07\x82\x01\x80Ta\x11\xE1\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x12\r\x90ae:V[\x80\x15a\x12XW\x80`\x1F\x10a\x12/Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x12XV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x12;W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x81R` \x01\x90`\x01\x01\x90a\x0E\xBCV[PPPP\x81RPP\x90Pa\x12\x88\x81\x83\x80T\x90Pa.\xF4V[\x15a\x12\xE7W_\x85`\x06\x01_\x8A\x81R` \x01\x90\x81R` \x01_ T\x90Pa\x12\xAE\x82\x82a/\x0BV[\x7Fh\x89\x8A\x98\x93k\xF2:V\xE8\xEDK#\xDC\xC9\x8C\xEF\x92k\xD9\xAC,\xE5\"\xF1\xF9B>8d\xF2\xF5\x82`@Qa\x12\xDD\x91\x90aY\x8EV[`@Q\x80\x91\x03\x90\xA1P[PPPPPPPPV[a\x12\xF9a/\x8EV[_a\x13\x02a+\xE7V[\x90P_a\x13\ra\x08\xA8V[\x90P_\x81`\x80\x01QQ\x90P_\x86\x86\x90P\x90P\x81\x81\x14a\x13eW\x81\x81`@Q\x7F\xD5\x95\xA9b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\\\x92\x91\x90ag\xDEV[`@Q\x80\x91\x03\x90\xFD[_a\x13na\x08\x14V[\x90P_\x81\x14a\x13\xB4W\x80`@Q\x7Fv#\xD3W\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\xAB\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[_a\x13\xC6\x85_\x01Q\x8D\x8C\x8C\x8C\x8Ca0\x15V[\x90P\x7F6b\xEC1mv\xE6\xA7^\xB7\xC4P\x01\xA8\xADt\xC3\xEB\x94>\x87x\x11\x1C\x02%\xF2\xA9\xFD^\0\xE6\x85\x82`@Qa\x13\xF9\x92\x91\x90ah\x05V[`@Q\x80\x91\x03\x90\xA1a\x14\x10\x86_\x01\x82_\x01Qa9cV[\x8A\x15a\x14\xA0W\x8C\x86`\x06\x01_\x83_\x01Q\x81R` \x01\x90\x81R` \x01_ \x81\x90UP_\x86`\x05\x01TCa\x14B\x91\x90ahgV[\x90P\x80\x87`\x12\x01_\x84_\x01Q\x81R` \x01\x90\x81R` \x01_ \x81\x90UP\x7F]\xC6\x01\x06Z\x03]x0\\\xD9\xEF'\xC9\x1A\0\x9C\xD8\xD3r\x97\xE4;\xB7c\x19I\x08\x95\xA0\xD0X\x86\x83\x83`@Qa\x14\x92\x93\x92\x91\x90ah\x9AV[`@Q\x80\x91\x03\x90\xA1Pa\x14\xABV[a\x14\xAA\x81\x8Ea/\x0BV[[PPPPPPPPPPPPPV[a\x14\xC2a/\x8EV[a\x14\xCAa:0V[_a\x14\xD3a\x08\xA8V[\x90Pa\x14\xE8\x81_\x01Q\x83\x83`\x80\x01QQa:qV[\x7F\xE4\x18\x02\xAFrW)\xAD\xCB\x8C\x15\x1E)78\n%\xC6\x91Uu~:\xF5\xD3\x97\x9A\xDA\xB5\x03X\0\x82`@Qa\x15\x17\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1PPV[a\x15+a/\x8EV[a\x153a;\x1AV[V[_\x80a\x15?a+\xE7V[\x90P\x80_\x01`\x03\x01T\x91PP\x90V[_\x80a\x15Xa+\xE7V[\x90P\x80`\x05\x01T\x91PP\x90V[_\x80a\x15oa+\xE7V[\x90Pa\x15}\x81_\x01\x84a;\x88V[\x91PP\x91\x90PV[a\x15\x8Da;\xB0V[a\x15\x96\x82a<\x96V[a\x15\xA0\x82\x82a<\xA1V[PPV[_a\x15\xADa=\xBFV[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x90P\x90V[_\x80a\x15\xDFa>FV[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x91PP\x90V[_\x81_a\x16\x02a+\xE7V[\x90P_\x81`\x08\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a\x16]W\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x16T\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[_a\x16fa+\xE7V[\x90P\x80`\x16\x01_\x86\x81R` \x01\x90\x81R` \x01_ T\x93PPPP\x91\x90PV[a\x16\x8Ea/\x8EV[a\x16\x97_a>mV[V[``_a\x16\xA4a\x155V[\x90P_a\x16\xAFa+\xE7V[\x90P\x80`\x10\x01_\x83\x81R` \x01\x90\x81R` \x01_ \x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x17AW` \x02\x82\x01\x91\x90_R` _ \x90[\x81_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x16\xF8W[PPPPP\x92PPP\x90V[_a\x17Va>\xAAV[\x90P\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x17wa\"\xDFV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x17\xCFW\x80`@Q\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x17\xC6\x91\x90aa\x1EV[`@Q\x80\x91\x03\x90\xFD[a\x17\xD8\x81a>mV[PV[``_a\x17\xE6a\x155V[\x90P_a\x17\xF1a+\xE7V[\x90P\x80`\x11\x01_\x83\x81R` \x01\x90\x81R` \x01_ \x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x18\x83W` \x02\x82\x01\x91\x90_R` _ \x90[\x81_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x18:W[PPPPP\x92PPP\x90V[a\x18\x97a\x1C\xC5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15\x80\x15a\x19~WPs\xC7\xD4Va\xA3E\xEC\\\xA0\xE8R\x1C\xFE\xF7\xE3/\xDA\r\xAAhs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cp\x08\xB5H`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x19*W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x19N\x91\x90ah\xF1V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15a\x19\xC0W3`@Q\x7FF\xC0\xD9\xAF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x19\xB7\x91\x90aa\x1EV[`@Q\x80\x91\x03\x90\xFD[a\x19\xC8a>\xB1V[V[_``\x80_\x80_``_a\x19\xDCa? V[\x90P_\x80\x1B\x81_\x01T\x14\x80\x15a\x19\xF7WP_\x80\x1B\x81`\x01\x01T\x14[a\x1A6W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1A-\x90aifV[`@Q\x80\x91\x03\x90\xFD[a\x1A>a?GV[a\x1AFa?\xE5V[F0_\x80\x1B_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1AeWa\x1Ada]\x0CV[[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x1A\x93W\x81` \x01` \x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x7F\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x95\x94\x93\x92\x91\x90\x97P\x97P\x97P\x97P\x97P\x97P\x97PP\x90\x91\x92\x93\x94\x95\x96V[a\x1A\xDBa:0V[_a\x1A\xE4a+\xE7V[\x90P_\x81_\x01`\x01\x01T\x90P_\x81\x14a\x1B\x8DW\x81`\x12\x01_\x82\x81R` \x01\x90\x81R` \x01_ TC\x11\x15a\x1B\x8CW~\x9F\xE8\xF0\xDBE\x99m\xEC\xF7\xB0o\xC7\xB6\xEC_\x88}_\x04\xDB.\x0CJ\xD7\xF4\xE4\xEE^\xEF\xC5\xA3\x81`@Qa\x1B@\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1a\x1BT\x82_\x01\x82a@\x83V[\x7F>\x8F\x02\xDCz\xF6\xE3\xA6\x7F:\xF0\xBC\x99\xBC\xF1\x1BM\xEBF\x10^\x9B\xA7\xF1\xACm\xA8#\"\xE9\x02^\x81`@Qa\x1B\x83\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1[[_\x82_\x01`\x02\x01T\x90P_\x81\x14a\x1CMW\x82`\x13\x01_\x82\x81R` \x01\x90\x81R` \x01_ TC\x11\x15a\x1CLW_a\x1B\xC2a\x155V[\x90Pa\x1B\xD0\x84_\x01\x82aAPV[\x7F\x85\x1A\x08\xC1k\x15\x95\x9C3\x8A\xC4\xB5df\xD0l\x9F\x9D_\xF8\xD7\x15\x16\x8A\xA1%\xD5\xCC\xAFS\x83 \x81`@Qa\x1B\xFF\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1a\x1C\x13\x84_\x01\x83aB&V[\x7FOT\xA6\xAC\x98\x1C\xC8\xDC\x83\x14+>\xB4\xD1 \xBE|p\xFC]\xE6Gz\x14\xEA\xE3\xE9\xCAdvD\xBC\x82`@Qa\x1CB\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1P[[_a\x1CVa\x08\x14V[\x90P_\x81\x14a\x1C\xBFW\x83`\x14\x01_\x82\x81R` \x01\x90\x81R` \x01_ TC\x11\x15a\x1C\xBEWa\x1C\x86\x84_\x01\x82aC!V[\x7F\x8F\xB7XX\xA5e\xAE\xE1\x174-\x93\x19j\x7F\x0BT\xC1\xC8Q\x98\x85\xED\xDD\xA6\xA0\x1FGsY\xB3c\x81`@Qa\x1C\xB5\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1[[PPPPV[_\x80a\x1C\xCFaD#V[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x90V[a\x1D\x02a/\x8EV[\x80_a\x1D\x0Ca+\xE7V[\x90P_\x81`\x08\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a\x1DgW\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1D^\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[_a\x1Dpa+\xE7V[\x90Pa\x1D~\x81_\x01\x85aDJV[\x15a\x1D\xC0W\x83`@Q\x7Fw\xD0^\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1D\xB7\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[a\x1D\xCC\x81_\x01\x85aD\x99V[\x7F\xBC\x11\x14\xFA\x9Awd\x8C\xD0\x97\xEEl\xF1I\xC3D\xFA'\x8B\x9B\x98?0\xDDe\xB6\xFDj\x9DFJ\x07\x84`@Qa\x1D\xFB\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1PPPPV[`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x81V[_\x81_a\x1EMa+\xE7V[\x90P_\x81`\x08\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a\x1E\xA8W\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1E\x9F\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[_a\x1E\xB1a+\xE7V[\x90P\x80`\x15\x01_\x86\x81R` \x01\x90\x81R` \x01_ T\x93PPPP\x91\x90PV[a\x1E\xD9a/\x8EV[\x80_a\x1E\xE3a+\xE7V[\x90P_\x81`\x08\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a\x1F>W\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1F5\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[_a\x1FGa+\xE7V[\x90Pa\x1FU\x81_\x01\x85aDJV[\x15a\x1F\x97W\x83`@Q\x7F\xB2^N\xB3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1F\x8E\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[a\x1F\xA3\x81_\x01\x85a@\x83V[\x7F>\x8F\x02\xDCz\xF6\xE3\xA6\x7F:\xF0\xBC\x99\xBC\xF1\x1BM\xEBF\x10^\x9B\xA7\xF1\xACm\xA8#\"\xE9\x02^\x84`@Qa\x1F\xD2\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1PPPPV[a\x1F\xE8a/\x8EV[a\x1F\xF0a:0V[_a\x1F\xF9a+\xE7V[\x90P\x81\x81`\x07\x01\x81\x90UP\x7F:\xD5\xC2'$\xAF\xAB\x8E\xD2\xB5x\xFB\x9B\x16\x0C\x7Fe\xF5\xAB\xD0\xAA\xD1\x05u+{\xA4\xE0h\xA3\xE0!\x82`@Qa 3\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1PPV[_\x80a Ia+\xE7V[\x90P\x80`\x07\x01T\x91PP\x90V[\x81_a `a+\xE7V[\x90P_\x81`\x08\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a \xBBW\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a \xB2\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[_a \xC4a+\xE7V[\x90P\x80`\x0E\x01_\x86\x81R` \x01\x90\x81R` \x01_ _\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a!dW\x84\x84`@Q\x7F\xFD\xF8\xA0]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a![\x92\x91\x90ai\x84V[`@Q\x80\x91\x03\x90\xFD[PPPPPV[\x81_a!ua+\xE7V[\x90P_\x81`\x08\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a!\xD0W\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a!\xC7\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[_a!\xD9a+\xE7V[\x90P\x80`\x0F\x01_\x86\x81R` \x01\x90\x81R` \x01_ _\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\"yW\x84\x84`@Q\x7F\x89\xB4^]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\"p\x92\x91\x90ai\x84V[`@Q\x80\x91\x03\x90\xFD[PPPPPV[a\"\x88a/\x8EV[a\"\x90a:0V[_a\"\x99a+\xE7V[\x90P\x81\x81`\x05\x01\x81\x90UP\x7FS\xCB\x96\x8D1\xC2\x8Ce\x04\xA6\xE7=\x99\x08\xDBn\x1C\x1A8kf\xDC\xAC\xEC\x1A\x01\x17u,Z\xB9\x86\x82`@Qa\"\xD3\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1PPV[_\x80a\"\xE9aE\xAEV[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x90V[a#\x1CaU,V[_a#%a\x155V[\x90P_a#0a+\xE7V[\x90P_\x81`\r\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `@Q\x80a\x01\0\x01`@R\x90\x81_\x82\x01\x80Ta#\x9C\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta#\xC8\x90ae:V[\x80\x15a$\x13W\x80`\x1F\x10a#\xEAWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a$\x13V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a#\xF6W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80Ta$\xE0\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta%\x0C\x90ae:V[\x80\x15a%WW\x80`\x1F\x10a%.Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a%WV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a%:W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta%p\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta%\x9C\x90ae:V[\x80\x15a%\xE7W\x80`\x1F\x10a%\xBEWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a%\xE7V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a%\xCAW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x06\x82\x01\x80Ta&\0\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta&,\x90ae:V[\x80\x15a&wW\x80`\x1F\x10a&NWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a&wV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a&ZW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x07\x82\x01\x80Ta&\x90\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta&\xBC\x90ae:V[\x80\x15a'\x07W\x80`\x1F\x10a&\xDEWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a'\x07V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a&\xEAW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x90P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81`@\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a'\x88W\x82\x85`@Q\x7F\x04\x94\xD3\xC0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a'\x7F\x92\x91\x90ai\x84V[`@Q\x80\x91\x03\x90\xFD[\x80\x93PPPP\x91\x90PV[``a'\x9Da\x08\xA8V[`\x80\x01Q\x90P\x90V[a'\xAEa/\x8EV[a'\xB6a:0V[_a'\xBFa\x08\xA8V[\x90Pa'\xD4\x81_\x01Q\x83\x83`\x80\x01QQaE\xD5V[\x7F\x83~\ne(\xDA\xDF\xA2\xDCy&\x92\xC5\x18.R\xA9\xF5\xBB\xDE\xED{#r\x92z&\xC6\x95\x83\x96\x13\x82`@Qa(\x03\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1PPV[`\x02_a(\x1AaF~V[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a(bWP\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15[\x15a(\x99W`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPa)R`@Q\x80`@\x01`@R\x80`\x0B\x81R` \x01\x7FKmsContexts\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP`@Q\x80`@\x01`@R\x80`\x01\x81R` \x01\x7F1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPaF\xA5V[a)ba)]a\x1C\xC5V[aF\xBBV[a)jaF\xCFV[_a)y_\x88\x88\x88\x88\x8Ea0\x15V[\x90P_a)\x84a+\xE7V[\x90Pa)\x95\x81_\x01\x83_\x01QaB&V[a)\xA2\x89\x83_\x01QaF\xE1V[\x7F\x01n\xE9\xC1b\x13\xEDg\xF32\"\xAB\xADM\xFEF\xEB\x95\x1E\xAD0\xA1\n\x1Ar\xDB3\x16\xFF\xB6d\xE0\x8A\x8A\x8A\x8A\x8A\x8A`@Qa)\xDB\x96\x95\x94\x93\x92\x91\x90amxV[`@Q\x80\x91\x03\x90\xA1PP_\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x82`@Qa*/\x91\x90am\xF5V[`@Q\x80\x91\x03\x90\xA1PPPPPPPPV[a*Ia/\x8EV[_a*Ra+\xE7V[\x90P_a*]a\x08\x14V[\x90P_\x81\x03a*\x98W`@Q\x7F ~\xA3\xF3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a*\xA1a\x155V[\x90Pa*\xAF\x83_\x01\x82aC!V[\x7F\x8F\xB7XX\xA5e\xAE\xE1\x174-\x93\x19j\x7F\x0BT\xC1\xC8Q\x98\x85\xED\xDD\xA6\xA0\x1FGsY\xB3c\x81`@Qa*\xDE\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1a*\xF2\x83_\x01\x83aB&V[\x7FOT\xA6\xAC\x98\x1C\xC8\xDC\x83\x14+>\xB4\xD1 \xBE|p\xFC]\xE6Gz\x14\xEA\xE3\xE9\xCAdvD\xBC\x82`@Qa+!\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xA1PPPV[a+6a/\x8EV[_a+?aE\xAEV[\x90P\x81\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a+\xA1a\x1C\xC5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F8\xD1k\x8C\xAC\"\xD9\x9F\xC7\xC1$\xB9\xCD\r\xE2\xD3\xFA\x1F\xAE\xF4 \xBF\xE7\x91\xD8\xC3b\xD7e\xE2'\0`@Q`@Q\x80\x91\x03\x90\xA3PPV[_\x7F}\x81Y\x81\n~\xBF\x94N\x8F\xA9<\xC4\xFB\xD1\xCA\xDElq\xF8\xB0\xB8k7\x18z\xC7\x99\x17w\xB1\0\x90P\x90V[``_`\x01a,\x1C\x84aG&V[\x01\x90P_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a,:Wa,9a]\x0CV[[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a,lW\x81` \x01`\x01\x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x90P_\x82` \x01\x82\x01\x90P[`\x01\x15a,\xCDW\x80\x80`\x01\x90\x03\x91PP\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\n\x86\x06\x1A\x81S`\n\x85\x81a,\xC2Wa,\xC1an\x0EV[[\x04\x94P_\x85\x03a,yW[\x81\x93PPPP\x91\x90PV[_`\x01`\x07\x81\x11\x15a,\xEDWa,\xECa\\RV[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15a-\x1EWa-\x1Da\\RV[[\x14\x90P\x92\x91PPV[_a-{`@Q\x80``\x01`@R\x80`+\x81R` \x01au\xF9`+\x919\x80Q\x90` \x01 \x83_\x01Q`@Q` \x01a-`\x92\x91\x90an;V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 aHwV[\x90P\x91\x90PV[_a-\x8Ba+\xE7V[\x90P_a-\xDB\x85\x85\x85\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x81\x84\x01R`\x1F\x19`\x1F\x82\x01\x16\x90P\x80\x83\x01\x92PPPPPPPaH\x90V[\x90Pa-\xE7\x86\x82a!kV[\x81`\n\x01_\x87\x81R` \x01\x90\x81R` \x01_ _\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a.\x86W\x85\x81`@Q\x7F\x99\xB1X\xC1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a.}\x92\x91\x90ai\x84V[`@Q\x80\x91\x03\x90\xFD[`\x01\x82`\n\x01_\x88\x81R` \x01\x90\x81R` \x01_ _\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPPPPPPPV[_\x80\x83`\x80\x01QQ\x90P\x80\x83\x10\x15\x91PP\x92\x91PPV[_a/\x14a+\xE7V[\x90Pa/%\x81_\x01\x84_\x01QaH\xBAV[_\x82Ca/2\x91\x90ahgV[\x90P\x80\x82`\x13\x01_\x86_\x01Q\x81R` \x01\x90\x81R` \x01_ \x81\x90UP\x7FE@\xF7\x80\x8F\xCA\xEC\x86\xC3v\xA8\x9D,\x0C\x93\xA5\x05l!h\r\xB5C2\xC7\xF2\x95\x9D\x87\xFE\xFC\x8B\x84\x82`@Qa/\x80\x92\x91\x90anbV[`@Q\x80\x91\x03\x90\xA1PPPPV[a/\x96a>\xAAV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a/\xB4a\x1C\xC5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a0\x13Wa/\xD7a>\xAAV[`@Q\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a0\n\x91\x90aa\x1EV[`@Q\x80\x91\x03\x90\xFD[V[a0\x1DaT\xE6V[_a0&a+\xE7V[\x90P_\x85\x85\x90P\x03a0dW`@Q\x7F\x06\x8C\x8D@\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80`\t\x01_\x81T\x80\x92\x91\x90a0x\x90an\x90V[\x91\x90PUP_\x81`\t\x01T\x90P\x80\x82`\x08\x01_\x83\x81R` \x01\x90\x81R` \x01_ _\x01\x81\x90UP\x88\x82`\x08\x01_\x83\x81R` \x01\x90\x81R` \x01_ `\x01\x01\x81\x90UP\x87\x82`\x08\x01_\x83\x81R` \x01\x90\x81R` \x01_ `\x02\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83`\xC0\x1C\x02\x17\x90UPa0\xFD\x81\x88\x88\x88\x90PaI\x90V[_[\x86\x86\x90P\x81\x10\x15a1\x86W\x82`\x08\x01_\x83\x81R` \x01\x90\x81R` \x01_ `\x04\x01\x87\x87\x83\x81\x81\x10a13Wa12an\xD7V[[\x90P` \x02\x81\x01\x90a1E\x91\x90ao\x10V[\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x08\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a1w\x91\x90as\x92V[PP\x80\x80`\x01\x01\x91PPa0\xFFV[P_[\x86\x86\x90P\x81\x10\x15a4\xDFW\x86\x86\x82\x81\x81\x10a1\xA7Wa1\xA6an\xD7V[[\x90P` \x02\x81\x01\x90a1\xB9\x91\x90ao\x10V[\x83`\r\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x89\x89\x85\x81\x81\x10a1\xE0Wa1\xDFan\xD7V[[\x90P` \x02\x81\x01\x90a1\xF2\x91\x90ao\x10V[`@\x01` \x81\x01\x90a2\x04\x91\x90aauV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ \x81\x81a2I\x91\x90as\x92V[\x90PP`\x01\x83`\x0E\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x89\x89\x85\x81\x81\x10a2uWa2tan\xD7V[[\x90P` \x02\x81\x01\x90a2\x87\x91\x90ao\x10V[`@\x01` \x81\x01\x90a2\x99\x91\x90aauV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x82`\x10\x01_\x83\x81R` \x01\x90\x81R` \x01_ \x87\x87\x83\x81\x81\x10a3\x0EWa3\ran\xD7V[[\x90P` \x02\x81\x01\x90a3 \x91\x90ao\x10V[`@\x01` \x81\x01\x90a32\x91\x90aauV[\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x83`\x0F\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x89\x89\x85\x81\x81\x10a3\xB8Wa3\xB7an\xD7V[[\x90P` \x02\x81\x01\x90a3\xCA\x91\x90ao\x10V[` \x01` \x81\x01\x90a3\xDC\x91\x90aauV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x82`\x11\x01_\x83\x81R` \x01\x90\x81R` \x01_ \x87\x87\x83\x81\x81\x10a4QWa4Pan\xD7V[[\x90P` \x02\x81\x01\x90a4c\x91\x90ao\x10V[` \x01` \x81\x01\x90a4u\x91\x90aauV[\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x80\x80`\x01\x01\x91PPa1\x89V[Pa4\xEE\x81\x85\x88\x88\x90PaJ\x04V[\x81`\x08\x01_\x82\x81R` \x01\x90\x81R` \x01_ `@Q\x80`\xA0\x01`@R\x90\x81_\x82\x01T\x81R` \x01`\x01\x82\x01T\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04`\xC0\x1Bw\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01_\x90[\x82\x82\x10\x15a9MW\x83\x82\x90_R` _ \x90`\x08\x02\x01`@Q\x80a\x01\0\x01`@R\x90\x81_\x82\x01\x80Ta5\xCA\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta5\xF6\x90ae:V[\x80\x15a6AW\x80`\x1F\x10a6\x18Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a6AV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a6$W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80Ta7\x0E\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta7:\x90ae:V[\x80\x15a7\x85W\x80`\x1F\x10a7\\Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a7\x85V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a7hW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta7\x9E\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta7\xCA\x90ae:V[\x80\x15a8\x15W\x80`\x1F\x10a7\xECWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a8\x15V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a7\xF8W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x06\x82\x01\x80Ta8.\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta8Z\x90ae:V[\x80\x15a8\xA5W\x80`\x1F\x10a8|Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a8\xA5V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a8\x88W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x07\x82\x01\x80Ta8\xBE\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta8\xEA\x90ae:V[\x80\x15a95W\x80`\x1F\x10a9\x0CWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a95V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a9\x18W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x81R` \x01\x90`\x01\x01\x90a5\x99V[PPPP\x81RPP\x92PPP\x96\x95PPPPPPV[\x80_\x81\x03a9\x9DW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a9\xA7\x83\x83aJ&V[a9\xE8W\x81`@Q\x7FfS\xF6\xD7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a9\xDF\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[`\x01\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15a:\x1DWa:\x1Ca\\RV[[\x02\x17\x90UP\x81\x83`\x01\x01\x81\x90UPPPPV[a:8a\x15\xD5V[\x15a:oW`@Q\x7F\xD9<\x06e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_a:za+\xE7V[\x90P_\x83\x03a:\xB5W`@Q\x7F\xB1\xAE\x92\xEA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x83\x11\x15a:\xFCW\x82\x82`@Q\x7F\x84 \x8F#\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a:\xF3\x92\x91\x90ag\xDEV[`@Q\x80\x91\x03\x90\xFD[\x82\x81`\x15\x01_\x86\x81R` \x01\x90\x81R` \x01_ \x81\x90UPPPPPV[a;\"aJtV[_a;+a>FV[\x90P_\x81_\x01_a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAAa;pa>\xAAV[`@Qa;}\x91\x90aa\x1EV[`@Q\x80\x91\x03\x90\xA1PV[_\x82_\x01_\x83\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x90P\x92\x91PPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x80a<]WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a<DaJ\xB4V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15a<\x94W`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[a<\x9Ea/\x8EV[PV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cR\xD1\x90-`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15a=\tWP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a=\x06\x91\x90as\xCAV[`\x01[a=JW\x81`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a=A\x91\x90aa\x1EV[`@Q\x80\x91\x03\x90\xFD[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x81\x14a=\xB0W\x80`@Q\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a=\xA7\x91\x90a^\xA2V[`@Q\x80\x91\x03\x90\xFD[a=\xBA\x83\x83aK\x07V[PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a>DW`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_\x7F\xCD^\xD1\\n\x18~w\xE9\xAE\xE8\x81\x84\xC2\x1FO!\x82\xABX'\xCB;~\x07\xFB\xED\xCDc\xF03\0\x90P\x90V[_a>vaE\xAEV[\x90P\x80_\x01_a\x01\0\n\x81T\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90Ua>\xA6\x82aKyV[PPV[_3\x90P\x90V[a>\xB9a:0V[_a>\xC2a>FV[\x90P`\x01\x81_\x01_a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2Xa?\x08a>\xAAV[`@Qa?\x15\x91\x90aa\x1EV[`@Q\x80\x91\x03\x90\xA1PV[_\x7F\xA1jF\xD9Ba\xC7Q|\xC8\xFF\x89\xF6\x1C\x0C\xE95\x98\xE3\xC8I\x80\x10\x11\xDE\xE6I\xA6\xA5W\xD1\0\x90P\x90V[``_a?Ra? V[\x90P\x80`\x02\x01\x80Ta?c\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta?\x8F\x90ae:V[\x80\x15a?\xDAW\x80`\x1F\x10a?\xB1Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a?\xDAV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a?\xBDW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x91PP\x90V[``_a?\xF0a? V[\x90P\x80`\x03\x01\x80Ta@\x01\x90ae:V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta@-\x90ae:V[\x80\x15a@xW\x80`\x1F\x10a@OWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a@xV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a@[W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x91PP\x90V[\x80_\x81\x03a@\xBDW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x07\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15a@\xF2Wa@\xF1a\\RV[[\x02\x17\x90UP\x81\x83`\x01\x01T\x03aA\x0CW_\x83`\x01\x01\x81\x90UP[\x81\x83`\x02\x01T\x03aA!W_\x83`\x02\x01\x81\x90UP[\x81\x83`\x03\x01T\x03aA6W_\x83`\x03\x01\x81\x90UP[\x81\x83`\x04\x01T\x03aAKW_\x83`\x04\x01\x81\x90UP[PPPV[\x80_\x81\x03aA\x8AW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aA\x94\x83\x83aDJV[aA\xD5W\x81`@Q\x7F3\x14\x86\xB3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aA\xCC\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[`\x04\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aB\nWaB\ta\\RV[[\x02\x17\x90UP\x81\x83`\x04\x01\x81\x90UP_\x83`\x03\x01\x81\x90UPPPPV[\x80_\x81\x03aB`W`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aBj\x83\x83aLJV[\x15\x80\x15aB~WPaB|\x83\x83aL\x99V[\x15[\x80\x15aB\x8EWP_\x83`\x03\x01T\x14\x15[\x15aB\xD0W\x81`@Q\x7F\x12\xB4\x9E=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aB\xC7\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[`\x03\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aC\x05WaC\x04a\\RV[[\x02\x17\x90UP\x81\x83`\x03\x01\x81\x90UP_\x83`\x02\x01\x81\x90UPPPPV[\x80_\x81\x03aC[W`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aCe\x83\x83aDJV[\x15\x80aCxWPaCv\x83\x83aL\x99V[\x15[\x15aC\xBAW\x81`@Q\x7F+6R\xD1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aC\xB1\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[`\x05\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aC\xEFWaC\xEEa\\RV[[\x02\x17\x90UP\x81\x83`\x03\x01T\x03aD\tW_\x83`\x03\x01\x81\x90UP[\x81\x83`\x04\x01T\x03aD\x1EW_\x83`\x04\x01\x81\x90UP[PPPV[_\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0\x90P\x90V[_`\x03`\x07\x81\x11\x15aD_WaD^a\\RV[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15aD\x90WaD\x8Fa\\RV[[\x14\x90P\x92\x91PPV[\x80_\x81\x03aD\xD3W`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aD\xDD\x83\x83aJ&V[\x80aD\xEEWPaD\xED\x83\x83a,\xD8V[[\x15aE0W\x81`@Q\x7F\xB0\xC5\x15\x1D\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aE'\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[`\x06\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aEeWaEda\\RV[[\x02\x17\x90UP\x81\x83`\x02\x01T\x03aE\x7FW_\x83`\x02\x01\x81\x90UP[\x81\x83`\x03\x01T\x03aE\x94W_\x83`\x03\x01\x81\x90UP[\x81\x83`\x04\x01T\x03aE\xA9W_\x83`\x04\x01\x81\x90UP[PPPV[_\x7F#~\x15\x82\"\xE3\xE6\x96\x8Br\xB9\xDB\r\x80C\xAA\xCF\x07J\xD9\xF6P\xF0\xD1`kM\x82\xEEC,\0\x90P\x90V[_aE\xDEa+\xE7V[\x90P_\x83\x03aF\x19W`@Q\x7F\xE6\nrq\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x83\x11\x15aF`W\x82\x82`@Q\x7F\xD2S^\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aFW\x92\x91\x90ag\xDEV[`@Q\x80\x91\x03\x90\xFD[\x82\x81`\x16\x01_\x86\x81R` \x01\x90\x81R` \x01_ \x81\x90UPPPPPV[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[aF\xADaL\xE8V[aF\xB7\x82\x82aM(V[PPV[aF\xC3aL\xE8V[aF\xCC\x81aMyV[PV[aF\xD7aL\xE8V[aF\xDFaM\xFDV[V[_aF\xEAa+\xE7V[\x90P\x82_\x015\x81`\x06\x01_\x84\x81R` \x01\x90\x81R` \x01_ \x81\x90UP\x82` \x015\x81`\x05\x01\x81\x90UP\x82`@\x015\x81`\x07\x01\x81\x90UPPPPV[_\x80_\x90Pz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x10aG\x82Wz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x81aGxWaGwan\x0EV[[\x04\x92P`@\x81\x01\x90P[m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x10aG\xBFWm\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x81aG\xB5WaG\xB4an\x0EV[[\x04\x92P` \x81\x01\x90P[f#\x86\xF2o\xC1\0\0\x83\x10aG\xEEWf#\x86\xF2o\xC1\0\0\x83\x81aG\xE4WaG\xE3an\x0EV[[\x04\x92P`\x10\x81\x01\x90P[c\x05\xF5\xE1\0\x83\x10aH\x17Wc\x05\xF5\xE1\0\x83\x81aH\rWaH\x0Can\x0EV[[\x04\x92P`\x08\x81\x01\x90P[a'\x10\x83\x10aH<Wa'\x10\x83\x81aH2WaH1an\x0EV[[\x04\x92P`\x04\x81\x01\x90P[`d\x83\x10aH_W`d\x83\x81aHUWaHTan\x0EV[[\x04\x92P`\x02\x81\x01\x90P[`\n\x83\x10aHnW`\x01\x81\x01\x90P[\x80\x91PP\x91\x90PV[_aH\x89aH\x83aN-V[\x83aN;V[\x90P\x91\x90PV[_\x80_\x80aH\x9E\x86\x86aN{V[\x92P\x92P\x92PaH\xAE\x82\x82aN\xD0V[\x82\x93PPPP\x92\x91PPV[\x80_\x81\x03aH\xF4W`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aH\xFE\x83\x83a,\xD8V[aI?W\x81`@Q\x7F\xC0\xB5\xEEf\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aI6\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[`\x02\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aItWaIsa\\RV[[\x02\x17\x90UP\x81\x83`\x02\x01\x81\x90UP_\x83`\x01\x01\x81\x90UPPPPV[_aI\x99a+\xE7V[\x90P\x81\x83\x10aI\xE3W\x83\x83\x83`@Q\x7F\x87\x89\xA6\xCA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aI\xDA\x93\x92\x91\x90as\xF5V[`@Q\x80\x91\x03\x90\xFD[\x82\x81`\x08\x01_\x86\x81R` \x01\x90\x81R` \x01_ `\x03\x01\x81\x90UPPPPPV[aJ\x12\x83\x83_\x015\x83a:qV[aJ!\x83\x83` \x015\x83aE\xD5V[PPPV[_\x80`\x07\x81\x11\x15aJ:WaJ9a\\RV[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15aJkWaJja\\RV[[\x14\x90P\x92\x91PPV[aJ|a\x15\xD5V[aJ\xB2W`@Q\x7F\x8D\xFC +\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_aJ\xE0\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1BaP2V[_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[aK\x10\x82aP;V[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;`@Q`@Q\x80\x91\x03\x90\xA2_\x81Q\x11\x15aKlWaKf\x82\x82aQ\x04V[PaKuV[aKtaQ\x84V[[PPV[_aK\x82aD#V[\x90P_\x81_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x82\x82_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPPV[_`\x02`\x07\x81\x11\x15aL_WaL^a\\RV[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15aL\x90WaL\x8Fa\\RV[[\x14\x90P\x92\x91PPV[_`\x04`\x07\x81\x11\x15aL\xAEWaL\xADa\\RV[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15aL\xDFWaL\xDEa\\RV[[\x14\x90P\x92\x91PPV[aL\xF0aQ\xC0V[aM&W`@Q\x7F\xD7\xE6\xBC\xF8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[aM0aL\xE8V[_aM9a? V[\x90P\x82\x81`\x02\x01\x90\x81aML\x91\x90at*V[P\x81\x81`\x03\x01\x90\x81aM^\x91\x90at*V[P_\x80\x1B\x81_\x01\x81\x90UP_\x80\x1B\x81`\x01\x01\x81\x90UPPPPV[aM\x81aL\xE8V[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03aM\xF1W_`@Q\x7F\x1EO\xBD\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aM\xE8\x91\x90aa\x1EV[`@Q\x80\x91\x03\x90\xFD[aM\xFA\x81a>mV[PV[aN\x05aL\xE8V[_aN\x0Ea>FV[\x90P_\x81_\x01_a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPPV[_aN6aQ\xDEV[\x90P\x90V[_`@Q\x7F\x19\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x83`\x02\x82\x01R\x82`\"\x82\x01R`B\x81 \x91PP\x92\x91PPV[_\x80_`A\x84Q\x03aN\xBBW_\x80_` \x87\x01Q\x92P`@\x87\x01Q\x91P``\x87\x01Q_\x1A\x90PaN\xAD\x88\x82\x85\x85aRAV[\x95P\x95P\x95PPPPaN\xC9V[_`\x02\x85Q_\x1B\x92P\x92P\x92P[\x92P\x92P\x92V[_`\x03\x81\x11\x15aN\xE3WaN\xE2a\\RV[[\x82`\x03\x81\x11\x15aN\xF6WaN\xF5a\\RV[[\x03\x15aP.W`\x01`\x03\x81\x11\x15aO\x10WaO\x0Fa\\RV[[\x82`\x03\x81\x11\x15aO#WaO\"a\\RV[[\x03aOZW`@Q\x7F\xF6E\xEE\xDF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02`\x03\x81\x11\x15aOnWaOma\\RV[[\x82`\x03\x81\x11\x15aO\x81WaO\x80a\\RV[[\x03aO\xC5W\x80_\x1C`@Q\x7F\xFC\xE6\x98\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aO\xBC\x91\x90aU\xB2V[`@Q\x80\x91\x03\x90\xFD[`\x03\x80\x81\x11\x15aO\xD8WaO\xD7a\\RV[[\x82`\x03\x81\x11\x15aO\xEBWaO\xEAa\\RV[[\x03aP-W\x80`@Q\x7F\xD7\x8B\xCE\x0C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aP$\x91\x90a^\xA2V[`@Q\x80\x91\x03\x90\xFD[[PPV[_\x81\x90P\x91\x90PV[_\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x03aP\x96W\x80`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aP\x8D\x91\x90aa\x1EV[`@Q\x80\x91\x03\x90\xFD[\x80aP\xC2\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1BaP2V[_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[``_\x80\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84`@QaQ-\x91\x90au3V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14aQeW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>aQjV[``\x91P[P\x91P\x91PaQz\x85\x83\x83aS(V[\x92PPP\x92\x91PPV[_4\x11\x15aQ\xBEW`@Q\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_aQ\xC9aF~V[_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x90P\x90V[_\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0FaR\x08aS\xB5V[aR\x10aT+V[F0`@Q` \x01aR&\x95\x94\x93\x92\x91\x90auIV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x90V[_\x80_\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0\x84_\x1C\x11\x15aR}W_`\x03\x85\x92P\x92P\x92PaS\x1EV[_`\x01\x88\x88\x88\x88`@Q_\x81R` \x01`@R`@QaR\xA0\x94\x93\x92\x91\x90au\xB5V[` `@Q` \x81\x03\x90\x80\x84\x03\x90\x85Z\xFA\x15\x80\x15aR\xC0W=_\x80>=_\xFD[PPP` `@Q\x03Q\x90P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03aS\x11W_`\x01_\x80\x1B\x93P\x93P\x93PPaS\x1EV[\x80_\x80_\x1B\x93P\x93P\x93PP[\x94P\x94P\x94\x91PPV[``\x82aS=WaS8\x82aT\xA2V[aS\xADV[_\x82Q\x14\x80\x15aScWP_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x14[\x15aS\xA5W\x83`@Q\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aS\x9C\x91\x90aa\x1EV[`@Q\x80\x91\x03\x90\xFD[\x81\x90PaS\xAEV[[\x93\x92PPPV[_\x80aS\xBFa? V[\x90P_aS\xCAa?GV[\x90P_\x81Q\x11\x15aS\xE6W\x80\x80Q\x90` \x01 \x92PPPaT(V[_\x82_\x01T\x90P_\x80\x1B\x81\x14aT\x01W\x80\x93PPPPaT(V[\x7F\xC5\xD2F\x01\x86\xF7#<\x92~}\xB2\xDC\xC7\x03\xC0\xE5\0\xB6S\xCA\x82';{\xFA\xD8\x04]\x85\xA4p\x93PPPP[\x90V[_\x80aT5a? V[\x90P_aT@a?\xE5V[\x90P_\x81Q\x11\x15aT\\W\x80\x80Q\x90` \x01 \x92PPPaT\x9FV[_\x82`\x01\x01T\x90P_\x80\x1B\x81\x14aTxW\x80\x93PPPPaT\x9FV[\x7F\xC5\xD2F\x01\x86\xF7#<\x92~}\xB2\xDC\xC7\x03\xC0\xE5\0\xB6S\xCA\x82';{\xFA\xD8\x04]\x85\xA4p\x93PPPP[\x90V[_\x81Q\x11\x15aT\xB4W\x80Q\x80\x82` \x01\xFD[`@Q\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Q\x80`\xA0\x01`@R\x80_\x81R` \x01_\x81R` \x01_w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01_\x81R` \x01``\x81RP\x90V[`@Q\x80a\x01\0\x01`@R\x80``\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_\x81R` \x01``\x81R` \x01``\x81R` \x01``\x81R` \x01``\x81RP\x90V[_\x81\x90P\x91\x90PV[aU\xAC\x81aU\x9AV[\x82RPPV[_` \x82\x01\x90PaU\xC5_\x83\x01\x84aU\xA3V[\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_[\x83\x81\x10\x15aV\x02W\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90PaU\xE7V[_\x84\x84\x01RPPPPV[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[_aV'\x82aU\xCBV[aV1\x81\x85aU\xD5V[\x93PaVA\x81\x85` \x86\x01aU\xE5V[aVJ\x81aV\rV[\x84\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01RaVm\x81\x84aV\x1DV[\x90P\x92\x91PPV[aV~\x81aU\x9AV[\x82RPPV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[aV\xB8\x81aV\x84V[\x82RPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_aW\x01\x82aU\xCBV[aW\x0B\x81\x85aV\xE7V[\x93PaW\x1B\x81\x85` \x86\x01aU\xE5V[aW$\x81aV\rV[\x84\x01\x91PP\x92\x91PPV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_aWX\x82aW/V[\x90P\x91\x90PV[aWh\x81aWNV[\x82RPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_aW\x92\x82aWnV[aW\x9C\x81\x85aWxV[\x93PaW\xAC\x81\x85` \x86\x01aU\xE5V[aW\xB5\x81aV\rV[\x84\x01\x91PP\x92\x91PPV[_a\x01\0\x83\x01_\x83\x01Q\x84\x82\x03_\x86\x01RaW\xDB\x82\x82aV\xF7V[\x91PP` \x83\x01QaW\xF0` \x86\x01\x82aW_V[P`@\x83\x01QaX\x03`@\x86\x01\x82aW_V[P``\x83\x01QaX\x16``\x86\x01\x82aVuV[P`\x80\x83\x01Q\x84\x82\x03`\x80\x86\x01RaX.\x82\x82aW\x88V[\x91PP`\xA0\x83\x01Q\x84\x82\x03`\xA0\x86\x01RaXH\x82\x82aV\xF7V[\x91PP`\xC0\x83\x01Q\x84\x82\x03`\xC0\x86\x01RaXb\x82\x82aV\xF7V[\x91PP`\xE0\x83\x01Q\x84\x82\x03`\xE0\x86\x01RaX|\x82\x82aW\x88V[\x91PP\x80\x91PP\x92\x91PPV[_aX\x94\x83\x83aW\xC0V[\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_aX\xB2\x82aV\xBEV[aX\xBC\x81\x85aV\xC8V[\x93P\x83` \x82\x02\x85\x01aX\xCE\x85aV\xD8V[\x80_[\x85\x81\x10\x15aY\tW\x84\x84\x03\x89R\x81QaX\xEA\x85\x82aX\x89V[\x94PaX\xF5\x83aX\x9CV[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90PaX\xD1V[P\x82\x97P\x87\x95PPPPPP\x92\x91PPV[_`\xA0\x83\x01_\x83\x01QaY0_\x86\x01\x82aVuV[P` \x83\x01QaYC` \x86\x01\x82aVuV[P`@\x83\x01QaYV`@\x86\x01\x82aV\xAFV[P``\x83\x01QaYi``\x86\x01\x82aVuV[P`\x80\x83\x01Q\x84\x82\x03`\x80\x86\x01RaY\x81\x82\x82aX\xA8V[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01RaY\xA6\x81\x84aY\x1BV[\x90P\x92\x91PPV[_`@Q\x90P\x90V[_\x80\xFD[_\x80\xFD[aY\xC8\x81aU\x9AV[\x81\x14aY\xD2W_\x80\xFD[PV[_\x815\x90PaY\xE3\x81aY\xBFV[\x92\x91PPV[_\x80\xFD[_\x80\xFD[_\x80\xFD[_\x80\x83`\x1F\x84\x01\x12aZ\nWaZ\taY\xE9V[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aZ'WaZ&aY\xEDV[[` \x83\x01\x91P\x83`\x01\x82\x02\x83\x01\x11\x15aZCWaZBaY\xF1V[[\x92P\x92\x90PV[_\x80_`@\x84\x86\x03\x12\x15aZaWaZ`aY\xB7V[[_aZn\x86\x82\x87\x01aY\xD5V[\x93PP` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aZ\x8FWaZ\x8EaY\xBBV[[aZ\x9B\x86\x82\x87\x01aY\xF5V[\x92P\x92PP\x92P\x92P\x92V[aZ\xB0\x81aV\x84V[\x81\x14aZ\xBAW_\x80\xFD[PV[_\x815\x90PaZ\xCB\x81aZ\xA7V[\x92\x91PPV[_\x81\x15\x15\x90P\x91\x90PV[aZ\xE5\x81aZ\xD1V[\x81\x14aZ\xEFW_\x80\xFD[PV[_\x815\x90Pa[\0\x81aZ\xDCV[\x92\x91PPV[_\x80\x83`\x1F\x84\x01\x12a[\x1BWa[\x1AaY\xE9V[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a[8Wa[7aY\xEDV[[` \x83\x01\x91P\x83` \x82\x02\x83\x01\x11\x15a[TWa[SaY\xF1V[[\x92P\x92\x90PV[_\x80\xFD[_`@\x82\x84\x03\x12\x15a[tWa[sa[[V[[\x81\x90P\x92\x91PPV[_\x80_\x80_\x80_`\xE0\x88\x8A\x03\x12\x15a[\x98Wa[\x97aY\xB7V[[_a[\xA5\x8A\x82\x8B\x01aY\xD5V[\x97PP` a[\xB6\x8A\x82\x8B\x01aZ\xBDV[\x96PP`@a[\xC7\x8A\x82\x8B\x01aZ\xF2V[\x95PP``a[\xD8\x8A\x82\x8B\x01aY\xD5V[\x94PP`\x80\x88\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a[\xF9Wa[\xF8aY\xBBV[[a\\\x05\x8A\x82\x8B\x01a[\x06V[\x93P\x93PP`\xA0a\\\x18\x8A\x82\x8B\x01a[_V[\x91PP\x92\x95\x98\x91\x94\x97P\x92\x95PV[_` \x82\x84\x03\x12\x15a\\<Wa\\;aY\xB7V[[_a\\I\x84\x82\x85\x01aY\xD5V[\x91PP\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`!`\x04R`$_\xFD[`\x08\x81\x10a\\\x90Wa\\\x8Fa\\RV[[PV[_\x81\x90Pa\\\xA0\x82a\\\x7FV[\x91\x90PV[_a\\\xAF\x82a\\\x93V[\x90P\x91\x90PV[a\\\xBF\x81a\\\xA5V[\x82RPPV[_` \x82\x01\x90Pa\\\xD8_\x83\x01\x84a\\\xB6V[\x92\x91PPV[a\\\xE7\x81aWNV[\x81\x14a\\\xF1W_\x80\xFD[PV[_\x815\x90Pa]\x02\x81a\\\xDEV[\x92\x91PPV[_\x80\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[a]B\x82aV\rV[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a]aWa]`a]\x0CV[[\x80`@RPPPV[_a]saY\xAEV[\x90Pa]\x7F\x82\x82a]9V[\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a]\x9EWa]\x9Da]\x0CV[[a]\xA7\x82aV\rV[\x90P` \x81\x01\x90P\x91\x90PV[\x82\x81\x837_\x83\x83\x01RPPPV[_a]\xD4a]\xCF\x84a]\x84V[a]jV[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a]\xF0Wa]\xEFa]\x08V[[a]\xFB\x84\x82\x85a]\xB4V[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a^\x17Wa^\x16aY\xE9V[[\x815a^'\x84\x82` \x86\x01a]\xC2V[\x91PP\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15a^FWa^EaY\xB7V[[_a^S\x85\x82\x86\x01a\\\xF4V[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a^tWa^saY\xBBV[[a^\x80\x85\x82\x86\x01a^\x03V[\x91PP\x92P\x92\x90PV[_\x81\x90P\x91\x90PV[a^\x9C\x81a^\x8AV[\x82RPPV[_` \x82\x01\x90Pa^\xB5_\x83\x01\x84a^\x93V[\x92\x91PPV[a^\xC4\x81aZ\xD1V[\x82RPPV[_` \x82\x01\x90Pa^\xDD_\x83\x01\x84a^\xBBV[\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_a_\x17\x83\x83aW_V[` \x83\x01\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_a_9\x82a^\xE3V[a_C\x81\x85a^\xEDV[\x93Pa_N\x83a^\xFDV[\x80_[\x83\x81\x10\x15a_~W\x81Qa_e\x88\x82a_\x0CV[\x97Pa_p\x83a_#V[\x92PP`\x01\x81\x01\x90Pa_QV[P\x85\x93PPPP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra_\xA3\x81\x84a_/V[\x90P\x92\x91PPV[_\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[a_\xDF\x81a_\xABV[\x82RPPV[a_\xEE\x81aWNV[\x82RPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_a`(\x83\x83aVuV[` \x83\x01\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_a`J\x82a_\xF4V[a`T\x81\x85a_\xFEV[\x93Pa`_\x83a`\x0EV[\x80_[\x83\x81\x10\x15a`\x8FW\x81Qa`v\x88\x82a`\x1DV[\x97Pa`\x81\x83a`4V[\x92PP`\x01\x81\x01\x90Pa`bV[P\x85\x93PPPP\x92\x91PPV[_`\xE0\x82\x01\x90Pa`\xAF_\x83\x01\x8Aa_\xD6V[\x81\x81\x03` \x83\x01Ra`\xC1\x81\x89aV\x1DV[\x90P\x81\x81\x03`@\x83\x01Ra`\xD5\x81\x88aV\x1DV[\x90Pa`\xE4``\x83\x01\x87aU\xA3V[a`\xF1`\x80\x83\x01\x86a_\xE5V[a`\xFE`\xA0\x83\x01\x85a^\x93V[\x81\x81\x03`\xC0\x83\x01Raa\x10\x81\x84a`@V[\x90P\x98\x97PPPPPPPPV[_` \x82\x01\x90Paa1_\x83\x01\x84a_\xE5V[\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15aaMWaaLaY\xB7V[[_aaZ\x85\x82\x86\x01aY\xD5V[\x92PP` aak\x85\x82\x86\x01a\\\xF4V[\x91PP\x92P\x92\x90PV[_` \x82\x84\x03\x12\x15aa\x8AWaa\x89aY\xB7V[[_aa\x97\x84\x82\x85\x01a\\\xF4V[\x91PP\x92\x91PPV[_a\x01\0\x83\x01_\x83\x01Q\x84\x82\x03_\x86\x01Raa\xBB\x82\x82aV\xF7V[\x91PP` \x83\x01Qaa\xD0` \x86\x01\x82aW_V[P`@\x83\x01Qaa\xE3`@\x86\x01\x82aW_V[P``\x83\x01Qaa\xF6``\x86\x01\x82aVuV[P`\x80\x83\x01Q\x84\x82\x03`\x80\x86\x01Rab\x0E\x82\x82aW\x88V[\x91PP`\xA0\x83\x01Q\x84\x82\x03`\xA0\x86\x01Rab(\x82\x82aV\xF7V[\x91PP`\xC0\x83\x01Q\x84\x82\x03`\xC0\x86\x01RabB\x82\x82aV\xF7V[\x91PP`\xE0\x83\x01Q\x84\x82\x03`\xE0\x86\x01Rab\\\x82\x82aW\x88V[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Rab\x81\x81\x84aa\xA0V[\x90P\x92\x91PPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_ab\xA3\x82aV\xBEV[ab\xAD\x81\x85ab\x89V[\x93P\x83` \x82\x02\x85\x01ab\xBF\x85aV\xD8V[\x80_[\x85\x81\x10\x15ab\xFAW\x84\x84\x03\x89R\x81Qab\xDB\x85\x82aX\x89V[\x94Pab\xE6\x83aX\x9CV[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90Pab\xC2V[P\x82\x97P\x87\x95PPPPPP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Rac$\x81\x84ab\x99V[\x90P\x92\x91PPV[_``\x82\x84\x03\x12\x15acAWac@a[[V[[\x81\x90P\x92\x91PPV[_\x80_\x80_\x80a\x01\0\x87\x89\x03\x12\x15aceWacdaY\xB7V[[_acr\x89\x82\x8A\x01a[_V[\x96PP`@ac\x83\x89\x82\x8A\x01ac,V[\x95PP`\xA0ac\x94\x89\x82\x8A\x01aZ\xBDV[\x94PP`\xC0ac\xA5\x89\x82\x8A\x01aY\xD5V[\x93PP`\xE0\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ac\xC6Wac\xC5aY\xBBV[[ac\xD2\x89\x82\x8A\x01a[\x06V[\x92P\x92PP\x92\x95P\x92\x95P\x92\x95V[_\x81\x90P\x92\x91PPV[_ac\xF5\x82aU\xCBV[ac\xFF\x81\x85ac\xE1V[\x93Pad\x0F\x81\x85` \x86\x01aU\xE5V[\x80\x84\x01\x91PP\x92\x91PPV[\x7F v\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_adO`\x02\x83ac\xE1V[\x91PadZ\x82ad\x1BV[`\x02\x82\x01\x90P\x91\x90PV[\x7F.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_ad\x99`\x01\x83ac\xE1V[\x91Pad\xA4\x82adeV[`\x01\x82\x01\x90P\x91\x90PV[_ad\xBA\x82\x87ac\xEBV[\x91Pad\xC5\x82adCV[\x91Pad\xD1\x82\x86ac\xEBV[\x91Pad\xDC\x82ad\x8DV[\x91Pad\xE8\x82\x85ac\xEBV[\x91Pad\xF3\x82ad\x8DV[\x91Pad\xFF\x82\x84ac\xEBV[\x91P\x81\x90P\x95\x94PPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\"`\x04R`$_\xFD[_`\x02\x82\x04\x90P`\x01\x82\x16\x80aeQW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03aedWaecae\rV[[P\x91\x90PV[_\x82\x90P\x92\x91PPV[_\x81\x90P\x81_R` _ \x90P\x91\x90PV[_` `\x1F\x83\x01\x04\x90P\x91\x90PV[_\x82\x82\x1B\x90P\x92\x91PPV[_`\x08\x83\x02ae\xD0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82ae\x95V[ae\xDA\x86\x83ae\x95V[\x95P\x80\x19\x84\x16\x93P\x80\x86\x16\x84\x17\x92PPP\x93\x92PPPV[_\x81\x90P\x91\x90PV[_af\x15af\x10af\x0B\x84aU\x9AV[ae\xF2V[aU\x9AV[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[af.\x83ae\xFBV[afBaf:\x82af\x1CV[\x84\x84Tae\xA1V[\x82UPPPPV[_\x90V[afVafJV[afa\x81\x84\x84af%V[PPPV[[\x81\x81\x10\x15af\x84Wafy_\x82afNV[`\x01\x81\x01\x90PafgV[PPV[`\x1F\x82\x11\x15af\xC9Waf\x9A\x81aetV[af\xA3\x84ae\x86V[\x81\x01` \x85\x10\x15af\xB2W\x81\x90P[af\xC6af\xBE\x85ae\x86V[\x83\x01\x82affV[PP[PPPV[_\x82\x82\x1C\x90P\x92\x91PPV[_af\xE9_\x19\x84`\x08\x02af\xCEV[\x19\x80\x83\x16\x91PP\x92\x91PPV[_ag\x01\x83\x83af\xDAV[\x91P\x82`\x02\x02\x82\x17\x90P\x92\x91PPV[ag\x1B\x83\x83aejV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ag4Wag3a]\x0CV[[ag>\x82Tae:V[agI\x82\x82\x85af\x88V[_`\x1F\x83\x11`\x01\x81\x14agvW_\x84\x15agdW\x82\x87\x015\x90P[agn\x85\x82af\xF6V[\x86UPag\xD5V[`\x1F\x19\x84\x16ag\x84\x86aetV[_[\x82\x81\x10\x15ag\xABW\x84\x89\x015\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Pag\x86V[\x86\x83\x10\x15ag\xC8W\x84\x89\x015ag\xC4`\x1F\x89\x16\x82af\xDAV[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPPV[_`@\x82\x01\x90Pag\xF1_\x83\x01\x85aU\xA3V[ag\xFE` \x83\x01\x84aU\xA3V[\x93\x92PPPV[_`@\x82\x01\x90P\x81\x81\x03_\x83\x01Rah\x1D\x81\x85aY\x1BV[\x90P\x81\x81\x03` \x83\x01Rah1\x81\x84aY\x1BV[\x90P\x93\x92PPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_ahq\x82aU\x9AV[\x91Pah|\x83aU\x9AV[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15ah\x94Wah\x93ah:V[[\x92\x91PPV[_``\x82\x01\x90P\x81\x81\x03_\x83\x01Rah\xB2\x81\x86aY\x1BV[\x90P\x81\x81\x03` \x83\x01Rah\xC6\x81\x85aY\x1BV[\x90Pah\xD5`@\x83\x01\x84aU\xA3V[\x94\x93PPPPV[_\x81Q\x90Pah\xEB\x81a\\\xDEV[\x92\x91PPV[_` \x82\x84\x03\x12\x15ai\x06Wai\x05aY\xB7V[[_ai\x13\x84\x82\x85\x01ah\xDDV[\x91PP\x92\x91PPV[\x7FEIP712: Uninitialized\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_aiP`\x15\x83aU\xD5V[\x91Pai[\x82ai\x1CV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Rai}\x81aiDV[\x90P\x91\x90PV[_`@\x82\x01\x90Pai\x97_\x83\x01\x85aU\xA3V[ai\xA4` \x83\x01\x84a_\xE5V[\x93\x92PPPV[_ai\xB9` \x84\x01\x84aY\xD5V[\x90P\x92\x91PPV[`@\x82\x01ai\xD1_\x83\x01\x83ai\xABV[ai\xDD_\x85\x01\x82aVuV[Pai\xEB` \x83\x01\x83ai\xABV[ai\xF8` \x85\x01\x82aVuV[PPPPV[``\x82\x01aj\x0E_\x83\x01\x83ai\xABV[aj\x1A_\x85\x01\x82aVuV[Paj(` \x83\x01\x83ai\xABV[aj5` \x85\x01\x82aVuV[PajC`@\x83\x01\x83ai\xABV[ajP`@\x85\x01\x82aVuV[PPPPV[aj_\x81aV\x84V[\x82RPPV[_\x81\x90P\x91\x90PV[_\x80\xFD[_\x80\xFD[_\x80\xFD[_\x80\x835`\x01` \x03\x846\x03\x03\x81\x12aj\x96Waj\x95ajvV[[\x83\x81\x01\x92P\x825\x91P` \x83\x01\x92Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15aj\xBEWaj\xBDajnV[[`\x01\x82\x026\x03\x83\x13\x15aj\xD4Waj\xD3ajrV[[P\x92P\x92\x90PV[_aj\xE7\x83\x85aV\xE7V[\x93Paj\xF4\x83\x85\x84a]\xB4V[aj\xFD\x83aV\rV[\x84\x01\x90P\x93\x92PPPV[_ak\x16` \x84\x01\x84a\\\xF4V[\x90P\x92\x91PPV[_\x80\x835`\x01` \x03\x846\x03\x03\x81\x12ak:Wak9ajvV[[\x83\x81\x01\x92P\x825\x91P` \x83\x01\x92Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15akbWakaajnV[[`\x01\x82\x026\x03\x83\x13\x15akxWakwajrV[[P\x92P\x92\x90PV[_ak\x8B\x83\x85aWxV[\x93Pak\x98\x83\x85\x84a]\xB4V[ak\xA1\x83aV\rV[\x84\x01\x90P\x93\x92PPPV[_a\x01\0\x83\x01ak\xBE_\x84\x01\x84ajzV[\x85\x83\x03_\x87\x01Rak\xD0\x83\x82\x84aj\xDCV[\x92PPPak\xE1` \x84\x01\x84ak\x08V[ak\xEE` \x86\x01\x82aW_V[Pak\xFC`@\x84\x01\x84ak\x08V[al\t`@\x86\x01\x82aW_V[Pal\x17``\x84\x01\x84ai\xABV[al$``\x86\x01\x82aVuV[Pal2`\x80\x84\x01\x84ak\x1EV[\x85\x83\x03`\x80\x87\x01RalE\x83\x82\x84ak\x80V[\x92PPPalV`\xA0\x84\x01\x84ajzV[\x85\x83\x03`\xA0\x87\x01Rali\x83\x82\x84aj\xDCV[\x92PPPalz`\xC0\x84\x01\x84ajzV[\x85\x83\x03`\xC0\x87\x01Ral\x8D\x83\x82\x84aj\xDCV[\x92PPPal\x9E`\xE0\x84\x01\x84ak\x1EV[\x85\x83\x03`\xE0\x87\x01Ral\xB1\x83\x82\x84ak\x80V[\x92PPP\x80\x91PP\x92\x91PPV[_al\xCA\x83\x83ak\xACV[\x90P\x92\x91PPV[_\x825`\x01a\x01\0\x03\x836\x03\x03\x81\x12al\xEEWal\xEDajvV[[\x82\x81\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_am\x11\x83\x85ab\x89V[\x93P\x83` \x84\x02\x85\x01am#\x84ajeV[\x80_[\x87\x81\x10\x15amfW\x84\x84\x03\x89Ram=\x82\x84al\xD2V[amG\x85\x82al\xBFV[\x94PamR\x83al\xFAV[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90Pam&V[P\x82\x97P\x87\x94PPPPP\x93\x92PPPV[_a\x01\0\x82\x01\x90Pam\x8C_\x83\x01\x89ai\xC1V[am\x99`@\x83\x01\x88ai\xFEV[am\xA6`\xA0\x83\x01\x87ajVV[am\xB3`\xC0\x83\x01\x86aU\xA3V[\x81\x81\x03`\xE0\x83\x01Ram\xC6\x81\x84\x86am\x06V[\x90P\x97\x96PPPPPPPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[am\xEF\x81am\xD3V[\x82RPPV[_` \x82\x01\x90Pan\x08_\x83\x01\x84am\xE6V[\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_`@\x82\x01\x90PanN_\x83\x01\x85a^\x93V[an[` \x83\x01\x84aU\xA3V[\x93\x92PPPV[_`@\x82\x01\x90P\x81\x81\x03_\x83\x01Ranz\x81\x85aY\x1BV[\x90Pan\x89` \x83\x01\x84aU\xA3V[\x93\x92PPPV[_an\x9A\x82aU\x9AV[\x91P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03an\xCCWan\xCBah:V[[`\x01\x82\x01\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[_\x80\xFD[_\x80\xFD[_\x80\xFD[_\x825`\x01a\x01\0\x03\x836\x03\x03\x81\x12ao,Wao+ao\x04V[[\x80\x83\x01\x91PP\x92\x91PPV[_\x80\x835`\x01` \x03\x846\x03\x03\x81\x12aoTWaoSao\x04V[[\x80\x84\x01\x92P\x825\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15aovWaouao\x08V[[` \x83\x01\x92P`\x01\x82\x026\x03\x83\x13\x15ao\x92Wao\x91ao\x0CV[[P\x92P\x92\x90PV[_\x82\x90P\x92\x91PPV[_\x81\x90P\x81_R` _ \x90P\x91\x90PV[`\x1F\x82\x11\x15ao\xF7Wao\xC8\x81ao\xA4V[ao\xD1\x84ae\x86V[\x81\x01` \x85\x10\x15ao\xE0W\x81\x90P[ao\xF4ao\xEC\x85ae\x86V[\x83\x01\x82affV[PP[PPPV[ap\x06\x83\x83ao\x9AV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ap\x1FWap\x1Ea]\x0CV[[ap)\x82Tae:V[ap4\x82\x82\x85ao\xB6V[_`\x1F\x83\x11`\x01\x81\x14apaW_\x84\x15apOW\x82\x87\x015\x90P[apY\x85\x82af\xF6V[\x86UPap\xC0V[`\x1F\x19\x84\x16apo\x86ao\xA4V[_[\x82\x81\x10\x15ap\x96W\x84\x89\x015\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90PapqV[\x86\x83\x10\x15ap\xB3W\x84\x89\x015ap\xAF`\x1F\x89\x16\x82af\xDAV[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPPV[ap\xD4\x83\x83\x83ao\xFCV[PPPV[_\x815ap\xE5\x81a\\\xDEV[\x80\x91PP\x91\x90PV[_\x81_\x1B\x90P\x91\x90PV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFaq\x18\x84ap\xEEV[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[_aqHaqCaq>\x84aW/V[ae\xF2V[aW/V[\x90P\x91\x90PV[_aqY\x82aq.V[\x90P\x91\x90PV[_aqj\x82aqOV[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[aq\x83\x82aq`V[aq\x96aq\x8F\x82aqqV[\x83Tap\xF9V[\x82UPPPV[_\x815aq\xA9\x81aY\xBFV[\x80\x91PP\x91\x90PV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFaq\xDD\x84ap\xEEV[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[aq\xFC\x82ae\xFBV[ar\x0Far\x08\x82af\x1CV[\x83Taq\xB2V[\x82UPPPV[_\x80\x835`\x01` \x03\x846\x03\x03\x81\x12ar2War1ao\x04V[[\x80\x84\x01\x92P\x825\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15arTWarSao\x08V[[` \x83\x01\x92P`\x01\x82\x026\x03\x83\x13\x15arpWaroao\x0CV[[P\x92P\x92\x90PV[ar\x83\x83\x83\x83ag\x11V[PPPV[_\x81\x01_\x83\x01ar\x98\x81\x85ao8V[ar\xA3\x81\x83\x86ap\xC9V[PPPP`\x01\x81\x01` \x83\x01\x80ar\xB9\x81ap\xD9V[\x90Par\xC5\x81\x84aqzV[PPP`\x02\x81\x01`@\x83\x01\x80ar\xDA\x81ap\xD9V[\x90Par\xE6\x81\x84aqzV[PPP`\x03\x81\x01``\x83\x01\x80ar\xFB\x81aq\x9DV[\x90Pas\x07\x81\x84aq\xF3V[PPP`\x04\x81\x01`\x80\x83\x01as\x1C\x81\x85ar\x16V[as'\x81\x83\x86arxV[PPPP`\x05\x81\x01`\xA0\x83\x01as=\x81\x85ao8V[asH\x81\x83\x86ap\xC9V[PPPP`\x06\x81\x01`\xC0\x83\x01as^\x81\x85ao8V[asi\x81\x83\x86ap\xC9V[PPPP`\x07\x81\x01`\xE0\x83\x01as\x7F\x81\x85ar\x16V[as\x8A\x81\x83\x86arxV[PPPPPPV[as\x9C\x82\x82ar\x88V[PPV[as\xA9\x81a^\x8AV[\x81\x14as\xB3W_\x80\xFD[PV[_\x81Q\x90Pas\xC4\x81as\xA0V[\x92\x91PPV[_` \x82\x84\x03\x12\x15as\xDFWas\xDEaY\xB7V[[_as\xEC\x84\x82\x85\x01as\xB6V[\x91PP\x92\x91PPV[_``\x82\x01\x90Pat\x08_\x83\x01\x86aU\xA3V[at\x15` \x83\x01\x85aU\xA3V[at\"`@\x83\x01\x84aU\xA3V[\x94\x93PPPPV[at3\x82aU\xCBV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15atLWatKa]\x0CV[[atV\x82Tae:V[ata\x82\x82\x85ao\xB6V[_` \x90P`\x1F\x83\x11`\x01\x81\x14at\x92W_\x84\x15at\x80W\x82\x87\x01Q\x90P[at\x8A\x85\x82af\xF6V[\x86UPat\xF1V[`\x1F\x19\x84\x16at\xA0\x86ao\xA4V[_[\x82\x81\x10\x15at\xC7W\x84\x89\x01Q\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Pat\xA2V[\x86\x83\x10\x15at\xE4W\x84\x89\x01Qat\xE0`\x1F\x89\x16\x82af\xDAV[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPV[_\x81\x90P\x92\x91PPV[_au\r\x82aWnV[au\x17\x81\x85at\xF9V[\x93Pau'\x81\x85` \x86\x01aU\xE5V[\x80\x84\x01\x91PP\x92\x91PPV[_au>\x82\x84au\x03V[\x91P\x81\x90P\x92\x91PPV[_`\xA0\x82\x01\x90Pau\\_\x83\x01\x88a^\x93V[aui` \x83\x01\x87a^\x93V[auv`@\x83\x01\x86a^\x93V[au\x83``\x83\x01\x85aU\xA3V[au\x90`\x80\x83\x01\x84a_\xE5V[\x96\x95PPPPPPV[_`\xFF\x82\x16\x90P\x91\x90PV[au\xAF\x81au\x9AV[\x82RPPV[_`\x80\x82\x01\x90Pau\xC8_\x83\x01\x87a^\x93V[au\xD5` \x83\x01\x86au\xA6V[au\xE2`@\x83\x01\x85a^\x93V[au\xEF``\x83\x01\x84a^\x93V[\x95\x94PPPPPV\xFEKeyResharingVerification(uint256 contextId)",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ContextStatus(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<ContextStatus> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl ContextStatus {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ContextStatus {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ContextStatus {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct DecryptionThresholds { uint256 publicDecryptionThreshold; uint256 userDecryptionThreshold; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DecryptionThresholds {
        #[allow(missing_docs)]
        pub publicDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub userDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DecryptionThresholds> for UnderlyingRustTuple<'_> {
            fn from(value: DecryptionThresholds) -> Self {
                (value.publicDecryptionThreshold, value.userDecryptionThreshold)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for DecryptionThresholds {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    publicDecryptionThreshold: tuple.0,
                    userDecryptionThreshold: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for DecryptionThresholds {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for DecryptionThresholds {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.publicDecryptionThreshold,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.userDecryptionThreshold,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for DecryptionThresholds {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for DecryptionThresholds {
            const NAME: &'static str = "DecryptionThresholds";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "DecryptionThresholds(uint256 publicDecryptionThreshold,uint256 userDecryptionThreshold)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.publicDecryptionThreshold,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.userDecryptionThreshold,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for DecryptionThresholds {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.publicDecryptionThreshold,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.userDecryptionThreshold,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.publicDecryptionThreshold,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.userDecryptionThreshold,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct KmsBlockPeriods { uint256 preActivationBlockPeriod; uint256 generationBlockPeriod; uint256 suspensionBlockPeriod; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KmsBlockPeriods {
        #[allow(missing_docs)]
        pub preActivationBlockPeriod: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub generationBlockPeriod: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub suspensionBlockPeriod: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KmsBlockPeriods> for UnderlyingRustTuple<'_> {
            fn from(value: KmsBlockPeriods) -> Self {
                (
                    value.preActivationBlockPeriod,
                    value.generationBlockPeriod,
                    value.suspensionBlockPeriod,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for KmsBlockPeriods {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    preActivationBlockPeriod: tuple.0,
                    generationBlockPeriod: tuple.1,
                    suspensionBlockPeriod: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for KmsBlockPeriods {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for KmsBlockPeriods {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.preActivationBlockPeriod,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.generationBlockPeriod,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.suspensionBlockPeriod),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for KmsBlockPeriods {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for KmsBlockPeriods {
            const NAME: &'static str = "KmsBlockPeriods";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "KmsBlockPeriods(uint256 preActivationBlockPeriod,uint256 generationBlockPeriod,uint256 suspensionBlockPeriod)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.preActivationBlockPeriod,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.generationBlockPeriod,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.suspensionBlockPeriod,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for KmsBlockPeriods {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.preActivationBlockPeriod,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.generationBlockPeriod,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.suspensionBlockPeriod,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.preActivationBlockPeriod,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.generationBlockPeriod,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.suspensionBlockPeriod,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct KmsContext { uint256 contextId; uint256 previousContextId; bytes8 softwareVersion; uint256 mpcThreshold; KmsNode[] kmsNodes; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KmsContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub previousContextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub softwareVersion: alloy::sol_types::private::FixedBytes<8>,
        #[allow(missing_docs)]
        pub mpcThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub kmsNodes: alloy::sol_types::private::Vec<
            <KmsNode as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<8>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<KmsNode>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<8>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <KmsNode as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KmsContext> for UnderlyingRustTuple<'_> {
            fn from(value: KmsContext) -> Self {
                (
                    value.contextId,
                    value.previousContextId,
                    value.softwareVersion,
                    value.mpcThreshold,
                    value.kmsNodes,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for KmsContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    contextId: tuple.0,
                    previousContextId: tuple.1,
                    softwareVersion: tuple.2,
                    mpcThreshold: tuple.3,
                    kmsNodes: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for KmsContext {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for KmsContext {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.previousContextId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.softwareVersion),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.mpcThreshold),
                    <alloy::sol_types::sol_data::Array<
                        KmsNode,
                    > as alloy_sol_types::SolType>::tokenize(&self.kmsNodes),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for KmsContext {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for KmsContext {
            const NAME: &'static str = "KmsContext";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "KmsContext(uint256 contextId,uint256 previousContextId,bytes8 softwareVersion,uint256 mpcThreshold,KmsNode[] kmsNodes)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(<KmsNode as alloy_sol_types::SolStruct>::eip712_root_type());
                components
                    .extend(
                        <KmsNode as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.contextId)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.previousContextId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        8,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.softwareVersion,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.mpcThreshold)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        KmsNode,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.kmsNodes)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for KmsContext {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.contextId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.previousContextId,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        8,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.softwareVersion,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.mpcThreshold,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        KmsNode,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.kmsNodes,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.contextId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.previousContextId,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.softwareVersion,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.mpcThreshold,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    KmsNode,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.kmsNodes,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct KmsNode { string name; address signerAddress; address txSenderAddress; uint256 partyId; bytes backupEncryptionKey; string externalUrl; string publicStorageUrl; bytes tlsCertificate; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KmsNode {
        #[allow(missing_docs)]
        pub name: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub signerAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub txSenderAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub partyId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub backupEncryptionKey: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub externalUrl: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub publicStorageUrl: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub tlsCertificate: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Bytes,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::String,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::String,
            alloy::sol_types::private::String,
            alloy::sol_types::private::Bytes,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KmsNode> for UnderlyingRustTuple<'_> {
            fn from(value: KmsNode) -> Self {
                (
                    value.name,
                    value.signerAddress,
                    value.txSenderAddress,
                    value.partyId,
                    value.backupEncryptionKey,
                    value.externalUrl,
                    value.publicStorageUrl,
                    value.tlsCertificate,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for KmsNode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    name: tuple.0,
                    signerAddress: tuple.1,
                    txSenderAddress: tuple.2,
                    partyId: tuple.3,
                    backupEncryptionKey: tuple.4,
                    externalUrl: tuple.5,
                    publicStorageUrl: tuple.6,
                    tlsCertificate: tuple.7,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for KmsNode {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for KmsNode {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signerAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.txSenderAddress,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.partyId),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.backupEncryptionKey,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.externalUrl,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.publicStorageUrl,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.tlsCertificate,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for KmsNode {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for KmsNode {
            const NAME: &'static str = "KmsNode";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "KmsNode(string name,address signerAddress,address txSenderAddress,uint256 partyId,bytes backupEncryptionKey,string externalUrl,string publicStorageUrl,bytes tlsCertificate)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.name,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.signerAddress,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.txSenderAddress,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.partyId)
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.backupEncryptionKey,
                        )
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.externalUrl,
                        )
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.publicStorageUrl,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.tlsCertificate,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for KmsNode {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.name,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.signerAddress,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.txSenderAddress,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.partyId,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.backupEncryptionKey,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.externalUrl,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.publicStorageUrl,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.tlsCertificate,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.name,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.signerAddress,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.txSenderAddress,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.partyId,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.backupEncryptionKey,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.externalUrl,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.publicStorageUrl,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.tlsCertificate,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AddressEmptyCode(address)` and selector `0x9996b315`.
```solidity
error AddressEmptyCode(address target);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AddressEmptyCode {
        #[allow(missing_docs)]
        pub target: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AddressEmptyCode> for UnderlyingRustTuple<'_> {
            fn from(value: AddressEmptyCode) -> Self {
                (value.target,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AddressEmptyCode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { target: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AddressEmptyCode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AddressEmptyCode(address)";
            const SELECTOR: [u8; 4] = [153u8, 150u8, 179u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `CompromiseActiveKmsContextNotAllowed(uint256)` and selector `0x77d05ea7`.
```solidity
error CompromiseActiveKmsContextNotAllowed(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CompromiseActiveKmsContextNotAllowed {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CompromiseActiveKmsContextNotAllowed>
        for UnderlyingRustTuple<'_> {
            fn from(value: CompromiseActiveKmsContextNotAllowed) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for CompromiseActiveKmsContextNotAllowed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CompromiseActiveKmsContextNotAllowed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CompromiseActiveKmsContextNotAllowed(uint256)";
            const SELECTOR: [u8; 4] = [119u8, 208u8, 94u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ContextAlreadyExists(uint256)` and selector `0x6653f6d7`.
```solidity
error ContextAlreadyExists(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ContextAlreadyExists {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ContextAlreadyExists> for UnderlyingRustTuple<'_> {
            fn from(value: ContextAlreadyExists) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ContextAlreadyExists {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ContextAlreadyExists {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ContextAlreadyExists(uint256)";
            const SELECTOR: [u8; 4] = [102u8, 83u8, 246u8, 215u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ContextNotActive(uint256)` and selector `0x331486b3`.
```solidity
error ContextNotActive(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ContextNotActive {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ContextNotActive> for UnderlyingRustTuple<'_> {
            fn from(value: ContextNotActive) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ContextNotActive {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ContextNotActive {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ContextNotActive(uint256)";
            const SELECTOR: [u8; 4] = [51u8, 20u8, 134u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ContextNotActiveOrSuspended(uint256)` and selector `0x2b3652d1`.
```solidity
error ContextNotActiveOrSuspended(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ContextNotActiveOrSuspended {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ContextNotActiveOrSuspended>
        for UnderlyingRustTuple<'_> {
            fn from(value: ContextNotActiveOrSuspended) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ContextNotActiveOrSuspended {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ContextNotActiveOrSuspended {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ContextNotActiveOrSuspended(uint256)";
            const SELECTOR: [u8; 4] = [43u8, 54u8, 82u8, 209u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ContextNotGenerated(uint256)` and selector `0xc0b5ee66`.
```solidity
error ContextNotGenerated(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ContextNotGenerated {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ContextNotGenerated> for UnderlyingRustTuple<'_> {
            fn from(value: ContextNotGenerated) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ContextNotGenerated {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ContextNotGenerated {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ContextNotGenerated(uint256)";
            const SELECTOR: [u8; 4] = [192u8, 181u8, 238u8, 102u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ContextNotInitializedOrIsGenerating(uint256)` and selector `0xb0c5151d`.
```solidity
error ContextNotInitializedOrIsGenerating(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ContextNotInitializedOrIsGenerating {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ContextNotInitializedOrIsGenerating>
        for UnderlyingRustTuple<'_> {
            fn from(value: ContextNotInitializedOrIsGenerating) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ContextNotInitializedOrIsGenerating {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ContextNotInitializedOrIsGenerating {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ContextNotInitializedOrIsGenerating(uint256)";
            const SELECTOR: [u8; 4] = [176u8, 197u8, 21u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ContextNotPreActivatedOrSuspended(uint256)` and selector `0x12b49e3d`.
```solidity
error ContextNotPreActivatedOrSuspended(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ContextNotPreActivatedOrSuspended {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ContextNotPreActivatedOrSuspended>
        for UnderlyingRustTuple<'_> {
            fn from(value: ContextNotPreActivatedOrSuspended) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ContextNotPreActivatedOrSuspended {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ContextNotPreActivatedOrSuspended {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ContextNotPreActivatedOrSuspended(uint256)";
            const SELECTOR: [u8; 4] = [18u8, 180u8, 158u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `DestroyActiveKmsContextNotAllowed(uint256)` and selector `0xb25e4eb3`.
```solidity
error DestroyActiveKmsContextNotAllowed(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DestroyActiveKmsContextNotAllowed {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DestroyActiveKmsContextNotAllowed>
        for UnderlyingRustTuple<'_> {
            fn from(value: DestroyActiveKmsContextNotAllowed) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for DestroyActiveKmsContextNotAllowed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for DestroyActiveKmsContextNotAllowed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DestroyActiveKmsContextNotAllowed(uint256)";
            const SELECTOR: [u8; 4] = [178u8, 94u8, 78u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ECDSAInvalidSignature()` and selector `0xf645eedf`.
```solidity
error ECDSAInvalidSignature();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignature {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignature> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignature) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignature()";
            const SELECTOR: [u8; 4] = [246u8, 69u8, 238u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ECDSAInvalidSignatureLength(uint256)` and selector `0xfce698f7`.
```solidity
error ECDSAInvalidSignatureLength(uint256 length);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureLength {
        #[allow(missing_docs)]
        pub length: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureLength>
        for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureLength) -> Self {
                (value.length,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ECDSAInvalidSignatureLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { length: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureLength(uint256)";
            const SELECTOR: [u8; 4] = [252u8, 230u8, 152u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.length),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ECDSAInvalidSignatureS(bytes32)` and selector `0xd78bce0c`.
```solidity
error ECDSAInvalidSignatureS(bytes32 s);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureS {
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureS> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureS) -> Self {
                (value.s,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignatureS {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { s: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureS {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureS(bytes32)";
            const SELECTOR: [u8; 4] = [215u8, 139u8, 206u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ERC1967InvalidImplementation(address)` and selector `0x4c9c8ce3`.
```solidity
error ERC1967InvalidImplementation(address implementation);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967InvalidImplementation {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967InvalidImplementation>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967InvalidImplementation) -> Self {
                (value.implementation,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC1967InvalidImplementation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { implementation: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967InvalidImplementation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967InvalidImplementation(address)";
            const SELECTOR: [u8; 4] = [76u8, 156u8, 140u8, 227u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ERC1967NonPayable()` and selector `0xb398979f`.
```solidity
error ERC1967NonPayable();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967NonPayable {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967NonPayable> for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967NonPayable) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC1967NonPayable {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967NonPayable {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967NonPayable()";
            const SELECTOR: [u8; 4] = [179u8, 152u8, 151u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `EmptyKmsNodes()` and selector `0x068c8d40`.
```solidity
error EmptyKmsNodes();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyKmsNodes {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyKmsNodes> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyKmsNodes) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyKmsNodes {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyKmsNodes {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyKmsNodes()";
            const SELECTOR: [u8; 4] = [6u8, 140u8, 141u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `EnforcedPause()` and selector `0xd93c0665`.
```solidity
error EnforcedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EnforcedPause {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EnforcedPause> for UnderlyingRustTuple<'_> {
            fn from(value: EnforcedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EnforcedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EnforcedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EnforcedPause()";
            const SELECTOR: [u8; 4] = [217u8, 60u8, 6u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ExpectedPause()` and selector `0x8dfc202b`.
```solidity
error ExpectedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExpectedPause {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExpectedPause> for UnderlyingRustTuple<'_> {
            fn from(value: ExpectedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ExpectedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ExpectedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ExpectedPause()";
            const SELECTOR: [u8; 4] = [141u8, 252u8, 32u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FailedCall()` and selector `0xd6bda275`.
```solidity
error FailedCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FailedCall {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedCall> for UnderlyingRustTuple<'_> {
            fn from(value: FailedCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FailedCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedCall()";
            const SELECTOR: [u8; 4] = [214u8, 189u8, 162u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidHighMpcThreshold(uint256,uint256,uint256)` and selector `0x8789a6ca`.
```solidity
error InvalidHighMpcThreshold(uint256 contextId, uint256 mpcThreshold, uint256 nKmsNodes);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidHighMpcThreshold {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub mpcThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nKmsNodes: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidHighMpcThreshold> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidHighMpcThreshold) -> Self {
                (value.contextId, value.mpcThreshold, value.nKmsNodes)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidHighMpcThreshold {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    contextId: tuple.0,
                    mpcThreshold: tuple.1,
                    nKmsNodes: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidHighMpcThreshold {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidHighMpcThreshold(uint256,uint256,uint256)";
            const SELECTOR: [u8; 4] = [135u8, 137u8, 166u8, 202u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.mpcThreshold),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nKmsNodes),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidHighPublicDecryptionThreshold(uint256,uint256)` and selector `0x84208f23`.
```solidity
error InvalidHighPublicDecryptionThreshold(uint256 publicDecryptionThreshold, uint256 nKmsNodes);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidHighPublicDecryptionThreshold {
        #[allow(missing_docs)]
        pub publicDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nKmsNodes: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidHighPublicDecryptionThreshold>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidHighPublicDecryptionThreshold) -> Self {
                (value.publicDecryptionThreshold, value.nKmsNodes)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidHighPublicDecryptionThreshold {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    publicDecryptionThreshold: tuple.0,
                    nKmsNodes: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidHighPublicDecryptionThreshold {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidHighPublicDecryptionThreshold(uint256,uint256)";
            const SELECTOR: [u8; 4] = [132u8, 32u8, 143u8, 35u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.publicDecryptionThreshold,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nKmsNodes),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidHighUserDecryptionThreshold(uint256,uint256)` and selector `0xd2535e11`.
```solidity
error InvalidHighUserDecryptionThreshold(uint256 userDecryptionThreshold, uint256 nKmsNodes);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidHighUserDecryptionThreshold {
        #[allow(missing_docs)]
        pub userDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nKmsNodes: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidHighUserDecryptionThreshold>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidHighUserDecryptionThreshold) -> Self {
                (value.userDecryptionThreshold, value.nKmsNodes)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidHighUserDecryptionThreshold {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    userDecryptionThreshold: tuple.0,
                    nKmsNodes: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidHighUserDecryptionThreshold {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidHighUserDecryptionThreshold(uint256,uint256)";
            const SELECTOR: [u8; 4] = [210u8, 83u8, 94u8, 17u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.userDecryptionThreshold,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nKmsNodes),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidInitialization()` and selector `0xf92ee8a9`.
```solidity
error InvalidInitialization();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidInitialization {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidInitialization> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidInitialization) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidInitialization {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidInitialization {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidInitialization()";
            const SELECTOR: [u8; 4] = [249u8, 46u8, 232u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidNullContextId()` and selector `0xcb17b7a5`.
```solidity
error InvalidNullContextId();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidNullContextId {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidNullContextId> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidNullContextId) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidNullContextId {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidNullContextId {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidNullContextId()";
            const SELECTOR: [u8; 4] = [203u8, 23u8, 183u8, 165u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidNullPublicDecryptionThreshold()` and selector `0xb1ae92ea`.
```solidity
error InvalidNullPublicDecryptionThreshold();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidNullPublicDecryptionThreshold {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidNullPublicDecryptionThreshold>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidNullPublicDecryptionThreshold) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidNullPublicDecryptionThreshold {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidNullPublicDecryptionThreshold {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidNullPublicDecryptionThreshold()";
            const SELECTOR: [u8; 4] = [177u8, 174u8, 146u8, 234u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidNullUserDecryptionThreshold()` and selector `0xe60a7271`.
```solidity
error InvalidNullUserDecryptionThreshold();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidNullUserDecryptionThreshold {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidNullUserDecryptionThreshold>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidNullUserDecryptionThreshold) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidNullUserDecryptionThreshold {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidNullUserDecryptionThreshold {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidNullUserDecryptionThreshold()";
            const SELECTOR: [u8; 4] = [230u8, 10u8, 114u8, 113u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `KmsContextNotGenerating(uint256)` and selector `0x5e51a2e1`.
```solidity
error KmsContextNotGenerating(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KmsContextNotGenerating {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KmsContextNotGenerating> for UnderlyingRustTuple<'_> {
            fn from(value: KmsContextNotGenerating) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for KmsContextNotGenerating {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for KmsContextNotGenerating {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "KmsContextNotGenerating(uint256)";
            const SELECTOR: [u8; 4] = [94u8, 81u8, 162u8, 225u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `KmsContextNotInitialized(uint256)` and selector `0x82b1fbda`.
```solidity
error KmsContextNotInitialized(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KmsContextNotInitialized {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KmsContextNotInitialized>
        for UnderlyingRustTuple<'_> {
            fn from(value: KmsContextNotInitialized) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for KmsContextNotInitialized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for KmsContextNotInitialized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "KmsContextNotInitialized(uint256)";
            const SELECTOR: [u8; 4] = [130u8, 177u8, 251u8, 218u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `KmsNodeAlreadyValidatedKeyResharing(uint256,address)` and selector `0x99b158c1`.
```solidity
error KmsNodeAlreadyValidatedKeyResharing(uint256 contextId, address kmsSigner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KmsNodeAlreadyValidatedKeyResharing {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub kmsSigner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KmsNodeAlreadyValidatedKeyResharing>
        for UnderlyingRustTuple<'_> {
            fn from(value: KmsNodeAlreadyValidatedKeyResharing) -> Self {
                (value.contextId, value.kmsSigner)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for KmsNodeAlreadyValidatedKeyResharing {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    contextId: tuple.0,
                    kmsSigner: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for KmsNodeAlreadyValidatedKeyResharing {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "KmsNodeAlreadyValidatedKeyResharing(uint256,address)";
            const SELECTOR: [u8; 4] = [153u8, 177u8, 88u8, 193u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.kmsSigner,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NoSuspendedKmsContext()` and selector `0x207ea3f3`.
```solidity
error NoSuspendedKmsContext();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NoSuspendedKmsContext {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NoSuspendedKmsContext> for UnderlyingRustTuple<'_> {
            fn from(value: NoSuspendedKmsContext) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NoSuspendedKmsContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NoSuspendedKmsContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NoSuspendedKmsContext()";
            const SELECTOR: [u8; 4] = [32u8, 126u8, 163u8, 243u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotInitializing()` and selector `0xd7e6bcf8`.
```solidity
error NotInitializing();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotInitializing {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotInitializing> for UnderlyingRustTuple<'_> {
            fn from(value: NotInitializing) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotInitializing {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotInitializing {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotInitializing()";
            const SELECTOR: [u8; 4] = [215u8, 230u8, 188u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotKmsNodeFromContext(uint256,address)` and selector `0x0494d3c0`.
```solidity
error NotKmsNodeFromContext(uint256 contextId, address kmsTxSenderAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotKmsNodeFromContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub kmsTxSenderAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotKmsNodeFromContext> for UnderlyingRustTuple<'_> {
            fn from(value: NotKmsNodeFromContext) -> Self {
                (value.contextId, value.kmsTxSenderAddress)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotKmsNodeFromContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    contextId: tuple.0,
                    kmsTxSenderAddress: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotKmsNodeFromContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotKmsNodeFromContext(uint256,address)";
            const SELECTOR: [u8; 4] = [4u8, 148u8, 211u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.kmsTxSenderAddress,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotKmsSignerFromContext(uint256,address)` and selector `0x89b45e5d`.
```solidity
error NotKmsSignerFromContext(uint256 contextId, address signerAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotKmsSignerFromContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub signerAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotKmsSignerFromContext> for UnderlyingRustTuple<'_> {
            fn from(value: NotKmsSignerFromContext) -> Self {
                (value.contextId, value.signerAddress)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotKmsSignerFromContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    contextId: tuple.0,
                    signerAddress: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotKmsSignerFromContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotKmsSignerFromContext(uint256,address)";
            const SELECTOR: [u8; 4] = [137u8, 180u8, 94u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signerAddress,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotKmsTxSenderFromContext(uint256,address)` and selector `0xfdf8a05d`.
```solidity
error NotKmsTxSenderFromContext(uint256 contextId, address txSenderAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotKmsTxSenderFromContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub txSenderAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotKmsTxSenderFromContext>
        for UnderlyingRustTuple<'_> {
            fn from(value: NotKmsTxSenderFromContext) -> Self {
                (value.contextId, value.txSenderAddress)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for NotKmsTxSenderFromContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    contextId: tuple.0,
                    txSenderAddress: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotKmsTxSenderFromContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotKmsTxSenderFromContext(uint256,address)";
            const SELECTOR: [u8; 4] = [253u8, 248u8, 160u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.txSenderAddress,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotOwnerOrPauser(address)` and selector `0x46c0d9af`.
```solidity
error NotOwnerOrPauser(address notOwnerOrPauser);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotOwnerOrPauser {
        #[allow(missing_docs)]
        pub notOwnerOrPauser: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotOwnerOrPauser> for UnderlyingRustTuple<'_> {
            fn from(value: NotOwnerOrPauser) -> Self {
                (value.notOwnerOrPauser,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotOwnerOrPauser {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { notOwnerOrPauser: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotOwnerOrPauser {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotOwnerOrPauser(address)";
            const SELECTOR: [u8; 4] = [70u8, 192u8, 217u8, 175u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.notOwnerOrPauser,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NumberOfKmsNodesChanged(uint256,uint256)` and selector `0xd595a962`.
```solidity
error NumberOfKmsNodesChanged(uint256 activeKmsNodesLength, uint256 newKmsNodesLength);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NumberOfKmsNodesChanged {
        #[allow(missing_docs)]
        pub activeKmsNodesLength: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub newKmsNodesLength: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NumberOfKmsNodesChanged> for UnderlyingRustTuple<'_> {
            fn from(value: NumberOfKmsNodesChanged) -> Self {
                (value.activeKmsNodesLength, value.newKmsNodesLength)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NumberOfKmsNodesChanged {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    activeKmsNodesLength: tuple.0,
                    newKmsNodesLength: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NumberOfKmsNodesChanged {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NumberOfKmsNodesChanged(uint256,uint256)";
            const SELECTOR: [u8; 4] = [213u8, 149u8, 169u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.activeKmsNodesLength),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newKmsNodesLength),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `OwnableInvalidOwner(address)` and selector `0x1e4fbdf7`.
```solidity
error OwnableInvalidOwner(address owner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OwnableInvalidOwner {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OwnableInvalidOwner> for UnderlyingRustTuple<'_> {
            fn from(value: OwnableInvalidOwner) -> Self {
                (value.owner,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OwnableInvalidOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { owner: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OwnableInvalidOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OwnableInvalidOwner(address)";
            const SELECTOR: [u8; 4] = [30u8, 79u8, 189u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `OwnableUnauthorizedAccount(address)` and selector `0x118cdaa7`.
```solidity
error OwnableUnauthorizedAccount(address account);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OwnableUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OwnableUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: OwnableUnauthorizedAccount) -> Self {
                (value.account,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for OwnableUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { account: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OwnableUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OwnableUnauthorizedAccount(address)";
            const SELECTOR: [u8; 4] = [17u8, 140u8, 218u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `SuspendedKmsContextOngoing(uint256)` and selector `0x7623d357`.
```solidity
error SuspendedKmsContextOngoing(uint256 suspendedContextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SuspendedKmsContextOngoing {
        #[allow(missing_docs)]
        pub suspendedContextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SuspendedKmsContextOngoing>
        for UnderlyingRustTuple<'_> {
            fn from(value: SuspendedKmsContextOngoing) -> Self {
                (value.suspendedContextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SuspendedKmsContextOngoing {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    suspendedContextId: tuple.0,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SuspendedKmsContextOngoing {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SuspendedKmsContextOngoing(uint256)";
            const SELECTOR: [u8; 4] = [118u8, 35u8, 211u8, 87u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.suspendedContextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UUPSUnauthorizedCallContext()` and selector `0xe07c8dba`.
```solidity
error UUPSUnauthorizedCallContext();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnauthorizedCallContext {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnauthorizedCallContext>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnauthorizedCallContext) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnauthorizedCallContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnauthorizedCallContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnauthorizedCallContext()";
            const SELECTOR: [u8; 4] = [224u8, 124u8, 141u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UUPSUnsupportedProxiableUUID(bytes32)` and selector `0xaa1d49a4`.
```solidity
error UUPSUnsupportedProxiableUUID(bytes32 slot);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnsupportedProxiableUUID {
        #[allow(missing_docs)]
        pub slot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnsupportedProxiableUUID>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnsupportedProxiableUUID) -> Self {
                (value.slot,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnsupportedProxiableUUID {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { slot: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnsupportedProxiableUUID {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnsupportedProxiableUUID(bytes32)";
            const SELECTOR: [u8; 4] = [170u8, 29u8, 73u8, 164u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ActivateKmsContext(uint256)` and selector `0x4f54a6ac981cc8dc83142b3eb4d120be7c70fc5de6477a14eae3e9ca647644bc`.
```solidity
event ActivateKmsContext(uint256 contextId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ActivateKmsContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ActivateKmsContext {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ActivateKmsContext(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                79u8, 84u8, 166u8, 172u8, 152u8, 28u8, 200u8, 220u8, 131u8, 20u8, 43u8,
                62u8, 180u8, 209u8, 32u8, 190u8, 124u8, 112u8, 252u8, 93u8, 230u8, 71u8,
                122u8, 20u8, 234u8, 227u8, 233u8, 202u8, 100u8, 118u8, 68u8, 188u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { contextId: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ActivateKmsContext {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ActivateKmsContext> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ActivateKmsContext) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `CompromiseKmsContext(uint256)` and selector `0xbc1114fa9a77648cd097ee6cf149c344fa278b9b983f30dd65b6fd6a9d464a07`.
```solidity
event CompromiseKmsContext(uint256 contextId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct CompromiseKmsContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for CompromiseKmsContext {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "CompromiseKmsContext(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                188u8, 17u8, 20u8, 250u8, 154u8, 119u8, 100u8, 140u8, 208u8, 151u8,
                238u8, 108u8, 241u8, 73u8, 195u8, 68u8, 250u8, 39u8, 139u8, 155u8, 152u8,
                63u8, 48u8, 221u8, 101u8, 182u8, 253u8, 106u8, 157u8, 70u8, 74u8, 7u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { contextId: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for CompromiseKmsContext {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&CompromiseKmsContext> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &CompromiseKmsContext) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `DeactivateKmsContext(uint256)` and selector `0x8fb75858a565aee117342d93196a7f0b54c1c8519885eddda6a01f477359b363`.
```solidity
event DeactivateKmsContext(uint256 contextId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DeactivateKmsContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DeactivateKmsContext {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "DeactivateKmsContext(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                143u8, 183u8, 88u8, 88u8, 165u8, 101u8, 174u8, 225u8, 23u8, 52u8, 45u8,
                147u8, 25u8, 106u8, 127u8, 11u8, 84u8, 193u8, 200u8, 81u8, 152u8, 133u8,
                237u8, 221u8, 166u8, 160u8, 31u8, 71u8, 115u8, 89u8, 179u8, 99u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { contextId: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DeactivateKmsContext {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DeactivateKmsContext> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DeactivateKmsContext) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `DestroyKmsContext(uint256)` and selector `0x3e8f02dc7af6e3a67f3af0bc99bcf11b4deb46105e9ba7f1ac6da82322e9025e`.
```solidity
event DestroyKmsContext(uint256 contextId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DestroyKmsContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DestroyKmsContext {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "DestroyKmsContext(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                62u8, 143u8, 2u8, 220u8, 122u8, 246u8, 227u8, 166u8, 127u8, 58u8, 240u8,
                188u8, 153u8, 188u8, 241u8, 27u8, 77u8, 235u8, 70u8, 16u8, 94u8, 155u8,
                167u8, 241u8, 172u8, 109u8, 168u8, 35u8, 34u8, 233u8, 2u8, 94u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { contextId: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DestroyKmsContext {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DestroyKmsContext> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DestroyKmsContext) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `EIP712DomainChanged()` and selector `0x0a6387c9ea3628b88a633bb4f3b151770f70085117a15f9bf3787cda53f13d31`.
```solidity
event EIP712DomainChanged();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EIP712DomainChanged {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EIP712DomainChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EIP712DomainChanged()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                10u8, 99u8, 135u8, 201u8, 234u8, 54u8, 40u8, 184u8, 138u8, 99u8, 59u8,
                180u8, 243u8, 177u8, 81u8, 119u8, 15u8, 112u8, 8u8, 81u8, 23u8, 161u8,
                95u8, 155u8, 243u8, 120u8, 124u8, 218u8, 83u8, 241u8, 61u8, 49u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EIP712DomainChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EIP712DomainChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EIP712DomainChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Initialization((uint256,uint256),(uint256,uint256,uint256),bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[])` and selector `0x016ee9c16213ed67f33222abad4dfe46eb951ead30a10a1a72db3316ffb664e0`.
```solidity
event Initialization(DecryptionThresholds decryptionThresholds, KmsBlockPeriods blockPeriods, bytes8 softwareVersion, uint256 mpcThreshold, KmsNode[] kmsNodes);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialization {
        #[allow(missing_docs)]
        pub decryptionThresholds: <DecryptionThresholds as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub blockPeriods: <KmsBlockPeriods as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub softwareVersion: alloy::sol_types::private::FixedBytes<8>,
        #[allow(missing_docs)]
        pub mpcThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub kmsNodes: alloy::sol_types::private::Vec<
            <KmsNode as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialization {
            type DataTuple<'a> = (
                DecryptionThresholds,
                KmsBlockPeriods,
                alloy::sol_types::sol_data::FixedBytes<8>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<KmsNode>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialization((uint256,uint256),(uint256,uint256,uint256),bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[])";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                1u8, 110u8, 233u8, 193u8, 98u8, 19u8, 237u8, 103u8, 243u8, 50u8, 34u8,
                171u8, 173u8, 77u8, 254u8, 70u8, 235u8, 149u8, 30u8, 173u8, 48u8, 161u8,
                10u8, 26u8, 114u8, 219u8, 51u8, 22u8, 255u8, 182u8, 100u8, 224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    decryptionThresholds: data.0,
                    blockPeriods: data.1,
                    softwareVersion: data.2,
                    mpcThreshold: data.3,
                    kmsNodes: data.4,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <DecryptionThresholds as alloy_sol_types::SolType>::tokenize(
                        &self.decryptionThresholds,
                    ),
                    <KmsBlockPeriods as alloy_sol_types::SolType>::tokenize(
                        &self.blockPeriods,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.softwareVersion),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.mpcThreshold),
                    <alloy::sol_types::sol_data::Array<
                        KmsNode,
                    > as alloy_sol_types::SolType>::tokenize(&self.kmsNodes),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialization {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialization> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialization) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Initialized(uint64)` and selector `0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2`.
```solidity
event Initialized(uint64 version);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.version),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `InvalidateKeyResharing(uint256)` and selector `0x009fe8f0db45996decf7b06fc7b6ec5f887d5f04db2e0c4ad7f4e4ee5eefc5a3`.
```solidity
event InvalidateKeyResharing(uint256 contextId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct InvalidateKeyResharing {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for InvalidateKeyResharing {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "InvalidateKeyResharing(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                0u8, 159u8, 232u8, 240u8, 219u8, 69u8, 153u8, 109u8, 236u8, 247u8, 176u8,
                111u8, 199u8, 182u8, 236u8, 95u8, 136u8, 125u8, 95u8, 4u8, 219u8, 46u8,
                12u8, 74u8, 215u8, 244u8, 228u8, 238u8, 94u8, 239u8, 197u8, 163u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { contextId: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for InvalidateKeyResharing {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&InvalidateKeyResharing> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &InvalidateKeyResharing) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `NewKmsContext((uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),(uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]))` and selector `0x3662ec316d76e6a75eb7c45001a8ad74c3eb943e8778111c0225f2a9fd5e00e6`.
```solidity
event NewKmsContext(KmsContext activeKmsContext, KmsContext newKmsContext);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct NewKmsContext {
        #[allow(missing_docs)]
        pub activeKmsContext: <KmsContext as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub newKmsContext: <KmsContext as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for NewKmsContext {
            type DataTuple<'a> = (KmsContext, KmsContext);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "NewKmsContext((uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),(uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]))";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                54u8, 98u8, 236u8, 49u8, 109u8, 118u8, 230u8, 167u8, 94u8, 183u8, 196u8,
                80u8, 1u8, 168u8, 173u8, 116u8, 195u8, 235u8, 148u8, 62u8, 135u8, 120u8,
                17u8, 28u8, 2u8, 37u8, 242u8, 169u8, 253u8, 94u8, 0u8, 230u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    activeKmsContext: data.0,
                    newKmsContext: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <KmsContext as alloy_sol_types::SolType>::tokenize(
                        &self.activeKmsContext,
                    ),
                    <KmsContext as alloy_sol_types::SolType>::tokenize(
                        &self.newKmsContext,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for NewKmsContext {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&NewKmsContext> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &NewKmsContext) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OwnershipTransferStarted(address,address)` and selector `0x38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e22700`.
```solidity
event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferStarted {
        #[allow(missing_docs)]
        pub previousOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferStarted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferStarted(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                56u8, 209u8, 107u8, 140u8, 172u8, 34u8, 217u8, 159u8, 199u8, 193u8, 36u8,
                185u8, 205u8, 13u8, 226u8, 211u8, 250u8, 31u8, 174u8, 244u8, 32u8, 191u8,
                231u8, 145u8, 216u8, 195u8, 98u8, 215u8, 101u8, 226u8, 39u8, 0u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferStarted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferStarted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &OwnershipTransferStarted,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
```solidity
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub previousOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Paused(address)` and selector `0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258`.
```solidity
event Paused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Paused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Paused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Paused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                98u8, 231u8, 140u8, 234u8, 1u8, 190u8, 227u8, 32u8, 205u8, 78u8, 66u8,
                2u8, 112u8, 181u8, 234u8, 116u8, 0u8, 13u8, 17u8, 176u8, 201u8, 247u8,
                71u8, 84u8, 235u8, 219u8, 252u8, 84u8, 75u8, 5u8, 162u8, 88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Paused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Paused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Paused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `PreActivateKmsContext((uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),uint256)` and selector `0x4540f7808fcaec86c376a89d2c0c93a5056c21680db54332c7f2959d87fefc8b`.
```solidity
event PreActivateKmsContext(KmsContext newKmsContext, uint256 preActivationBlockNumber);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct PreActivateKmsContext {
        #[allow(missing_docs)]
        pub newKmsContext: <KmsContext as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub preActivationBlockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for PreActivateKmsContext {
            type DataTuple<'a> = (KmsContext, alloy::sol_types::sol_data::Uint<256>);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "PreActivateKmsContext((uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                69u8, 64u8, 247u8, 128u8, 143u8, 202u8, 236u8, 134u8, 195u8, 118u8,
                168u8, 157u8, 44u8, 12u8, 147u8, 165u8, 5u8, 108u8, 33u8, 104u8, 13u8,
                181u8, 67u8, 50u8, 199u8, 242u8, 149u8, 157u8, 135u8, 254u8, 252u8, 139u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    newKmsContext: data.0,
                    preActivationBlockNumber: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <KmsContext as alloy_sol_types::SolType>::tokenize(
                        &self.newKmsContext,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.preActivationBlockNumber,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for PreActivateKmsContext {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&PreActivateKmsContext> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &PreActivateKmsContext) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `StartKeyResharing((uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),(uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),uint256)` and selector `0x5dc601065a035d78305cd9ef27c91a009cd8d37297e43bb76319490895a0d058`.
```solidity
event StartKeyResharing(KmsContext activeKmsContext, KmsContext newKmsContext, uint256 generationBlockNumber);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct StartKeyResharing {
        #[allow(missing_docs)]
        pub activeKmsContext: <KmsContext as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub newKmsContext: <KmsContext as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub generationBlockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for StartKeyResharing {
            type DataTuple<'a> = (
                KmsContext,
                KmsContext,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "StartKeyResharing((uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),(uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                93u8, 198u8, 1u8, 6u8, 90u8, 3u8, 93u8, 120u8, 48u8, 92u8, 217u8, 239u8,
                39u8, 201u8, 26u8, 0u8, 156u8, 216u8, 211u8, 114u8, 151u8, 228u8, 59u8,
                183u8, 99u8, 25u8, 73u8, 8u8, 149u8, 160u8, 208u8, 88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    activeKmsContext: data.0,
                    newKmsContext: data.1,
                    generationBlockNumber: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <KmsContext as alloy_sol_types::SolType>::tokenize(
                        &self.activeKmsContext,
                    ),
                    <KmsContext as alloy_sol_types::SolType>::tokenize(
                        &self.newKmsContext,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.generationBlockNumber),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for StartKeyResharing {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&StartKeyResharing> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &StartKeyResharing) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `SuspendKmsContext(uint256)` and selector `0x851a08c16b15959c338ac4b56466d06c9f9d5ff8d715168aa125d5ccaf538320`.
```solidity
event SuspendKmsContext(uint256 contextId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SuspendKmsContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SuspendKmsContext {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "SuspendKmsContext(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                133u8, 26u8, 8u8, 193u8, 107u8, 21u8, 149u8, 156u8, 51u8, 138u8, 196u8,
                181u8, 100u8, 102u8, 208u8, 108u8, 159u8, 157u8, 95u8, 248u8, 215u8,
                21u8, 22u8, 138u8, 161u8, 37u8, 213u8, 204u8, 175u8, 83u8, 131u8, 32u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { contextId: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SuspendKmsContext {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SuspendKmsContext> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SuspendKmsContext) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Unpaused(address)` and selector `0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa`.
```solidity
event Unpaused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Unpaused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Unpaused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Unpaused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                93u8, 185u8, 238u8, 10u8, 73u8, 91u8, 242u8, 230u8, 255u8, 156u8, 145u8,
                167u8, 131u8, 76u8, 27u8, 164u8, 253u8, 210u8, 68u8, 165u8, 232u8, 170u8,
                78u8, 83u8, 123u8, 211u8, 138u8, 234u8, 228u8, 176u8, 115u8, 170u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Unpaused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Unpaused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Unpaused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `UpdateKmsContextGenerationBlockPeriod(uint256)` and selector `0x53cb968d31c28c6504a6e73d9908db6e1c1a386b66dcacec1a0117752c5ab986`.
```solidity
event UpdateKmsContextGenerationBlockPeriod(uint256 newKmsContextGenerationBlockPeriod);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct UpdateKmsContextGenerationBlockPeriod {
        #[allow(missing_docs)]
        pub newKmsContextGenerationBlockPeriod: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for UpdateKmsContextGenerationBlockPeriod {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "UpdateKmsContextGenerationBlockPeriod(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                83u8, 203u8, 150u8, 141u8, 49u8, 194u8, 140u8, 101u8, 4u8, 166u8, 231u8,
                61u8, 153u8, 8u8, 219u8, 110u8, 28u8, 26u8, 56u8, 107u8, 102u8, 220u8,
                172u8, 236u8, 26u8, 1u8, 23u8, 117u8, 44u8, 90u8, 185u8, 134u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    newKmsContextGenerationBlockPeriod: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.newKmsContextGenerationBlockPeriod,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData
        for UpdateKmsContextGenerationBlockPeriod {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&UpdateKmsContextGenerationBlockPeriod>
        for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &UpdateKmsContextGenerationBlockPeriod,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `UpdateKmsContextSuspensionBlockPeriod(uint256)` and selector `0x3ad5c22724afab8ed2b578fb9b160c7f65f5abd0aad105752b7ba4e068a3e021`.
```solidity
event UpdateKmsContextSuspensionBlockPeriod(uint256 newKmsContextSuspensionBlockPeriod);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct UpdateKmsContextSuspensionBlockPeriod {
        #[allow(missing_docs)]
        pub newKmsContextSuspensionBlockPeriod: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for UpdateKmsContextSuspensionBlockPeriod {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "UpdateKmsContextSuspensionBlockPeriod(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                58u8, 213u8, 194u8, 39u8, 36u8, 175u8, 171u8, 142u8, 210u8, 181u8, 120u8,
                251u8, 155u8, 22u8, 12u8, 127u8, 101u8, 245u8, 171u8, 208u8, 170u8,
                209u8, 5u8, 117u8, 43u8, 123u8, 164u8, 224u8, 104u8, 163u8, 224u8, 33u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    newKmsContextSuspensionBlockPeriod: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.newKmsContextSuspensionBlockPeriod,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData
        for UpdateKmsContextSuspensionBlockPeriod {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&UpdateKmsContextSuspensionBlockPeriod>
        for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &UpdateKmsContextSuspensionBlockPeriod,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `UpdatePublicDecryptionThreshold(uint256)` and selector `0xe41802af725729adcb8c151e2937380a25c69155757e3af5d3979adab5035800`.
```solidity
event UpdatePublicDecryptionThreshold(uint256 newPublicDecryptionThreshold);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct UpdatePublicDecryptionThreshold {
        #[allow(missing_docs)]
        pub newPublicDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for UpdatePublicDecryptionThreshold {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "UpdatePublicDecryptionThreshold(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                228u8, 24u8, 2u8, 175u8, 114u8, 87u8, 41u8, 173u8, 203u8, 140u8, 21u8,
                30u8, 41u8, 55u8, 56u8, 10u8, 37u8, 198u8, 145u8, 85u8, 117u8, 126u8,
                58u8, 245u8, 211u8, 151u8, 154u8, 218u8, 181u8, 3u8, 88u8, 0u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    newPublicDecryptionThreshold: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.newPublicDecryptionThreshold,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for UpdatePublicDecryptionThreshold {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&UpdatePublicDecryptionThreshold>
        for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &UpdatePublicDecryptionThreshold,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `UpdateUserDecryptionThreshold(uint256)` and selector `0x837e0a6528dadfa2dc792692c5182e52a9f5bbdeed7b2372927a26c695839613`.
```solidity
event UpdateUserDecryptionThreshold(uint256 newUserDecryptionThreshold);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct UpdateUserDecryptionThreshold {
        #[allow(missing_docs)]
        pub newUserDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for UpdateUserDecryptionThreshold {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "UpdateUserDecryptionThreshold(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                131u8, 126u8, 10u8, 101u8, 40u8, 218u8, 223u8, 162u8, 220u8, 121u8, 38u8,
                146u8, 197u8, 24u8, 46u8, 82u8, 169u8, 245u8, 187u8, 222u8, 237u8, 123u8,
                35u8, 114u8, 146u8, 122u8, 38u8, 198u8, 149u8, 131u8, 150u8, 19u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    newUserDecryptionThreshold: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.newUserDecryptionThreshold,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for UpdateUserDecryptionThreshold {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&UpdateUserDecryptionThreshold> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &UpdateUserDecryptionThreshold,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Upgraded(address)` and selector `0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b`.
```solidity
event Upgraded(address indexed implementation);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Upgraded {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Upgraded {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Upgraded(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                188u8, 124u8, 215u8, 90u8, 32u8, 238u8, 39u8, 253u8, 154u8, 222u8, 186u8,
                179u8, 32u8, 65u8, 247u8, 85u8, 33u8, 77u8, 188u8, 107u8, 255u8, 169u8,
                12u8, 192u8, 34u8, 91u8, 57u8, 218u8, 46u8, 92u8, 45u8, 59u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { implementation: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.implementation.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.implementation,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Upgraded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Upgraded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Upgraded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ValidateKeyResharing((uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]))` and selector `0x68898a98936bf23a56e8ed4b23dcc98cef926bd9ac2ce522f1f9423e3864f2f5`.
```solidity
event ValidateKeyResharing(KmsContext newKmsContext);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ValidateKeyResharing {
        #[allow(missing_docs)]
        pub newKmsContext: <KmsContext as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ValidateKeyResharing {
            type DataTuple<'a> = (KmsContext,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ValidateKeyResharing((uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]))";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                104u8, 137u8, 138u8, 152u8, 147u8, 107u8, 242u8, 58u8, 86u8, 232u8,
                237u8, 75u8, 35u8, 220u8, 201u8, 140u8, 239u8, 146u8, 107u8, 217u8,
                172u8, 44u8, 229u8, 34u8, 241u8, 249u8, 66u8, 62u8, 56u8, 100u8, 242u8,
                245u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { newKmsContext: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <KmsContext as alloy_sol_types::SolType>::tokenize(
                        &self.newKmsContext,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ValidateKeyResharing {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ValidateKeyResharing> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ValidateKeyResharing) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {}
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `UPGRADE_INTERFACE_VERSION()` and selector `0xad3cb1cc`.
```solidity
function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`UPGRADE_INTERFACE_VERSION()`](UPGRADE_INTERFACE_VERSIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for UPGRADE_INTERFACE_VERSIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = UPGRADE_INTERFACE_VERSIONReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UPGRADE_INTERFACE_VERSION()";
            const SELECTOR: [u8; 4] = [173u8, 60u8, 177u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `acceptOwnership()` and selector `0x79ba5097`.
```solidity
function acceptOwnership() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct acceptOwnershipCall {}
    ///Container type for the return parameters of the [`acceptOwnership()`](acceptOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct acceptOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<acceptOwnershipCall> for UnderlyingRustTuple<'_> {
                fn from(value: acceptOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for acceptOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<acceptOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: acceptOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for acceptOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for acceptOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = acceptOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "acceptOwnership()";
            const SELECTOR: [u8; 4] = [121u8, 186u8, 80u8, 151u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `addKmsContext(uint256,bytes8,bool,uint256,(string,address,address,uint256,bytes,string,string,bytes)[],(uint256,uint256))` and selector `0x169cac14`.
```solidity
function addKmsContext(uint256 preActivationBlockPeriod, bytes8 softwareVersion, bool reshareKeys, uint256 mpcThreshold, KmsNode[] memory kmsNodes, DecryptionThresholds memory decryptionThresholds) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addKmsContextCall {
        #[allow(missing_docs)]
        pub preActivationBlockPeriod: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub softwareVersion: alloy::sol_types::private::FixedBytes<8>,
        #[allow(missing_docs)]
        pub reshareKeys: bool,
        #[allow(missing_docs)]
        pub mpcThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub kmsNodes: alloy::sol_types::private::Vec<
            <KmsNode as alloy::sol_types::SolType>::RustType,
        >,
        #[allow(missing_docs)]
        pub decryptionThresholds: <DecryptionThresholds as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`addKmsContext(uint256,bytes8,bool,uint256,(string,address,address,uint256,bytes,string,string,bytes)[],(uint256,uint256))`](addKmsContextCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addKmsContextReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<8>,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<KmsNode>,
                DecryptionThresholds,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<8>,
                bool,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Vec<
                    <KmsNode as alloy::sol_types::SolType>::RustType,
                >,
                <DecryptionThresholds as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addKmsContextCall> for UnderlyingRustTuple<'_> {
                fn from(value: addKmsContextCall) -> Self {
                    (
                        value.preActivationBlockPeriod,
                        value.softwareVersion,
                        value.reshareKeys,
                        value.mpcThreshold,
                        value.kmsNodes,
                        value.decryptionThresholds,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addKmsContextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        preActivationBlockPeriod: tuple.0,
                        softwareVersion: tuple.1,
                        reshareKeys: tuple.2,
                        mpcThreshold: tuple.3,
                        kmsNodes: tuple.4,
                        decryptionThresholds: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addKmsContextReturn> for UnderlyingRustTuple<'_> {
                fn from(value: addKmsContextReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addKmsContextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addKmsContextCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<8>,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<KmsNode>,
                DecryptionThresholds,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addKmsContextReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addKmsContext(uint256,bytes8,bool,uint256,(string,address,address,uint256,bytes,string,string,bytes)[],(uint256,uint256))";
            const SELECTOR: [u8; 4] = [22u8, 156u8, 172u8, 20u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.preActivationBlockPeriod,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.softwareVersion),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.reshareKeys,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.mpcThreshold),
                    <alloy::sol_types::sol_data::Array<
                        KmsNode,
                    > as alloy_sol_types::SolType>::tokenize(&self.kmsNodes),
                    <DecryptionThresholds as alloy_sol_types::SolType>::tokenize(
                        &self.decryptionThresholds,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkIsKmsSignerFromContext(uint256,address)` and selector `0xdfe36aee`.
```solidity
function checkIsKmsSignerFromContext(uint256 contextId, address signerAddress) external view;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsKmsSignerFromContextCall {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub signerAddress: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkIsKmsSignerFromContext(uint256,address)`](checkIsKmsSignerFromContextCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsKmsSignerFromContextReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsKmsSignerFromContextCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsKmsSignerFromContextCall) -> Self {
                    (value.contextId, value.signerAddress)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsKmsSignerFromContextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        contextId: tuple.0,
                        signerAddress: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsKmsSignerFromContextReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsKmsSignerFromContextReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsKmsSignerFromContextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkIsKmsSignerFromContextCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkIsKmsSignerFromContextReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkIsKmsSignerFromContext(uint256,address)";
            const SELECTOR: [u8; 4] = [223u8, 227u8, 106u8, 238u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signerAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkIsKmsTxSenderFromContext(uint256,address)` and selector `0xdefba06a`.
```solidity
function checkIsKmsTxSenderFromContext(uint256 contextId, address txSenderAddress) external view;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsKmsTxSenderFromContextCall {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub txSenderAddress: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkIsKmsTxSenderFromContext(uint256,address)`](checkIsKmsTxSenderFromContextCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsKmsTxSenderFromContextReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsKmsTxSenderFromContextCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsKmsTxSenderFromContextCall) -> Self {
                    (value.contextId, value.txSenderAddress)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsKmsTxSenderFromContextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        contextId: tuple.0,
                        txSenderAddress: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsKmsTxSenderFromContextReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsKmsTxSenderFromContextReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsKmsTxSenderFromContextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkIsKmsTxSenderFromContextCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkIsKmsTxSenderFromContextReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkIsKmsTxSenderFromContext(uint256,address)";
            const SELECTOR: [u8; 4] = [222u8, 251u8, 160u8, 106u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.txSenderAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `compromiseKmsContext(uint256)` and selector `0x9ee77af3`.
```solidity
function compromiseKmsContext(uint256 contextId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct compromiseKmsContextCall {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`compromiseKmsContext(uint256)`](compromiseKmsContextCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct compromiseKmsContextReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<compromiseKmsContextCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: compromiseKmsContextCall) -> Self {
                    (value.contextId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for compromiseKmsContextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { contextId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<compromiseKmsContextReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: compromiseKmsContextReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for compromiseKmsContextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for compromiseKmsContextCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = compromiseKmsContextReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "compromiseKmsContext(uint256)";
            const SELECTOR: [u8; 4] = [158u8, 231u8, 122u8, 243u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `destroyKmsContext(uint256)` and selector `0xc0ae64f7`.
```solidity
function destroyKmsContext(uint256 contextId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct destroyKmsContextCall {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`destroyKmsContext(uint256)`](destroyKmsContextCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct destroyKmsContextReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<destroyKmsContextCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: destroyKmsContextCall) -> Self {
                    (value.contextId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for destroyKmsContextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { contextId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<destroyKmsContextReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: destroyKmsContextReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for destroyKmsContextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for destroyKmsContextCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = destroyKmsContextReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "destroyKmsContext(uint256)";
            const SELECTOR: [u8; 4] = [192u8, 174u8, 100u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `eip712Domain()` and selector `0x84b0196e`.
```solidity
function eip712Domain() external view returns (bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] memory extensions);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eip712DomainCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`eip712Domain()`](eip712DomainCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eip712DomainReturn {
        #[allow(missing_docs)]
        pub fields: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub name: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub version: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub verifyingContract: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub salt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub extensions: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eip712DomainCall> for UnderlyingRustTuple<'_> {
                fn from(value: eip712DomainCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eip712DomainCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eip712DomainReturn> for UnderlyingRustTuple<'_> {
                fn from(value: eip712DomainReturn) -> Self {
                    (
                        value.fields,
                        value.name,
                        value.version,
                        value.chainId,
                        value.verifyingContract,
                        value.salt,
                        value.extensions,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eip712DomainReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        fields: tuple.0,
                        name: tuple.1,
                        version: tuple.2,
                        chainId: tuple.3,
                        verifyingContract: tuple.4,
                        salt: tuple.5,
                        extensions: tuple.6,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for eip712DomainCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = eip712DomainReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "eip712Domain()";
            const SELECTOR: [u8; 4] = [132u8, 176u8, 25u8, 110u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getActiveKmsContext()` and selector `0x0dd486c0`.
```solidity
function getActiveKmsContext() external view returns (KmsContext memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getActiveKmsContextCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getActiveKmsContext()`](getActiveKmsContextCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getActiveKmsContextReturn {
        #[allow(missing_docs)]
        pub _0: <KmsContext as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getActiveKmsContextCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getActiveKmsContextCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getActiveKmsContextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (KmsContext,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <KmsContext as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getActiveKmsContextReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getActiveKmsContextReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getActiveKmsContextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getActiveKmsContextCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getActiveKmsContextReturn;
            type ReturnTuple<'a> = (KmsContext,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getActiveKmsContext()";
            const SELECTOR: [u8; 4] = [13u8, 212u8, 134u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getActiveKmsContextId()` and selector `0x43e37e8a`.
```solidity
function getActiveKmsContextId() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getActiveKmsContextIdCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getActiveKmsContextId()`](getActiveKmsContextIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getActiveKmsContextIdReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getActiveKmsContextIdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getActiveKmsContextIdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getActiveKmsContextIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getActiveKmsContextIdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getActiveKmsContextIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getActiveKmsContextIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getActiveKmsContextIdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getActiveKmsContextIdReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getActiveKmsContextId()";
            const SELECTOR: [u8; 4] = [67u8, 227u8, 126u8, 138u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getKmsContextGenerationBlockPeriod()` and selector `0x4965e455`.
```solidity
function getKmsContextGenerationBlockPeriod() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsContextGenerationBlockPeriodCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getKmsContextGenerationBlockPeriod()`](getKmsContextGenerationBlockPeriodCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsContextGenerationBlockPeriodReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsContextGenerationBlockPeriodCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsContextGenerationBlockPeriodCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsContextGenerationBlockPeriodCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsContextGenerationBlockPeriodReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsContextGenerationBlockPeriodReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsContextGenerationBlockPeriodReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsContextGenerationBlockPeriodCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsContextGenerationBlockPeriodReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsContextGenerationBlockPeriod()";
            const SELECTOR: [u8; 4] = [73u8, 101u8, 228u8, 85u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getKmsContextStatus(uint256)` and selector `0x4d694260`.
```solidity
function getKmsContextStatus(uint256 contextId) external view returns (ContextStatus);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsContextStatusCall {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getKmsContextStatus(uint256)`](getKmsContextStatusCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsContextStatusReturn {
        #[allow(missing_docs)]
        pub _0: <ContextStatus as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsContextStatusCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsContextStatusCall) -> Self {
                    (value.contextId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsContextStatusCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { contextId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ContextStatus,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ContextStatus as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsContextStatusReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsContextStatusReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsContextStatusReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsContextStatusCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsContextStatusReturn;
            type ReturnTuple<'a> = (ContextStatus,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsContextStatus(uint256)";
            const SELECTOR: [u8; 4] = [77u8, 105u8, 66u8, 96u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getKmsContextSuspensionBlockPeriod()` and selector `0xd8e3ae01`.
```solidity
function getKmsContextSuspensionBlockPeriod() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsContextSuspensionBlockPeriodCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getKmsContextSuspensionBlockPeriod()`](getKmsContextSuspensionBlockPeriodCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsContextSuspensionBlockPeriodReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsContextSuspensionBlockPeriodCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsContextSuspensionBlockPeriodCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsContextSuspensionBlockPeriodCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsContextSuspensionBlockPeriodReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsContextSuspensionBlockPeriodReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsContextSuspensionBlockPeriodReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsContextSuspensionBlockPeriodCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsContextSuspensionBlockPeriodReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsContextSuspensionBlockPeriod()";
            const SELECTOR: [u8; 4] = [216u8, 227u8, 174u8, 1u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getKmsNode(address)` and selector `0xe3b2a874`.
```solidity
function getKmsNode(address kmsTxSenderAddress) external view returns (KmsNode memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsNodeCall {
        #[allow(missing_docs)]
        pub kmsTxSenderAddress: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getKmsNode(address)`](getKmsNodeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsNodeReturn {
        #[allow(missing_docs)]
        pub _0: <KmsNode as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsNodeCall> for UnderlyingRustTuple<'_> {
                fn from(value: getKmsNodeCall) -> Self {
                    (value.kmsTxSenderAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getKmsNodeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        kmsTxSenderAddress: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (KmsNode,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <KmsNode as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsNodeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getKmsNodeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getKmsNodeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsNodeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsNodeReturn;
            type ReturnTuple<'a> = (KmsNode,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsNode(address)";
            const SELECTOR: [u8; 4] = [227u8, 178u8, 168u8, 116u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.kmsTxSenderAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getKmsNodes()` and selector `0xe72ee991`.
```solidity
function getKmsNodes() external view returns (KmsNode[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsNodesCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getKmsNodes()`](getKmsNodesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsNodesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<
            <KmsNode as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsNodesCall> for UnderlyingRustTuple<'_> {
                fn from(value: getKmsNodesCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getKmsNodesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Array<KmsNode>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    <KmsNode as alloy::sol_types::SolType>::RustType,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsNodesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getKmsNodesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getKmsNodesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsNodesCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsNodesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Array<KmsNode>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsNodes()";
            const SELECTOR: [u8; 4] = [231u8, 46u8, 233u8, 145u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getKmsSigners()` and selector `0x7eaac8f2`.
```solidity
function getKmsSigners() external view returns (address[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsSignersCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getKmsSigners()`](getKmsSignersCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsSignersReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsSignersCall> for UnderlyingRustTuple<'_> {
                fn from(value: getKmsSignersCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getKmsSignersCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsSignersReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getKmsSignersReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getKmsSignersReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsSignersCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsSignersReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsSigners()";
            const SELECTOR: [u8; 4] = [126u8, 170u8, 200u8, 242u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getKmsTxSenders()` and selector `0x7420f3d4`.
```solidity
function getKmsTxSenders() external view returns (address[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsTxSendersCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getKmsTxSenders()`](getKmsTxSendersCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsTxSendersReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsTxSendersCall> for UnderlyingRustTuple<'_> {
                fn from(value: getKmsTxSendersCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getKmsTxSendersCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsTxSendersReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsTxSendersReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsTxSendersReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsTxSendersCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsTxSendersReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsTxSenders()";
            const SELECTOR: [u8; 4] = [116u8, 32u8, 243u8, 212u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getPublicDecryptionThresholdFromContext(uint256)` and selector `0xb8715d4d`.
```solidity
function getPublicDecryptionThresholdFromContext(uint256 contextId) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPublicDecryptionThresholdFromContextCall {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getPublicDecryptionThresholdFromContext(uint256)`](getPublicDecryptionThresholdFromContextCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPublicDecryptionThresholdFromContextReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPublicDecryptionThresholdFromContextCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPublicDecryptionThresholdFromContextCall) -> Self {
                    (value.contextId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPublicDecryptionThresholdFromContextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { contextId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPublicDecryptionThresholdFromContextReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPublicDecryptionThresholdFromContextReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPublicDecryptionThresholdFromContextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPublicDecryptionThresholdFromContextCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPublicDecryptionThresholdFromContextReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPublicDecryptionThresholdFromContext(uint256)";
            const SELECTOR: [u8; 4] = [184u8, 113u8, 93u8, 77u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getSuspendedKmsContextId()` and selector `0x0a50e318`.
```solidity
function getSuspendedKmsContextId() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSuspendedKmsContextIdCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getSuspendedKmsContextId()`](getSuspendedKmsContextIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSuspendedKmsContextIdReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSuspendedKmsContextIdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getSuspendedKmsContextIdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getSuspendedKmsContextIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSuspendedKmsContextIdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getSuspendedKmsContextIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getSuspendedKmsContextIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getSuspendedKmsContextIdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getSuspendedKmsContextIdReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getSuspendedKmsContextId()";
            const SELECTOR: [u8; 4] = [10u8, 80u8, 227u8, 24u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getUserDecryptionThresholdFromContext(uint256)` and selector `0x64b00cc5`.
```solidity
function getUserDecryptionThresholdFromContext(uint256 contextId) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUserDecryptionThresholdFromContextCall {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getUserDecryptionThresholdFromContext(uint256)`](getUserDecryptionThresholdFromContextCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUserDecryptionThresholdFromContextReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUserDecryptionThresholdFromContextCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getUserDecryptionThresholdFromContextCall) -> Self {
                    (value.contextId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getUserDecryptionThresholdFromContextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { contextId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUserDecryptionThresholdFromContextReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getUserDecryptionThresholdFromContextReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getUserDecryptionThresholdFromContextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getUserDecryptionThresholdFromContextCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getUserDecryptionThresholdFromContextReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getUserDecryptionThresholdFromContext(uint256)";
            const SELECTOR: [u8; 4] = [100u8, 176u8, 12u8, 197u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getVersion()` and selector `0x0d8e6e2c`.
```solidity
function getVersion() external pure returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVersionCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getVersion()`](getVersionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVersionReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVersionCall> for UnderlyingRustTuple<'_> {
                fn from(value: getVersionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVersionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVersionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getVersionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVersionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getVersionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getVersionReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getVersion()";
            const SELECTOR: [u8; 4] = [13u8, 142u8, 110u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `initialize((uint256,uint256),(uint256,uint256,uint256),bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[])` and selector `0xedc44f19`.
```solidity
function initialize(DecryptionThresholds memory initialDecryptionThresholds, KmsBlockPeriods memory initialBlockPeriods, bytes8 initialSoftwareVersion, uint256 initialMpcThreshold, KmsNode[] memory initialKmsNodes) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeCall {
        #[allow(missing_docs)]
        pub initialDecryptionThresholds: <DecryptionThresholds as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub initialBlockPeriods: <KmsBlockPeriods as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub initialSoftwareVersion: alloy::sol_types::private::FixedBytes<8>,
        #[allow(missing_docs)]
        pub initialMpcThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub initialKmsNodes: alloy::sol_types::private::Vec<
            <KmsNode as alloy::sol_types::SolType>::RustType,
        >,
    }
    ///Container type for the return parameters of the [`initialize((uint256,uint256),(uint256,uint256,uint256),bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[])`](initializeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                DecryptionThresholds,
                KmsBlockPeriods,
                alloy::sol_types::sol_data::FixedBytes<8>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<KmsNode>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <DecryptionThresholds as alloy::sol_types::SolType>::RustType,
                <KmsBlockPeriods as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<8>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Vec<
                    <KmsNode as alloy::sol_types::SolType>::RustType,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeCall> for UnderlyingRustTuple<'_> {
                fn from(value: initializeCall) -> Self {
                    (
                        value.initialDecryptionThresholds,
                        value.initialBlockPeriods,
                        value.initialSoftwareVersion,
                        value.initialMpcThreshold,
                        value.initialKmsNodes,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        initialDecryptionThresholds: tuple.0,
                        initialBlockPeriods: tuple.1,
                        initialSoftwareVersion: tuple.2,
                        initialMpcThreshold: tuple.3,
                        initialKmsNodes: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: initializeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeCall {
            type Parameters<'a> = (
                DecryptionThresholds,
                KmsBlockPeriods,
                alloy::sol_types::sol_data::FixedBytes<8>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<KmsNode>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initialize((uint256,uint256),(uint256,uint256,uint256),bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[])";
            const SELECTOR: [u8; 4] = [237u8, 196u8, 79u8, 25u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <DecryptionThresholds as alloy_sol_types::SolType>::tokenize(
                        &self.initialDecryptionThresholds,
                    ),
                    <KmsBlockPeriods as alloy_sol_types::SolType>::tokenize(
                        &self.initialBlockPeriods,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.initialSoftwareVersion,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.initialMpcThreshold),
                    <alloy::sol_types::sol_data::Array<
                        KmsNode,
                    > as alloy_sol_types::SolType>::tokenize(&self.initialKmsNodes),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `moveSuspendedKmsContextToActive()` and selector `0xf27cb957`.
```solidity
function moveSuspendedKmsContextToActive() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct moveSuspendedKmsContextToActiveCall {}
    ///Container type for the return parameters of the [`moveSuspendedKmsContextToActive()`](moveSuspendedKmsContextToActiveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct moveSuspendedKmsContextToActiveReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<moveSuspendedKmsContextToActiveCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: moveSuspendedKmsContextToActiveCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for moveSuspendedKmsContextToActiveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<moveSuspendedKmsContextToActiveReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: moveSuspendedKmsContextToActiveReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for moveSuspendedKmsContextToActiveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for moveSuspendedKmsContextToActiveCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = moveSuspendedKmsContextToActiveReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "moveSuspendedKmsContextToActive()";
            const SELECTOR: [u8; 4] = [242u8, 124u8, 185u8, 87u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ownerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `pause()` and selector `0x8456cb59`.
```solidity
function pause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseCall {}
    ///Container type for the return parameters of the [`pause()`](pauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pause()";
            const SELECTOR: [u8; 4] = [132u8, 86u8, 203u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `paused()` and selector `0x5c975abb`.
```solidity
function paused() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`paused()`](pausedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedCall> for UnderlyingRustTuple<'_> {
                fn from(value: pausedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pausedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pausedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pausedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "paused()";
            const SELECTOR: [u8; 4] = [92u8, 151u8, 90u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `pendingOwner()` and selector `0xe30c3978`.
```solidity
function pendingOwner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingOwnerCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`pendingOwner()`](pendingOwnerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingOwnerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingOwnerCall> for UnderlyingRustTuple<'_> {
                fn from(value: pendingOwnerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pendingOwnerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingOwnerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pendingOwnerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pendingOwnerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pendingOwnerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pendingOwnerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pendingOwner()";
            const SELECTOR: [u8; 4] = [227u8, 12u8, 57u8, 120u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `proxiableUUID()` and selector `0x52d1902d`.
```solidity
function proxiableUUID() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`proxiableUUID()`](proxiableUUIDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDCall> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proxiableUUIDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = proxiableUUIDReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "proxiableUUID()";
            const SELECTOR: [u8; 4] = [82u8, 209u8, 144u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `refreshKmsContextStatuses()` and selector `0x8cb96751`.
```solidity
function refreshKmsContextStatuses() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct refreshKmsContextStatusesCall {}
    ///Container type for the return parameters of the [`refreshKmsContextStatuses()`](refreshKmsContextStatusesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct refreshKmsContextStatusesReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<refreshKmsContextStatusesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: refreshKmsContextStatusesCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for refreshKmsContextStatusesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<refreshKmsContextStatusesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: refreshKmsContextStatusesReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for refreshKmsContextStatusesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for refreshKmsContextStatusesCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = refreshKmsContextStatusesReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "refreshKmsContextStatuses()";
            const SELECTOR: [u8; 4] = [140u8, 185u8, 103u8, 81u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `renounceOwnership()` and selector `0x715018a6`.
```solidity
function renounceOwnership() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall {}
    ///Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address newOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `unpause()` and selector `0x3f4ba83a`.
```solidity
function unpause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseCall {}
    ///Container type for the return parameters of the [`unpause()`](unpauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unpauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = unpauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unpause()";
            const SELECTOR: [u8; 4] = [63u8, 75u8, 168u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `updateKmsContextGenerationBlockPeriod(uint256)` and selector `0xe24ba4e5`.
```solidity
function updateKmsContextGenerationBlockPeriod(uint256 newKmsContextGenerationBlockPeriod) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateKmsContextGenerationBlockPeriodCall {
        #[allow(missing_docs)]
        pub newKmsContextGenerationBlockPeriod: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`updateKmsContextGenerationBlockPeriod(uint256)`](updateKmsContextGenerationBlockPeriodCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateKmsContextGenerationBlockPeriodReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateKmsContextGenerationBlockPeriodCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateKmsContextGenerationBlockPeriodCall) -> Self {
                    (value.newKmsContextGenerationBlockPeriod,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateKmsContextGenerationBlockPeriodCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newKmsContextGenerationBlockPeriod: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateKmsContextGenerationBlockPeriodReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateKmsContextGenerationBlockPeriodReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateKmsContextGenerationBlockPeriodReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateKmsContextGenerationBlockPeriodCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateKmsContextGenerationBlockPeriodReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateKmsContextGenerationBlockPeriod(uint256)";
            const SELECTOR: [u8; 4] = [226u8, 75u8, 164u8, 229u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.newKmsContextGenerationBlockPeriod,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `updateKmsContextSuspensionBlockPeriod(uint256)` and selector `0xc1c8b725`.
```solidity
function updateKmsContextSuspensionBlockPeriod(uint256 newKmsContextSuspensionBlockPeriod) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateKmsContextSuspensionBlockPeriodCall {
        #[allow(missing_docs)]
        pub newKmsContextSuspensionBlockPeriod: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`updateKmsContextSuspensionBlockPeriod(uint256)`](updateKmsContextSuspensionBlockPeriodCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateKmsContextSuspensionBlockPeriodReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateKmsContextSuspensionBlockPeriodCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateKmsContextSuspensionBlockPeriodCall) -> Self {
                    (value.newKmsContextSuspensionBlockPeriod,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateKmsContextSuspensionBlockPeriodCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newKmsContextSuspensionBlockPeriod: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateKmsContextSuspensionBlockPeriodReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateKmsContextSuspensionBlockPeriodReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateKmsContextSuspensionBlockPeriodReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateKmsContextSuspensionBlockPeriodCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateKmsContextSuspensionBlockPeriodReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateKmsContextSuspensionBlockPeriod(uint256)";
            const SELECTOR: [u8; 4] = [193u8, 200u8, 183u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.newKmsContextSuspensionBlockPeriod,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `updatePublicDecryptionThreshold(uint256)` and selector `0x2e2d3a82`.
```solidity
function updatePublicDecryptionThreshold(uint256 newPublicDecryptionThreshold) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updatePublicDecryptionThresholdCall {
        #[allow(missing_docs)]
        pub newPublicDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`updatePublicDecryptionThreshold(uint256)`](updatePublicDecryptionThresholdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updatePublicDecryptionThresholdReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updatePublicDecryptionThresholdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updatePublicDecryptionThresholdCall) -> Self {
                    (value.newPublicDecryptionThreshold,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updatePublicDecryptionThresholdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newPublicDecryptionThreshold: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updatePublicDecryptionThresholdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updatePublicDecryptionThresholdReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updatePublicDecryptionThresholdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updatePublicDecryptionThresholdCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updatePublicDecryptionThresholdReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updatePublicDecryptionThreshold(uint256)";
            const SELECTOR: [u8; 4] = [46u8, 45u8, 58u8, 130u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.newPublicDecryptionThreshold,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `updateUserDecryptionThreshold(uint256)` and selector `0xeb843cf6`.
```solidity
function updateUserDecryptionThreshold(uint256 newUserDecryptionThreshold) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateUserDecryptionThresholdCall {
        #[allow(missing_docs)]
        pub newUserDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`updateUserDecryptionThreshold(uint256)`](updateUserDecryptionThresholdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateUserDecryptionThresholdReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateUserDecryptionThresholdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateUserDecryptionThresholdCall) -> Self {
                    (value.newUserDecryptionThreshold,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateUserDecryptionThresholdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newUserDecryptionThreshold: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateUserDecryptionThresholdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateUserDecryptionThresholdReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateUserDecryptionThresholdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateUserDecryptionThresholdCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateUserDecryptionThresholdReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateUserDecryptionThreshold(uint256)";
            const SELECTOR: [u8; 4] = [235u8, 132u8, 60u8, 246u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.newUserDecryptionThreshold,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `upgradeToAndCall(address,bytes)` and selector `0x4f1ef286`.
```solidity
function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallCall {
        #[allow(missing_docs)]
        pub newImplementation: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`upgradeToAndCall(address,bytes)`](upgradeToAndCallCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallCall) -> Self {
                    (value.newImplementation, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newImplementation: tuple.0,
                        data: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for upgradeToAndCallCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = upgradeToAndCallReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "upgradeToAndCall(address,bytes)";
            const SELECTOR: [u8; 4] = [79u8, 30u8, 242u8, 134u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newImplementation,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `validateKeyResharing(uint256,bytes)` and selector `0x1079ebeb`.
```solidity
function validateKeyResharing(uint256 contextId, bytes memory signature) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct validateKeyResharingCall {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub signature: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`validateKeyResharing(uint256,bytes)`](validateKeyResharingCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct validateKeyResharingReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<validateKeyResharingCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: validateKeyResharingCall) -> Self {
                    (value.contextId, value.signature)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for validateKeyResharingCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        contextId: tuple.0,
                        signature: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<validateKeyResharingReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: validateKeyResharingReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for validateKeyResharingReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for validateKeyResharingCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = validateKeyResharingReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "validateKeyResharing(uint256,bytes)";
            const SELECTOR: [u8; 4] = [16u8, 121u8, 235u8, 235u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.signature,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`KmsContexts`](self) function calls.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum KmsContextsCalls {
        #[allow(missing_docs)]
        UPGRADE_INTERFACE_VERSION(UPGRADE_INTERFACE_VERSIONCall),
        #[allow(missing_docs)]
        acceptOwnership(acceptOwnershipCall),
        #[allow(missing_docs)]
        addKmsContext(addKmsContextCall),
        #[allow(missing_docs)]
        checkIsKmsSignerFromContext(checkIsKmsSignerFromContextCall),
        #[allow(missing_docs)]
        checkIsKmsTxSenderFromContext(checkIsKmsTxSenderFromContextCall),
        #[allow(missing_docs)]
        compromiseKmsContext(compromiseKmsContextCall),
        #[allow(missing_docs)]
        destroyKmsContext(destroyKmsContextCall),
        #[allow(missing_docs)]
        eip712Domain(eip712DomainCall),
        #[allow(missing_docs)]
        getActiveKmsContext(getActiveKmsContextCall),
        #[allow(missing_docs)]
        getActiveKmsContextId(getActiveKmsContextIdCall),
        #[allow(missing_docs)]
        getKmsContextGenerationBlockPeriod(getKmsContextGenerationBlockPeriodCall),
        #[allow(missing_docs)]
        getKmsContextStatus(getKmsContextStatusCall),
        #[allow(missing_docs)]
        getKmsContextSuspensionBlockPeriod(getKmsContextSuspensionBlockPeriodCall),
        #[allow(missing_docs)]
        getKmsNode(getKmsNodeCall),
        #[allow(missing_docs)]
        getKmsNodes(getKmsNodesCall),
        #[allow(missing_docs)]
        getKmsSigners(getKmsSignersCall),
        #[allow(missing_docs)]
        getKmsTxSenders(getKmsTxSendersCall),
        #[allow(missing_docs)]
        getPublicDecryptionThresholdFromContext(
            getPublicDecryptionThresholdFromContextCall,
        ),
        #[allow(missing_docs)]
        getSuspendedKmsContextId(getSuspendedKmsContextIdCall),
        #[allow(missing_docs)]
        getUserDecryptionThresholdFromContext(getUserDecryptionThresholdFromContextCall),
        #[allow(missing_docs)]
        getVersion(getVersionCall),
        #[allow(missing_docs)]
        initialize(initializeCall),
        #[allow(missing_docs)]
        moveSuspendedKmsContextToActive(moveSuspendedKmsContextToActiveCall),
        #[allow(missing_docs)]
        owner(ownerCall),
        #[allow(missing_docs)]
        pause(pauseCall),
        #[allow(missing_docs)]
        paused(pausedCall),
        #[allow(missing_docs)]
        pendingOwner(pendingOwnerCall),
        #[allow(missing_docs)]
        proxiableUUID(proxiableUUIDCall),
        #[allow(missing_docs)]
        refreshKmsContextStatuses(refreshKmsContextStatusesCall),
        #[allow(missing_docs)]
        renounceOwnership(renounceOwnershipCall),
        #[allow(missing_docs)]
        transferOwnership(transferOwnershipCall),
        #[allow(missing_docs)]
        unpause(unpauseCall),
        #[allow(missing_docs)]
        updateKmsContextGenerationBlockPeriod(updateKmsContextGenerationBlockPeriodCall),
        #[allow(missing_docs)]
        updateKmsContextSuspensionBlockPeriod(updateKmsContextSuspensionBlockPeriodCall),
        #[allow(missing_docs)]
        updatePublicDecryptionThreshold(updatePublicDecryptionThresholdCall),
        #[allow(missing_docs)]
        updateUserDecryptionThreshold(updateUserDecryptionThresholdCall),
        #[allow(missing_docs)]
        upgradeToAndCall(upgradeToAndCallCall),
        #[allow(missing_docs)]
        validateKeyResharing(validateKeyResharingCall),
    }
    #[automatically_derived]
    impl KmsContextsCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [10u8, 80u8, 227u8, 24u8],
            [13u8, 142u8, 110u8, 44u8],
            [13u8, 212u8, 134u8, 192u8],
            [16u8, 121u8, 235u8, 235u8],
            [22u8, 156u8, 172u8, 20u8],
            [46u8, 45u8, 58u8, 130u8],
            [63u8, 75u8, 168u8, 58u8],
            [67u8, 227u8, 126u8, 138u8],
            [73u8, 101u8, 228u8, 85u8],
            [77u8, 105u8, 66u8, 96u8],
            [79u8, 30u8, 242u8, 134u8],
            [82u8, 209u8, 144u8, 45u8],
            [92u8, 151u8, 90u8, 187u8],
            [100u8, 176u8, 12u8, 197u8],
            [113u8, 80u8, 24u8, 166u8],
            [116u8, 32u8, 243u8, 212u8],
            [121u8, 186u8, 80u8, 151u8],
            [126u8, 170u8, 200u8, 242u8],
            [132u8, 86u8, 203u8, 89u8],
            [132u8, 176u8, 25u8, 110u8],
            [140u8, 185u8, 103u8, 81u8],
            [141u8, 165u8, 203u8, 91u8],
            [158u8, 231u8, 122u8, 243u8],
            [173u8, 60u8, 177u8, 204u8],
            [184u8, 113u8, 93u8, 77u8],
            [192u8, 174u8, 100u8, 247u8],
            [193u8, 200u8, 183u8, 37u8],
            [216u8, 227u8, 174u8, 1u8],
            [222u8, 251u8, 160u8, 106u8],
            [223u8, 227u8, 106u8, 238u8],
            [226u8, 75u8, 164u8, 229u8],
            [227u8, 12u8, 57u8, 120u8],
            [227u8, 178u8, 168u8, 116u8],
            [231u8, 46u8, 233u8, 145u8],
            [235u8, 132u8, 60u8, 246u8],
            [237u8, 196u8, 79u8, 25u8],
            [242u8, 124u8, 185u8, 87u8],
            [242u8, 253u8, 227u8, 139u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for KmsContextsCalls {
        const NAME: &'static str = "KmsContextsCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 38usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(_) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::acceptOwnership(_) => {
                    <acceptOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::addKmsContext(_) => {
                    <addKmsContextCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkIsKmsSignerFromContext(_) => {
                    <checkIsKmsSignerFromContextCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkIsKmsTxSenderFromContext(_) => {
                    <checkIsKmsTxSenderFromContextCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::compromiseKmsContext(_) => {
                    <compromiseKmsContextCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::destroyKmsContext(_) => {
                    <destroyKmsContextCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::eip712Domain(_) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getActiveKmsContext(_) => {
                    <getActiveKmsContextCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getActiveKmsContextId(_) => {
                    <getActiveKmsContextIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsContextGenerationBlockPeriod(_) => {
                    <getKmsContextGenerationBlockPeriodCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsContextStatus(_) => {
                    <getKmsContextStatusCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsContextSuspensionBlockPeriod(_) => {
                    <getKmsContextSuspensionBlockPeriodCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsNode(_) => {
                    <getKmsNodeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsNodes(_) => {
                    <getKmsNodesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsSigners(_) => {
                    <getKmsSignersCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsTxSenders(_) => {
                    <getKmsTxSendersCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPublicDecryptionThresholdFromContext(_) => {
                    <getPublicDecryptionThresholdFromContextCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getSuspendedKmsContextId(_) => {
                    <getSuspendedKmsContextIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getUserDecryptionThresholdFromContext(_) => {
                    <getUserDecryptionThresholdFromContextCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getVersion(_) => {
                    <getVersionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initialize(_) => {
                    <initializeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::moveSuspendedKmsContextToActive(_) => {
                    <moveSuspendedKmsContextToActiveCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pause(_) => <pauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::paused(_) => <pausedCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pendingOwner(_) => {
                    <pendingOwnerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::proxiableUUID(_) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::refreshKmsContextStatuses(_) => {
                    <refreshKmsContextStatusesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceOwnership(_) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::unpause(_) => <unpauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::updateKmsContextGenerationBlockPeriod(_) => {
                    <updateKmsContextGenerationBlockPeriodCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateKmsContextSuspensionBlockPeriod(_) => {
                    <updateKmsContextSuspensionBlockPeriodCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updatePublicDecryptionThreshold(_) => {
                    <updatePublicDecryptionThresholdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateUserDecryptionThreshold(_) => {
                    <updateUserDecryptionThresholdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::upgradeToAndCall(_) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::validateKeyResharing(_) => {
                    <validateKeyResharingCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<KmsContextsCalls>] = &[
                {
                    fn getSuspendedKmsContextId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getSuspendedKmsContextIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getSuspendedKmsContextId)
                    }
                    getSuspendedKmsContextId
                },
                {
                    fn getVersion(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getVersionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getVersion)
                    }
                    getVersion
                },
                {
                    fn getActiveKmsContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getActiveKmsContextCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getActiveKmsContext)
                    }
                    getActiveKmsContext
                },
                {
                    fn validateKeyResharing(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <validateKeyResharingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::validateKeyResharing)
                    }
                    validateKeyResharing
                },
                {
                    fn addKmsContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <addKmsContextCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::addKmsContext)
                    }
                    addKmsContext
                },
                {
                    fn updatePublicDecryptionThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <updatePublicDecryptionThresholdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::updatePublicDecryptionThreshold)
                    }
                    updatePublicDecryptionThreshold
                },
                {
                    fn unpause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <unpauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::unpause)
                    }
                    unpause
                },
                {
                    fn getActiveKmsContextId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getActiveKmsContextIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getActiveKmsContextId)
                    }
                    getActiveKmsContextId
                },
                {
                    fn getKmsContextGenerationBlockPeriod(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getKmsContextGenerationBlockPeriodCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getKmsContextGenerationBlockPeriod)
                    }
                    getKmsContextGenerationBlockPeriod
                },
                {
                    fn getKmsContextStatus(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getKmsContextStatusCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getKmsContextStatus)
                    }
                    getKmsContextStatus
                },
                {
                    fn upgradeToAndCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::upgradeToAndCall)
                    }
                    upgradeToAndCall
                },
                {
                    fn proxiableUUID(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::proxiableUUID)
                    }
                    proxiableUUID
                },
                {
                    fn paused(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <pausedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::paused)
                    }
                    paused
                },
                {
                    fn getUserDecryptionThresholdFromContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getUserDecryptionThresholdFromContextCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getUserDecryptionThresholdFromContext)
                    }
                    getUserDecryptionThresholdFromContext
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn getKmsTxSenders(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getKmsTxSendersCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getKmsTxSenders)
                    }
                    getKmsTxSenders
                },
                {
                    fn acceptOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <acceptOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::acceptOwnership)
                    }
                    acceptOwnership
                },
                {
                    fn getKmsSigners(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getKmsSignersCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getKmsSigners)
                    }
                    getKmsSigners
                },
                {
                    fn pause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::pause)
                    }
                    pause
                },
                {
                    fn eip712Domain(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <eip712DomainCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::eip712Domain)
                    }
                    eip712Domain
                },
                {
                    fn refreshKmsContextStatuses(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <refreshKmsContextStatusesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::refreshKmsContextStatuses)
                    }
                    refreshKmsContextStatuses
                },
                {
                    fn owner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::owner)
                    }
                    owner
                },
                {
                    fn compromiseKmsContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <compromiseKmsContextCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::compromiseKmsContext)
                    }
                    compromiseKmsContext
                },
                {
                    fn UPGRADE_INTERFACE_VERSION(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::UPGRADE_INTERFACE_VERSION)
                    }
                    UPGRADE_INTERFACE_VERSION
                },
                {
                    fn getPublicDecryptionThresholdFromContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getPublicDecryptionThresholdFromContextCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                KmsContextsCalls::getPublicDecryptionThresholdFromContext,
                            )
                    }
                    getPublicDecryptionThresholdFromContext
                },
                {
                    fn destroyKmsContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <destroyKmsContextCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::destroyKmsContext)
                    }
                    destroyKmsContext
                },
                {
                    fn updateKmsContextSuspensionBlockPeriod(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <updateKmsContextSuspensionBlockPeriodCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::updateKmsContextSuspensionBlockPeriod)
                    }
                    updateKmsContextSuspensionBlockPeriod
                },
                {
                    fn getKmsContextSuspensionBlockPeriod(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getKmsContextSuspensionBlockPeriodCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getKmsContextSuspensionBlockPeriod)
                    }
                    getKmsContextSuspensionBlockPeriod
                },
                {
                    fn checkIsKmsTxSenderFromContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <checkIsKmsTxSenderFromContextCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::checkIsKmsTxSenderFromContext)
                    }
                    checkIsKmsTxSenderFromContext
                },
                {
                    fn checkIsKmsSignerFromContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <checkIsKmsSignerFromContextCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::checkIsKmsSignerFromContext)
                    }
                    checkIsKmsSignerFromContext
                },
                {
                    fn updateKmsContextGenerationBlockPeriod(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <updateKmsContextGenerationBlockPeriodCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::updateKmsContextGenerationBlockPeriod)
                    }
                    updateKmsContextGenerationBlockPeriod
                },
                {
                    fn pendingOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <pendingOwnerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::pendingOwner)
                    }
                    pendingOwner
                },
                {
                    fn getKmsNode(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getKmsNodeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getKmsNode)
                    }
                    getKmsNode
                },
                {
                    fn getKmsNodes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getKmsNodesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getKmsNodes)
                    }
                    getKmsNodes
                },
                {
                    fn updateUserDecryptionThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <updateUserDecryptionThresholdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::updateUserDecryptionThreshold)
                    }
                    updateUserDecryptionThreshold
                },
                {
                    fn initialize(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::initialize)
                    }
                    initialize
                },
                {
                    fn moveSuspendedKmsContextToActive(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <moveSuspendedKmsContextToActiveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::moveSuspendedKmsContextToActive)
                    }
                    moveSuspendedKmsContextToActive
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::transferOwnership)
                    }
                    transferOwnership
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::acceptOwnership(inner) => {
                    <acceptOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::addKmsContext(inner) => {
                    <addKmsContextCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkIsKmsSignerFromContext(inner) => {
                    <checkIsKmsSignerFromContextCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkIsKmsTxSenderFromContext(inner) => {
                    <checkIsKmsTxSenderFromContextCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::compromiseKmsContext(inner) => {
                    <compromiseKmsContextCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::destroyKmsContext(inner) => {
                    <destroyKmsContextCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::eip712Domain(inner) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getActiveKmsContext(inner) => {
                    <getActiveKmsContextCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getActiveKmsContextId(inner) => {
                    <getActiveKmsContextIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKmsContextGenerationBlockPeriod(inner) => {
                    <getKmsContextGenerationBlockPeriodCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKmsContextStatus(inner) => {
                    <getKmsContextStatusCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKmsContextSuspensionBlockPeriod(inner) => {
                    <getKmsContextSuspensionBlockPeriodCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKmsNode(inner) => {
                    <getKmsNodeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getKmsNodes(inner) => {
                    <getKmsNodesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKmsSigners(inner) => {
                    <getKmsSignersCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKmsTxSenders(inner) => {
                    <getKmsTxSendersCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPublicDecryptionThresholdFromContext(inner) => {
                    <getPublicDecryptionThresholdFromContextCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getSuspendedKmsContextId(inner) => {
                    <getSuspendedKmsContextIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getUserDecryptionThresholdFromContext(inner) => {
                    <getUserDecryptionThresholdFromContextCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getVersion(inner) => {
                    <getVersionCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::moveSuspendedKmsContextToActive(inner) => {
                    <moveSuspendedKmsContextToActiveCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pendingOwner(inner) => {
                    <pendingOwnerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::refreshKmsContextStatuses(inner) => {
                    <refreshKmsContextStatusesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::updateKmsContextGenerationBlockPeriod(inner) => {
                    <updateKmsContextGenerationBlockPeriodCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateKmsContextSuspensionBlockPeriod(inner) => {
                    <updateKmsContextSuspensionBlockPeriodCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updatePublicDecryptionThreshold(inner) => {
                    <updatePublicDecryptionThresholdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateUserDecryptionThreshold(inner) => {
                    <updateUserDecryptionThresholdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::validateKeyResharing(inner) => {
                    <validateKeyResharingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::acceptOwnership(inner) => {
                    <acceptOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::addKmsContext(inner) => {
                    <addKmsContextCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkIsKmsSignerFromContext(inner) => {
                    <checkIsKmsSignerFromContextCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkIsKmsTxSenderFromContext(inner) => {
                    <checkIsKmsTxSenderFromContextCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::compromiseKmsContext(inner) => {
                    <compromiseKmsContextCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::destroyKmsContext(inner) => {
                    <destroyKmsContextCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::eip712Domain(inner) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getActiveKmsContext(inner) => {
                    <getActiveKmsContextCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getActiveKmsContextId(inner) => {
                    <getActiveKmsContextIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsContextGenerationBlockPeriod(inner) => {
                    <getKmsContextGenerationBlockPeriodCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsContextStatus(inner) => {
                    <getKmsContextStatusCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsContextSuspensionBlockPeriod(inner) => {
                    <getKmsContextSuspensionBlockPeriodCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsNode(inner) => {
                    <getKmsNodeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsNodes(inner) => {
                    <getKmsNodesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsSigners(inner) => {
                    <getKmsSignersCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsTxSenders(inner) => {
                    <getKmsTxSendersCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPublicDecryptionThresholdFromContext(inner) => {
                    <getPublicDecryptionThresholdFromContextCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getSuspendedKmsContextId(inner) => {
                    <getSuspendedKmsContextIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getUserDecryptionThresholdFromContext(inner) => {
                    <getUserDecryptionThresholdFromContextCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getVersion(inner) => {
                    <getVersionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::moveSuspendedKmsContextToActive(inner) => {
                    <moveSuspendedKmsContextToActiveCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pendingOwner(inner) => {
                    <pendingOwnerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::refreshKmsContextStatuses(inner) => {
                    <refreshKmsContextStatusesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::updateKmsContextGenerationBlockPeriod(inner) => {
                    <updateKmsContextGenerationBlockPeriodCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateKmsContextSuspensionBlockPeriod(inner) => {
                    <updateKmsContextSuspensionBlockPeriodCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updatePublicDecryptionThreshold(inner) => {
                    <updatePublicDecryptionThresholdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateUserDecryptionThreshold(inner) => {
                    <updateUserDecryptionThresholdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::validateKeyResharing(inner) => {
                    <validateKeyResharingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`KmsContexts`](self) custom errors.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum KmsContextsErrors {
        #[allow(missing_docs)]
        AddressEmptyCode(AddressEmptyCode),
        #[allow(missing_docs)]
        CompromiseActiveKmsContextNotAllowed(CompromiseActiveKmsContextNotAllowed),
        #[allow(missing_docs)]
        ContextAlreadyExists(ContextAlreadyExists),
        #[allow(missing_docs)]
        ContextNotActive(ContextNotActive),
        #[allow(missing_docs)]
        ContextNotActiveOrSuspended(ContextNotActiveOrSuspended),
        #[allow(missing_docs)]
        ContextNotGenerated(ContextNotGenerated),
        #[allow(missing_docs)]
        ContextNotInitializedOrIsGenerating(ContextNotInitializedOrIsGenerating),
        #[allow(missing_docs)]
        ContextNotPreActivatedOrSuspended(ContextNotPreActivatedOrSuspended),
        #[allow(missing_docs)]
        DestroyActiveKmsContextNotAllowed(DestroyActiveKmsContextNotAllowed),
        #[allow(missing_docs)]
        ECDSAInvalidSignature(ECDSAInvalidSignature),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureLength(ECDSAInvalidSignatureLength),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureS(ECDSAInvalidSignatureS),
        #[allow(missing_docs)]
        ERC1967InvalidImplementation(ERC1967InvalidImplementation),
        #[allow(missing_docs)]
        ERC1967NonPayable(ERC1967NonPayable),
        #[allow(missing_docs)]
        EmptyKmsNodes(EmptyKmsNodes),
        #[allow(missing_docs)]
        EnforcedPause(EnforcedPause),
        #[allow(missing_docs)]
        ExpectedPause(ExpectedPause),
        #[allow(missing_docs)]
        FailedCall(FailedCall),
        #[allow(missing_docs)]
        InvalidHighMpcThreshold(InvalidHighMpcThreshold),
        #[allow(missing_docs)]
        InvalidHighPublicDecryptionThreshold(InvalidHighPublicDecryptionThreshold),
        #[allow(missing_docs)]
        InvalidHighUserDecryptionThreshold(InvalidHighUserDecryptionThreshold),
        #[allow(missing_docs)]
        InvalidInitialization(InvalidInitialization),
        #[allow(missing_docs)]
        InvalidNullContextId(InvalidNullContextId),
        #[allow(missing_docs)]
        InvalidNullPublicDecryptionThreshold(InvalidNullPublicDecryptionThreshold),
        #[allow(missing_docs)]
        InvalidNullUserDecryptionThreshold(InvalidNullUserDecryptionThreshold),
        #[allow(missing_docs)]
        KmsContextNotGenerating(KmsContextNotGenerating),
        #[allow(missing_docs)]
        KmsContextNotInitialized(KmsContextNotInitialized),
        #[allow(missing_docs)]
        KmsNodeAlreadyValidatedKeyResharing(KmsNodeAlreadyValidatedKeyResharing),
        #[allow(missing_docs)]
        NoSuspendedKmsContext(NoSuspendedKmsContext),
        #[allow(missing_docs)]
        NotInitializing(NotInitializing),
        #[allow(missing_docs)]
        NotKmsNodeFromContext(NotKmsNodeFromContext),
        #[allow(missing_docs)]
        NotKmsSignerFromContext(NotKmsSignerFromContext),
        #[allow(missing_docs)]
        NotKmsTxSenderFromContext(NotKmsTxSenderFromContext),
        #[allow(missing_docs)]
        NotOwnerOrPauser(NotOwnerOrPauser),
        #[allow(missing_docs)]
        NumberOfKmsNodesChanged(NumberOfKmsNodesChanged),
        #[allow(missing_docs)]
        OwnableInvalidOwner(OwnableInvalidOwner),
        #[allow(missing_docs)]
        OwnableUnauthorizedAccount(OwnableUnauthorizedAccount),
        #[allow(missing_docs)]
        SuspendedKmsContextOngoing(SuspendedKmsContextOngoing),
        #[allow(missing_docs)]
        UUPSUnauthorizedCallContext(UUPSUnauthorizedCallContext),
        #[allow(missing_docs)]
        UUPSUnsupportedProxiableUUID(UUPSUnsupportedProxiableUUID),
    }
    #[automatically_derived]
    impl KmsContextsErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [4u8, 148u8, 211u8, 192u8],
            [6u8, 140u8, 141u8, 64u8],
            [17u8, 140u8, 218u8, 167u8],
            [18u8, 180u8, 158u8, 61u8],
            [30u8, 79u8, 189u8, 247u8],
            [32u8, 126u8, 163u8, 243u8],
            [43u8, 54u8, 82u8, 209u8],
            [51u8, 20u8, 134u8, 179u8],
            [70u8, 192u8, 217u8, 175u8],
            [76u8, 156u8, 140u8, 227u8],
            [94u8, 81u8, 162u8, 225u8],
            [102u8, 83u8, 246u8, 215u8],
            [118u8, 35u8, 211u8, 87u8],
            [119u8, 208u8, 94u8, 167u8],
            [130u8, 177u8, 251u8, 218u8],
            [132u8, 32u8, 143u8, 35u8],
            [135u8, 137u8, 166u8, 202u8],
            [137u8, 180u8, 94u8, 93u8],
            [141u8, 252u8, 32u8, 43u8],
            [153u8, 150u8, 179u8, 21u8],
            [153u8, 177u8, 88u8, 193u8],
            [170u8, 29u8, 73u8, 164u8],
            [176u8, 197u8, 21u8, 29u8],
            [177u8, 174u8, 146u8, 234u8],
            [178u8, 94u8, 78u8, 179u8],
            [179u8, 152u8, 151u8, 159u8],
            [192u8, 181u8, 238u8, 102u8],
            [203u8, 23u8, 183u8, 165u8],
            [210u8, 83u8, 94u8, 17u8],
            [213u8, 149u8, 169u8, 98u8],
            [214u8, 189u8, 162u8, 117u8],
            [215u8, 139u8, 206u8, 12u8],
            [215u8, 230u8, 188u8, 248u8],
            [217u8, 60u8, 6u8, 101u8],
            [224u8, 124u8, 141u8, 186u8],
            [230u8, 10u8, 114u8, 113u8],
            [246u8, 69u8, 238u8, 223u8],
            [249u8, 46u8, 232u8, 169u8],
            [252u8, 230u8, 152u8, 247u8],
            [253u8, 248u8, 160u8, 93u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for KmsContextsErrors {
        const NAME: &'static str = "KmsContextsErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 40usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AddressEmptyCode(_) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CompromiseActiveKmsContextNotAllowed(_) => {
                    <CompromiseActiveKmsContextNotAllowed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ContextAlreadyExists(_) => {
                    <ContextAlreadyExists as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ContextNotActive(_) => {
                    <ContextNotActive as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ContextNotActiveOrSuspended(_) => {
                    <ContextNotActiveOrSuspended as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ContextNotGenerated(_) => {
                    <ContextNotGenerated as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ContextNotInitializedOrIsGenerating(_) => {
                    <ContextNotInitializedOrIsGenerating as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ContextNotPreActivatedOrSuspended(_) => {
                    <ContextNotPreActivatedOrSuspended as alloy_sol_types::SolError>::SELECTOR
                }
                Self::DestroyActiveKmsContextNotAllowed(_) => {
                    <DestroyActiveKmsContextNotAllowed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignature(_) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureLength(_) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureS(_) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967InvalidImplementation(_) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967NonPayable(_) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyKmsNodes(_) => {
                    <EmptyKmsNodes as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EnforcedPause(_) => {
                    <EnforcedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ExpectedPause(_) => {
                    <ExpectedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FailedCall(_) => {
                    <FailedCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidHighMpcThreshold(_) => {
                    <InvalidHighMpcThreshold as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidHighPublicDecryptionThreshold(_) => {
                    <InvalidHighPublicDecryptionThreshold as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidHighUserDecryptionThreshold(_) => {
                    <InvalidHighUserDecryptionThreshold as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidInitialization(_) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidNullContextId(_) => {
                    <InvalidNullContextId as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidNullPublicDecryptionThreshold(_) => {
                    <InvalidNullPublicDecryptionThreshold as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidNullUserDecryptionThreshold(_) => {
                    <InvalidNullUserDecryptionThreshold as alloy_sol_types::SolError>::SELECTOR
                }
                Self::KmsContextNotGenerating(_) => {
                    <KmsContextNotGenerating as alloy_sol_types::SolError>::SELECTOR
                }
                Self::KmsContextNotInitialized(_) => {
                    <KmsContextNotInitialized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::KmsNodeAlreadyValidatedKeyResharing(_) => {
                    <KmsNodeAlreadyValidatedKeyResharing as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NoSuspendedKmsContext(_) => {
                    <NoSuspendedKmsContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotInitializing(_) => {
                    <NotInitializing as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotKmsNodeFromContext(_) => {
                    <NotKmsNodeFromContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotKmsSignerFromContext(_) => {
                    <NotKmsSignerFromContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotKmsTxSenderFromContext(_) => {
                    <NotKmsTxSenderFromContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotOwnerOrPauser(_) => {
                    <NotOwnerOrPauser as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NumberOfKmsNodesChanged(_) => {
                    <NumberOfKmsNodesChanged as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OwnableInvalidOwner(_) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OwnableUnauthorizedAccount(_) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SuspendedKmsContextOngoing(_) => {
                    <SuspendedKmsContextOngoing as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnauthorizedCallContext(_) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnsupportedProxiableUUID(_) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<KmsContextsErrors>] = &[
                {
                    fn NotKmsNodeFromContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <NotKmsNodeFromContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::NotKmsNodeFromContext)
                    }
                    NotKmsNodeFromContext
                },
                {
                    fn EmptyKmsNodes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <EmptyKmsNodes as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::EmptyKmsNodes)
                    }
                    EmptyKmsNodes
                },
                {
                    fn OwnableUnauthorizedAccount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::OwnableUnauthorizedAccount)
                    }
                    OwnableUnauthorizedAccount
                },
                {
                    fn ContextNotPreActivatedOrSuspended(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ContextNotPreActivatedOrSuspended as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ContextNotPreActivatedOrSuspended)
                    }
                    ContextNotPreActivatedOrSuspended
                },
                {
                    fn OwnableInvalidOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::OwnableInvalidOwner)
                    }
                    OwnableInvalidOwner
                },
                {
                    fn NoSuspendedKmsContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <NoSuspendedKmsContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::NoSuspendedKmsContext)
                    }
                    NoSuspendedKmsContext
                },
                {
                    fn ContextNotActiveOrSuspended(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ContextNotActiveOrSuspended as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ContextNotActiveOrSuspended)
                    }
                    ContextNotActiveOrSuspended
                },
                {
                    fn ContextNotActive(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ContextNotActive as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ContextNotActive)
                    }
                    ContextNotActive
                },
                {
                    fn NotOwnerOrPauser(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <NotOwnerOrPauser as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::NotOwnerOrPauser)
                    }
                    NotOwnerOrPauser
                },
                {
                    fn ERC1967InvalidImplementation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ERC1967InvalidImplementation)
                    }
                    ERC1967InvalidImplementation
                },
                {
                    fn KmsContextNotGenerating(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <KmsContextNotGenerating as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::KmsContextNotGenerating)
                    }
                    KmsContextNotGenerating
                },
                {
                    fn ContextAlreadyExists(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ContextAlreadyExists as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ContextAlreadyExists)
                    }
                    ContextAlreadyExists
                },
                {
                    fn SuspendedKmsContextOngoing(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <SuspendedKmsContextOngoing as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::SuspendedKmsContextOngoing)
                    }
                    SuspendedKmsContextOngoing
                },
                {
                    fn CompromiseActiveKmsContextNotAllowed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <CompromiseActiveKmsContextNotAllowed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::CompromiseActiveKmsContextNotAllowed)
                    }
                    CompromiseActiveKmsContextNotAllowed
                },
                {
                    fn KmsContextNotInitialized(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <KmsContextNotInitialized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::KmsContextNotInitialized)
                    }
                    KmsContextNotInitialized
                },
                {
                    fn InvalidHighPublicDecryptionThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <InvalidHighPublicDecryptionThreshold as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::InvalidHighPublicDecryptionThreshold)
                    }
                    InvalidHighPublicDecryptionThreshold
                },
                {
                    fn InvalidHighMpcThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <InvalidHighMpcThreshold as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::InvalidHighMpcThreshold)
                    }
                    InvalidHighMpcThreshold
                },
                {
                    fn NotKmsSignerFromContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <NotKmsSignerFromContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::NotKmsSignerFromContext)
                    }
                    NotKmsSignerFromContext
                },
                {
                    fn ExpectedPause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ExpectedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ExpectedPause)
                    }
                    ExpectedPause
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn KmsNodeAlreadyValidatedKeyResharing(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <KmsNodeAlreadyValidatedKeyResharing as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::KmsNodeAlreadyValidatedKeyResharing)
                    }
                    KmsNodeAlreadyValidatedKeyResharing
                },
                {
                    fn UUPSUnsupportedProxiableUUID(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::UUPSUnsupportedProxiableUUID)
                    }
                    UUPSUnsupportedProxiableUUID
                },
                {
                    fn ContextNotInitializedOrIsGenerating(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ContextNotInitializedOrIsGenerating as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ContextNotInitializedOrIsGenerating)
                    }
                    ContextNotInitializedOrIsGenerating
                },
                {
                    fn InvalidNullPublicDecryptionThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <InvalidNullPublicDecryptionThreshold as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::InvalidNullPublicDecryptionThreshold)
                    }
                    InvalidNullPublicDecryptionThreshold
                },
                {
                    fn DestroyActiveKmsContextNotAllowed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <DestroyActiveKmsContextNotAllowed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::DestroyActiveKmsContextNotAllowed)
                    }
                    DestroyActiveKmsContextNotAllowed
                },
                {
                    fn ERC1967NonPayable(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ERC1967NonPayable as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ERC1967NonPayable)
                    }
                    ERC1967NonPayable
                },
                {
                    fn ContextNotGenerated(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ContextNotGenerated as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ContextNotGenerated)
                    }
                    ContextNotGenerated
                },
                {
                    fn InvalidNullContextId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <InvalidNullContextId as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::InvalidNullContextId)
                    }
                    InvalidNullContextId
                },
                {
                    fn InvalidHighUserDecryptionThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <InvalidHighUserDecryptionThreshold as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::InvalidHighUserDecryptionThreshold)
                    }
                    InvalidHighUserDecryptionThreshold
                },
                {
                    fn NumberOfKmsNodesChanged(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <NumberOfKmsNodesChanged as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::NumberOfKmsNodesChanged)
                    }
                    NumberOfKmsNodesChanged
                },
                {
                    fn FailedCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn ECDSAInvalidSignatureS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ECDSAInvalidSignatureS)
                    }
                    ECDSAInvalidSignatureS
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn EnforcedPause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <EnforcedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::EnforcedPause)
                    }
                    EnforcedPause
                },
                {
                    fn UUPSUnauthorizedCallContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::UUPSUnauthorizedCallContext)
                    }
                    UUPSUnauthorizedCallContext
                },
                {
                    fn InvalidNullUserDecryptionThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <InvalidNullUserDecryptionThreshold as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::InvalidNullUserDecryptionThreshold)
                    }
                    InvalidNullUserDecryptionThreshold
                },
                {
                    fn ECDSAInvalidSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ECDSAInvalidSignature)
                    }
                    ECDSAInvalidSignature
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::InvalidInitialization)
                    }
                    InvalidInitialization
                },
                {
                    fn ECDSAInvalidSignatureLength(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ECDSAInvalidSignatureLength)
                    }
                    ECDSAInvalidSignatureLength
                },
                {
                    fn NotKmsTxSenderFromContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <NotKmsTxSenderFromContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::NotKmsTxSenderFromContext)
                    }
                    NotKmsTxSenderFromContext
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CompromiseActiveKmsContextNotAllowed(inner) => {
                    <CompromiseActiveKmsContextNotAllowed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ContextAlreadyExists(inner) => {
                    <ContextAlreadyExists as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ContextNotActive(inner) => {
                    <ContextNotActive as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ContextNotActiveOrSuspended(inner) => {
                    <ContextNotActiveOrSuspended as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ContextNotGenerated(inner) => {
                    <ContextNotGenerated as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ContextNotInitializedOrIsGenerating(inner) => {
                    <ContextNotInitializedOrIsGenerating as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ContextNotPreActivatedOrSuspended(inner) => {
                    <ContextNotPreActivatedOrSuspended as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DestroyActiveKmsContextNotAllowed(inner) => {
                    <DestroyActiveKmsContextNotAllowed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyKmsNodes(inner) => {
                    <EmptyKmsNodes as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidHighMpcThreshold(inner) => {
                    <InvalidHighMpcThreshold as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidHighPublicDecryptionThreshold(inner) => {
                    <InvalidHighPublicDecryptionThreshold as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidHighUserDecryptionThreshold(inner) => {
                    <InvalidHighUserDecryptionThreshold as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidNullContextId(inner) => {
                    <InvalidNullContextId as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidNullPublicDecryptionThreshold(inner) => {
                    <InvalidNullPublicDecryptionThreshold as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidNullUserDecryptionThreshold(inner) => {
                    <InvalidNullUserDecryptionThreshold as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::KmsContextNotGenerating(inner) => {
                    <KmsContextNotGenerating as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::KmsContextNotInitialized(inner) => {
                    <KmsContextNotInitialized as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::KmsNodeAlreadyValidatedKeyResharing(inner) => {
                    <KmsNodeAlreadyValidatedKeyResharing as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NoSuspendedKmsContext(inner) => {
                    <NoSuspendedKmsContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotKmsNodeFromContext(inner) => {
                    <NotKmsNodeFromContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotKmsSignerFromContext(inner) => {
                    <NotKmsSignerFromContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotKmsTxSenderFromContext(inner) => {
                    <NotKmsTxSenderFromContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotOwnerOrPauser(inner) => {
                    <NotOwnerOrPauser as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NumberOfKmsNodesChanged(inner) => {
                    <NumberOfKmsNodesChanged as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OwnableInvalidOwner(inner) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OwnableUnauthorizedAccount(inner) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SuspendedKmsContextOngoing(inner) => {
                    <SuspendedKmsContextOngoing as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CompromiseActiveKmsContextNotAllowed(inner) => {
                    <CompromiseActiveKmsContextNotAllowed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ContextAlreadyExists(inner) => {
                    <ContextAlreadyExists as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ContextNotActive(inner) => {
                    <ContextNotActive as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ContextNotActiveOrSuspended(inner) => {
                    <ContextNotActiveOrSuspended as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ContextNotGenerated(inner) => {
                    <ContextNotGenerated as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ContextNotInitializedOrIsGenerating(inner) => {
                    <ContextNotInitializedOrIsGenerating as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ContextNotPreActivatedOrSuspended(inner) => {
                    <ContextNotPreActivatedOrSuspended as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DestroyActiveKmsContextNotAllowed(inner) => {
                    <DestroyActiveKmsContextNotAllowed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyKmsNodes(inner) => {
                    <EmptyKmsNodes as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::InvalidHighMpcThreshold(inner) => {
                    <InvalidHighMpcThreshold as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidHighPublicDecryptionThreshold(inner) => {
                    <InvalidHighPublicDecryptionThreshold as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidHighUserDecryptionThreshold(inner) => {
                    <InvalidHighUserDecryptionThreshold as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidNullContextId(inner) => {
                    <InvalidNullContextId as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidNullPublicDecryptionThreshold(inner) => {
                    <InvalidNullPublicDecryptionThreshold as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidNullUserDecryptionThreshold(inner) => {
                    <InvalidNullUserDecryptionThreshold as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::KmsContextNotGenerating(inner) => {
                    <KmsContextNotGenerating as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::KmsContextNotInitialized(inner) => {
                    <KmsContextNotInitialized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::KmsNodeAlreadyValidatedKeyResharing(inner) => {
                    <KmsNodeAlreadyValidatedKeyResharing as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NoSuspendedKmsContext(inner) => {
                    <NoSuspendedKmsContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotKmsNodeFromContext(inner) => {
                    <NotKmsNodeFromContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotKmsSignerFromContext(inner) => {
                    <NotKmsSignerFromContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotKmsTxSenderFromContext(inner) => {
                    <NotKmsTxSenderFromContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotOwnerOrPauser(inner) => {
                    <NotOwnerOrPauser as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NumberOfKmsNodesChanged(inner) => {
                    <NumberOfKmsNodesChanged as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OwnableInvalidOwner(inner) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OwnableUnauthorizedAccount(inner) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SuspendedKmsContextOngoing(inner) => {
                    <SuspendedKmsContextOngoing as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`KmsContexts`](self) events.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum KmsContextsEvents {
        #[allow(missing_docs)]
        ActivateKmsContext(ActivateKmsContext),
        #[allow(missing_docs)]
        CompromiseKmsContext(CompromiseKmsContext),
        #[allow(missing_docs)]
        DeactivateKmsContext(DeactivateKmsContext),
        #[allow(missing_docs)]
        DestroyKmsContext(DestroyKmsContext),
        #[allow(missing_docs)]
        EIP712DomainChanged(EIP712DomainChanged),
        #[allow(missing_docs)]
        Initialization(Initialization),
        #[allow(missing_docs)]
        Initialized(Initialized),
        #[allow(missing_docs)]
        InvalidateKeyResharing(InvalidateKeyResharing),
        #[allow(missing_docs)]
        NewKmsContext(NewKmsContext),
        #[allow(missing_docs)]
        OwnershipTransferStarted(OwnershipTransferStarted),
        #[allow(missing_docs)]
        OwnershipTransferred(OwnershipTransferred),
        #[allow(missing_docs)]
        Paused(Paused),
        #[allow(missing_docs)]
        PreActivateKmsContext(PreActivateKmsContext),
        #[allow(missing_docs)]
        StartKeyResharing(StartKeyResharing),
        #[allow(missing_docs)]
        SuspendKmsContext(SuspendKmsContext),
        #[allow(missing_docs)]
        Unpaused(Unpaused),
        #[allow(missing_docs)]
        UpdateKmsContextGenerationBlockPeriod(UpdateKmsContextGenerationBlockPeriod),
        #[allow(missing_docs)]
        UpdateKmsContextSuspensionBlockPeriod(UpdateKmsContextSuspensionBlockPeriod),
        #[allow(missing_docs)]
        UpdatePublicDecryptionThreshold(UpdatePublicDecryptionThreshold),
        #[allow(missing_docs)]
        UpdateUserDecryptionThreshold(UpdateUserDecryptionThreshold),
        #[allow(missing_docs)]
        Upgraded(Upgraded),
        #[allow(missing_docs)]
        ValidateKeyResharing(ValidateKeyResharing),
    }
    #[automatically_derived]
    impl KmsContextsEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                0u8, 159u8, 232u8, 240u8, 219u8, 69u8, 153u8, 109u8, 236u8, 247u8, 176u8,
                111u8, 199u8, 182u8, 236u8, 95u8, 136u8, 125u8, 95u8, 4u8, 219u8, 46u8,
                12u8, 74u8, 215u8, 244u8, 228u8, 238u8, 94u8, 239u8, 197u8, 163u8,
            ],
            [
                1u8, 110u8, 233u8, 193u8, 98u8, 19u8, 237u8, 103u8, 243u8, 50u8, 34u8,
                171u8, 173u8, 77u8, 254u8, 70u8, 235u8, 149u8, 30u8, 173u8, 48u8, 161u8,
                10u8, 26u8, 114u8, 219u8, 51u8, 22u8, 255u8, 182u8, 100u8, 224u8,
            ],
            [
                10u8, 99u8, 135u8, 201u8, 234u8, 54u8, 40u8, 184u8, 138u8, 99u8, 59u8,
                180u8, 243u8, 177u8, 81u8, 119u8, 15u8, 112u8, 8u8, 81u8, 23u8, 161u8,
                95u8, 155u8, 243u8, 120u8, 124u8, 218u8, 83u8, 241u8, 61u8, 49u8,
            ],
            [
                54u8, 98u8, 236u8, 49u8, 109u8, 118u8, 230u8, 167u8, 94u8, 183u8, 196u8,
                80u8, 1u8, 168u8, 173u8, 116u8, 195u8, 235u8, 148u8, 62u8, 135u8, 120u8,
                17u8, 28u8, 2u8, 37u8, 242u8, 169u8, 253u8, 94u8, 0u8, 230u8,
            ],
            [
                56u8, 209u8, 107u8, 140u8, 172u8, 34u8, 217u8, 159u8, 199u8, 193u8, 36u8,
                185u8, 205u8, 13u8, 226u8, 211u8, 250u8, 31u8, 174u8, 244u8, 32u8, 191u8,
                231u8, 145u8, 216u8, 195u8, 98u8, 215u8, 101u8, 226u8, 39u8, 0u8,
            ],
            [
                58u8, 213u8, 194u8, 39u8, 36u8, 175u8, 171u8, 142u8, 210u8, 181u8, 120u8,
                251u8, 155u8, 22u8, 12u8, 127u8, 101u8, 245u8, 171u8, 208u8, 170u8,
                209u8, 5u8, 117u8, 43u8, 123u8, 164u8, 224u8, 104u8, 163u8, 224u8, 33u8,
            ],
            [
                62u8, 143u8, 2u8, 220u8, 122u8, 246u8, 227u8, 166u8, 127u8, 58u8, 240u8,
                188u8, 153u8, 188u8, 241u8, 27u8, 77u8, 235u8, 70u8, 16u8, 94u8, 155u8,
                167u8, 241u8, 172u8, 109u8, 168u8, 35u8, 34u8, 233u8, 2u8, 94u8,
            ],
            [
                69u8, 64u8, 247u8, 128u8, 143u8, 202u8, 236u8, 134u8, 195u8, 118u8,
                168u8, 157u8, 44u8, 12u8, 147u8, 165u8, 5u8, 108u8, 33u8, 104u8, 13u8,
                181u8, 67u8, 50u8, 199u8, 242u8, 149u8, 157u8, 135u8, 254u8, 252u8, 139u8,
            ],
            [
                79u8, 84u8, 166u8, 172u8, 152u8, 28u8, 200u8, 220u8, 131u8, 20u8, 43u8,
                62u8, 180u8, 209u8, 32u8, 190u8, 124u8, 112u8, 252u8, 93u8, 230u8, 71u8,
                122u8, 20u8, 234u8, 227u8, 233u8, 202u8, 100u8, 118u8, 68u8, 188u8,
            ],
            [
                83u8, 203u8, 150u8, 141u8, 49u8, 194u8, 140u8, 101u8, 4u8, 166u8, 231u8,
                61u8, 153u8, 8u8, 219u8, 110u8, 28u8, 26u8, 56u8, 107u8, 102u8, 220u8,
                172u8, 236u8, 26u8, 1u8, 23u8, 117u8, 44u8, 90u8, 185u8, 134u8,
            ],
            [
                93u8, 185u8, 238u8, 10u8, 73u8, 91u8, 242u8, 230u8, 255u8, 156u8, 145u8,
                167u8, 131u8, 76u8, 27u8, 164u8, 253u8, 210u8, 68u8, 165u8, 232u8, 170u8,
                78u8, 83u8, 123u8, 211u8, 138u8, 234u8, 228u8, 176u8, 115u8, 170u8,
            ],
            [
                93u8, 198u8, 1u8, 6u8, 90u8, 3u8, 93u8, 120u8, 48u8, 92u8, 217u8, 239u8,
                39u8, 201u8, 26u8, 0u8, 156u8, 216u8, 211u8, 114u8, 151u8, 228u8, 59u8,
                183u8, 99u8, 25u8, 73u8, 8u8, 149u8, 160u8, 208u8, 88u8,
            ],
            [
                98u8, 231u8, 140u8, 234u8, 1u8, 190u8, 227u8, 32u8, 205u8, 78u8, 66u8,
                2u8, 112u8, 181u8, 234u8, 116u8, 0u8, 13u8, 17u8, 176u8, 201u8, 247u8,
                71u8, 84u8, 235u8, 219u8, 252u8, 84u8, 75u8, 5u8, 162u8, 88u8,
            ],
            [
                104u8, 137u8, 138u8, 152u8, 147u8, 107u8, 242u8, 58u8, 86u8, 232u8,
                237u8, 75u8, 35u8, 220u8, 201u8, 140u8, 239u8, 146u8, 107u8, 217u8,
                172u8, 44u8, 229u8, 34u8, 241u8, 249u8, 66u8, 62u8, 56u8, 100u8, 242u8,
                245u8,
            ],
            [
                131u8, 126u8, 10u8, 101u8, 40u8, 218u8, 223u8, 162u8, 220u8, 121u8, 38u8,
                146u8, 197u8, 24u8, 46u8, 82u8, 169u8, 245u8, 187u8, 222u8, 237u8, 123u8,
                35u8, 114u8, 146u8, 122u8, 38u8, 198u8, 149u8, 131u8, 150u8, 19u8,
            ],
            [
                133u8, 26u8, 8u8, 193u8, 107u8, 21u8, 149u8, 156u8, 51u8, 138u8, 196u8,
                181u8, 100u8, 102u8, 208u8, 108u8, 159u8, 157u8, 95u8, 248u8, 215u8,
                21u8, 22u8, 138u8, 161u8, 37u8, 213u8, 204u8, 175u8, 83u8, 131u8, 32u8,
            ],
            [
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ],
            [
                143u8, 183u8, 88u8, 88u8, 165u8, 101u8, 174u8, 225u8, 23u8, 52u8, 45u8,
                147u8, 25u8, 106u8, 127u8, 11u8, 84u8, 193u8, 200u8, 81u8, 152u8, 133u8,
                237u8, 221u8, 166u8, 160u8, 31u8, 71u8, 115u8, 89u8, 179u8, 99u8,
            ],
            [
                188u8, 17u8, 20u8, 250u8, 154u8, 119u8, 100u8, 140u8, 208u8, 151u8,
                238u8, 108u8, 241u8, 73u8, 195u8, 68u8, 250u8, 39u8, 139u8, 155u8, 152u8,
                63u8, 48u8, 221u8, 101u8, 182u8, 253u8, 106u8, 157u8, 70u8, 74u8, 7u8,
            ],
            [
                188u8, 124u8, 215u8, 90u8, 32u8, 238u8, 39u8, 253u8, 154u8, 222u8, 186u8,
                179u8, 32u8, 65u8, 247u8, 85u8, 33u8, 77u8, 188u8, 107u8, 255u8, 169u8,
                12u8, 192u8, 34u8, 91u8, 57u8, 218u8, 46u8, 92u8, 45u8, 59u8,
            ],
            [
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ],
            [
                228u8, 24u8, 2u8, 175u8, 114u8, 87u8, 41u8, 173u8, 203u8, 140u8, 21u8,
                30u8, 41u8, 55u8, 56u8, 10u8, 37u8, 198u8, 145u8, 85u8, 117u8, 126u8,
                58u8, 245u8, 211u8, 151u8, 154u8, 218u8, 181u8, 3u8, 88u8, 0u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for KmsContextsEvents {
        const NAME: &'static str = "KmsContextsEvents";
        const COUNT: usize = 22usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <ActivateKmsContext as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ActivateKmsContext as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ActivateKmsContext)
                }
                Some(
                    <CompromiseKmsContext as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <CompromiseKmsContext as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::CompromiseKmsContext)
                }
                Some(
                    <DeactivateKmsContext as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <DeactivateKmsContext as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::DeactivateKmsContext)
                }
                Some(
                    <DestroyKmsContext as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <DestroyKmsContext as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::DestroyKmsContext)
                }
                Some(
                    <EIP712DomainChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <EIP712DomainChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EIP712DomainChanged)
                }
                Some(<Initialization as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialization as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Initialization)
                }
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Initialized)
                }
                Some(
                    <InvalidateKeyResharing as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <InvalidateKeyResharing as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::InvalidateKeyResharing)
                }
                Some(<NewKmsContext as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <NewKmsContext as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::NewKmsContext)
                }
                Some(
                    <OwnershipTransferStarted as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferStarted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OwnershipTransferStarted)
                }
                Some(
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OwnershipTransferred)
                }
                Some(<Paused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Paused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Paused)
                }
                Some(
                    <PreActivateKmsContext as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <PreActivateKmsContext as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::PreActivateKmsContext)
                }
                Some(
                    <StartKeyResharing as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <StartKeyResharing as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::StartKeyResharing)
                }
                Some(
                    <SuspendKmsContext as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <SuspendKmsContext as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::SuspendKmsContext)
                }
                Some(<Unpaused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Unpaused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Unpaused)
                }
                Some(
                    <UpdateKmsContextGenerationBlockPeriod as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <UpdateKmsContextGenerationBlockPeriod as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::UpdateKmsContextGenerationBlockPeriod)
                }
                Some(
                    <UpdateKmsContextSuspensionBlockPeriod as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <UpdateKmsContextSuspensionBlockPeriod as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::UpdateKmsContextSuspensionBlockPeriod)
                }
                Some(
                    <UpdatePublicDecryptionThreshold as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <UpdatePublicDecryptionThreshold as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::UpdatePublicDecryptionThreshold)
                }
                Some(
                    <UpdateUserDecryptionThreshold as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <UpdateUserDecryptionThreshold as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::UpdateUserDecryptionThreshold)
                }
                Some(<Upgraded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Upgraded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Upgraded)
                }
                Some(
                    <ValidateKeyResharing as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ValidateKeyResharing as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ValidateKeyResharing)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for KmsContextsEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ActivateKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::CompromiseKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DeactivateKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DestroyKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EIP712DomainChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialization(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::InvalidateKeyResharing(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::NewKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::PreActivateKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::StartKeyResharing(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SuspendKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::UpdateKmsContextGenerationBlockPeriod(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::UpdateKmsContextSuspensionBlockPeriod(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::UpdatePublicDecryptionThreshold(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::UpdateUserDecryptionThreshold(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ValidateKeyResharing(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ActivateKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::CompromiseKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DeactivateKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DestroyKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EIP712DomainChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialization(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::InvalidateKeyResharing(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::NewKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::PreActivateKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::StartKeyResharing(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SuspendKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::UpdateKmsContextGenerationBlockPeriod(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::UpdateKmsContextSuspensionBlockPeriod(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::UpdatePublicDecryptionThreshold(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::UpdateUserDecryptionThreshold(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ValidateKeyResharing(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`KmsContexts`](self) contract instance.

See the [wrapper's documentation](`KmsContextsInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> KmsContextsInstance<T, P, N> {
        KmsContextsInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<KmsContextsInstance<T, P, N>>,
    > {
        KmsContextsInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        KmsContextsInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`KmsContexts`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`KmsContexts`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct KmsContextsInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for KmsContextsInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("KmsContextsInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > KmsContextsInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`KmsContexts`](self) contract instance.

See the [wrapper's documentation](`KmsContextsInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<KmsContextsInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> KmsContextsInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> KmsContextsInstance<T, P, N> {
            KmsContextsInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > KmsContextsInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`UPGRADE_INTERFACE_VERSION`] function.
        pub fn UPGRADE_INTERFACE_VERSION(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, UPGRADE_INTERFACE_VERSIONCall, N> {
            self.call_builder(&UPGRADE_INTERFACE_VERSIONCall {})
        }
        ///Creates a new call builder for the [`acceptOwnership`] function.
        pub fn acceptOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, acceptOwnershipCall, N> {
            self.call_builder(&acceptOwnershipCall {})
        }
        ///Creates a new call builder for the [`addKmsContext`] function.
        pub fn addKmsContext(
            &self,
            preActivationBlockPeriod: alloy::sol_types::private::primitives::aliases::U256,
            softwareVersion: alloy::sol_types::private::FixedBytes<8>,
            reshareKeys: bool,
            mpcThreshold: alloy::sol_types::private::primitives::aliases::U256,
            kmsNodes: alloy::sol_types::private::Vec<
                <KmsNode as alloy::sol_types::SolType>::RustType,
            >,
            decryptionThresholds: <DecryptionThresholds as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, addKmsContextCall, N> {
            self.call_builder(
                &addKmsContextCall {
                    preActivationBlockPeriod,
                    softwareVersion,
                    reshareKeys,
                    mpcThreshold,
                    kmsNodes,
                    decryptionThresholds,
                },
            )
        }
        ///Creates a new call builder for the [`checkIsKmsSignerFromContext`] function.
        pub fn checkIsKmsSignerFromContext(
            &self,
            contextId: alloy::sol_types::private::primitives::aliases::U256,
            signerAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkIsKmsSignerFromContextCall, N> {
            self.call_builder(
                &checkIsKmsSignerFromContextCall {
                    contextId,
                    signerAddress,
                },
            )
        }
        ///Creates a new call builder for the [`checkIsKmsTxSenderFromContext`] function.
        pub fn checkIsKmsTxSenderFromContext(
            &self,
            contextId: alloy::sol_types::private::primitives::aliases::U256,
            txSenderAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            checkIsKmsTxSenderFromContextCall,
            N,
        > {
            self.call_builder(
                &checkIsKmsTxSenderFromContextCall {
                    contextId,
                    txSenderAddress,
                },
            )
        }
        ///Creates a new call builder for the [`compromiseKmsContext`] function.
        pub fn compromiseKmsContext(
            &self,
            contextId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, compromiseKmsContextCall, N> {
            self.call_builder(
                &compromiseKmsContextCall {
                    contextId,
                },
            )
        }
        ///Creates a new call builder for the [`destroyKmsContext`] function.
        pub fn destroyKmsContext(
            &self,
            contextId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, destroyKmsContextCall, N> {
            self.call_builder(&destroyKmsContextCall { contextId })
        }
        ///Creates a new call builder for the [`eip712Domain`] function.
        pub fn eip712Domain(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, eip712DomainCall, N> {
            self.call_builder(&eip712DomainCall {})
        }
        ///Creates a new call builder for the [`getActiveKmsContext`] function.
        pub fn getActiveKmsContext(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getActiveKmsContextCall, N> {
            self.call_builder(&getActiveKmsContextCall {})
        }
        ///Creates a new call builder for the [`getActiveKmsContextId`] function.
        pub fn getActiveKmsContextId(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getActiveKmsContextIdCall, N> {
            self.call_builder(&getActiveKmsContextIdCall {})
        }
        ///Creates a new call builder for the [`getKmsContextGenerationBlockPeriod`] function.
        pub fn getKmsContextGenerationBlockPeriod(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            getKmsContextGenerationBlockPeriodCall,
            N,
        > {
            self.call_builder(
                &getKmsContextGenerationBlockPeriodCall {
                },
            )
        }
        ///Creates a new call builder for the [`getKmsContextStatus`] function.
        pub fn getKmsContextStatus(
            &self,
            contextId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getKmsContextStatusCall, N> {
            self.call_builder(
                &getKmsContextStatusCall {
                    contextId,
                },
            )
        }
        ///Creates a new call builder for the [`getKmsContextSuspensionBlockPeriod`] function.
        pub fn getKmsContextSuspensionBlockPeriod(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            getKmsContextSuspensionBlockPeriodCall,
            N,
        > {
            self.call_builder(
                &getKmsContextSuspensionBlockPeriodCall {
                },
            )
        }
        ///Creates a new call builder for the [`getKmsNode`] function.
        pub fn getKmsNode(
            &self,
            kmsTxSenderAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getKmsNodeCall, N> {
            self.call_builder(
                &getKmsNodeCall {
                    kmsTxSenderAddress,
                },
            )
        }
        ///Creates a new call builder for the [`getKmsNodes`] function.
        pub fn getKmsNodes(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getKmsNodesCall, N> {
            self.call_builder(&getKmsNodesCall {})
        }
        ///Creates a new call builder for the [`getKmsSigners`] function.
        pub fn getKmsSigners(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getKmsSignersCall, N> {
            self.call_builder(&getKmsSignersCall {})
        }
        ///Creates a new call builder for the [`getKmsTxSenders`] function.
        pub fn getKmsTxSenders(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getKmsTxSendersCall, N> {
            self.call_builder(&getKmsTxSendersCall {})
        }
        ///Creates a new call builder for the [`getPublicDecryptionThresholdFromContext`] function.
        pub fn getPublicDecryptionThresholdFromContext(
            &self,
            contextId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            getPublicDecryptionThresholdFromContextCall,
            N,
        > {
            self.call_builder(
                &getPublicDecryptionThresholdFromContextCall {
                    contextId,
                },
            )
        }
        ///Creates a new call builder for the [`getSuspendedKmsContextId`] function.
        pub fn getSuspendedKmsContextId(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getSuspendedKmsContextIdCall, N> {
            self.call_builder(&getSuspendedKmsContextIdCall {})
        }
        ///Creates a new call builder for the [`getUserDecryptionThresholdFromContext`] function.
        pub fn getUserDecryptionThresholdFromContext(
            &self,
            contextId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            getUserDecryptionThresholdFromContextCall,
            N,
        > {
            self.call_builder(
                &getUserDecryptionThresholdFromContextCall {
                    contextId,
                },
            )
        }
        ///Creates a new call builder for the [`getVersion`] function.
        pub fn getVersion(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getVersionCall, N> {
            self.call_builder(&getVersionCall {})
        }
        ///Creates a new call builder for the [`initialize`] function.
        pub fn initialize(
            &self,
            initialDecryptionThresholds: <DecryptionThresholds as alloy::sol_types::SolType>::RustType,
            initialBlockPeriods: <KmsBlockPeriods as alloy::sol_types::SolType>::RustType,
            initialSoftwareVersion: alloy::sol_types::private::FixedBytes<8>,
            initialMpcThreshold: alloy::sol_types::private::primitives::aliases::U256,
            initialKmsNodes: alloy::sol_types::private::Vec<
                <KmsNode as alloy::sol_types::SolType>::RustType,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, initializeCall, N> {
            self.call_builder(
                &initializeCall {
                    initialDecryptionThresholds,
                    initialBlockPeriods,
                    initialSoftwareVersion,
                    initialMpcThreshold,
                    initialKmsNodes,
                },
            )
        }
        ///Creates a new call builder for the [`moveSuspendedKmsContextToActive`] function.
        pub fn moveSuspendedKmsContextToActive(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            moveSuspendedKmsContextToActiveCall,
            N,
        > {
            self.call_builder(
                &moveSuspendedKmsContextToActiveCall {
                },
            )
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<T, &P, ownerCall, N> {
            self.call_builder(&ownerCall {})
        }
        ///Creates a new call builder for the [`pause`] function.
        pub fn pause(&self) -> alloy_contract::SolCallBuilder<T, &P, pauseCall, N> {
            self.call_builder(&pauseCall {})
        }
        ///Creates a new call builder for the [`paused`] function.
        pub fn paused(&self) -> alloy_contract::SolCallBuilder<T, &P, pausedCall, N> {
            self.call_builder(&pausedCall {})
        }
        ///Creates a new call builder for the [`pendingOwner`] function.
        pub fn pendingOwner(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, pendingOwnerCall, N> {
            self.call_builder(&pendingOwnerCall {})
        }
        ///Creates a new call builder for the [`proxiableUUID`] function.
        pub fn proxiableUUID(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, proxiableUUIDCall, N> {
            self.call_builder(&proxiableUUIDCall {})
        }
        ///Creates a new call builder for the [`refreshKmsContextStatuses`] function.
        pub fn refreshKmsContextStatuses(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, refreshKmsContextStatusesCall, N> {
            self.call_builder(&refreshKmsContextStatusesCall {})
        }
        ///Creates a new call builder for the [`renounceOwnership`] function.
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall {})
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
        ///Creates a new call builder for the [`unpause`] function.
        pub fn unpause(&self) -> alloy_contract::SolCallBuilder<T, &P, unpauseCall, N> {
            self.call_builder(&unpauseCall {})
        }
        ///Creates a new call builder for the [`updateKmsContextGenerationBlockPeriod`] function.
        pub fn updateKmsContextGenerationBlockPeriod(
            &self,
            newKmsContextGenerationBlockPeriod: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            updateKmsContextGenerationBlockPeriodCall,
            N,
        > {
            self.call_builder(
                &updateKmsContextGenerationBlockPeriodCall {
                    newKmsContextGenerationBlockPeriod,
                },
            )
        }
        ///Creates a new call builder for the [`updateKmsContextSuspensionBlockPeriod`] function.
        pub fn updateKmsContextSuspensionBlockPeriod(
            &self,
            newKmsContextSuspensionBlockPeriod: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            updateKmsContextSuspensionBlockPeriodCall,
            N,
        > {
            self.call_builder(
                &updateKmsContextSuspensionBlockPeriodCall {
                    newKmsContextSuspensionBlockPeriod,
                },
            )
        }
        ///Creates a new call builder for the [`updatePublicDecryptionThreshold`] function.
        pub fn updatePublicDecryptionThreshold(
            &self,
            newPublicDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            updatePublicDecryptionThresholdCall,
            N,
        > {
            self.call_builder(
                &updatePublicDecryptionThresholdCall {
                    newPublicDecryptionThreshold,
                },
            )
        }
        ///Creates a new call builder for the [`updateUserDecryptionThreshold`] function.
        pub fn updateUserDecryptionThreshold(
            &self,
            newUserDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            updateUserDecryptionThresholdCall,
            N,
        > {
            self.call_builder(
                &updateUserDecryptionThresholdCall {
                    newUserDecryptionThreshold,
                },
            )
        }
        ///Creates a new call builder for the [`upgradeToAndCall`] function.
        pub fn upgradeToAndCall(
            &self,
            newImplementation: alloy::sol_types::private::Address,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, upgradeToAndCallCall, N> {
            self.call_builder(
                &upgradeToAndCallCall {
                    newImplementation,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`validateKeyResharing`] function.
        pub fn validateKeyResharing(
            &self,
            contextId: alloy::sol_types::private::primitives::aliases::U256,
            signature: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, validateKeyResharingCall, N> {
            self.call_builder(
                &validateKeyResharingCall {
                    contextId,
                    signature,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > KmsContextsInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`ActivateKmsContext`] event.
        pub fn ActivateKmsContext_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ActivateKmsContext, N> {
            self.event_filter::<ActivateKmsContext>()
        }
        ///Creates a new event filter for the [`CompromiseKmsContext`] event.
        pub fn CompromiseKmsContext_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, CompromiseKmsContext, N> {
            self.event_filter::<CompromiseKmsContext>()
        }
        ///Creates a new event filter for the [`DeactivateKmsContext`] event.
        pub fn DeactivateKmsContext_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, DeactivateKmsContext, N> {
            self.event_filter::<DeactivateKmsContext>()
        }
        ///Creates a new event filter for the [`DestroyKmsContext`] event.
        pub fn DestroyKmsContext_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, DestroyKmsContext, N> {
            self.event_filter::<DestroyKmsContext>()
        }
        ///Creates a new event filter for the [`EIP712DomainChanged`] event.
        pub fn EIP712DomainChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EIP712DomainChanged, N> {
            self.event_filter::<EIP712DomainChanged>()
        }
        ///Creates a new event filter for the [`Initialization`] event.
        pub fn Initialization_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, Initialization, N> {
            self.event_filter::<Initialization>()
        }
        ///Creates a new event filter for the [`Initialized`] event.
        pub fn Initialized_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        ///Creates a new event filter for the [`InvalidateKeyResharing`] event.
        pub fn InvalidateKeyResharing_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, InvalidateKeyResharing, N> {
            self.event_filter::<InvalidateKeyResharing>()
        }
        ///Creates a new event filter for the [`NewKmsContext`] event.
        pub fn NewKmsContext_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, NewKmsContext, N> {
            self.event_filter::<NewKmsContext>()
        }
        ///Creates a new event filter for the [`OwnershipTransferStarted`] event.
        pub fn OwnershipTransferStarted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipTransferStarted, N> {
            self.event_filter::<OwnershipTransferStarted>()
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        ///Creates a new event filter for the [`Paused`] event.
        pub fn Paused_filter(&self) -> alloy_contract::Event<T, &P, Paused, N> {
            self.event_filter::<Paused>()
        }
        ///Creates a new event filter for the [`PreActivateKmsContext`] event.
        pub fn PreActivateKmsContext_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, PreActivateKmsContext, N> {
            self.event_filter::<PreActivateKmsContext>()
        }
        ///Creates a new event filter for the [`StartKeyResharing`] event.
        pub fn StartKeyResharing_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, StartKeyResharing, N> {
            self.event_filter::<StartKeyResharing>()
        }
        ///Creates a new event filter for the [`SuspendKmsContext`] event.
        pub fn SuspendKmsContext_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, SuspendKmsContext, N> {
            self.event_filter::<SuspendKmsContext>()
        }
        ///Creates a new event filter for the [`Unpaused`] event.
        pub fn Unpaused_filter(&self) -> alloy_contract::Event<T, &P, Unpaused, N> {
            self.event_filter::<Unpaused>()
        }
        ///Creates a new event filter for the [`UpdateKmsContextGenerationBlockPeriod`] event.
        pub fn UpdateKmsContextGenerationBlockPeriod_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, UpdateKmsContextGenerationBlockPeriod, N> {
            self.event_filter::<UpdateKmsContextGenerationBlockPeriod>()
        }
        ///Creates a new event filter for the [`UpdateKmsContextSuspensionBlockPeriod`] event.
        pub fn UpdateKmsContextSuspensionBlockPeriod_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, UpdateKmsContextSuspensionBlockPeriod, N> {
            self.event_filter::<UpdateKmsContextSuspensionBlockPeriod>()
        }
        ///Creates a new event filter for the [`UpdatePublicDecryptionThreshold`] event.
        pub fn UpdatePublicDecryptionThreshold_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, UpdatePublicDecryptionThreshold, N> {
            self.event_filter::<UpdatePublicDecryptionThreshold>()
        }
        ///Creates a new event filter for the [`UpdateUserDecryptionThreshold`] event.
        pub fn UpdateUserDecryptionThreshold_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, UpdateUserDecryptionThreshold, N> {
            self.event_filter::<UpdateUserDecryptionThreshold>()
        }
        ///Creates a new event filter for the [`Upgraded`] event.
        pub fn Upgraded_filter(&self) -> alloy_contract::Event<T, &P, Upgraded, N> {
            self.event_filter::<Upgraded>()
        }
        ///Creates a new event filter for the [`ValidateKeyResharing`] event.
        pub fn ValidateKeyResharing_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ValidateKeyResharing, N> {
            self.event_filter::<ValidateKeyResharing>()
        }
    }
}
