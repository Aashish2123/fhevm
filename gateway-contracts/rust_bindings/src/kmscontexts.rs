/**

Generated by the following Solidity interface...
```solidity
interface KmsContexts {
    type ContextStatus is uint8;
    struct DecryptionThresholds {
        uint256 publicDecryptionThreshold;
        uint256 userDecryptionThreshold;
    }
    struct KmsBlockPeriods {
        uint256 preActivationBlockPeriod;
        uint256 generationBlockPeriod;
        uint256 suspensionBlockPeriod;
    }
    struct KmsContext {
        uint256 contextId;
        uint256 previousContextId;
        bytes8 softwareVersion;
        uint256 mpcThreshold;
        KmsNode[] kmsNodes;
    }
    struct KmsNode {
        string name;
        address signerAddress;
        address txSenderAddress;
        uint256 partyId;
        bytes backupEncryptionKey;
        string externalUrl;
        string publicStorageUrl;
        bytes tlsCertificate;
    }

    error AddressEmptyCode(address target);
    error CompromiseActiveKmsContextNotAllowed(uint256 contextId);
    error ContextAlreadyExists(uint256 contextId);
    error ContextNotActive(uint256 contextId);
    error ContextNotActiveOrSuspended(uint256 contextId);
    error ContextNotGenerated(uint256 contextId);
    error ContextNotInitializedOrIsGenerating(uint256 contextId);
    error ContextNotPreActivatedOrSuspended(uint256 contextId);
    error DestroyActiveKmsContextNotAllowed(uint256 contextId);
    error ECDSAInvalidSignature();
    error ECDSAInvalidSignatureLength(uint256 length);
    error ECDSAInvalidSignatureS(bytes32 s);
    error ERC1967InvalidImplementation(address implementation);
    error ERC1967NonPayable();
    error EmptyKmsNodes();
    error EnforcedPause();
    error ExpectedPause();
    error FailedCall();
    error InvalidHighMpcThreshold(uint256 contextId, uint256 mpcThreshold, uint256 nKmsNodes);
    error InvalidHighPublicDecryptionThreshold(uint256 publicDecryptionThreshold, uint256 nKmsNodes);
    error InvalidHighUserDecryptionThreshold(uint256 userDecryptionThreshold, uint256 nKmsNodes);
    error InvalidInitialization();
    error InvalidNullContextId();
    error InvalidNullPublicDecryptionThreshold();
    error InvalidNullUserDecryptionThreshold();
    error KmsContextNotGenerating(uint256 contextId);
    error KmsContextNotInitialized(uint256 contextId);
    error KmsNodeAlreadyValidatedKeyResharing(uint256 contextId, address kmsSigner);
    error NoSuspendedKmsContext();
    error NotInitializing();
    error NotInitializingFromEmptyProxy();
    error NotKmsNodeFromContext(uint256 contextId, address kmsTxSenderAddress);
    error NotKmsSignerFromContext(uint256 contextId, address signerAddress);
    error NotKmsTxSenderFromContext(uint256 contextId, address txSenderAddress);
    error NotOwnerOrPauser(address notOwnerOrPauser);
    error NumberOfKmsNodesChanged(uint256 activeKmsNodesLength, uint256 newKmsNodesLength);
    error OwnableInvalidOwner(address owner);
    error OwnableUnauthorizedAccount(address account);
    error SuspendedKmsContextOngoing(uint256 suspendedContextId);
    error UUPSUnauthorizedCallContext();
    error UUPSUnsupportedProxiableUUID(bytes32 slot);

    event ActivateKmsContext(uint256 contextId);
    event CompromiseKmsContext(uint256 contextId);
    event DeactivateKmsContext(uint256 contextId);
    event DestroyKmsContext(uint256 contextId);
    event EIP712DomainChanged();
    event Initialization(DecryptionThresholds decryptionThresholds, KmsBlockPeriods blockPeriods, bytes8 softwareVersion, uint256 mpcThreshold, KmsNode[] kmsNodes);
    event Initialized(uint64 version);
    event InvalidateKeyResharing(uint256 contextId);
    event NewKmsContext(KmsContext activeKmsContext, KmsContext newKmsContext);
    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event Paused(address account);
    event PreActivateKmsContext(KmsContext newKmsContext, uint256 preActivationBlockNumber);
    event StartKeyResharing(KmsContext activeKmsContext, KmsContext newKmsContext, uint256 generationBlockNumber);
    event SuspendKmsContext(uint256 contextId);
    event Unpaused(address account);
    event UpdateKmsContextGenerationBlockPeriod(uint256 newKmsContextGenerationBlockPeriod);
    event UpdateKmsContextSuspensionBlockPeriod(uint256 newKmsContextSuspensionBlockPeriod);
    event UpdatePublicDecryptionThreshold(uint256 newPublicDecryptionThreshold);
    event UpdateUserDecryptionThreshold(uint256 newUserDecryptionThreshold);
    event Upgraded(address indexed implementation);
    event ValidateKeyResharing(KmsContext newKmsContext);

    constructor();

    function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
    function acceptOwnership() external;
    function addKmsContext(uint256 preActivationBlockPeriod, bytes8 softwareVersion, bool reshareKeys, uint256 mpcThreshold, KmsNode[] memory kmsNodes, DecryptionThresholds memory decryptionThresholds) external;
    function checkIsKmsSignerFromContext(uint256 contextId, address signerAddress) external view;
    function checkIsKmsTxSenderFromContext(uint256 contextId, address txSenderAddress) external view;
    function compromiseKmsContext(uint256 contextId) external;
    function destroyKmsContext(uint256 contextId) external;
    function eip712Domain() external view returns (bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] memory extensions);
    function getActiveKmsContext() external view returns (KmsContext memory);
    function getActiveKmsContextId() external view returns (uint256);
    function getKmsContextGenerationBlockPeriod() external view returns (uint256);
    function getKmsContextStatus(uint256 contextId) external view returns (ContextStatus);
    function getKmsContextSuspensionBlockPeriod() external view returns (uint256);
    function getKmsNode(address kmsTxSenderAddress) external view returns (KmsNode memory);
    function getKmsNodes() external view returns (KmsNode[] memory);
    function getKmsSigners() external view returns (address[] memory);
    function getKmsTxSenders() external view returns (address[] memory);
    function getPublicDecryptionThresholdFromContext(uint256 contextId) external view returns (uint256);
    function getSuspendedKmsContextId() external view returns (uint256);
    function getUserDecryptionThresholdFromContext(uint256 contextId) external view returns (uint256);
    function getVersion() external pure returns (string memory);
    function initializeFromEmptyProxy(DecryptionThresholds memory initialDecryptionThresholds, KmsBlockPeriods memory initialBlockPeriods, bytes8 initialSoftwareVersion, uint256 initialMpcThreshold, KmsNode[] memory initialKmsNodes) external;
    function moveSuspendedKmsContextToActive() external;
    function owner() external view returns (address);
    function pause() external;
    function paused() external view returns (bool);
    function pendingOwner() external view returns (address);
    function proxiableUUID() external view returns (bytes32);
    function refreshKmsContextStatuses() external;
    function renounceOwnership() external;
    function transferOwnership(address newOwner) external;
    function unpause() external;
    function updateKmsContextGenerationBlockPeriod(uint256 newKmsContextGenerationBlockPeriod) external;
    function updateKmsContextSuspensionBlockPeriod(uint256 newKmsContextSuspensionBlockPeriod) external;
    function updatePublicDecryptionThreshold(uint256 newPublicDecryptionThreshold) external;
    function updateUserDecryptionThreshold(uint256 newUserDecryptionThreshold) external;
    function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
    function validateKeyResharing(uint256 contextId, bytes memory signature) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "UPGRADE_INTERFACE_VERSION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "acceptOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "addKmsContext",
    "inputs": [
      {
        "name": "preActivationBlockPeriod",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "softwareVersion",
        "type": "bytes8",
        "internalType": "bytes8"
      },
      {
        "name": "reshareKeys",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "mpcThreshold",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "kmsNodes",
        "type": "tuple[]",
        "internalType": "struct KmsNode[]",
        "components": [
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "partyId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "backupEncryptionKey",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "externalUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "publicStorageUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "tlsCertificate",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      },
      {
        "name": "decryptionThresholds",
        "type": "tuple",
        "internalType": "struct DecryptionThresholds",
        "components": [
          {
            "name": "publicDecryptionThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "userDecryptionThreshold",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkIsKmsSignerFromContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "signerAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "checkIsKmsTxSenderFromContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "txSenderAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "compromiseKmsContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "destroyKmsContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "eip712Domain",
    "inputs": [],
    "outputs": [
      {
        "name": "fields",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "version",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "verifyingContract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "salt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "extensions",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getActiveKmsContext",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct KmsContext",
        "components": [
          {
            "name": "contextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "previousContextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "softwareVersion",
            "type": "bytes8",
            "internalType": "bytes8"
          },
          {
            "name": "mpcThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "kmsNodes",
            "type": "tuple[]",
            "internalType": "struct KmsNode[]",
            "components": [
              {
                "name": "name",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "signerAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "txSenderAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "partyId",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "backupEncryptionKey",
                "type": "bytes",
                "internalType": "bytes"
              },
              {
                "name": "externalUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "publicStorageUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "tlsCertificate",
                "type": "bytes",
                "internalType": "bytes"
              }
            ]
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getActiveKmsContextId",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsContextGenerationBlockPeriod",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsContextStatus",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "enum ContextStatus"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsContextSuspensionBlockPeriod",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsNode",
    "inputs": [
      {
        "name": "kmsTxSenderAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct KmsNode",
        "components": [
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "partyId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "backupEncryptionKey",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "externalUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "publicStorageUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "tlsCertificate",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsNodes",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "tuple[]",
        "internalType": "struct KmsNode[]",
        "components": [
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "partyId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "backupEncryptionKey",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "externalUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "publicStorageUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "tlsCertificate",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsSigners",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsTxSenders",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPublicDecryptionThresholdFromContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getSuspendedKmsContextId",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getUserDecryptionThresholdFromContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getVersion",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "initializeFromEmptyProxy",
    "inputs": [
      {
        "name": "initialDecryptionThresholds",
        "type": "tuple",
        "internalType": "struct DecryptionThresholds",
        "components": [
          {
            "name": "publicDecryptionThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "userDecryptionThreshold",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      },
      {
        "name": "initialBlockPeriods",
        "type": "tuple",
        "internalType": "struct KmsBlockPeriods",
        "components": [
          {
            "name": "preActivationBlockPeriod",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "generationBlockPeriod",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "suspensionBlockPeriod",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      },
      {
        "name": "initialSoftwareVersion",
        "type": "bytes8",
        "internalType": "bytes8"
      },
      {
        "name": "initialMpcThreshold",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "initialKmsNodes",
        "type": "tuple[]",
        "internalType": "struct KmsNode[]",
        "components": [
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "partyId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "backupEncryptionKey",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "externalUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "publicStorageUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "tlsCertificate",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "moveSuspendedKmsContextToActive",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "paused",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pendingOwner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "proxiableUUID",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "refreshKmsContextStatuses",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "unpause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateKmsContextGenerationBlockPeriod",
    "inputs": [
      {
        "name": "newKmsContextGenerationBlockPeriod",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateKmsContextSuspensionBlockPeriod",
    "inputs": [
      {
        "name": "newKmsContextSuspensionBlockPeriod",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updatePublicDecryptionThreshold",
    "inputs": [
      {
        "name": "newPublicDecryptionThreshold",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateUserDecryptionThreshold",
    "inputs": [
      {
        "name": "newUserDecryptionThreshold",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "upgradeToAndCall",
    "inputs": [
      {
        "name": "newImplementation",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "validateKeyResharing",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "signature",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "ActivateKmsContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "CompromiseKmsContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DeactivateKmsContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DestroyKmsContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EIP712DomainChanged",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialization",
    "inputs": [
      {
        "name": "decryptionThresholds",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct DecryptionThresholds",
        "components": [
          {
            "name": "publicDecryptionThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "userDecryptionThreshold",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      },
      {
        "name": "blockPeriods",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct KmsBlockPeriods",
        "components": [
          {
            "name": "preActivationBlockPeriod",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "generationBlockPeriod",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "suspensionBlockPeriod",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      },
      {
        "name": "softwareVersion",
        "type": "bytes8",
        "indexed": false,
        "internalType": "bytes8"
      },
      {
        "name": "mpcThreshold",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "kmsNodes",
        "type": "tuple[]",
        "indexed": false,
        "internalType": "struct KmsNode[]",
        "components": [
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "partyId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "backupEncryptionKey",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "externalUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "publicStorageUrl",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "tlsCertificate",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      {
        "name": "version",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "InvalidateKeyResharing",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "NewKmsContext",
    "inputs": [
      {
        "name": "activeKmsContext",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct KmsContext",
        "components": [
          {
            "name": "contextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "previousContextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "softwareVersion",
            "type": "bytes8",
            "internalType": "bytes8"
          },
          {
            "name": "mpcThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "kmsNodes",
            "type": "tuple[]",
            "internalType": "struct KmsNode[]",
            "components": [
              {
                "name": "name",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "signerAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "txSenderAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "partyId",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "backupEncryptionKey",
                "type": "bytes",
                "internalType": "bytes"
              },
              {
                "name": "externalUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "publicStorageUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "tlsCertificate",
                "type": "bytes",
                "internalType": "bytes"
              }
            ]
          }
        ]
      },
      {
        "name": "newKmsContext",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct KmsContext",
        "components": [
          {
            "name": "contextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "previousContextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "softwareVersion",
            "type": "bytes8",
            "internalType": "bytes8"
          },
          {
            "name": "mpcThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "kmsNodes",
            "type": "tuple[]",
            "internalType": "struct KmsNode[]",
            "components": [
              {
                "name": "name",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "signerAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "txSenderAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "partyId",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "backupEncryptionKey",
                "type": "bytes",
                "internalType": "bytes"
              },
              {
                "name": "externalUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "publicStorageUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "tlsCertificate",
                "type": "bytes",
                "internalType": "bytes"
              }
            ]
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferStarted",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Paused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "PreActivateKmsContext",
    "inputs": [
      {
        "name": "newKmsContext",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct KmsContext",
        "components": [
          {
            "name": "contextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "previousContextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "softwareVersion",
            "type": "bytes8",
            "internalType": "bytes8"
          },
          {
            "name": "mpcThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "kmsNodes",
            "type": "tuple[]",
            "internalType": "struct KmsNode[]",
            "components": [
              {
                "name": "name",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "signerAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "txSenderAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "partyId",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "backupEncryptionKey",
                "type": "bytes",
                "internalType": "bytes"
              },
              {
                "name": "externalUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "publicStorageUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "tlsCertificate",
                "type": "bytes",
                "internalType": "bytes"
              }
            ]
          }
        ]
      },
      {
        "name": "preActivationBlockNumber",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "StartKeyResharing",
    "inputs": [
      {
        "name": "activeKmsContext",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct KmsContext",
        "components": [
          {
            "name": "contextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "previousContextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "softwareVersion",
            "type": "bytes8",
            "internalType": "bytes8"
          },
          {
            "name": "mpcThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "kmsNodes",
            "type": "tuple[]",
            "internalType": "struct KmsNode[]",
            "components": [
              {
                "name": "name",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "signerAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "txSenderAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "partyId",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "backupEncryptionKey",
                "type": "bytes",
                "internalType": "bytes"
              },
              {
                "name": "externalUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "publicStorageUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "tlsCertificate",
                "type": "bytes",
                "internalType": "bytes"
              }
            ]
          }
        ]
      },
      {
        "name": "newKmsContext",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct KmsContext",
        "components": [
          {
            "name": "contextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "previousContextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "softwareVersion",
            "type": "bytes8",
            "internalType": "bytes8"
          },
          {
            "name": "mpcThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "kmsNodes",
            "type": "tuple[]",
            "internalType": "struct KmsNode[]",
            "components": [
              {
                "name": "name",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "signerAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "txSenderAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "partyId",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "backupEncryptionKey",
                "type": "bytes",
                "internalType": "bytes"
              },
              {
                "name": "externalUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "publicStorageUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "tlsCertificate",
                "type": "bytes",
                "internalType": "bytes"
              }
            ]
          }
        ]
      },
      {
        "name": "generationBlockNumber",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SuspendKmsContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Unpaused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "UpdateKmsContextGenerationBlockPeriod",
    "inputs": [
      {
        "name": "newKmsContextGenerationBlockPeriod",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "UpdateKmsContextSuspensionBlockPeriod",
    "inputs": [
      {
        "name": "newKmsContextSuspensionBlockPeriod",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "UpdatePublicDecryptionThreshold",
    "inputs": [
      {
        "name": "newPublicDecryptionThreshold",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "UpdateUserDecryptionThreshold",
    "inputs": [
      {
        "name": "newUserDecryptionThreshold",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Upgraded",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ValidateKeyResharing",
    "inputs": [
      {
        "name": "newKmsContext",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct KmsContext",
        "components": [
          {
            "name": "contextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "previousContextId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "softwareVersion",
            "type": "bytes8",
            "internalType": "bytes8"
          },
          {
            "name": "mpcThreshold",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "kmsNodes",
            "type": "tuple[]",
            "internalType": "struct KmsNode[]",
            "components": [
              {
                "name": "name",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "signerAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "txSenderAddress",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "partyId",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "backupEncryptionKey",
                "type": "bytes",
                "internalType": "bytes"
              },
              {
                "name": "externalUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "publicStorageUrl",
                "type": "string",
                "internalType": "string"
              },
              {
                "name": "tlsCertificate",
                "type": "bytes",
                "internalType": "bytes"
              }
            ]
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AddressEmptyCode",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "CompromiseActiveKmsContextNotAllowed",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ContextAlreadyExists",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ContextNotActive",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ContextNotActiveOrSuspended",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ContextNotGenerated",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ContextNotInitializedOrIsGenerating",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ContextNotPreActivatedOrSuspended",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "DestroyActiveKmsContextNotAllowed",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignature",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureLength",
    "inputs": [
      {
        "name": "length",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureS",
    "inputs": [
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1967InvalidImplementation",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1967NonPayable",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyKmsNodes",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EnforcedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ExpectedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FailedCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidHighMpcThreshold",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "mpcThreshold",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nKmsNodes",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidHighPublicDecryptionThreshold",
    "inputs": [
      {
        "name": "publicDecryptionThreshold",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nKmsNodes",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidHighUserDecryptionThreshold",
    "inputs": [
      {
        "name": "userDecryptionThreshold",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nKmsNodes",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidInitialization",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidNullContextId",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidNullPublicDecryptionThreshold",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidNullUserDecryptionThreshold",
    "inputs": []
  },
  {
    "type": "error",
    "name": "KmsContextNotGenerating",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "KmsContextNotInitialized",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "KmsNodeAlreadyValidatedKeyResharing",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "kmsSigner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NoSuspendedKmsContext",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotInitializing",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotInitializingFromEmptyProxy",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotKmsNodeFromContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "kmsTxSenderAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotKmsSignerFromContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "signerAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotKmsTxSenderFromContext",
    "inputs": [
      {
        "name": "contextId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "txSenderAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotOwnerOrPauser",
    "inputs": [
      {
        "name": "notOwnerOrPauser",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NumberOfKmsNodesChanged",
    "inputs": [
      {
        "name": "activeKmsNodesLength",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "newKmsNodesLength",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "OwnableInvalidOwner",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "OwnableUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "SuspendedKmsContextOngoing",
    "inputs": [
      {
        "name": "suspendedContextId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "UUPSUnauthorizedCallContext",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UUPSUnsupportedProxiableUUID",
    "inputs": [
      {
        "name": "slot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod KmsContexts {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a06040523073ffffffffffffffffffffffffffffffffffffffff1660809073ffffffffffffffffffffffffffffffffffffffff1681525034801562000043575f80fd5b50620000546200005a60201b60201c565b620001c4565b5f6200006b6200015e60201b60201c565b9050805f0160089054906101000a900460ff1615620000b6576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b67ffffffffffffffff8016815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff16146200015b5767ffffffffffffffff815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d267ffffffffffffffff604051620001529190620001a9565b60405180910390a15b50565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b5f67ffffffffffffffff82169050919050565b620001a38162000185565b82525050565b5f602082019050620001be5f83018462000198565b92915050565b608051617693620001eb5f395f8181613bfd01528181613c520152613e0c01526176935ff3fe608060405260043610610224575f3560e01c80638456cb5911610122578063d8e3ae01116100aa578063e3b2a8741161006e578063e3b2a87414610748578063e72ee99114610784578063eb843cf6146107ae578063f27cb957146107d6578063f2fde38b146107ec57610224565b8063d8e3ae011461067c578063defba06a146106a6578063dfe36aee146106ce578063e24ba4e5146106f6578063e30c39781461071e57610224565b80639ee77af3116100f15780639ee77af31461059e578063ad3cb1cc146105c6578063b8715d4d146105f0578063c0ae64f71461062c578063c1c8b7251461065457610224565b80638456cb591461051857806384b0196e1461052e5780638cb967511461055e5780638da5cb5b1461057457610224565b80634d694260116101b05780636a1d51eb116101745780636a1d51eb14610470578063715018a6146104985780637420f3d4146104ae57806379ba5097146104d85780637eaac8f2146104ee57610224565b80634d694260146103885780634f1ef286146103c457806352d1902d146103e05780635c975abb1461040a57806364b00cc51461043457610224565b8063169cac14116101f7578063169cac14146102ce5780632e2d3a82146102f65780633f4ba83a1461031e57806343e37e8a146103345780634965e4551461035e57610224565b80630a50e318146102285780630d8e6e2c146102525780630dd486c01461027c5780631079ebeb146102a6575b5f80fd5b348015610233575f80fd5b5061023c610814565b6040516102499190615621565b60405180910390f35b34801561025d575f80fd5b5061026661082d565b60405161027391906156c4565b60405180910390f35b348015610287575f80fd5b506102906108a8565b60405161029d91906159fd565b60405180910390f35b3480156102b1575f80fd5b506102cc60048036038101906102c79190615ab9565b610d34565b005b3480156102d9575f80fd5b506102f460048036038101906102ef9190615bec565b6112f1565b005b348015610301575f80fd5b5061031c60048036038101906103179190615c96565b6114ba565b005b348015610329575f80fd5b50610332611523565b005b34801561033f575f80fd5b50610348611535565b6040516103559190615621565b60405180910390f35b348015610369575f80fd5b5061037261154e565b60405161037f9190615621565b60405180910390f35b348015610393575f80fd5b506103ae60048036038101906103a99190615c96565b611565565b6040516103bb9190615d34565b60405180910390f35b6103de60048036038101906103d99190615e9f565b611585565b005b3480156103eb575f80fd5b506103f46115a4565b6040516104019190615f11565b60405180910390f35b348015610415575f80fd5b5061041e6115d5565b60405161042b9190615f39565b60405180910390f35b34801561043f575f80fd5b5061045a60048036038101906104559190615c96565b6115f7565b6040516104679190615621565b60405180910390f35b34801561047b575f80fd5b5061049660048036038101906104919190615f70565b611686565b005b3480156104a3575f80fd5b506104ac611903565b005b3480156104b9575f80fd5b506104c2611916565b6040516104cf91906160af565b60405180910390f35b3480156104e3575f80fd5b506104ec6119ca565b005b3480156104f9575f80fd5b50610502611a58565b60405161050f91906160af565b60405180910390f35b348015610523575f80fd5b5061052c611b0c565b005b348015610539575f80fd5b50610542611c47565b60405161055597969594939291906161c0565b60405180910390f35b348015610569575f80fd5b50610572611d50565b005b34801561057f575f80fd5b50610588611f42565b6040516105959190616242565b60405180910390f35b3480156105a9575f80fd5b506105c460048036038101906105bf9190615c96565b611f77565b005b3480156105d1575f80fd5b506105da612086565b6040516105e791906156c4565b60405180910390f35b3480156105fb575f80fd5b5061061660048036038101906106119190615c96565b6120bf565b6040516106239190615621565b60405180910390f35b348015610637575f80fd5b50610652600480360381019061064d9190615c96565b61214e565b005b34801561065f575f80fd5b5061067a60048036038101906106759190615c96565b61225d565b005b348015610687575f80fd5b506106906122bc565b60405161069d9190615621565b60405180910390f35b3480156106b1575f80fd5b506106cc60048036038101906106c7919061625b565b6122d3565b005b3480156106d9575f80fd5b506106f460048036038101906106ef919061625b565b6123e8565b005b348015610701575f80fd5b5061071c60048036038101906107179190615c96565b6124fd565b005b348015610729575f80fd5b5061073261255c565b60405161073f9190616242565b60405180910390f35b348015610753575f80fd5b5061076e60048036038101906107699190616299565b612591565b60405161077b919061638d565b60405180910390f35b34801561078f575f80fd5b50610798612a10565b6040516107a59190616430565b60405180910390f35b3480156107b9575f80fd5b506107d460048036038101906107cf9190615c96565b612a23565b005b3480156107e1575f80fd5b506107ea612a8c565b005b3480156107f7575f80fd5b50610812600480360381019061080d9190616299565b612b79565b005b5f8061081e612c32565b9050805f016004015491505090565b60606040518060400160405280600b81526020017f4b6d73436f6e746578747300000000000000000000000000000000000000000081525061086e5f612c59565b6108786001612c59565b6108815f612c59565b604051602001610894949392919061651e565b604051602081830303815290604052905090565b6108b0615555565b5f6108b9612c32565b90505f6108c4611535565b9050816008015f8281526020019081526020015f206040518060a00160405290815f820154815260200160018201548152602001600282015f9054906101000a900460c01b77ffffffffffffffffffffffffffffffffffffffffffffffff191677ffffffffffffffffffffffffffffffffffffffffffffffff191681526020016003820154815260200160048201805480602002602001604051908101604052809291908181526020015f905b82821015610d25578382905f5260205f209060080201604051806101000160405290815f820180546109a2906165a9565b80601f01602080910402602001604051908101604052809291908181526020018280546109ce906165a9565b8015610a195780601f106109f057610100808354040283529160200191610a19565b820191905f5260205f20905b8154815290600101906020018083116109fc57829003601f168201915b50505050508152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200160038201548152602001600482018054610ae6906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054610b12906165a9565b8015610b5d5780601f10610b3457610100808354040283529160200191610b5d565b820191905f5260205f20905b815481529060010190602001808311610b4057829003601f168201915b50505050508152602001600582018054610b76906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054610ba2906165a9565b8015610bed5780601f10610bc457610100808354040283529160200191610bed565b820191905f5260205f20905b815481529060010190602001808311610bd057829003601f168201915b50505050508152602001600682018054610c06906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054610c32906165a9565b8015610c7d5780601f10610c5457610100808354040283529160200191610c7d565b820191905f5260205f20905b815481529060010190602001808311610c6057829003601f168201915b50505050508152602001600782018054610c96906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054610cc2906165a9565b8015610d0d5780601f10610ce457610100808354040283529160200191610d0d565b820191905f5260205f20905b815481529060010190602001808311610cf057829003601f168201915b50505050508152505081526020019060010190610971565b50505050815250509250505090565b610d3e83336122d3565b5f610d47612c32565b9050610d55815f0185612d23565b610d9657836040517f5e51a2e1000000000000000000000000000000000000000000000000000000008152600401610d8d9190615621565b60405180910390fd5b5f60405180602001604052808681525090505f610db282612d72565b9050610dc086828787612dcd565b5f83600c015f8881526020019081526020015f20905080868690918060018154018082558091505060019003905f5260205f20015f909192909192909192909192509182610e0f929190616780565b505f846008015f8981526020019081526020015f206040518060a00160405290815f820154815260200160018201548152602001600282015f9054906101000a900460c01b77ffffffffffffffffffffffffffffffffffffffffffffffff191677ffffffffffffffffffffffffffffffffffffffffffffffff191681526020016003820154815260200160048201805480602002602001604051908101604052809291908181526020015f905b82821015611270578382905f5260205f209060080201604051806101000160405290815f82018054610eed906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054610f19906165a9565b8015610f645780601f10610f3b57610100808354040283529160200191610f64565b820191905f5260205f20905b815481529060010190602001808311610f4757829003601f168201915b50505050508152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200160038201548152602001600482018054611031906165a9565b80601f016020809104026020016040519081016040528092919081815260200182805461105d906165a9565b80156110a85780601f1061107f576101008083540402835291602001916110a8565b820191905f5260205f20905b81548152906001019060200180831161108b57829003601f168201915b505050505081526020016005820180546110c1906165a9565b80601f01602080910402602001604051908101604052809291908181526020018280546110ed906165a9565b80156111385780601f1061110f57610100808354040283529160200191611138565b820191905f5260205f20905b81548152906001019060200180831161111b57829003601f168201915b50505050508152602001600682018054611151906165a9565b80601f016020809104026020016040519081016040528092919081815260200182805461117d906165a9565b80156111c85780601f1061119f576101008083540402835291602001916111c8565b820191905f5260205f20905b8154815290600101906020018083116111ab57829003601f168201915b505050505081526020016007820180546111e1906165a9565b80601f016020809104026020016040519081016040528092919081815260200182805461120d906165a9565b80156112585780601f1061122f57610100808354040283529160200191611258565b820191905f5260205f20905b81548152906001019060200180831161123b57829003601f168201915b50505050508152505081526020019060010190610ebc565b50505050815250509050611288818380549050612f3f565b156112e7575f856006015f8a81526020019081526020015f205490506112ae8282612f56565b7f68898a98936bf23a56e8ed4b23dcc98cef926bd9ac2ce522f1f9423e3864f2f5826040516112dd91906159fd565b60405180910390a1505b5050505050505050565b6112f9612fd9565b5f611302612c32565b90505f61130d6108a8565b90505f81608001515190505f8686905090508181146113655781816040517fd595a96200000000000000000000000000000000000000000000000000000000815260040161135c92919061684d565b60405180910390fd5b5f61136e610814565b90505f81146113b457806040517f7623d3570000000000000000000000000000000000000000000000000000000081526004016113ab9190615621565b60405180910390fd5b5f6113c6855f01518d8c8c8c8c613060565b90507f3662ec316d76e6a75eb7c45001a8ad74c3eb943e8778111c0225f2a9fd5e00e685826040516113f9929190616874565b60405180910390a1611410865f01825f01516139ae565b8a156114a0578c866006015f835f015181526020019081526020015f20819055505f86600501544361144291906168d6565b905080876012015f845f015181526020019081526020015f20819055507f5dc601065a035d78305cd9ef27c91a009cd8d37297e43bb76319490895a0d05886838360405161149293929190616909565b60405180910390a1506114ab565b6114aa818e612f56565b5b50505050505050505050505050565b6114c2612fd9565b6114ca613a7b565b5f6114d36108a8565b90506114e8815f015183836080015151613abc565b7fe41802af725729adcb8c151e2937380a25c69155757e3af5d3979adab5035800826040516115179190615621565b60405180910390a15050565b61152b612fd9565b611533613b65565b565b5f8061153f612c32565b9050805f016003015491505090565b5f80611558612c32565b9050806005015491505090565b5f8061156f612c32565b905061157d815f0184613bd3565b915050919050565b61158d613bfb565b61159682613ce1565b6115a08282613cec565b5050565b5f6115ad613e0a565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b905090565b5f806115df613e91565b9050805f015f9054906101000a900460ff1691505090565b5f815f611602612c32565b90505f816008015f8481526020019081526020015f205f01540361165d57816040517f82b1fbda0000000000000000000000000000000000000000000000000000000081526004016116549190615621565b60405180910390fd5b5f611666612c32565b9050806016015f8681526020019081526020015f20549350505050919050565b6001611690613eb8565b67ffffffffffffffff16146116d1576040517f6f4f731f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60025f6116dc613edc565b9050805f0160089054906101000a900460ff168061172457508167ffffffffffffffff16815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff1610155b1561175b576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055506001815f0160086101000a81548160ff0219169083151502179055506118146040518060400160405280600b81526020017f4b6d73436f6e74657874730000000000000000000000000000000000000000008152506040518060400160405280600181526020017f3100000000000000000000000000000000000000000000000000000000000000815250613f03565b61182461181f611f42565b613f19565b61182c613f2d565b5f61183b5f888888888e613060565b90505f611846612c32565b9050611857815f01835f0151613f3f565b61186489835f015161403a565b7f016ee9c16213ed67f33222abad4dfe46eb951ead30a10a1a72db3316ffb664e08a8a8a8a8a8a60405161189d96959493929190616d19565b60405180910390a150505f815f0160086101000a81548160ff0219169083151502179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2826040516118f19190616d96565b60405180910390a15050505050505050565b61190b612fd9565b6119145f61407f565b565b60605f611921611535565b90505f61192c612c32565b9050806010015f8381526020019081526020015f208054806020026020016040519081016040528092919081815260200182805480156119be57602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311611975575b50505050509250505090565b5f6119d36140bc565b90508073ffffffffffffffffffffffffffffffffffffffff166119f461255c565b73ffffffffffffffffffffffffffffffffffffffff1614611a4c57806040517f118cdaa7000000000000000000000000000000000000000000000000000000008152600401611a439190616242565b60405180910390fd5b611a558161407f565b50565b60605f611a63611535565b90505f611a6e612c32565b9050806011015f8381526020019081526020015f20805480602002602001604051908101604052809291908181526020018280548015611b0057602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311611ab7575b50505050509250505090565b611b14611f42565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614158015611bfb575073c7d45661a345ec5ca0e8521cfef7e32fda0daa6873ffffffffffffffffffffffffffffffffffffffff16637008b5486040518163ffffffff1660e01b8152600401602060405180830381865afa158015611ba7573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611bcb9190616dc3565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614155b15611c3d57336040517f46c0d9af000000000000000000000000000000000000000000000000000000008152600401611c349190616242565b60405180910390fd5b611c456140c3565b565b5f6060805f805f60605f611c59614132565b90505f801b815f0154148015611c7457505f801b8160010154145b611cb3576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611caa90616e38565b60405180910390fd5b611cbb614159565b611cc36141f7565b46305f801b5f67ffffffffffffffff811115611ce257611ce1615d7b565b5b604051908082528060200260200182016040528015611d105781602001602082028036833780820191505090505b507f0f0000000000000000000000000000000000000000000000000000000000000095949392919097509750975097509750975097505090919293949596565b611d58613a7b565b5f611d61612c32565b90505f815f016001015490505f8114611e0a57816012015f8281526020019081526020015f2054431115611e09577e9fe8f0db45996decf7b06fc7b6ec5f887d5f04db2e0c4ad7f4e4ee5eefc5a381604051611dbd9190615621565b60405180910390a1611dd1825f0182614295565b7f3e8f02dc7af6e3a67f3af0bc99bcf11b4deb46105e9ba7f1ac6da82322e9025e81604051611e009190615621565b60405180910390a15b5b5f825f016002015490505f8114611eca57826013015f8281526020019081526020015f2054431115611ec9575f611e3f611535565b9050611e4d845f0182614362565b7f851a08c16b15959c338ac4b56466d06c9f9d5ff8d715168aa125d5ccaf53832081604051611e7c9190615621565b60405180910390a1611e90845f0183613f3f565b7f4f54a6ac981cc8dc83142b3eb4d120be7c70fc5de6477a14eae3e9ca647644bc82604051611ebf9190615621565b60405180910390a1505b5b5f611ed3610814565b90505f8114611f3c57836014015f8281526020019081526020015f2054431115611f3b57611f03845f0182614438565b7f8fb75858a565aee117342d93196a7f0b54c1c8519885eddda6a01f477359b36381604051611f329190615621565b60405180910390a15b5b50505050565b5f80611f4c61453a565b9050805f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b611f7f612fd9565b805f611f89612c32565b90505f816008015f8481526020019081526020015f205f015403611fe457816040517f82b1fbda000000000000000000000000000000000000000000000000000000008152600401611fdb9190615621565b60405180910390fd5b5f611fed612c32565b9050611ffb815f0185614561565b1561203d57836040517f77d05ea70000000000000000000000000000000000000000000000000000000081526004016120349190615621565b60405180910390fd5b612049815f01856145b0565b7fbc1114fa9a77648cd097ee6cf149c344fa278b9b983f30dd65b6fd6a9d464a07846040516120789190615621565b60405180910390a150505050565b6040518060400160405280600581526020017f352e302e3000000000000000000000000000000000000000000000000000000081525081565b5f815f6120ca612c32565b90505f816008015f8481526020019081526020015f205f01540361212557816040517f82b1fbda00000000000000000000000000000000000000000000000000000000815260040161211c9190615621565b60405180910390fd5b5f61212e612c32565b9050806015015f8681526020019081526020015f20549350505050919050565b612156612fd9565b805f612160612c32565b90505f816008015f8481526020019081526020015f205f0154036121bb57816040517f82b1fbda0000000000000000000000000000000000000000000000000000000081526004016121b29190615621565b60405180910390fd5b5f6121c4612c32565b90506121d2815f0185614561565b1561221457836040517fb25e4eb300000000000000000000000000000000000000000000000000000000815260040161220b9190615621565b60405180910390fd5b612220815f0185614295565b7f3e8f02dc7af6e3a67f3af0bc99bcf11b4deb46105e9ba7f1ac6da82322e9025e8460405161224f9190615621565b60405180910390a150505050565b612265612fd9565b61226d613a7b565b5f612276612c32565b90508181600701819055507f3ad5c22724afab8ed2b578fb9b160c7f65f5abd0aad105752b7ba4e068a3e021826040516122b09190615621565b60405180910390a15050565b5f806122c6612c32565b9050806007015491505090565b815f6122dd612c32565b90505f816008015f8481526020019081526020015f205f01540361233857816040517f82b1fbda00000000000000000000000000000000000000000000000000000000815260040161232f9190615621565b60405180910390fd5b5f612341612c32565b905080600e015f8681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff166123e15784846040517ffdf8a05d0000000000000000000000000000000000000000000000000000000081526004016123d8929190616e56565b60405180910390fd5b5050505050565b815f6123f2612c32565b90505f816008015f8481526020019081526020015f205f01540361244d57816040517f82b1fbda0000000000000000000000000000000000000000000000000000000081526004016124449190615621565b60405180910390fd5b5f612456612c32565b905080600f015f8681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff166124f65784846040517f89b45e5d0000000000000000000000000000000000000000000000000000000081526004016124ed929190616e56565b60405180910390fd5b5050505050565b612505612fd9565b61250d613a7b565b5f612516612c32565b90508181600501819055507f53cb968d31c28c6504a6e73d9908db6e1c1a386b66dcacec1a0117752c5ab986826040516125509190615621565b60405180910390a15050565b5f806125666146c5565b9050805f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b61259961559b565b5f6125a2611535565b90505f6125ad612c32565b90505f81600d015f8481526020019081526020015f205f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20604051806101000160405290815f82018054612619906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054612645906165a9565b80156126905780601f1061266757610100808354040283529160200191612690565b820191905f5260205f20905b81548152906001019060200180831161267357829003601f168201915b50505050508152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020016003820154815260200160048201805461275d906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054612789906165a9565b80156127d45780601f106127ab576101008083540402835291602001916127d4565b820191905f5260205f20905b8154815290600101906020018083116127b757829003601f168201915b505050505081526020016005820180546127ed906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054612819906165a9565b80156128645780601f1061283b57610100808354040283529160200191612864565b820191905f5260205f20905b81548152906001019060200180831161284757829003601f168201915b5050505050815260200160068201805461287d906165a9565b80601f01602080910402602001604051908101604052809291908181526020018280546128a9906165a9565b80156128f45780601f106128cb576101008083540402835291602001916128f4565b820191905f5260205f20905b8154815290600101906020018083116128d757829003601f168201915b5050505050815260200160078201805461290d906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054612939906165a9565b80156129845780601f1061295b57610100808354040283529160200191612984565b820191905f5260205f20905b81548152906001019060200180831161296757829003601f168201915b50505050508152505090505f73ffffffffffffffffffffffffffffffffffffffff16816040015173ffffffffffffffffffffffffffffffffffffffff1603612a055782856040517f0494d3c00000000000000000000000000000000000000000000000000000000081526004016129fc929190616e56565b60405180910390fd5b809350505050919050565b6060612a1a6108a8565b60800151905090565b612a2b612fd9565b612a33613a7b565b5f612a3c6108a8565b9050612a51815f0151838360800151516146ec565b7f837e0a6528dadfa2dc792692c5182e52a9f5bbdeed7b2372927a26c69583961382604051612a809190615621565b60405180910390a15050565b612a94612fd9565b5f612a9d612c32565b90505f612aa8610814565b90505f8103612ae3576040517f207ea3f300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f612aec611535565b9050612afa835f0182614438565b7f8fb75858a565aee117342d93196a7f0b54c1c8519885eddda6a01f477359b36381604051612b299190615621565b60405180910390a1612b3d835f0183613f3f565b7f4f54a6ac981cc8dc83142b3eb4d120be7c70fc5de6477a14eae3e9ca647644bc82604051612b6c9190615621565b60405180910390a1505050565b612b81612fd9565b5f612b8a6146c5565b905081815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff16612bec611f42565b73ffffffffffffffffffffffffffffffffffffffff167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a35050565b5f7f7d8159810a7ebf944e8fa93cc4fbd1cade6c71f8b0b86b37187ac7991777b100905090565b60605f6001612c6784614795565b0190505f8167ffffffffffffffff811115612c8557612c84615d7b565b5b6040519080825280601f01601f191660200182016040528015612cb75781602001600182028036833780820191505090505b5090505f82602001820190505b600115612d18578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a8581612d0d57612d0c616e7d565b5b0494505f8503612cc4575b819350505050919050565b5f60016007811115612d3857612d37615cc1565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115612d6957612d68615cc1565b5b14905092915050565b5f612dc66040518060600160405280602b8152602001617668602b913980519060200120835f0151604051602001612dab929190616eaa565b604051602081830303815290604052805190602001206148e6565b9050919050565b5f612dd6612c32565b90505f612e268585858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f81840152601f19601f820116905080830192505050505050506148ff565b9050612e3286826123e8565b81600a015f8781526020019081526020015f205f8273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff1615612ed15785816040517f99b158c1000000000000000000000000000000000000000000000000000000008152600401612ec8929190616e56565b60405180910390fd5b600182600a015f8881526020019081526020015f205f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550505050505050565b5f8083608001515190508083101591505092915050565b5f612f5f612c32565b9050612f70815f01845f0151614929565b5f8243612f7d91906168d6565b905080826013015f865f015181526020019081526020015f20819055507f4540f7808fcaec86c376a89d2c0c93a5056c21680db54332c7f2959d87fefc8b8482604051612fcb929190616ed1565b60405180910390a150505050565b612fe16140bc565b73ffffffffffffffffffffffffffffffffffffffff16612fff611f42565b73ffffffffffffffffffffffffffffffffffffffff161461305e576130226140bc565b6040517f118cdaa70000000000000000000000000000000000000000000000000000000081526004016130559190616242565b60405180910390fd5b565b613068615555565b5f613071612c32565b90505f85859050036130af576040517f068c8d4000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b806009015f8154809291906130c390616eff565b91905055505f8160090154905080826008015f8381526020019081526020015f205f018190555088826008015f8381526020019081526020015f206001018190555087826008015f8381526020019081526020015f206002015f6101000a81548167ffffffffffffffff021916908360c01c02179055506131488188888890506149ff565b5f5b868690508110156131d157826008015f8381526020019081526020015f2060040187878381811061317e5761317d616f46565b5b90506020028101906131909190616f7f565b908060018154018082558091505060019003905f5260205f2090600802015f9091909190915081816131c29190617401565b5050808060010191505061314a565b505f5b8686905081101561352a578686828181106131f2576131f1616f46565b5b90506020028101906132049190616f7f565b83600d015f8481526020019081526020015f205f89898581811061322b5761322a616f46565b5b905060200281019061323d9190616f7f565b604001602081019061324f9190616299565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2081816132949190617401565b905050600183600e015f8481526020019081526020015f205f8989858181106132c0576132bf616f46565b5b90506020028101906132d29190616f7f565b60400160208101906132e49190616299565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550826010015f8381526020019081526020015f2087878381811061335957613358616f46565b5b905060200281019061336b9190616f7f565b604001602081019061337d9190616299565b908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600183600f015f8481526020019081526020015f205f89898581811061340357613402616f46565b5b90506020028101906134159190616f7f565b60200160208101906134279190616299565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550826011015f8381526020019081526020015f2087878381811061349c5761349b616f46565b5b90506020028101906134ae9190616f7f565b60200160208101906134c09190616299565b908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080806001019150506131d4565b50613539818588889050614a73565b816008015f8281526020019081526020015f206040518060a00160405290815f820154815260200160018201548152602001600282015f9054906101000a900460c01b77ffffffffffffffffffffffffffffffffffffffffffffffff191677ffffffffffffffffffffffffffffffffffffffffffffffff191681526020016003820154815260200160048201805480602002602001604051908101604052809291908181526020015f905b82821015613998578382905f5260205f209060080201604051806101000160405290815f82018054613615906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054613641906165a9565b801561368c5780601f106136635761010080835404028352916020019161368c565b820191905f5260205f20905b81548152906001019060200180831161366f57829003601f168201915b50505050508152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200160038201548152602001600482018054613759906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054613785906165a9565b80156137d05780601f106137a7576101008083540402835291602001916137d0565b820191905f5260205f20905b8154815290600101906020018083116137b357829003601f168201915b505050505081526020016005820180546137e9906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054613815906165a9565b80156138605780601f1061383757610100808354040283529160200191613860565b820191905f5260205f20905b81548152906001019060200180831161384357829003601f168201915b50505050508152602001600682018054613879906165a9565b80601f01602080910402602001604051908101604052809291908181526020018280546138a5906165a9565b80156138f05780601f106138c7576101008083540402835291602001916138f0565b820191905f5260205f20905b8154815290600101906020018083116138d357829003601f168201915b50505050508152602001600782018054613909906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054613935906165a9565b80156139805780601f1061395757610100808354040283529160200191613980565b820191905f5260205f20905b81548152906001019060200180831161396357829003601f168201915b505050505081525050815260200190600101906135e4565b5050505081525050925050509695505050505050565b805f81036139e8576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6139f28383614a95565b613a3357816040517f6653f6d7000000000000000000000000000000000000000000000000000000008152600401613a2a9190615621565b60405180910390fd5b6001835f015f8481526020019081526020015f205f6101000a81548160ff02191690836007811115613a6857613a67615cc1565b5b0217905550818360010181905550505050565b613a836115d5565b15613aba576040517fd93c066500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f613ac5612c32565b90505f8303613b00576040517fb1ae92ea00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81831115613b475782826040517f84208f23000000000000000000000000000000000000000000000000000000008152600401613b3e92919061684d565b60405180910390fd5b82816015015f8681526020019081526020015f208190555050505050565b613b6d614ae3565b5f613b76613e91565b90505f815f015f6101000a81548160ff0219169083151502179055507f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa613bbb6140bc565b604051613bc89190616242565b60405180910390a150565b5f825f015f8381526020019081526020015f205f9054906101000a900460ff16905092915050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff161480613ca857507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16613c8f614b23565b73ffffffffffffffffffffffffffffffffffffffff1614155b15613cdf576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b613ce9612fd9565b50565b8173ffffffffffffffffffffffffffffffffffffffff166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015613d5457506040513d601f19601f82011682018060405250810190613d519190617439565b60015b613d9557816040517f4c9c8ce3000000000000000000000000000000000000000000000000000000008152600401613d8c9190616242565b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b8114613dfb57806040517faa1d49a4000000000000000000000000000000000000000000000000000000008152600401613df29190615f11565b60405180910390fd5b613e058383614b76565b505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614613e8f576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f7fcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300905090565b5f613ec1613edc565b5f015f9054906101000a900467ffffffffffffffff16905090565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b613f0b614be8565b613f158282614c28565b5050565b613f21614be8565b613f2a81614c79565b50565b613f35614be8565b613f3d614cfd565b565b805f8103613f79576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b613f838383614d2d565b158015613f975750613f958383614d7c565b155b8015613fa757505f836003015414155b15613fe957816040517f12b49e3d000000000000000000000000000000000000000000000000000000008152600401613fe09190615621565b60405180910390fd5b6003835f015f8481526020019081526020015f205f6101000a81548160ff0219169083600781111561401e5761401d615cc1565b5b02179055508183600301819055505f8360020181905550505050565b5f614043612c32565b9050825f0135816006015f8481526020019081526020015f20819055508260200135816005018190555082604001358160070181905550505050565b5f6140886146c5565b9050805f015f6101000a81549073ffffffffffffffffffffffffffffffffffffffff02191690556140b882614dcb565b5050565b5f33905090565b6140cb613a7b565b5f6140d4613e91565b90506001815f015f6101000a81548160ff0219169083151502179055507f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a25861411a6140bc565b6040516141279190616242565b60405180910390a150565b5f7fa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100905090565b60605f614164614132565b9050806002018054614175906165a9565b80601f01602080910402602001604051908101604052809291908181526020018280546141a1906165a9565b80156141ec5780601f106141c3576101008083540402835291602001916141ec565b820191905f5260205f20905b8154815290600101906020018083116141cf57829003601f168201915b505050505091505090565b60605f614202614132565b9050806003018054614213906165a9565b80601f016020809104026020016040519081016040528092919081815260200182805461423f906165a9565b801561428a5780601f106142615761010080835404028352916020019161428a565b820191905f5260205f20905b81548152906001019060200180831161426d57829003601f168201915b505050505091505090565b805f81036142cf576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6007835f015f8481526020019081526020015f205f6101000a81548160ff0219169083600781111561430457614303615cc1565b5b02179055508183600101540361431e575f83600101819055505b81836002015403614333575f83600201819055505b81836003015403614348575f83600301819055505b8183600401540361435d575f83600401819055505b505050565b805f810361439c576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6143a68383614561565b6143e757816040517f331486b30000000000000000000000000000000000000000000000000000000081526004016143de9190615621565b60405180910390fd5b6004835f015f8481526020019081526020015f205f6101000a81548160ff0219169083600781111561441c5761441b615cc1565b5b02179055508183600401819055505f8360030181905550505050565b805f8103614472576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61447c8383614561565b158061448f575061448d8383614d7c565b155b156144d157816040517f2b3652d10000000000000000000000000000000000000000000000000000000081526004016144c89190615621565b60405180910390fd5b6005835f015f8481526020019081526020015f205f6101000a81548160ff0219169083600781111561450657614505615cc1565b5b021790555081836003015403614520575f83600301819055505b81836004015403614535575f83600401819055505b505050565b5f7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300905090565b5f6003600781111561457657614575615cc1565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff1660078111156145a7576145a6615cc1565b5b14905092915050565b805f81036145ea576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6145f48383614a95565b8061460557506146048383612d23565b5b1561464757816040517fb0c5151d00000000000000000000000000000000000000000000000000000000815260040161463e9190615621565b60405180910390fd5b6006835f015f8481526020019081526020015f205f6101000a81548160ff0219169083600781111561467c5761467b615cc1565b5b021790555081836002015403614696575f83600201819055505b818360030154036146ab575f83600301819055505b818360040154036146c0575f83600401819055505b505050565b5f7f237e158222e3e6968b72b9db0d8043aacf074ad9f650f0d1606b4d82ee432c00905090565b5f6146f5612c32565b90505f8303614730576040517fe60a727100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b818311156147775782826040517fd2535e1100000000000000000000000000000000000000000000000000000000815260040161476e92919061684d565b60405180910390fd5b82816016015f8681526020019081526020015f208190555050505050565b5f805f90507a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083106147f1577a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083816147e7576147e6616e7d565b5b0492506040810190505b6d04ee2d6d415b85acef8100000000831061482e576d04ee2d6d415b85acef8100000000838161482457614823616e7d565b5b0492506020810190505b662386f26fc10000831061485d57662386f26fc10000838161485357614852616e7d565b5b0492506010810190505b6305f5e1008310614886576305f5e100838161487c5761487b616e7d565b5b0492506008810190505b61271083106148ab5761271083816148a1576148a0616e7d565b5b0492506004810190505b606483106148ce57606483816148c4576148c3616e7d565b5b0492506002810190505b600a83106148dd576001810190505b80915050919050565b5f6148f86148f2614e9c565b83614eaa565b9050919050565b5f805f8061490d8686614eea565b92509250925061491d8282614f3f565b82935050505092915050565b805f8103614963576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61496d8383612d23565b6149ae57816040517fc0b5ee660000000000000000000000000000000000000000000000000000000081526004016149a59190615621565b60405180910390fd5b6002835f015f8481526020019081526020015f205f6101000a81548160ff021916908360078111156149e3576149e2615cc1565b5b02179055508183600201819055505f8360010181905550505050565b5f614a08612c32565b9050818310614a52578383836040517f8789a6ca000000000000000000000000000000000000000000000000000000008152600401614a4993929190617464565b60405180910390fd5b82816008015f8681526020019081526020015f206003018190555050505050565b614a8183835f013583613abc565b614a90838360200135836146ec565b505050565b5f806007811115614aa957614aa8615cc1565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115614ada57614ad9615cc1565b5b14905092915050565b614aeb6115d5565b614b21576040517f8dfc202b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f614b4f7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b6150a1565b5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b614b7f826150aa565b8173ffffffffffffffffffffffffffffffffffffffff167fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b60405160405180910390a25f81511115614bdb57614bd58282615173565b50614be4565b614be36151f3565b5b5050565b614bf061522f565b614c26576040517fd7e6bcf800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b614c30614be8565b5f614c39614132565b905082816002019081614c4c9190617499565b5081816003019081614c5e9190617499565b505f801b815f01819055505f801b8160010181905550505050565b614c81614be8565b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603614cf1575f6040517f1e4fbdf7000000000000000000000000000000000000000000000000000000008152600401614ce89190616242565b60405180910390fd5b614cfa8161407f565b50565b614d05614be8565b5f614d0e613e91565b90505f815f015f6101000a81548160ff02191690831515021790555050565b5f60026007811115614d4257614d41615cc1565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115614d7357614d72615cc1565b5b14905092915050565b5f60046007811115614d9157614d90615cc1565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115614dc257614dc1615cc1565b5b14905092915050565b5f614dd461453a565b90505f815f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905082825f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a3505050565b5f614ea561524d565b905090565b5f6040517f190100000000000000000000000000000000000000000000000000000000000081528360028201528260228201526042812091505092915050565b5f805f6041845103614f2a575f805f602087015192506040870151915060608701515f1a9050614f1c888285856152b0565b955095509550505050614f38565b5f600285515f1b9250925092505b9250925092565b5f6003811115614f5257614f51615cc1565b5b826003811115614f6557614f64615cc1565b5b031561509d5760016003811115614f7f57614f7e615cc1565b5b826003811115614f9257614f91615cc1565b5b03614fc9576040517ff645eedf00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60026003811115614fdd57614fdc615cc1565b5b826003811115614ff057614fef615cc1565b5b0361503457805f1c6040517ffce698f700000000000000000000000000000000000000000000000000000000815260040161502b9190615621565b60405180910390fd5b60038081111561504757615046615cc1565b5b82600381111561505a57615059615cc1565b5b0361509c57806040517fd78bce0c0000000000000000000000000000000000000000000000000000000081526004016150939190615f11565b60405180910390fd5b5b5050565b5f819050919050565b5f8173ffffffffffffffffffffffffffffffffffffffff163b0361510557806040517f4c9c8ce30000000000000000000000000000000000000000000000000000000081526004016150fc9190616242565b60405180910390fd5b806151317f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b6150a1565b5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60605f808473ffffffffffffffffffffffffffffffffffffffff168460405161519c91906175a2565b5f60405180830381855af49150503d805f81146151d4576040519150601f19603f3d011682016040523d82523d5f602084013e6151d9565b606091505b50915091506151e9858383615397565b9250505092915050565b5f34111561522d576040517fb398979f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f615238613edc565b5f0160089054906101000a900460ff16905090565b5f7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f615277615424565b61527f61549a565b46306040516020016152959594939291906175b8565b60405160208183030381529060405280519060200120905090565b5f805f7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0845f1c11156152ec575f60038592509250925061538d565b5f6001888888886040515f815260200160405260405161530f9493929190617624565b6020604051602081039080840390855afa15801561532f573d5f803e3d5ffd5b5050506020604051035190505f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603615380575f60015f801b9350935093505061538d565b805f805f1b935093509350505b9450945094915050565b6060826153ac576153a782615511565b61541c565b5f82511480156153d257505f8473ffffffffffffffffffffffffffffffffffffffff163b145b1561541457836040517f9996b31500000000000000000000000000000000000000000000000000000000815260040161540b9190616242565b60405180910390fd5b81905061541d565b5b9392505050565b5f8061542e614132565b90505f615439614159565b90505f8151111561545557808051906020012092505050615497565b5f825f015490505f801b811461547057809350505050615497565b7fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a47093505050505b90565b5f806154a4614132565b90505f6154af6141f7565b90505f815111156154cb5780805190602001209250505061550e565b5f826001015490505f801b81146154e75780935050505061550e565b7fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a47093505050505b90565b5f815111156155235780518082602001fd5b6040517fd6bda27500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040518060a001604052805f81526020015f81526020015f77ffffffffffffffffffffffffffffffffffffffffffffffff191681526020015f8152602001606081525090565b604051806101000160405280606081526020015f73ffffffffffffffffffffffffffffffffffffffff1681526020015f73ffffffffffffffffffffffffffffffffffffffff1681526020015f8152602001606081526020016060815260200160608152602001606081525090565b5f819050919050565b61561b81615609565b82525050565b5f6020820190506156345f830184615612565b92915050565b5f81519050919050565b5f82825260208201905092915050565b5f5b83811015615671578082015181840152602081019050615656565b5f8484015250505050565b5f601f19601f8301169050919050565b5f6156968261563a565b6156a08185615644565b93506156b0818560208601615654565b6156b98161567c565b840191505092915050565b5f6020820190508181035f8301526156dc818461568c565b905092915050565b6156ed81615609565b82525050565b5f7fffffffffffffffff00000000000000000000000000000000000000000000000082169050919050565b615727816156f3565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f82825260208201905092915050565b5f6157708261563a565b61577a8185615756565b935061578a818560208601615654565b6157938161567c565b840191505092915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6157c78261579e565b9050919050565b6157d7816157bd565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f615801826157dd565b61580b81856157e7565b935061581b818560208601615654565b6158248161567c565b840191505092915050565b5f61010083015f8301518482035f86015261584a8282615766565b915050602083015161585f60208601826157ce565b50604083015161587260408601826157ce565b50606083015161588560608601826156e4565b506080830151848203608086015261589d82826157f7565b91505060a083015184820360a08601526158b78282615766565b91505060c083015184820360c08601526158d18282615766565b91505060e083015184820360e08601526158eb82826157f7565b9150508091505092915050565b5f615903838361582f565b905092915050565b5f602082019050919050565b5f6159218261572d565b61592b8185615737565b93508360208202850161593d85615747565b805f5b85811015615978578484038952815161595985826158f8565b94506159648361590b565b925060208a01995050600181019050615940565b50829750879550505050505092915050565b5f60a083015f83015161599f5f8601826156e4565b5060208301516159b260208601826156e4565b5060408301516159c5604086018261571e565b5060608301516159d860608601826156e4565b50608083015184820360808601526159f08282615917565b9150508091505092915050565b5f6020820190508181035f830152615a15818461598a565b905092915050565b5f604051905090565b5f80fd5b5f80fd5b615a3781615609565b8114615a41575f80fd5b50565b5f81359050615a5281615a2e565b92915050565b5f80fd5b5f80fd5b5f80fd5b5f8083601f840112615a7957615a78615a58565b5b8235905067ffffffffffffffff811115615a9657615a95615a5c565b5b602083019150836001820283011115615ab257615ab1615a60565b5b9250929050565b5f805f60408486031215615ad057615acf615a26565b5b5f615add86828701615a44565b935050602084013567ffffffffffffffff811115615afe57615afd615a2a565b5b615b0a86828701615a64565b92509250509250925092565b615b1f816156f3565b8114615b29575f80fd5b50565b5f81359050615b3a81615b16565b92915050565b5f8115159050919050565b615b5481615b40565b8114615b5e575f80fd5b50565b5f81359050615b6f81615b4b565b92915050565b5f8083601f840112615b8a57615b89615a58565b5b8235905067ffffffffffffffff811115615ba757615ba6615a5c565b5b602083019150836020820283011115615bc357615bc2615a60565b5b9250929050565b5f80fd5b5f60408284031215615be357615be2615bca565b5b81905092915050565b5f805f805f805f60e0888a031215615c0757615c06615a26565b5b5f615c148a828b01615a44565b9750506020615c258a828b01615b2c565b9650506040615c368a828b01615b61565b9550506060615c478a828b01615a44565b945050608088013567ffffffffffffffff811115615c6857615c67615a2a565b5b615c748a828b01615b75565b935093505060a0615c878a828b01615bce565b91505092959891949750929550565b5f60208284031215615cab57615caa615a26565b5b5f615cb884828501615a44565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b60088110615cff57615cfe615cc1565b5b50565b5f819050615d0f82615cee565b919050565b5f615d1e82615d02565b9050919050565b615d2e81615d14565b82525050565b5f602082019050615d475f830184615d25565b92915050565b615d56816157bd565b8114615d60575f80fd5b50565b5f81359050615d7181615d4d565b92915050565b5f80fd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b615db18261567c565b810181811067ffffffffffffffff82111715615dd057615dcf615d7b565b5b80604052505050565b5f615de2615a1d565b9050615dee8282615da8565b919050565b5f67ffffffffffffffff821115615e0d57615e0c615d7b565b5b615e168261567c565b9050602081019050919050565b828183375f83830152505050565b5f615e43615e3e84615df3565b615dd9565b905082815260208101848484011115615e5f57615e5e615d77565b5b615e6a848285615e23565b509392505050565b5f82601f830112615e8657615e85615a58565b5b8135615e96848260208601615e31565b91505092915050565b5f8060408385031215615eb557615eb4615a26565b5b5f615ec285828601615d63565b925050602083013567ffffffffffffffff811115615ee357615ee2615a2a565b5b615eef85828601615e72565b9150509250929050565b5f819050919050565b615f0b81615ef9565b82525050565b5f602082019050615f245f830184615f02565b92915050565b615f3381615b40565b82525050565b5f602082019050615f4c5f830184615f2a565b92915050565b5f60608284031215615f6757615f66615bca565b5b81905092915050565b5f805f805f806101008789031215615f8b57615f8a615a26565b5b5f615f9889828a01615bce565b9650506040615fa989828a01615f52565b95505060a0615fba89828a01615b2c565b94505060c0615fcb89828a01615a44565b93505060e087013567ffffffffffffffff811115615fec57615feb615a2a565b5b615ff889828a01615b75565b92509250509295509295509295565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f61603b83836157ce565b60208301905092915050565b5f602082019050919050565b5f61605d82616007565b6160678185616011565b935061607283616021565b805f5b838110156160a25781516160898882616030565b975061609483616047565b925050600181019050616075565b5085935050505092915050565b5f6020820190508181035f8301526160c78184616053565b905092915050565b5f7fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b616103816160cf565b82525050565b616112816157bd565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f61614c83836156e4565b60208301905092915050565b5f602082019050919050565b5f61616e82616118565b6161788185616122565b935061618383616132565b805f5b838110156161b357815161619a8882616141565b97506161a583616158565b925050600181019050616186565b5085935050505092915050565b5f60e0820190506161d35f83018a6160fa565b81810360208301526161e5818961568c565b905081810360408301526161f9818861568c565b90506162086060830187615612565b6162156080830186616109565b61622260a0830185615f02565b81810360c08301526162348184616164565b905098975050505050505050565b5f6020820190506162555f830184616109565b92915050565b5f806040838503121561627157616270615a26565b5b5f61627e85828601615a44565b925050602061628f85828601615d63565b9150509250929050565b5f602082840312156162ae576162ad615a26565b5b5f6162bb84828501615d63565b91505092915050565b5f61010083015f8301518482035f8601526162df8282615766565b91505060208301516162f460208601826157ce565b50604083015161630760408601826157ce565b50606083015161631a60608601826156e4565b506080830151848203608086015261633282826157f7565b91505060a083015184820360a086015261634c8282615766565b91505060c083015184820360c08601526163668282615766565b91505060e083015184820360e086015261638082826157f7565b9150508091505092915050565b5f6020820190508181035f8301526163a581846162c4565b905092915050565b5f82825260208201905092915050565b5f6163c78261572d565b6163d181856163ad565b9350836020820285016163e385615747565b805f5b8581101561641e57848403895281516163ff85826158f8565b945061640a8361590b565b925060208a019950506001810190506163e6565b50829750879550505050505092915050565b5f6020820190508181035f83015261644881846163bd565b905092915050565b5f81905092915050565b5f6164648261563a565b61646e8185616450565b935061647e818560208601615654565b80840191505092915050565b7f20760000000000000000000000000000000000000000000000000000000000005f82015250565b5f6164be600283616450565b91506164c98261648a565b600282019050919050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f616508600183616450565b9150616513826164d4565b600182019050919050565b5f616529828761645a565b9150616534826164b2565b9150616540828661645a565b915061654b826164fc565b9150616557828561645a565b9150616562826164fc565b915061656e828461645a565b915081905095945050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f60028204905060018216806165c057607f821691505b6020821081036165d3576165d261657c565b5b50919050565b5f82905092915050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f6008830261663f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82616604565b6166498683616604565b95508019841693508086168417925050509392505050565b5f819050919050565b5f61668461667f61667a84615609565b616661565b615609565b9050919050565b5f819050919050565b61669d8361666a565b6166b16166a98261668b565b848454616610565b825550505050565b5f90565b6166c56166b9565b6166d0818484616694565b505050565b5b818110156166f3576166e85f826166bd565b6001810190506166d6565b5050565b601f82111561673857616709816165e3565b616712846165f5565b81016020851015616721578190505b61673561672d856165f5565b8301826166d5565b50505b505050565b5f82821c905092915050565b5f6167585f198460080261673d565b1980831691505092915050565b5f6167708383616749565b9150826002028217905092915050565b61678a83836165d9565b67ffffffffffffffff8111156167a3576167a2615d7b565b5b6167ad82546165a9565b6167b88282856166f7565b5f601f8311600181146167e5575f84156167d3578287013590505b6167dd8582616765565b865550616844565b601f1984166167f3866165e3565b5f5b8281101561681a578489013582556001820191506020850194506020810190506167f5565b868310156168375784890135616833601f891682616749565b8355505b6001600288020188555050505b50505050505050565b5f6040820190506168605f830185615612565b61686d6020830184615612565b9392505050565b5f6040820190508181035f83015261688c818561598a565b905081810360208301526168a0818461598a565b90509392505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6168e082615609565b91506168eb83615609565b9250828201905080821115616903576169026168a9565b5b92915050565b5f6060820190508181035f830152616921818661598a565b90508181036020830152616935818561598a565b90506169446040830184615612565b949350505050565b5f61695a6020840184615a44565b905092915050565b604082016169725f83018361694c565b61697e5f8501826156e4565b5061698c602083018361694c565b61699960208501826156e4565b50505050565b606082016169af5f83018361694c565b6169bb5f8501826156e4565b506169c9602083018361694c565b6169d660208501826156e4565b506169e4604083018361694c565b6169f160408501826156e4565b50505050565b616a00816156f3565b82525050565b5f819050919050565b5f80fd5b5f80fd5b5f80fd5b5f8083356001602003843603038112616a3757616a36616a17565b5b83810192508235915060208301925067ffffffffffffffff821115616a5f57616a5e616a0f565b5b600182023603831315616a7557616a74616a13565b5b509250929050565b5f616a888385615756565b9350616a95838584615e23565b616a9e8361567c565b840190509392505050565b5f616ab76020840184615d63565b905092915050565b5f8083356001602003843603038112616adb57616ada616a17565b5b83810192508235915060208301925067ffffffffffffffff821115616b0357616b02616a0f565b5b600182023603831315616b1957616b18616a13565b5b509250929050565b5f616b2c83856157e7565b9350616b39838584615e23565b616b428361567c565b840190509392505050565b5f6101008301616b5f5f840184616a1b565b8583035f870152616b71838284616a7d565b92505050616b826020840184616aa9565b616b8f60208601826157ce565b50616b9d6040840184616aa9565b616baa60408601826157ce565b50616bb8606084018461694c565b616bc560608601826156e4565b50616bd36080840184616abf565b8583036080870152616be6838284616b21565b92505050616bf760a0840184616a1b565b85830360a0870152616c0a838284616a7d565b92505050616c1b60c0840184616a1b565b85830360c0870152616c2e838284616a7d565b92505050616c3f60e0840184616abf565b85830360e0870152616c52838284616b21565b925050508091505092915050565b5f616c6b8383616b4d565b905092915050565b5f8235600161010003833603038112616c8f57616c8e616a17565b5b82810191505092915050565b5f602082019050919050565b5f616cb283856163ad565b935083602084028501616cc484616a06565b805f5b87811015616d07578484038952616cde8284616c73565b616ce88582616c60565b9450616cf383616c9b565b925060208a01995050600181019050616cc7565b50829750879450505050509392505050565b5f61010082019050616d2d5f830189616962565b616d3a604083018861699f565b616d4760a08301876169f7565b616d5460c0830186615612565b81810360e0830152616d67818486616ca7565b9050979650505050505050565b5f67ffffffffffffffff82169050919050565b616d9081616d74565b82525050565b5f602082019050616da95f830184616d87565b92915050565b5f81519050616dbd81615d4d565b92915050565b5f60208284031215616dd857616dd7615a26565b5b5f616de584828501616daf565b91505092915050565b7f4549503731323a20556e696e697469616c697a656400000000000000000000005f82015250565b5f616e22601583615644565b9150616e2d82616dee565b602082019050919050565b5f6020820190508181035f830152616e4f81616e16565b9050919050565b5f604082019050616e695f830185615612565b616e766020830184616109565b9392505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f604082019050616ebd5f830185615f02565b616eca6020830184615612565b9392505050565b5f6040820190508181035f830152616ee9818561598a565b9050616ef86020830184615612565b9392505050565b5f616f0982615609565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203616f3b57616f3a6168a9565b5b600182019050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f80fd5b5f80fd5b5f80fd5b5f8235600161010003833603038112616f9b57616f9a616f73565b5b80830191505092915050565b5f8083356001602003843603038112616fc357616fc2616f73565b5b80840192508235915067ffffffffffffffff821115616fe557616fe4616f77565b5b60208301925060018202360383131561700157617000616f7b565b5b509250929050565b5f82905092915050565b5f819050815f5260205f209050919050565b601f8211156170665761703781617013565b617040846165f5565b8101602085101561704f578190505b61706361705b856165f5565b8301826166d5565b50505b505050565b6170758383617009565b67ffffffffffffffff81111561708e5761708d615d7b565b5b61709882546165a9565b6170a3828285617025565b5f601f8311600181146170d0575f84156170be578287013590505b6170c88582616765565b86555061712f565b601f1984166170de86617013565b5f5b82811015617105578489013582556001820191506020850194506020810190506170e0565b86831015617122578489013561711e601f891682616749565b8355505b6001600288020188555050505b50505050505050565b61714383838361706b565b505050565b5f813561715481615d4d565b80915050919050565b5f815f1b9050919050565b5f73ffffffffffffffffffffffffffffffffffffffff6171878461715d565b9350801983169250808416831791505092915050565b5f6171b76171b26171ad8461579e565b616661565b61579e565b9050919050565b5f6171c88261719d565b9050919050565b5f6171d9826171be565b9050919050565b5f819050919050565b6171f2826171cf565b6172056171fe826171e0565b8354617168565b8255505050565b5f813561721881615a2e565b80915050919050565b5f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff61724c8461715d565b9350801983169250808416831791505092915050565b61726b8261666a565b61727e6172778261668b565b8354617221565b8255505050565b5f80833560016020038436030381126172a1576172a0616f73565b5b80840192508235915067ffffffffffffffff8211156172c3576172c2616f77565b5b6020830192506001820236038313156172df576172de616f7b565b5b509250929050565b6172f2838383616780565b505050565b5f81015f83016173078185616fa7565b617312818386617138565b5050505060018101602083018061732881617148565b905061733481846171e9565b50505060028101604083018061734981617148565b905061735581846171e9565b50505060038101606083018061736a8161720c565b90506173768184617262565b505050600481016080830161738b8185617285565b6173968183866172e7565b505050506005810160a083016173ac8185616fa7565b6173b7818386617138565b505050506006810160c083016173cd8185616fa7565b6173d8818386617138565b505050506007810160e083016173ee8185617285565b6173f98183866172e7565b505050505050565b61740b82826172f7565b5050565b61741881615ef9565b8114617422575f80fd5b50565b5f815190506174338161740f565b92915050565b5f6020828403121561744e5761744d615a26565b5b5f61745b84828501617425565b91505092915050565b5f6060820190506174775f830186615612565b6174846020830185615612565b6174916040830184615612565b949350505050565b6174a28261563a565b67ffffffffffffffff8111156174bb576174ba615d7b565b5b6174c582546165a9565b6174d0828285617025565b5f60209050601f831160018114617501575f84156174ef578287015190505b6174f98582616765565b865550617560565b601f19841661750f86617013565b5f5b8281101561753657848901518255600182019150602085019450602081019050617511565b86831015617553578489015161754f601f891682616749565b8355505b6001600288020188555050505b505050505050565b5f81905092915050565b5f61757c826157dd565b6175868185617568565b9350617596818560208601615654565b80840191505092915050565b5f6175ad8284617572565b915081905092915050565b5f60a0820190506175cb5f830188615f02565b6175d86020830187615f02565b6175e56040830186615f02565b6175f26060830185615612565b6175ff6080830184616109565b9695505050505050565b5f60ff82169050919050565b61761e81617609565b82525050565b5f6080820190506176375f830187615f02565b6176446020830186617615565b6176516040830185615f02565b61765e6060830184615f02565b9594505050505056fe4b6579526573686172696e67566572696669636174696f6e2875696e7432353620636f6e74657874496429
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0`@R0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x80\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP4\x80\x15b\0\0CW_\x80\xFD[Pb\0\0Tb\0\0Z` \x1B` \x1CV[b\0\x01\xC4V[_b\0\0kb\0\x01^` \x1B` \x1CV[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15b\0\0\xB6W`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14b\0\x01[Wg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@Qb\0\x01R\x91\x90b\0\x01\xA9V[`@Q\x80\x91\x03\x90\xA1[PV[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[b\0\x01\xA3\x81b\0\x01\x85V[\x82RPPV[_` \x82\x01\x90Pb\0\x01\xBE_\x83\x01\x84b\0\x01\x98V[\x92\x91PPV[`\x80Qav\x93b\0\x01\xEB_9_\x81\x81a;\xFD\x01R\x81\x81a<R\x01Ra>\x0C\x01Rav\x93_\xF3\xFE`\x80`@R`\x046\x10a\x02$W_5`\xE0\x1C\x80c\x84V\xCBY\x11a\x01\"W\x80c\xD8\xE3\xAE\x01\x11a\0\xAAW\x80c\xE3\xB2\xA8t\x11a\0nW\x80c\xE3\xB2\xA8t\x14a\x07HW\x80c\xE7.\xE9\x91\x14a\x07\x84W\x80c\xEB\x84<\xF6\x14a\x07\xAEW\x80c\xF2|\xB9W\x14a\x07\xD6W\x80c\xF2\xFD\xE3\x8B\x14a\x07\xECWa\x02$V[\x80c\xD8\xE3\xAE\x01\x14a\x06|W\x80c\xDE\xFB\xA0j\x14a\x06\xA6W\x80c\xDF\xE3j\xEE\x14a\x06\xCEW\x80c\xE2K\xA4\xE5\x14a\x06\xF6W\x80c\xE3\x0C9x\x14a\x07\x1EWa\x02$V[\x80c\x9E\xE7z\xF3\x11a\0\xF1W\x80c\x9E\xE7z\xF3\x14a\x05\x9EW\x80c\xAD<\xB1\xCC\x14a\x05\xC6W\x80c\xB8q]M\x14a\x05\xF0W\x80c\xC0\xAEd\xF7\x14a\x06,W\x80c\xC1\xC8\xB7%\x14a\x06TWa\x02$V[\x80c\x84V\xCBY\x14a\x05\x18W\x80c\x84\xB0\x19n\x14a\x05.W\x80c\x8C\xB9gQ\x14a\x05^W\x80c\x8D\xA5\xCB[\x14a\x05tWa\x02$V[\x80cMiB`\x11a\x01\xB0W\x80cj\x1DQ\xEB\x11a\x01tW\x80cj\x1DQ\xEB\x14a\x04pW\x80cqP\x18\xA6\x14a\x04\x98W\x80ct \xF3\xD4\x14a\x04\xAEW\x80cy\xBAP\x97\x14a\x04\xD8W\x80c~\xAA\xC8\xF2\x14a\x04\xEEWa\x02$V[\x80cMiB`\x14a\x03\x88W\x80cO\x1E\xF2\x86\x14a\x03\xC4W\x80cR\xD1\x90-\x14a\x03\xE0W\x80c\\\x97Z\xBB\x14a\x04\nW\x80cd\xB0\x0C\xC5\x14a\x044Wa\x02$V[\x80c\x16\x9C\xAC\x14\x11a\x01\xF7W\x80c\x16\x9C\xAC\x14\x14a\x02\xCEW\x80c.-:\x82\x14a\x02\xF6W\x80c?K\xA8:\x14a\x03\x1EW\x80cC\xE3~\x8A\x14a\x034W\x80cIe\xE4U\x14a\x03^Wa\x02$V[\x80c\nP\xE3\x18\x14a\x02(W\x80c\r\x8En,\x14a\x02RW\x80c\r\xD4\x86\xC0\x14a\x02|W\x80c\x10y\xEB\xEB\x14a\x02\xA6W[_\x80\xFD[4\x80\x15a\x023W_\x80\xFD[Pa\x02<a\x08\x14V[`@Qa\x02I\x91\x90aV!V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02]W_\x80\xFD[Pa\x02fa\x08-V[`@Qa\x02s\x91\x90aV\xC4V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\x87W_\x80\xFD[Pa\x02\x90a\x08\xA8V[`@Qa\x02\x9D\x91\x90aY\xFDV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xB1W_\x80\xFD[Pa\x02\xCC`\x04\x806\x03\x81\x01\x90a\x02\xC7\x91\x90aZ\xB9V[a\r4V[\0[4\x80\x15a\x02\xD9W_\x80\xFD[Pa\x02\xF4`\x04\x806\x03\x81\x01\x90a\x02\xEF\x91\x90a[\xECV[a\x12\xF1V[\0[4\x80\x15a\x03\x01W_\x80\xFD[Pa\x03\x1C`\x04\x806\x03\x81\x01\x90a\x03\x17\x91\x90a\\\x96V[a\x14\xBAV[\0[4\x80\x15a\x03)W_\x80\xFD[Pa\x032a\x15#V[\0[4\x80\x15a\x03?W_\x80\xFD[Pa\x03Ha\x155V[`@Qa\x03U\x91\x90aV!V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03iW_\x80\xFD[Pa\x03ra\x15NV[`@Qa\x03\x7F\x91\x90aV!V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x93W_\x80\xFD[Pa\x03\xAE`\x04\x806\x03\x81\x01\x90a\x03\xA9\x91\x90a\\\x96V[a\x15eV[`@Qa\x03\xBB\x91\x90a]4V[`@Q\x80\x91\x03\x90\xF3[a\x03\xDE`\x04\x806\x03\x81\x01\x90a\x03\xD9\x91\x90a^\x9FV[a\x15\x85V[\0[4\x80\x15a\x03\xEBW_\x80\xFD[Pa\x03\xF4a\x15\xA4V[`@Qa\x04\x01\x91\x90a_\x11V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x15W_\x80\xFD[Pa\x04\x1Ea\x15\xD5V[`@Qa\x04+\x91\x90a_9V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04?W_\x80\xFD[Pa\x04Z`\x04\x806\x03\x81\x01\x90a\x04U\x91\x90a\\\x96V[a\x15\xF7V[`@Qa\x04g\x91\x90aV!V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04{W_\x80\xFD[Pa\x04\x96`\x04\x806\x03\x81\x01\x90a\x04\x91\x91\x90a_pV[a\x16\x86V[\0[4\x80\x15a\x04\xA3W_\x80\xFD[Pa\x04\xACa\x19\x03V[\0[4\x80\x15a\x04\xB9W_\x80\xFD[Pa\x04\xC2a\x19\x16V[`@Qa\x04\xCF\x91\x90a`\xAFV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xE3W_\x80\xFD[Pa\x04\xECa\x19\xCAV[\0[4\x80\x15a\x04\xF9W_\x80\xFD[Pa\x05\x02a\x1AXV[`@Qa\x05\x0F\x91\x90a`\xAFV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05#W_\x80\xFD[Pa\x05,a\x1B\x0CV[\0[4\x80\x15a\x059W_\x80\xFD[Pa\x05Ba\x1CGV[`@Qa\x05U\x97\x96\x95\x94\x93\x92\x91\x90aa\xC0V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05iW_\x80\xFD[Pa\x05ra\x1DPV[\0[4\x80\x15a\x05\x7FW_\x80\xFD[Pa\x05\x88a\x1FBV[`@Qa\x05\x95\x91\x90abBV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xA9W_\x80\xFD[Pa\x05\xC4`\x04\x806\x03\x81\x01\x90a\x05\xBF\x91\x90a\\\x96V[a\x1FwV[\0[4\x80\x15a\x05\xD1W_\x80\xFD[Pa\x05\xDAa \x86V[`@Qa\x05\xE7\x91\x90aV\xC4V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xFBW_\x80\xFD[Pa\x06\x16`\x04\x806\x03\x81\x01\x90a\x06\x11\x91\x90a\\\x96V[a \xBFV[`@Qa\x06#\x91\x90aV!V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x067W_\x80\xFD[Pa\x06R`\x04\x806\x03\x81\x01\x90a\x06M\x91\x90a\\\x96V[a!NV[\0[4\x80\x15a\x06_W_\x80\xFD[Pa\x06z`\x04\x806\x03\x81\x01\x90a\x06u\x91\x90a\\\x96V[a\"]V[\0[4\x80\x15a\x06\x87W_\x80\xFD[Pa\x06\x90a\"\xBCV[`@Qa\x06\x9D\x91\x90aV!V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xB1W_\x80\xFD[Pa\x06\xCC`\x04\x806\x03\x81\x01\x90a\x06\xC7\x91\x90ab[V[a\"\xD3V[\0[4\x80\x15a\x06\xD9W_\x80\xFD[Pa\x06\xF4`\x04\x806\x03\x81\x01\x90a\x06\xEF\x91\x90ab[V[a#\xE8V[\0[4\x80\x15a\x07\x01W_\x80\xFD[Pa\x07\x1C`\x04\x806\x03\x81\x01\x90a\x07\x17\x91\x90a\\\x96V[a$\xFDV[\0[4\x80\x15a\x07)W_\x80\xFD[Pa\x072a%\\V[`@Qa\x07?\x91\x90abBV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07SW_\x80\xFD[Pa\x07n`\x04\x806\x03\x81\x01\x90a\x07i\x91\x90ab\x99V[a%\x91V[`@Qa\x07{\x91\x90ac\x8DV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\x8FW_\x80\xFD[Pa\x07\x98a*\x10V[`@Qa\x07\xA5\x91\x90ad0V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\xB9W_\x80\xFD[Pa\x07\xD4`\x04\x806\x03\x81\x01\x90a\x07\xCF\x91\x90a\\\x96V[a*#V[\0[4\x80\x15a\x07\xE1W_\x80\xFD[Pa\x07\xEAa*\x8CV[\0[4\x80\x15a\x07\xF7W_\x80\xFD[Pa\x08\x12`\x04\x806\x03\x81\x01\x90a\x08\r\x91\x90ab\x99V[a+yV[\0[_\x80a\x08\x1Ea,2V[\x90P\x80_\x01`\x04\x01T\x91PP\x90V[```@Q\x80`@\x01`@R\x80`\x0B\x81R` \x01\x7FKmsContexts\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa\x08n_a,YV[a\x08x`\x01a,YV[a\x08\x81_a,YV[`@Q` \x01a\x08\x94\x94\x93\x92\x91\x90ae\x1EV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P\x90V[a\x08\xB0aUUV[_a\x08\xB9a,2V[\x90P_a\x08\xC4a\x155V[\x90P\x81`\x08\x01_\x82\x81R` \x01\x90\x81R` \x01_ `@Q\x80`\xA0\x01`@R\x90\x81_\x82\x01T\x81R` \x01`\x01\x82\x01T\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04`\xC0\x1Bw\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01_\x90[\x82\x82\x10\x15a\r%W\x83\x82\x90_R` _ \x90`\x08\x02\x01`@Q\x80a\x01\0\x01`@R\x90\x81_\x82\x01\x80Ta\t\xA2\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\t\xCE\x90ae\xA9V[\x80\x15a\n\x19W\x80`\x1F\x10a\t\xF0Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\n\x19V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\t\xFCW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80Ta\n\xE6\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0B\x12\x90ae\xA9V[\x80\x15a\x0B]W\x80`\x1F\x10a\x0B4Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0B]V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0B@W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta\x0Bv\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0B\xA2\x90ae\xA9V[\x80\x15a\x0B\xEDW\x80`\x1F\x10a\x0B\xC4Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0B\xEDV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0B\xD0W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x06\x82\x01\x80Ta\x0C\x06\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0C2\x90ae\xA9V[\x80\x15a\x0C}W\x80`\x1F\x10a\x0CTWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0C}V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0C`W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x07\x82\x01\x80Ta\x0C\x96\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0C\xC2\x90ae\xA9V[\x80\x15a\r\rW\x80`\x1F\x10a\x0C\xE4Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\r\rV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0C\xF0W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x81R` \x01\x90`\x01\x01\x90a\tqV[PPPP\x81RPP\x92PPP\x90V[a\r>\x833a\"\xD3V[_a\rGa,2V[\x90Pa\rU\x81_\x01\x85a-#V[a\r\x96W\x83`@Q\x7F^Q\xA2\xE1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\r\x8D\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[_`@Q\x80` \x01`@R\x80\x86\x81RP\x90P_a\r\xB2\x82a-rV[\x90Pa\r\xC0\x86\x82\x87\x87a-\xCDV[_\x83`\x0C\x01_\x88\x81R` \x01\x90\x81R` \x01_ \x90P\x80\x86\x86\x90\x91\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x92\x90\x91\x92\x90\x91\x92\x90\x91\x92P\x91\x82a\x0E\x0F\x92\x91\x90ag\x80V[P_\x84`\x08\x01_\x89\x81R` \x01\x90\x81R` \x01_ `@Q\x80`\xA0\x01`@R\x90\x81_\x82\x01T\x81R` \x01`\x01\x82\x01T\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04`\xC0\x1Bw\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01_\x90[\x82\x82\x10\x15a\x12pW\x83\x82\x90_R` _ \x90`\x08\x02\x01`@Q\x80a\x01\0\x01`@R\x90\x81_\x82\x01\x80Ta\x0E\xED\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0F\x19\x90ae\xA9V[\x80\x15a\x0FdW\x80`\x1F\x10a\x0F;Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0FdV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0FGW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80Ta\x101\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x10]\x90ae\xA9V[\x80\x15a\x10\xA8W\x80`\x1F\x10a\x10\x7FWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x10\xA8V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x10\x8BW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta\x10\xC1\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x10\xED\x90ae\xA9V[\x80\x15a\x118W\x80`\x1F\x10a\x11\x0FWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x118V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x11\x1BW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x06\x82\x01\x80Ta\x11Q\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x11}\x90ae\xA9V[\x80\x15a\x11\xC8W\x80`\x1F\x10a\x11\x9FWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x11\xC8V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x11\xABW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x07\x82\x01\x80Ta\x11\xE1\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x12\r\x90ae\xA9V[\x80\x15a\x12XW\x80`\x1F\x10a\x12/Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x12XV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x12;W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x81R` \x01\x90`\x01\x01\x90a\x0E\xBCV[PPPP\x81RPP\x90Pa\x12\x88\x81\x83\x80T\x90Pa/?V[\x15a\x12\xE7W_\x85`\x06\x01_\x8A\x81R` \x01\x90\x81R` \x01_ T\x90Pa\x12\xAE\x82\x82a/VV[\x7Fh\x89\x8A\x98\x93k\xF2:V\xE8\xEDK#\xDC\xC9\x8C\xEF\x92k\xD9\xAC,\xE5\"\xF1\xF9B>8d\xF2\xF5\x82`@Qa\x12\xDD\x91\x90aY\xFDV[`@Q\x80\x91\x03\x90\xA1P[PPPPPPPPV[a\x12\xF9a/\xD9V[_a\x13\x02a,2V[\x90P_a\x13\ra\x08\xA8V[\x90P_\x81`\x80\x01QQ\x90P_\x86\x86\x90P\x90P\x81\x81\x14a\x13eW\x81\x81`@Q\x7F\xD5\x95\xA9b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\\\x92\x91\x90ahMV[`@Q\x80\x91\x03\x90\xFD[_a\x13na\x08\x14V[\x90P_\x81\x14a\x13\xB4W\x80`@Q\x7Fv#\xD3W\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\xAB\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[_a\x13\xC6\x85_\x01Q\x8D\x8C\x8C\x8C\x8Ca0`V[\x90P\x7F6b\xEC1mv\xE6\xA7^\xB7\xC4P\x01\xA8\xADt\xC3\xEB\x94>\x87x\x11\x1C\x02%\xF2\xA9\xFD^\0\xE6\x85\x82`@Qa\x13\xF9\x92\x91\x90ahtV[`@Q\x80\x91\x03\x90\xA1a\x14\x10\x86_\x01\x82_\x01Qa9\xAEV[\x8A\x15a\x14\xA0W\x8C\x86`\x06\x01_\x83_\x01Q\x81R` \x01\x90\x81R` \x01_ \x81\x90UP_\x86`\x05\x01TCa\x14B\x91\x90ah\xD6V[\x90P\x80\x87`\x12\x01_\x84_\x01Q\x81R` \x01\x90\x81R` \x01_ \x81\x90UP\x7F]\xC6\x01\x06Z\x03]x0\\\xD9\xEF'\xC9\x1A\0\x9C\xD8\xD3r\x97\xE4;\xB7c\x19I\x08\x95\xA0\xD0X\x86\x83\x83`@Qa\x14\x92\x93\x92\x91\x90ai\tV[`@Q\x80\x91\x03\x90\xA1Pa\x14\xABV[a\x14\xAA\x81\x8Ea/VV[[PPPPPPPPPPPPPV[a\x14\xC2a/\xD9V[a\x14\xCAa:{V[_a\x14\xD3a\x08\xA8V[\x90Pa\x14\xE8\x81_\x01Q\x83\x83`\x80\x01QQa:\xBCV[\x7F\xE4\x18\x02\xAFrW)\xAD\xCB\x8C\x15\x1E)78\n%\xC6\x91Uu~:\xF5\xD3\x97\x9A\xDA\xB5\x03X\0\x82`@Qa\x15\x17\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1PPV[a\x15+a/\xD9V[a\x153a;eV[V[_\x80a\x15?a,2V[\x90P\x80_\x01`\x03\x01T\x91PP\x90V[_\x80a\x15Xa,2V[\x90P\x80`\x05\x01T\x91PP\x90V[_\x80a\x15oa,2V[\x90Pa\x15}\x81_\x01\x84a;\xD3V[\x91PP\x91\x90PV[a\x15\x8Da;\xFBV[a\x15\x96\x82a<\xE1V[a\x15\xA0\x82\x82a<\xECV[PPV[_a\x15\xADa>\nV[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x90P\x90V[_\x80a\x15\xDFa>\x91V[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x91PP\x90V[_\x81_a\x16\x02a,2V[\x90P_\x81`\x08\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a\x16]W\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x16T\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[_a\x16fa,2V[\x90P\x80`\x16\x01_\x86\x81R` \x01\x90\x81R` \x01_ T\x93PPPP\x91\x90PV[`\x01a\x16\x90a>\xB8V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x16\xD1W`@Q\x7FoOs\x1F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02_a\x16\xDCa>\xDCV[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a\x17$WP\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15[\x15a\x17[W`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPa\x18\x14`@Q\x80`@\x01`@R\x80`\x0B\x81R` \x01\x7FKmsContexts\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP`@Q\x80`@\x01`@R\x80`\x01\x81R` \x01\x7F1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa?\x03V[a\x18$a\x18\x1Fa\x1FBV[a?\x19V[a\x18,a?-V[_a\x18;_\x88\x88\x88\x88\x8Ea0`V[\x90P_a\x18Fa,2V[\x90Pa\x18W\x81_\x01\x83_\x01Qa??V[a\x18d\x89\x83_\x01Qa@:V[\x7F\x01n\xE9\xC1b\x13\xEDg\xF32\"\xAB\xADM\xFEF\xEB\x95\x1E\xAD0\xA1\n\x1Ar\xDB3\x16\xFF\xB6d\xE0\x8A\x8A\x8A\x8A\x8A\x8A`@Qa\x18\x9D\x96\x95\x94\x93\x92\x91\x90am\x19V[`@Q\x80\x91\x03\x90\xA1PP_\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x82`@Qa\x18\xF1\x91\x90am\x96V[`@Q\x80\x91\x03\x90\xA1PPPPPPPPV[a\x19\x0Ba/\xD9V[a\x19\x14_a@\x7FV[V[``_a\x19!a\x155V[\x90P_a\x19,a,2V[\x90P\x80`\x10\x01_\x83\x81R` \x01\x90\x81R` \x01_ \x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x19\xBEW` \x02\x82\x01\x91\x90_R` _ \x90[\x81_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x19uW[PPPPP\x92PPP\x90V[_a\x19\xD3a@\xBCV[\x90P\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x19\xF4a%\\V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1ALW\x80`@Q\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1AC\x91\x90abBV[`@Q\x80\x91\x03\x90\xFD[a\x1AU\x81a@\x7FV[PV[``_a\x1Aca\x155V[\x90P_a\x1Ana,2V[\x90P\x80`\x11\x01_\x83\x81R` \x01\x90\x81R` \x01_ \x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x1B\0W` \x02\x82\x01\x91\x90_R` _ \x90[\x81_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x1A\xB7W[PPPPP\x92PPP\x90V[a\x1B\x14a\x1FBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15\x80\x15a\x1B\xFBWPs\xC7\xD4Va\xA3E\xEC\\\xA0\xE8R\x1C\xFE\xF7\xE3/\xDA\r\xAAhs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cp\x08\xB5H`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1B\xA7W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1B\xCB\x91\x90am\xC3V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15a\x1C=W3`@Q\x7FF\xC0\xD9\xAF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1C4\x91\x90abBV[`@Q\x80\x91\x03\x90\xFD[a\x1CEa@\xC3V[V[_``\x80_\x80_``_a\x1CYaA2V[\x90P_\x80\x1B\x81_\x01T\x14\x80\x15a\x1CtWP_\x80\x1B\x81`\x01\x01T\x14[a\x1C\xB3W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1C\xAA\x90an8V[`@Q\x80\x91\x03\x90\xFD[a\x1C\xBBaAYV[a\x1C\xC3aA\xF7V[F0_\x80\x1B_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1C\xE2Wa\x1C\xE1a]{V[[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x1D\x10W\x81` \x01` \x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x7F\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x95\x94\x93\x92\x91\x90\x97P\x97P\x97P\x97P\x97P\x97P\x97PP\x90\x91\x92\x93\x94\x95\x96V[a\x1DXa:{V[_a\x1Daa,2V[\x90P_\x81_\x01`\x01\x01T\x90P_\x81\x14a\x1E\nW\x81`\x12\x01_\x82\x81R` \x01\x90\x81R` \x01_ TC\x11\x15a\x1E\tW~\x9F\xE8\xF0\xDBE\x99m\xEC\xF7\xB0o\xC7\xB6\xEC_\x88}_\x04\xDB.\x0CJ\xD7\xF4\xE4\xEE^\xEF\xC5\xA3\x81`@Qa\x1D\xBD\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1a\x1D\xD1\x82_\x01\x82aB\x95V[\x7F>\x8F\x02\xDCz\xF6\xE3\xA6\x7F:\xF0\xBC\x99\xBC\xF1\x1BM\xEBF\x10^\x9B\xA7\xF1\xACm\xA8#\"\xE9\x02^\x81`@Qa\x1E\0\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1[[_\x82_\x01`\x02\x01T\x90P_\x81\x14a\x1E\xCAW\x82`\x13\x01_\x82\x81R` \x01\x90\x81R` \x01_ TC\x11\x15a\x1E\xC9W_a\x1E?a\x155V[\x90Pa\x1EM\x84_\x01\x82aCbV[\x7F\x85\x1A\x08\xC1k\x15\x95\x9C3\x8A\xC4\xB5df\xD0l\x9F\x9D_\xF8\xD7\x15\x16\x8A\xA1%\xD5\xCC\xAFS\x83 \x81`@Qa\x1E|\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1a\x1E\x90\x84_\x01\x83a??V[\x7FOT\xA6\xAC\x98\x1C\xC8\xDC\x83\x14+>\xB4\xD1 \xBE|p\xFC]\xE6Gz\x14\xEA\xE3\xE9\xCAdvD\xBC\x82`@Qa\x1E\xBF\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1P[[_a\x1E\xD3a\x08\x14V[\x90P_\x81\x14a\x1F<W\x83`\x14\x01_\x82\x81R` \x01\x90\x81R` \x01_ TC\x11\x15a\x1F;Wa\x1F\x03\x84_\x01\x82aD8V[\x7F\x8F\xB7XX\xA5e\xAE\xE1\x174-\x93\x19j\x7F\x0BT\xC1\xC8Q\x98\x85\xED\xDD\xA6\xA0\x1FGsY\xB3c\x81`@Qa\x1F2\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1[[PPPPV[_\x80a\x1FLaE:V[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x90V[a\x1F\x7Fa/\xD9V[\x80_a\x1F\x89a,2V[\x90P_\x81`\x08\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a\x1F\xE4W\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1F\xDB\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[_a\x1F\xEDa,2V[\x90Pa\x1F\xFB\x81_\x01\x85aEaV[\x15a =W\x83`@Q\x7Fw\xD0^\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a 4\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[a I\x81_\x01\x85aE\xB0V[\x7F\xBC\x11\x14\xFA\x9Awd\x8C\xD0\x97\xEEl\xF1I\xC3D\xFA'\x8B\x9B\x98?0\xDDe\xB6\xFDj\x9DFJ\x07\x84`@Qa x\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1PPPPV[`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x81V[_\x81_a \xCAa,2V[\x90P_\x81`\x08\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a!%W\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a!\x1C\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[_a!.a,2V[\x90P\x80`\x15\x01_\x86\x81R` \x01\x90\x81R` \x01_ T\x93PPPP\x91\x90PV[a!Va/\xD9V[\x80_a!`a,2V[\x90P_\x81`\x08\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a!\xBBW\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a!\xB2\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[_a!\xC4a,2V[\x90Pa!\xD2\x81_\x01\x85aEaV[\x15a\"\x14W\x83`@Q\x7F\xB2^N\xB3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\"\x0B\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[a\" \x81_\x01\x85aB\x95V[\x7F>\x8F\x02\xDCz\xF6\xE3\xA6\x7F:\xF0\xBC\x99\xBC\xF1\x1BM\xEBF\x10^\x9B\xA7\xF1\xACm\xA8#\"\xE9\x02^\x84`@Qa\"O\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1PPPPV[a\"ea/\xD9V[a\"ma:{V[_a\"va,2V[\x90P\x81\x81`\x07\x01\x81\x90UP\x7F:\xD5\xC2'$\xAF\xAB\x8E\xD2\xB5x\xFB\x9B\x16\x0C\x7Fe\xF5\xAB\xD0\xAA\xD1\x05u+{\xA4\xE0h\xA3\xE0!\x82`@Qa\"\xB0\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1PPV[_\x80a\"\xC6a,2V[\x90P\x80`\x07\x01T\x91PP\x90V[\x81_a\"\xDDa,2V[\x90P_\x81`\x08\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a#8W\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a#/\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[_a#Aa,2V[\x90P\x80`\x0E\x01_\x86\x81R` \x01\x90\x81R` \x01_ _\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a#\xE1W\x84\x84`@Q\x7F\xFD\xF8\xA0]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a#\xD8\x92\x91\x90anVV[`@Q\x80\x91\x03\x90\xFD[PPPPPV[\x81_a#\xF2a,2V[\x90P_\x81`\x08\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a$MW\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a$D\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[_a$Va,2V[\x90P\x80`\x0F\x01_\x86\x81R` \x01\x90\x81R` \x01_ _\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a$\xF6W\x84\x84`@Q\x7F\x89\xB4^]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a$\xED\x92\x91\x90anVV[`@Q\x80\x91\x03\x90\xFD[PPPPPV[a%\x05a/\xD9V[a%\ra:{V[_a%\x16a,2V[\x90P\x81\x81`\x05\x01\x81\x90UP\x7FS\xCB\x96\x8D1\xC2\x8Ce\x04\xA6\xE7=\x99\x08\xDBn\x1C\x1A8kf\xDC\xAC\xEC\x1A\x01\x17u,Z\xB9\x86\x82`@Qa%P\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1PPV[_\x80a%faF\xC5V[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x90V[a%\x99aU\x9BV[_a%\xA2a\x155V[\x90P_a%\xADa,2V[\x90P_\x81`\r\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `@Q\x80a\x01\0\x01`@R\x90\x81_\x82\x01\x80Ta&\x19\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta&E\x90ae\xA9V[\x80\x15a&\x90W\x80`\x1F\x10a&gWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a&\x90V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a&sW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80Ta']\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta'\x89\x90ae\xA9V[\x80\x15a'\xD4W\x80`\x1F\x10a'\xABWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a'\xD4V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a'\xB7W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta'\xED\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta(\x19\x90ae\xA9V[\x80\x15a(dW\x80`\x1F\x10a(;Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a(dV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a(GW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x06\x82\x01\x80Ta(}\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta(\xA9\x90ae\xA9V[\x80\x15a(\xF4W\x80`\x1F\x10a(\xCBWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a(\xF4V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a(\xD7W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x07\x82\x01\x80Ta)\r\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta)9\x90ae\xA9V[\x80\x15a)\x84W\x80`\x1F\x10a)[Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a)\x84V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a)gW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x90P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81`@\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a*\x05W\x82\x85`@Q\x7F\x04\x94\xD3\xC0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a)\xFC\x92\x91\x90anVV[`@Q\x80\x91\x03\x90\xFD[\x80\x93PPPP\x91\x90PV[``a*\x1Aa\x08\xA8V[`\x80\x01Q\x90P\x90V[a*+a/\xD9V[a*3a:{V[_a*<a\x08\xA8V[\x90Pa*Q\x81_\x01Q\x83\x83`\x80\x01QQaF\xECV[\x7F\x83~\ne(\xDA\xDF\xA2\xDCy&\x92\xC5\x18.R\xA9\xF5\xBB\xDE\xED{#r\x92z&\xC6\x95\x83\x96\x13\x82`@Qa*\x80\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1PPV[a*\x94a/\xD9V[_a*\x9Da,2V[\x90P_a*\xA8a\x08\x14V[\x90P_\x81\x03a*\xE3W`@Q\x7F ~\xA3\xF3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a*\xECa\x155V[\x90Pa*\xFA\x83_\x01\x82aD8V[\x7F\x8F\xB7XX\xA5e\xAE\xE1\x174-\x93\x19j\x7F\x0BT\xC1\xC8Q\x98\x85\xED\xDD\xA6\xA0\x1FGsY\xB3c\x81`@Qa+)\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1a+=\x83_\x01\x83a??V[\x7FOT\xA6\xAC\x98\x1C\xC8\xDC\x83\x14+>\xB4\xD1 \xBE|p\xFC]\xE6Gz\x14\xEA\xE3\xE9\xCAdvD\xBC\x82`@Qa+l\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1PPPV[a+\x81a/\xD9V[_a+\x8AaF\xC5V[\x90P\x81\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a+\xECa\x1FBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F8\xD1k\x8C\xAC\"\xD9\x9F\xC7\xC1$\xB9\xCD\r\xE2\xD3\xFA\x1F\xAE\xF4 \xBF\xE7\x91\xD8\xC3b\xD7e\xE2'\0`@Q`@Q\x80\x91\x03\x90\xA3PPV[_\x7F}\x81Y\x81\n~\xBF\x94N\x8F\xA9<\xC4\xFB\xD1\xCA\xDElq\xF8\xB0\xB8k7\x18z\xC7\x99\x17w\xB1\0\x90P\x90V[``_`\x01a,g\x84aG\x95V[\x01\x90P_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a,\x85Wa,\x84a]{V[[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a,\xB7W\x81` \x01`\x01\x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x90P_\x82` \x01\x82\x01\x90P[`\x01\x15a-\x18W\x80\x80`\x01\x90\x03\x91PP\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\n\x86\x06\x1A\x81S`\n\x85\x81a-\rWa-\x0Can}V[[\x04\x94P_\x85\x03a,\xC4W[\x81\x93PPPP\x91\x90PV[_`\x01`\x07\x81\x11\x15a-8Wa-7a\\\xC1V[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15a-iWa-ha\\\xC1V[[\x14\x90P\x92\x91PPV[_a-\xC6`@Q\x80``\x01`@R\x80`+\x81R` \x01avh`+\x919\x80Q\x90` \x01 \x83_\x01Q`@Q` \x01a-\xAB\x92\x91\x90an\xAAV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 aH\xE6V[\x90P\x91\x90PV[_a-\xD6a,2V[\x90P_a.&\x85\x85\x85\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x81\x84\x01R`\x1F\x19`\x1F\x82\x01\x16\x90P\x80\x83\x01\x92PPPPPPPaH\xFFV[\x90Pa.2\x86\x82a#\xE8V[\x81`\n\x01_\x87\x81R` \x01\x90\x81R` \x01_ _\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a.\xD1W\x85\x81`@Q\x7F\x99\xB1X\xC1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a.\xC8\x92\x91\x90anVV[`@Q\x80\x91\x03\x90\xFD[`\x01\x82`\n\x01_\x88\x81R` \x01\x90\x81R` \x01_ _\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPPPPPPPV[_\x80\x83`\x80\x01QQ\x90P\x80\x83\x10\x15\x91PP\x92\x91PPV[_a/_a,2V[\x90Pa/p\x81_\x01\x84_\x01QaI)V[_\x82Ca/}\x91\x90ah\xD6V[\x90P\x80\x82`\x13\x01_\x86_\x01Q\x81R` \x01\x90\x81R` \x01_ \x81\x90UP\x7FE@\xF7\x80\x8F\xCA\xEC\x86\xC3v\xA8\x9D,\x0C\x93\xA5\x05l!h\r\xB5C2\xC7\xF2\x95\x9D\x87\xFE\xFC\x8B\x84\x82`@Qa/\xCB\x92\x91\x90an\xD1V[`@Q\x80\x91\x03\x90\xA1PPPPV[a/\xE1a@\xBCV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a/\xFFa\x1FBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a0^Wa0\"a@\xBCV[`@Q\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a0U\x91\x90abBV[`@Q\x80\x91\x03\x90\xFD[V[a0haUUV[_a0qa,2V[\x90P_\x85\x85\x90P\x03a0\xAFW`@Q\x7F\x06\x8C\x8D@\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80`\t\x01_\x81T\x80\x92\x91\x90a0\xC3\x90an\xFFV[\x91\x90PUP_\x81`\t\x01T\x90P\x80\x82`\x08\x01_\x83\x81R` \x01\x90\x81R` \x01_ _\x01\x81\x90UP\x88\x82`\x08\x01_\x83\x81R` \x01\x90\x81R` \x01_ `\x01\x01\x81\x90UP\x87\x82`\x08\x01_\x83\x81R` \x01\x90\x81R` \x01_ `\x02\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83`\xC0\x1C\x02\x17\x90UPa1H\x81\x88\x88\x88\x90PaI\xFFV[_[\x86\x86\x90P\x81\x10\x15a1\xD1W\x82`\x08\x01_\x83\x81R` \x01\x90\x81R` \x01_ `\x04\x01\x87\x87\x83\x81\x81\x10a1~Wa1}aoFV[[\x90P` \x02\x81\x01\x90a1\x90\x91\x90ao\x7FV[\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x08\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a1\xC2\x91\x90at\x01V[PP\x80\x80`\x01\x01\x91PPa1JV[P_[\x86\x86\x90P\x81\x10\x15a5*W\x86\x86\x82\x81\x81\x10a1\xF2Wa1\xF1aoFV[[\x90P` \x02\x81\x01\x90a2\x04\x91\x90ao\x7FV[\x83`\r\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x89\x89\x85\x81\x81\x10a2+Wa2*aoFV[[\x90P` \x02\x81\x01\x90a2=\x91\x90ao\x7FV[`@\x01` \x81\x01\x90a2O\x91\x90ab\x99V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ \x81\x81a2\x94\x91\x90at\x01V[\x90PP`\x01\x83`\x0E\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x89\x89\x85\x81\x81\x10a2\xC0Wa2\xBFaoFV[[\x90P` \x02\x81\x01\x90a2\xD2\x91\x90ao\x7FV[`@\x01` \x81\x01\x90a2\xE4\x91\x90ab\x99V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x82`\x10\x01_\x83\x81R` \x01\x90\x81R` \x01_ \x87\x87\x83\x81\x81\x10a3YWa3XaoFV[[\x90P` \x02\x81\x01\x90a3k\x91\x90ao\x7FV[`@\x01` \x81\x01\x90a3}\x91\x90ab\x99V[\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x83`\x0F\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x89\x89\x85\x81\x81\x10a4\x03Wa4\x02aoFV[[\x90P` \x02\x81\x01\x90a4\x15\x91\x90ao\x7FV[` \x01` \x81\x01\x90a4'\x91\x90ab\x99V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x82`\x11\x01_\x83\x81R` \x01\x90\x81R` \x01_ \x87\x87\x83\x81\x81\x10a4\x9CWa4\x9BaoFV[[\x90P` \x02\x81\x01\x90a4\xAE\x91\x90ao\x7FV[` \x01` \x81\x01\x90a4\xC0\x91\x90ab\x99V[\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x80\x80`\x01\x01\x91PPa1\xD4V[Pa59\x81\x85\x88\x88\x90PaJsV[\x81`\x08\x01_\x82\x81R` \x01\x90\x81R` \x01_ `@Q\x80`\xA0\x01`@R\x90\x81_\x82\x01T\x81R` \x01`\x01\x82\x01T\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04`\xC0\x1Bw\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01_\x90[\x82\x82\x10\x15a9\x98W\x83\x82\x90_R` _ \x90`\x08\x02\x01`@Q\x80a\x01\0\x01`@R\x90\x81_\x82\x01\x80Ta6\x15\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta6A\x90ae\xA9V[\x80\x15a6\x8CW\x80`\x1F\x10a6cWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a6\x8CV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a6oW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80Ta7Y\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta7\x85\x90ae\xA9V[\x80\x15a7\xD0W\x80`\x1F\x10a7\xA7Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a7\xD0V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a7\xB3W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta7\xE9\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta8\x15\x90ae\xA9V[\x80\x15a8`W\x80`\x1F\x10a87Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a8`V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a8CW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x06\x82\x01\x80Ta8y\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta8\xA5\x90ae\xA9V[\x80\x15a8\xF0W\x80`\x1F\x10a8\xC7Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a8\xF0V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a8\xD3W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x07\x82\x01\x80Ta9\t\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta95\x90ae\xA9V[\x80\x15a9\x80W\x80`\x1F\x10a9WWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a9\x80V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a9cW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x81R` \x01\x90`\x01\x01\x90a5\xE4V[PPPP\x81RPP\x92PPP\x96\x95PPPPPPV[\x80_\x81\x03a9\xE8W`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a9\xF2\x83\x83aJ\x95V[a:3W\x81`@Q\x7FfS\xF6\xD7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a:*\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[`\x01\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15a:hWa:ga\\\xC1V[[\x02\x17\x90UP\x81\x83`\x01\x01\x81\x90UPPPPV[a:\x83a\x15\xD5V[\x15a:\xBAW`@Q\x7F\xD9<\x06e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_a:\xC5a,2V[\x90P_\x83\x03a;\0W`@Q\x7F\xB1\xAE\x92\xEA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x83\x11\x15a;GW\x82\x82`@Q\x7F\x84 \x8F#\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a;>\x92\x91\x90ahMV[`@Q\x80\x91\x03\x90\xFD[\x82\x81`\x15\x01_\x86\x81R` \x01\x90\x81R` \x01_ \x81\x90UPPPPPV[a;maJ\xE3V[_a;va>\x91V[\x90P_\x81_\x01_a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAAa;\xBBa@\xBCV[`@Qa;\xC8\x91\x90abBV[`@Q\x80\x91\x03\x90\xA1PV[_\x82_\x01_\x83\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x90P\x92\x91PPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x80a<\xA8WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a<\x8FaK#V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15a<\xDFW`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[a<\xE9a/\xD9V[PV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cR\xD1\x90-`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15a=TWP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a=Q\x91\x90at9V[`\x01[a=\x95W\x81`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a=\x8C\x91\x90abBV[`@Q\x80\x91\x03\x90\xFD[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x81\x14a=\xFBW\x80`@Q\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a=\xF2\x91\x90a_\x11V[`@Q\x80\x91\x03\x90\xFD[a>\x05\x83\x83aKvV[PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a>\x8FW`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_\x7F\xCD^\xD1\\n\x18~w\xE9\xAE\xE8\x81\x84\xC2\x1FO!\x82\xABX'\xCB;~\x07\xFB\xED\xCDc\xF03\0\x90P\x90V[_a>\xC1a>\xDCV[_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[a?\x0BaK\xE8V[a?\x15\x82\x82aL(V[PPV[a?!aK\xE8V[a?*\x81aLyV[PV[a?5aK\xE8V[a?=aL\xFDV[V[\x80_\x81\x03a?yW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a?\x83\x83\x83aM-V[\x15\x80\x15a?\x97WPa?\x95\x83\x83aM|V[\x15[\x80\x15a?\xA7WP_\x83`\x03\x01T\x14\x15[\x15a?\xE9W\x81`@Q\x7F\x12\xB4\x9E=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a?\xE0\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[`\x03\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15a@\x1EWa@\x1Da\\\xC1V[[\x02\x17\x90UP\x81\x83`\x03\x01\x81\x90UP_\x83`\x02\x01\x81\x90UPPPPV[_a@Ca,2V[\x90P\x82_\x015\x81`\x06\x01_\x84\x81R` \x01\x90\x81R` \x01_ \x81\x90UP\x82` \x015\x81`\x05\x01\x81\x90UP\x82`@\x015\x81`\x07\x01\x81\x90UPPPPV[_a@\x88aF\xC5V[\x90P\x80_\x01_a\x01\0\n\x81T\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90Ua@\xB8\x82aM\xCBV[PPV[_3\x90P\x90V[a@\xCBa:{V[_a@\xD4a>\x91V[\x90P`\x01\x81_\x01_a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2XaA\x1Aa@\xBCV[`@QaA'\x91\x90abBV[`@Q\x80\x91\x03\x90\xA1PV[_\x7F\xA1jF\xD9Ba\xC7Q|\xC8\xFF\x89\xF6\x1C\x0C\xE95\x98\xE3\xC8I\x80\x10\x11\xDE\xE6I\xA6\xA5W\xD1\0\x90P\x90V[``_aAdaA2V[\x90P\x80`\x02\x01\x80TaAu\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80TaA\xA1\x90ae\xA9V[\x80\x15aA\xECW\x80`\x1F\x10aA\xC3Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91aA\xECV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11aA\xCFW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x91PP\x90V[``_aB\x02aA2V[\x90P\x80`\x03\x01\x80TaB\x13\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80TaB?\x90ae\xA9V[\x80\x15aB\x8AW\x80`\x1F\x10aBaWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91aB\x8AV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11aBmW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x91PP\x90V[\x80_\x81\x03aB\xCFW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x07\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aC\x04WaC\x03a\\\xC1V[[\x02\x17\x90UP\x81\x83`\x01\x01T\x03aC\x1EW_\x83`\x01\x01\x81\x90UP[\x81\x83`\x02\x01T\x03aC3W_\x83`\x02\x01\x81\x90UP[\x81\x83`\x03\x01T\x03aCHW_\x83`\x03\x01\x81\x90UP[\x81\x83`\x04\x01T\x03aC]W_\x83`\x04\x01\x81\x90UP[PPPV[\x80_\x81\x03aC\x9CW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aC\xA6\x83\x83aEaV[aC\xE7W\x81`@Q\x7F3\x14\x86\xB3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aC\xDE\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[`\x04\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aD\x1CWaD\x1Ba\\\xC1V[[\x02\x17\x90UP\x81\x83`\x04\x01\x81\x90UP_\x83`\x03\x01\x81\x90UPPPPV[\x80_\x81\x03aDrW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aD|\x83\x83aEaV[\x15\x80aD\x8FWPaD\x8D\x83\x83aM|V[\x15[\x15aD\xD1W\x81`@Q\x7F+6R\xD1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aD\xC8\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[`\x05\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aE\x06WaE\x05a\\\xC1V[[\x02\x17\x90UP\x81\x83`\x03\x01T\x03aE W_\x83`\x03\x01\x81\x90UP[\x81\x83`\x04\x01T\x03aE5W_\x83`\x04\x01\x81\x90UP[PPPV[_\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0\x90P\x90V[_`\x03`\x07\x81\x11\x15aEvWaEua\\\xC1V[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15aE\xA7WaE\xA6a\\\xC1V[[\x14\x90P\x92\x91PPV[\x80_\x81\x03aE\xEAW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aE\xF4\x83\x83aJ\x95V[\x80aF\x05WPaF\x04\x83\x83a-#V[[\x15aFGW\x81`@Q\x7F\xB0\xC5\x15\x1D\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aF>\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[`\x06\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aF|WaF{a\\\xC1V[[\x02\x17\x90UP\x81\x83`\x02\x01T\x03aF\x96W_\x83`\x02\x01\x81\x90UP[\x81\x83`\x03\x01T\x03aF\xABW_\x83`\x03\x01\x81\x90UP[\x81\x83`\x04\x01T\x03aF\xC0W_\x83`\x04\x01\x81\x90UP[PPPV[_\x7F#~\x15\x82\"\xE3\xE6\x96\x8Br\xB9\xDB\r\x80C\xAA\xCF\x07J\xD9\xF6P\xF0\xD1`kM\x82\xEEC,\0\x90P\x90V[_aF\xF5a,2V[\x90P_\x83\x03aG0W`@Q\x7F\xE6\nrq\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x83\x11\x15aGwW\x82\x82`@Q\x7F\xD2S^\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aGn\x92\x91\x90ahMV[`@Q\x80\x91\x03\x90\xFD[\x82\x81`\x16\x01_\x86\x81R` \x01\x90\x81R` \x01_ \x81\x90UPPPPPV[_\x80_\x90Pz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x10aG\xF1Wz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x81aG\xE7WaG\xE6an}V[[\x04\x92P`@\x81\x01\x90P[m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x10aH.Wm\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x81aH$WaH#an}V[[\x04\x92P` \x81\x01\x90P[f#\x86\xF2o\xC1\0\0\x83\x10aH]Wf#\x86\xF2o\xC1\0\0\x83\x81aHSWaHRan}V[[\x04\x92P`\x10\x81\x01\x90P[c\x05\xF5\xE1\0\x83\x10aH\x86Wc\x05\xF5\xE1\0\x83\x81aH|WaH{an}V[[\x04\x92P`\x08\x81\x01\x90P[a'\x10\x83\x10aH\xABWa'\x10\x83\x81aH\xA1WaH\xA0an}V[[\x04\x92P`\x04\x81\x01\x90P[`d\x83\x10aH\xCEW`d\x83\x81aH\xC4WaH\xC3an}V[[\x04\x92P`\x02\x81\x01\x90P[`\n\x83\x10aH\xDDW`\x01\x81\x01\x90P[\x80\x91PP\x91\x90PV[_aH\xF8aH\xF2aN\x9CV[\x83aN\xAAV[\x90P\x91\x90PV[_\x80_\x80aI\r\x86\x86aN\xEAV[\x92P\x92P\x92PaI\x1D\x82\x82aO?V[\x82\x93PPPP\x92\x91PPV[\x80_\x81\x03aIcW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aIm\x83\x83a-#V[aI\xAEW\x81`@Q\x7F\xC0\xB5\xEEf\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aI\xA5\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[`\x02\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aI\xE3WaI\xE2a\\\xC1V[[\x02\x17\x90UP\x81\x83`\x02\x01\x81\x90UP_\x83`\x01\x01\x81\x90UPPPPV[_aJ\x08a,2V[\x90P\x81\x83\x10aJRW\x83\x83\x83`@Q\x7F\x87\x89\xA6\xCA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aJI\x93\x92\x91\x90atdV[`@Q\x80\x91\x03\x90\xFD[\x82\x81`\x08\x01_\x86\x81R` \x01\x90\x81R` \x01_ `\x03\x01\x81\x90UPPPPPV[aJ\x81\x83\x83_\x015\x83a:\xBCV[aJ\x90\x83\x83` \x015\x83aF\xECV[PPPV[_\x80`\x07\x81\x11\x15aJ\xA9WaJ\xA8a\\\xC1V[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15aJ\xDAWaJ\xD9a\\\xC1V[[\x14\x90P\x92\x91PPV[aJ\xEBa\x15\xD5V[aK!W`@Q\x7F\x8D\xFC +\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_aKO\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1BaP\xA1V[_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[aK\x7F\x82aP\xAAV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;`@Q`@Q\x80\x91\x03\x90\xA2_\x81Q\x11\x15aK\xDBWaK\xD5\x82\x82aQsV[PaK\xE4V[aK\xE3aQ\xF3V[[PPV[aK\xF0aR/V[aL&W`@Q\x7F\xD7\xE6\xBC\xF8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[aL0aK\xE8V[_aL9aA2V[\x90P\x82\x81`\x02\x01\x90\x81aLL\x91\x90at\x99V[P\x81\x81`\x03\x01\x90\x81aL^\x91\x90at\x99V[P_\x80\x1B\x81_\x01\x81\x90UP_\x80\x1B\x81`\x01\x01\x81\x90UPPPPV[aL\x81aK\xE8V[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03aL\xF1W_`@Q\x7F\x1EO\xBD\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aL\xE8\x91\x90abBV[`@Q\x80\x91\x03\x90\xFD[aL\xFA\x81a@\x7FV[PV[aM\x05aK\xE8V[_aM\x0Ea>\x91V[\x90P_\x81_\x01_a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPPV[_`\x02`\x07\x81\x11\x15aMBWaMAa\\\xC1V[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15aMsWaMra\\\xC1V[[\x14\x90P\x92\x91PPV[_`\x04`\x07\x81\x11\x15aM\x91WaM\x90a\\\xC1V[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15aM\xC2WaM\xC1a\\\xC1V[[\x14\x90P\x92\x91PPV[_aM\xD4aE:V[\x90P_\x81_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x82\x82_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPPV[_aN\xA5aRMV[\x90P\x90V[_`@Q\x7F\x19\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x83`\x02\x82\x01R\x82`\"\x82\x01R`B\x81 \x91PP\x92\x91PPV[_\x80_`A\x84Q\x03aO*W_\x80_` \x87\x01Q\x92P`@\x87\x01Q\x91P``\x87\x01Q_\x1A\x90PaO\x1C\x88\x82\x85\x85aR\xB0V[\x95P\x95P\x95PPPPaO8V[_`\x02\x85Q_\x1B\x92P\x92P\x92P[\x92P\x92P\x92V[_`\x03\x81\x11\x15aORWaOQa\\\xC1V[[\x82`\x03\x81\x11\x15aOeWaOda\\\xC1V[[\x03\x15aP\x9DW`\x01`\x03\x81\x11\x15aO\x7FWaO~a\\\xC1V[[\x82`\x03\x81\x11\x15aO\x92WaO\x91a\\\xC1V[[\x03aO\xC9W`@Q\x7F\xF6E\xEE\xDF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02`\x03\x81\x11\x15aO\xDDWaO\xDCa\\\xC1V[[\x82`\x03\x81\x11\x15aO\xF0WaO\xEFa\\\xC1V[[\x03aP4W\x80_\x1C`@Q\x7F\xFC\xE6\x98\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aP+\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[`\x03\x80\x81\x11\x15aPGWaPFa\\\xC1V[[\x82`\x03\x81\x11\x15aPZWaPYa\\\xC1V[[\x03aP\x9CW\x80`@Q\x7F\xD7\x8B\xCE\x0C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aP\x93\x91\x90a_\x11V[`@Q\x80\x91\x03\x90\xFD[[PPV[_\x81\x90P\x91\x90PV[_\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x03aQ\x05W\x80`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aP\xFC\x91\x90abBV[`@Q\x80\x91\x03\x90\xFD[\x80aQ1\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1BaP\xA1V[_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[``_\x80\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84`@QaQ\x9C\x91\x90au\xA2V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14aQ\xD4W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>aQ\xD9V[``\x91P[P\x91P\x91PaQ\xE9\x85\x83\x83aS\x97V[\x92PPP\x92\x91PPV[_4\x11\x15aR-W`@Q\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_aR8a>\xDCV[_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x90P\x90V[_\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0FaRwaT$V[aR\x7FaT\x9AV[F0`@Q` \x01aR\x95\x95\x94\x93\x92\x91\x90au\xB8V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x90V[_\x80_\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0\x84_\x1C\x11\x15aR\xECW_`\x03\x85\x92P\x92P\x92PaS\x8DV[_`\x01\x88\x88\x88\x88`@Q_\x81R` \x01`@R`@QaS\x0F\x94\x93\x92\x91\x90av$V[` `@Q` \x81\x03\x90\x80\x84\x03\x90\x85Z\xFA\x15\x80\x15aS/W=_\x80>=_\xFD[PPP` `@Q\x03Q\x90P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03aS\x80W_`\x01_\x80\x1B\x93P\x93P\x93PPaS\x8DV[\x80_\x80_\x1B\x93P\x93P\x93PP[\x94P\x94P\x94\x91PPV[``\x82aS\xACWaS\xA7\x82aU\x11V[aT\x1CV[_\x82Q\x14\x80\x15aS\xD2WP_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x14[\x15aT\x14W\x83`@Q\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aT\x0B\x91\x90abBV[`@Q\x80\x91\x03\x90\xFD[\x81\x90PaT\x1DV[[\x93\x92PPPV[_\x80aT.aA2V[\x90P_aT9aAYV[\x90P_\x81Q\x11\x15aTUW\x80\x80Q\x90` \x01 \x92PPPaT\x97V[_\x82_\x01T\x90P_\x80\x1B\x81\x14aTpW\x80\x93PPPPaT\x97V[\x7F\xC5\xD2F\x01\x86\xF7#<\x92~}\xB2\xDC\xC7\x03\xC0\xE5\0\xB6S\xCA\x82';{\xFA\xD8\x04]\x85\xA4p\x93PPPP[\x90V[_\x80aT\xA4aA2V[\x90P_aT\xAFaA\xF7V[\x90P_\x81Q\x11\x15aT\xCBW\x80\x80Q\x90` \x01 \x92PPPaU\x0EV[_\x82`\x01\x01T\x90P_\x80\x1B\x81\x14aT\xE7W\x80\x93PPPPaU\x0EV[\x7F\xC5\xD2F\x01\x86\xF7#<\x92~}\xB2\xDC\xC7\x03\xC0\xE5\0\xB6S\xCA\x82';{\xFA\xD8\x04]\x85\xA4p\x93PPPP[\x90V[_\x81Q\x11\x15aU#W\x80Q\x80\x82` \x01\xFD[`@Q\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Q\x80`\xA0\x01`@R\x80_\x81R` \x01_\x81R` \x01_w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01_\x81R` \x01``\x81RP\x90V[`@Q\x80a\x01\0\x01`@R\x80``\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_\x81R` \x01``\x81R` \x01``\x81R` \x01``\x81R` \x01``\x81RP\x90V[_\x81\x90P\x91\x90PV[aV\x1B\x81aV\tV[\x82RPPV[_` \x82\x01\x90PaV4_\x83\x01\x84aV\x12V[\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_[\x83\x81\x10\x15aVqW\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90PaVVV[_\x84\x84\x01RPPPPV[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[_aV\x96\x82aV:V[aV\xA0\x81\x85aVDV[\x93PaV\xB0\x81\x85` \x86\x01aVTV[aV\xB9\x81aV|V[\x84\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01RaV\xDC\x81\x84aV\x8CV[\x90P\x92\x91PPV[aV\xED\x81aV\tV[\x82RPPV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[aW'\x81aV\xF3V[\x82RPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_aWp\x82aV:V[aWz\x81\x85aWVV[\x93PaW\x8A\x81\x85` \x86\x01aVTV[aW\x93\x81aV|V[\x84\x01\x91PP\x92\x91PPV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_aW\xC7\x82aW\x9EV[\x90P\x91\x90PV[aW\xD7\x81aW\xBDV[\x82RPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_aX\x01\x82aW\xDDV[aX\x0B\x81\x85aW\xE7V[\x93PaX\x1B\x81\x85` \x86\x01aVTV[aX$\x81aV|V[\x84\x01\x91PP\x92\x91PPV[_a\x01\0\x83\x01_\x83\x01Q\x84\x82\x03_\x86\x01RaXJ\x82\x82aWfV[\x91PP` \x83\x01QaX_` \x86\x01\x82aW\xCEV[P`@\x83\x01QaXr`@\x86\x01\x82aW\xCEV[P``\x83\x01QaX\x85``\x86\x01\x82aV\xE4V[P`\x80\x83\x01Q\x84\x82\x03`\x80\x86\x01RaX\x9D\x82\x82aW\xF7V[\x91PP`\xA0\x83\x01Q\x84\x82\x03`\xA0\x86\x01RaX\xB7\x82\x82aWfV[\x91PP`\xC0\x83\x01Q\x84\x82\x03`\xC0\x86\x01RaX\xD1\x82\x82aWfV[\x91PP`\xE0\x83\x01Q\x84\x82\x03`\xE0\x86\x01RaX\xEB\x82\x82aW\xF7V[\x91PP\x80\x91PP\x92\x91PPV[_aY\x03\x83\x83aX/V[\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_aY!\x82aW-V[aY+\x81\x85aW7V[\x93P\x83` \x82\x02\x85\x01aY=\x85aWGV[\x80_[\x85\x81\x10\x15aYxW\x84\x84\x03\x89R\x81QaYY\x85\x82aX\xF8V[\x94PaYd\x83aY\x0BV[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90PaY@V[P\x82\x97P\x87\x95PPPPPP\x92\x91PPV[_`\xA0\x83\x01_\x83\x01QaY\x9F_\x86\x01\x82aV\xE4V[P` \x83\x01QaY\xB2` \x86\x01\x82aV\xE4V[P`@\x83\x01QaY\xC5`@\x86\x01\x82aW\x1EV[P``\x83\x01QaY\xD8``\x86\x01\x82aV\xE4V[P`\x80\x83\x01Q\x84\x82\x03`\x80\x86\x01RaY\xF0\x82\x82aY\x17V[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01RaZ\x15\x81\x84aY\x8AV[\x90P\x92\x91PPV[_`@Q\x90P\x90V[_\x80\xFD[_\x80\xFD[aZ7\x81aV\tV[\x81\x14aZAW_\x80\xFD[PV[_\x815\x90PaZR\x81aZ.V[\x92\x91PPV[_\x80\xFD[_\x80\xFD[_\x80\xFD[_\x80\x83`\x1F\x84\x01\x12aZyWaZxaZXV[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aZ\x96WaZ\x95aZ\\V[[` \x83\x01\x91P\x83`\x01\x82\x02\x83\x01\x11\x15aZ\xB2WaZ\xB1aZ`V[[\x92P\x92\x90PV[_\x80_`@\x84\x86\x03\x12\x15aZ\xD0WaZ\xCFaZ&V[[_aZ\xDD\x86\x82\x87\x01aZDV[\x93PP` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aZ\xFEWaZ\xFDaZ*V[[a[\n\x86\x82\x87\x01aZdV[\x92P\x92PP\x92P\x92P\x92V[a[\x1F\x81aV\xF3V[\x81\x14a[)W_\x80\xFD[PV[_\x815\x90Pa[:\x81a[\x16V[\x92\x91PPV[_\x81\x15\x15\x90P\x91\x90PV[a[T\x81a[@V[\x81\x14a[^W_\x80\xFD[PV[_\x815\x90Pa[o\x81a[KV[\x92\x91PPV[_\x80\x83`\x1F\x84\x01\x12a[\x8AWa[\x89aZXV[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a[\xA7Wa[\xA6aZ\\V[[` \x83\x01\x91P\x83` \x82\x02\x83\x01\x11\x15a[\xC3Wa[\xC2aZ`V[[\x92P\x92\x90PV[_\x80\xFD[_`@\x82\x84\x03\x12\x15a[\xE3Wa[\xE2a[\xCAV[[\x81\x90P\x92\x91PPV[_\x80_\x80_\x80_`\xE0\x88\x8A\x03\x12\x15a\\\x07Wa\\\x06aZ&V[[_a\\\x14\x8A\x82\x8B\x01aZDV[\x97PP` a\\%\x8A\x82\x8B\x01a[,V[\x96PP`@a\\6\x8A\x82\x8B\x01a[aV[\x95PP``a\\G\x8A\x82\x8B\x01aZDV[\x94PP`\x80\x88\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\\hWa\\gaZ*V[[a\\t\x8A\x82\x8B\x01a[uV[\x93P\x93PP`\xA0a\\\x87\x8A\x82\x8B\x01a[\xCEV[\x91PP\x92\x95\x98\x91\x94\x97P\x92\x95PV[_` \x82\x84\x03\x12\x15a\\\xABWa\\\xAAaZ&V[[_a\\\xB8\x84\x82\x85\x01aZDV[\x91PP\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`!`\x04R`$_\xFD[`\x08\x81\x10a\\\xFFWa\\\xFEa\\\xC1V[[PV[_\x81\x90Pa]\x0F\x82a\\\xEEV[\x91\x90PV[_a]\x1E\x82a]\x02V[\x90P\x91\x90PV[a].\x81a]\x14V[\x82RPPV[_` \x82\x01\x90Pa]G_\x83\x01\x84a]%V[\x92\x91PPV[a]V\x81aW\xBDV[\x81\x14a]`W_\x80\xFD[PV[_\x815\x90Pa]q\x81a]MV[\x92\x91PPV[_\x80\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[a]\xB1\x82aV|V[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a]\xD0Wa]\xCFa]{V[[\x80`@RPPPV[_a]\xE2aZ\x1DV[\x90Pa]\xEE\x82\x82a]\xA8V[\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a^\rWa^\x0Ca]{V[[a^\x16\x82aV|V[\x90P` \x81\x01\x90P\x91\x90PV[\x82\x81\x837_\x83\x83\x01RPPPV[_a^Ca^>\x84a]\xF3V[a]\xD9V[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a^_Wa^^a]wV[[a^j\x84\x82\x85a^#V[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a^\x86Wa^\x85aZXV[[\x815a^\x96\x84\x82` \x86\x01a^1V[\x91PP\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15a^\xB5Wa^\xB4aZ&V[[_a^\xC2\x85\x82\x86\x01a]cV[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a^\xE3Wa^\xE2aZ*V[[a^\xEF\x85\x82\x86\x01a^rV[\x91PP\x92P\x92\x90PV[_\x81\x90P\x91\x90PV[a_\x0B\x81a^\xF9V[\x82RPPV[_` \x82\x01\x90Pa_$_\x83\x01\x84a_\x02V[\x92\x91PPV[a_3\x81a[@V[\x82RPPV[_` \x82\x01\x90Pa_L_\x83\x01\x84a_*V[\x92\x91PPV[_``\x82\x84\x03\x12\x15a_gWa_fa[\xCAV[[\x81\x90P\x92\x91PPV[_\x80_\x80_\x80a\x01\0\x87\x89\x03\x12\x15a_\x8BWa_\x8AaZ&V[[_a_\x98\x89\x82\x8A\x01a[\xCEV[\x96PP`@a_\xA9\x89\x82\x8A\x01a_RV[\x95PP`\xA0a_\xBA\x89\x82\x8A\x01a[,V[\x94PP`\xC0a_\xCB\x89\x82\x8A\x01aZDV[\x93PP`\xE0\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a_\xECWa_\xEBaZ*V[[a_\xF8\x89\x82\x8A\x01a[uV[\x92P\x92PP\x92\x95P\x92\x95P\x92\x95V[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_a`;\x83\x83aW\xCEV[` \x83\x01\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_a`]\x82a`\x07V[a`g\x81\x85a`\x11V[\x93Pa`r\x83a`!V[\x80_[\x83\x81\x10\x15a`\xA2W\x81Qa`\x89\x88\x82a`0V[\x97Pa`\x94\x83a`GV[\x92PP`\x01\x81\x01\x90Pa`uV[P\x85\x93PPPP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra`\xC7\x81\x84a`SV[\x90P\x92\x91PPV[_\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[aa\x03\x81a`\xCFV[\x82RPPV[aa\x12\x81aW\xBDV[\x82RPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_aaL\x83\x83aV\xE4V[` \x83\x01\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_aan\x82aa\x18V[aax\x81\x85aa\"V[\x93Paa\x83\x83aa2V[\x80_[\x83\x81\x10\x15aa\xB3W\x81Qaa\x9A\x88\x82aaAV[\x97Paa\xA5\x83aaXV[\x92PP`\x01\x81\x01\x90Paa\x86V[P\x85\x93PPPP\x92\x91PPV[_`\xE0\x82\x01\x90Paa\xD3_\x83\x01\x8Aa`\xFAV[\x81\x81\x03` \x83\x01Raa\xE5\x81\x89aV\x8CV[\x90P\x81\x81\x03`@\x83\x01Raa\xF9\x81\x88aV\x8CV[\x90Pab\x08``\x83\x01\x87aV\x12V[ab\x15`\x80\x83\x01\x86aa\tV[ab\"`\xA0\x83\x01\x85a_\x02V[\x81\x81\x03`\xC0\x83\x01Rab4\x81\x84aadV[\x90P\x98\x97PPPPPPPPV[_` \x82\x01\x90PabU_\x83\x01\x84aa\tV[\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15abqWabpaZ&V[[_ab~\x85\x82\x86\x01aZDV[\x92PP` ab\x8F\x85\x82\x86\x01a]cV[\x91PP\x92P\x92\x90PV[_` \x82\x84\x03\x12\x15ab\xAEWab\xADaZ&V[[_ab\xBB\x84\x82\x85\x01a]cV[\x91PP\x92\x91PPV[_a\x01\0\x83\x01_\x83\x01Q\x84\x82\x03_\x86\x01Rab\xDF\x82\x82aWfV[\x91PP` \x83\x01Qab\xF4` \x86\x01\x82aW\xCEV[P`@\x83\x01Qac\x07`@\x86\x01\x82aW\xCEV[P``\x83\x01Qac\x1A``\x86\x01\x82aV\xE4V[P`\x80\x83\x01Q\x84\x82\x03`\x80\x86\x01Rac2\x82\x82aW\xF7V[\x91PP`\xA0\x83\x01Q\x84\x82\x03`\xA0\x86\x01RacL\x82\x82aWfV[\x91PP`\xC0\x83\x01Q\x84\x82\x03`\xC0\x86\x01Racf\x82\x82aWfV[\x91PP`\xE0\x83\x01Q\x84\x82\x03`\xE0\x86\x01Rac\x80\x82\x82aW\xF7V[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Rac\xA5\x81\x84ab\xC4V[\x90P\x92\x91PPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_ac\xC7\x82aW-V[ac\xD1\x81\x85ac\xADV[\x93P\x83` \x82\x02\x85\x01ac\xE3\x85aWGV[\x80_[\x85\x81\x10\x15ad\x1EW\x84\x84\x03\x89R\x81Qac\xFF\x85\x82aX\xF8V[\x94Pad\n\x83aY\x0BV[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90Pac\xE6V[P\x82\x97P\x87\x95PPPPPP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01RadH\x81\x84ac\xBDV[\x90P\x92\x91PPV[_\x81\x90P\x92\x91PPV[_add\x82aV:V[adn\x81\x85adPV[\x93Pad~\x81\x85` \x86\x01aVTV[\x80\x84\x01\x91PP\x92\x91PPV[\x7F v\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_ad\xBE`\x02\x83adPV[\x91Pad\xC9\x82ad\x8AV[`\x02\x82\x01\x90P\x91\x90PV[\x7F.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_ae\x08`\x01\x83adPV[\x91Pae\x13\x82ad\xD4V[`\x01\x82\x01\x90P\x91\x90PV[_ae)\x82\x87adZV[\x91Pae4\x82ad\xB2V[\x91Pae@\x82\x86adZV[\x91PaeK\x82ad\xFCV[\x91PaeW\x82\x85adZV[\x91Paeb\x82ad\xFCV[\x91Paen\x82\x84adZV[\x91P\x81\x90P\x95\x94PPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\"`\x04R`$_\xFD[_`\x02\x82\x04\x90P`\x01\x82\x16\x80ae\xC0W`\x7F\x82\x16\x91P[` \x82\x10\x81\x03ae\xD3Wae\xD2ae|V[[P\x91\x90PV[_\x82\x90P\x92\x91PPV[_\x81\x90P\x81_R` _ \x90P\x91\x90PV[_` `\x1F\x83\x01\x04\x90P\x91\x90PV[_\x82\x82\x1B\x90P\x92\x91PPV[_`\x08\x83\x02af?\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82af\x04V[afI\x86\x83af\x04V[\x95P\x80\x19\x84\x16\x93P\x80\x86\x16\x84\x17\x92PPP\x93\x92PPPV[_\x81\x90P\x91\x90PV[_af\x84af\x7Fafz\x84aV\tV[afaV[aV\tV[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[af\x9D\x83afjV[af\xB1af\xA9\x82af\x8BV[\x84\x84Taf\x10V[\x82UPPPPV[_\x90V[af\xC5af\xB9V[af\xD0\x81\x84\x84af\x94V[PPPV[[\x81\x81\x10\x15af\xF3Waf\xE8_\x82af\xBDV[`\x01\x81\x01\x90Paf\xD6V[PPV[`\x1F\x82\x11\x15ag8Wag\t\x81ae\xE3V[ag\x12\x84ae\xF5V[\x81\x01` \x85\x10\x15ag!W\x81\x90P[ag5ag-\x85ae\xF5V[\x83\x01\x82af\xD5V[PP[PPPV[_\x82\x82\x1C\x90P\x92\x91PPV[_agX_\x19\x84`\x08\x02ag=V[\x19\x80\x83\x16\x91PP\x92\x91PPV[_agp\x83\x83agIV[\x91P\x82`\x02\x02\x82\x17\x90P\x92\x91PPV[ag\x8A\x83\x83ae\xD9V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ag\xA3Wag\xA2a]{V[[ag\xAD\x82Tae\xA9V[ag\xB8\x82\x82\x85af\xF7V[_`\x1F\x83\x11`\x01\x81\x14ag\xE5W_\x84\x15ag\xD3W\x82\x87\x015\x90P[ag\xDD\x85\x82ageV[\x86UPahDV[`\x1F\x19\x84\x16ag\xF3\x86ae\xE3V[_[\x82\x81\x10\x15ah\x1AW\x84\x89\x015\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Pag\xF5V[\x86\x83\x10\x15ah7W\x84\x89\x015ah3`\x1F\x89\x16\x82agIV[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPPV[_`@\x82\x01\x90Pah`_\x83\x01\x85aV\x12V[ahm` \x83\x01\x84aV\x12V[\x93\x92PPPV[_`@\x82\x01\x90P\x81\x81\x03_\x83\x01Rah\x8C\x81\x85aY\x8AV[\x90P\x81\x81\x03` \x83\x01Rah\xA0\x81\x84aY\x8AV[\x90P\x93\x92PPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_ah\xE0\x82aV\tV[\x91Pah\xEB\x83aV\tV[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15ai\x03Wai\x02ah\xA9V[[\x92\x91PPV[_``\x82\x01\x90P\x81\x81\x03_\x83\x01Rai!\x81\x86aY\x8AV[\x90P\x81\x81\x03` \x83\x01Rai5\x81\x85aY\x8AV[\x90PaiD`@\x83\x01\x84aV\x12V[\x94\x93PPPPV[_aiZ` \x84\x01\x84aZDV[\x90P\x92\x91PPV[`@\x82\x01air_\x83\x01\x83aiLV[ai~_\x85\x01\x82aV\xE4V[Pai\x8C` \x83\x01\x83aiLV[ai\x99` \x85\x01\x82aV\xE4V[PPPPV[``\x82\x01ai\xAF_\x83\x01\x83aiLV[ai\xBB_\x85\x01\x82aV\xE4V[Pai\xC9` \x83\x01\x83aiLV[ai\xD6` \x85\x01\x82aV\xE4V[Pai\xE4`@\x83\x01\x83aiLV[ai\xF1`@\x85\x01\x82aV\xE4V[PPPPV[aj\0\x81aV\xF3V[\x82RPPV[_\x81\x90P\x91\x90PV[_\x80\xFD[_\x80\xFD[_\x80\xFD[_\x80\x835`\x01` \x03\x846\x03\x03\x81\x12aj7Waj6aj\x17V[[\x83\x81\x01\x92P\x825\x91P` \x83\x01\x92Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15aj_Waj^aj\x0FV[[`\x01\x82\x026\x03\x83\x13\x15ajuWajtaj\x13V[[P\x92P\x92\x90PV[_aj\x88\x83\x85aWVV[\x93Paj\x95\x83\x85\x84a^#V[aj\x9E\x83aV|V[\x84\x01\x90P\x93\x92PPPV[_aj\xB7` \x84\x01\x84a]cV[\x90P\x92\x91PPV[_\x80\x835`\x01` \x03\x846\x03\x03\x81\x12aj\xDBWaj\xDAaj\x17V[[\x83\x81\x01\x92P\x825\x91P` \x83\x01\x92Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15ak\x03Wak\x02aj\x0FV[[`\x01\x82\x026\x03\x83\x13\x15ak\x19Wak\x18aj\x13V[[P\x92P\x92\x90PV[_ak,\x83\x85aW\xE7V[\x93Pak9\x83\x85\x84a^#V[akB\x83aV|V[\x84\x01\x90P\x93\x92PPPV[_a\x01\0\x83\x01ak__\x84\x01\x84aj\x1BV[\x85\x83\x03_\x87\x01Rakq\x83\x82\x84aj}V[\x92PPPak\x82` \x84\x01\x84aj\xA9V[ak\x8F` \x86\x01\x82aW\xCEV[Pak\x9D`@\x84\x01\x84aj\xA9V[ak\xAA`@\x86\x01\x82aW\xCEV[Pak\xB8``\x84\x01\x84aiLV[ak\xC5``\x86\x01\x82aV\xE4V[Pak\xD3`\x80\x84\x01\x84aj\xBFV[\x85\x83\x03`\x80\x87\x01Rak\xE6\x83\x82\x84ak!V[\x92PPPak\xF7`\xA0\x84\x01\x84aj\x1BV[\x85\x83\x03`\xA0\x87\x01Ral\n\x83\x82\x84aj}V[\x92PPPal\x1B`\xC0\x84\x01\x84aj\x1BV[\x85\x83\x03`\xC0\x87\x01Ral.\x83\x82\x84aj}V[\x92PPPal?`\xE0\x84\x01\x84aj\xBFV[\x85\x83\x03`\xE0\x87\x01RalR\x83\x82\x84ak!V[\x92PPP\x80\x91PP\x92\x91PPV[_alk\x83\x83akMV[\x90P\x92\x91PPV[_\x825`\x01a\x01\0\x03\x836\x03\x03\x81\x12al\x8FWal\x8Eaj\x17V[[\x82\x81\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_al\xB2\x83\x85ac\xADV[\x93P\x83` \x84\x02\x85\x01al\xC4\x84aj\x06V[\x80_[\x87\x81\x10\x15am\x07W\x84\x84\x03\x89Ral\xDE\x82\x84alsV[al\xE8\x85\x82al`V[\x94Pal\xF3\x83al\x9BV[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90Pal\xC7V[P\x82\x97P\x87\x94PPPPP\x93\x92PPPV[_a\x01\0\x82\x01\x90Pam-_\x83\x01\x89aibV[am:`@\x83\x01\x88ai\x9FV[amG`\xA0\x83\x01\x87ai\xF7V[amT`\xC0\x83\x01\x86aV\x12V[\x81\x81\x03`\xE0\x83\x01Ramg\x81\x84\x86al\xA7V[\x90P\x97\x96PPPPPPPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[am\x90\x81amtV[\x82RPPV[_` \x82\x01\x90Pam\xA9_\x83\x01\x84am\x87V[\x92\x91PPV[_\x81Q\x90Pam\xBD\x81a]MV[\x92\x91PPV[_` \x82\x84\x03\x12\x15am\xD8Wam\xD7aZ&V[[_am\xE5\x84\x82\x85\x01am\xAFV[\x91PP\x92\x91PPV[\x7FEIP712: Uninitialized\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_an\"`\x15\x83aVDV[\x91Pan-\x82am\xEEV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01RanO\x81an\x16V[\x90P\x91\x90PV[_`@\x82\x01\x90Pani_\x83\x01\x85aV\x12V[anv` \x83\x01\x84aa\tV[\x93\x92PPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_`@\x82\x01\x90Pan\xBD_\x83\x01\x85a_\x02V[an\xCA` \x83\x01\x84aV\x12V[\x93\x92PPPV[_`@\x82\x01\x90P\x81\x81\x03_\x83\x01Ran\xE9\x81\x85aY\x8AV[\x90Pan\xF8` \x83\x01\x84aV\x12V[\x93\x92PPPV[_ao\t\x82aV\tV[\x91P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03ao;Wao:ah\xA9V[[`\x01\x82\x01\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[_\x80\xFD[_\x80\xFD[_\x80\xFD[_\x825`\x01a\x01\0\x03\x836\x03\x03\x81\x12ao\x9BWao\x9AaosV[[\x80\x83\x01\x91PP\x92\x91PPV[_\x80\x835`\x01` \x03\x846\x03\x03\x81\x12ao\xC3Wao\xC2aosV[[\x80\x84\x01\x92P\x825\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15ao\xE5Wao\xE4aowV[[` \x83\x01\x92P`\x01\x82\x026\x03\x83\x13\x15ap\x01Wap\0ao{V[[P\x92P\x92\x90PV[_\x82\x90P\x92\x91PPV[_\x81\x90P\x81_R` _ \x90P\x91\x90PV[`\x1F\x82\x11\x15apfWap7\x81ap\x13V[ap@\x84ae\xF5V[\x81\x01` \x85\x10\x15apOW\x81\x90P[apcap[\x85ae\xF5V[\x83\x01\x82af\xD5V[PP[PPPV[apu\x83\x83ap\tV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ap\x8EWap\x8Da]{V[[ap\x98\x82Tae\xA9V[ap\xA3\x82\x82\x85ap%V[_`\x1F\x83\x11`\x01\x81\x14ap\xD0W_\x84\x15ap\xBEW\x82\x87\x015\x90P[ap\xC8\x85\x82ageV[\x86UPaq/V[`\x1F\x19\x84\x16ap\xDE\x86ap\x13V[_[\x82\x81\x10\x15aq\x05W\x84\x89\x015\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Pap\xE0V[\x86\x83\x10\x15aq\"W\x84\x89\x015aq\x1E`\x1F\x89\x16\x82agIV[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPPV[aqC\x83\x83\x83apkV[PPPV[_\x815aqT\x81a]MV[\x80\x91PP\x91\x90PV[_\x81_\x1B\x90P\x91\x90PV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFaq\x87\x84aq]V[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[_aq\xB7aq\xB2aq\xAD\x84aW\x9EV[afaV[aW\x9EV[\x90P\x91\x90PV[_aq\xC8\x82aq\x9DV[\x90P\x91\x90PV[_aq\xD9\x82aq\xBEV[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[aq\xF2\x82aq\xCFV[ar\x05aq\xFE\x82aq\xE0V[\x83TaqhV[\x82UPPPV[_\x815ar\x18\x81aZ.V[\x80\x91PP\x91\x90PV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFarL\x84aq]V[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[ark\x82afjV[ar~arw\x82af\x8BV[\x83Tar!V[\x82UPPPV[_\x80\x835`\x01` \x03\x846\x03\x03\x81\x12ar\xA1War\xA0aosV[[\x80\x84\x01\x92P\x825\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15ar\xC3War\xC2aowV[[` \x83\x01\x92P`\x01\x82\x026\x03\x83\x13\x15ar\xDFWar\xDEao{V[[P\x92P\x92\x90PV[ar\xF2\x83\x83\x83ag\x80V[PPPV[_\x81\x01_\x83\x01as\x07\x81\x85ao\xA7V[as\x12\x81\x83\x86aq8V[PPPP`\x01\x81\x01` \x83\x01\x80as(\x81aqHV[\x90Pas4\x81\x84aq\xE9V[PPP`\x02\x81\x01`@\x83\x01\x80asI\x81aqHV[\x90PasU\x81\x84aq\xE9V[PPP`\x03\x81\x01``\x83\x01\x80asj\x81ar\x0CV[\x90Pasv\x81\x84arbV[PPP`\x04\x81\x01`\x80\x83\x01as\x8B\x81\x85ar\x85V[as\x96\x81\x83\x86ar\xE7V[PPPP`\x05\x81\x01`\xA0\x83\x01as\xAC\x81\x85ao\xA7V[as\xB7\x81\x83\x86aq8V[PPPP`\x06\x81\x01`\xC0\x83\x01as\xCD\x81\x85ao\xA7V[as\xD8\x81\x83\x86aq8V[PPPP`\x07\x81\x01`\xE0\x83\x01as\xEE\x81\x85ar\x85V[as\xF9\x81\x83\x86ar\xE7V[PPPPPPV[at\x0B\x82\x82ar\xF7V[PPV[at\x18\x81a^\xF9V[\x81\x14at\"W_\x80\xFD[PV[_\x81Q\x90Pat3\x81at\x0FV[\x92\x91PPV[_` \x82\x84\x03\x12\x15atNWatMaZ&V[[_at[\x84\x82\x85\x01at%V[\x91PP\x92\x91PPV[_``\x82\x01\x90Patw_\x83\x01\x86aV\x12V[at\x84` \x83\x01\x85aV\x12V[at\x91`@\x83\x01\x84aV\x12V[\x94\x93PPPPV[at\xA2\x82aV:V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15at\xBBWat\xBAa]{V[[at\xC5\x82Tae\xA9V[at\xD0\x82\x82\x85ap%V[_` \x90P`\x1F\x83\x11`\x01\x81\x14au\x01W_\x84\x15at\xEFW\x82\x87\x01Q\x90P[at\xF9\x85\x82ageV[\x86UPau`V[`\x1F\x19\x84\x16au\x0F\x86ap\x13V[_[\x82\x81\x10\x15au6W\x84\x89\x01Q\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Pau\x11V[\x86\x83\x10\x15auSW\x84\x89\x01QauO`\x1F\x89\x16\x82agIV[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPV[_\x81\x90P\x92\x91PPV[_au|\x82aW\xDDV[au\x86\x81\x85auhV[\x93Pau\x96\x81\x85` \x86\x01aVTV[\x80\x84\x01\x91PP\x92\x91PPV[_au\xAD\x82\x84aurV[\x91P\x81\x90P\x92\x91PPV[_`\xA0\x82\x01\x90Pau\xCB_\x83\x01\x88a_\x02V[au\xD8` \x83\x01\x87a_\x02V[au\xE5`@\x83\x01\x86a_\x02V[au\xF2``\x83\x01\x85aV\x12V[au\xFF`\x80\x83\x01\x84aa\tV[\x96\x95PPPPPPV[_`\xFF\x82\x16\x90P\x91\x90PV[av\x1E\x81av\tV[\x82RPPV[_`\x80\x82\x01\x90Pav7_\x83\x01\x87a_\x02V[avD` \x83\x01\x86av\x15V[avQ`@\x83\x01\x85a_\x02V[av^``\x83\x01\x84a_\x02V[\x95\x94PPPPPV\xFEKeyResharingVerification(uint256 contextId)",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405260043610610224575f3560e01c80638456cb5911610122578063d8e3ae01116100aa578063e3b2a8741161006e578063e3b2a87414610748578063e72ee99114610784578063eb843cf6146107ae578063f27cb957146107d6578063f2fde38b146107ec57610224565b8063d8e3ae011461067c578063defba06a146106a6578063dfe36aee146106ce578063e24ba4e5146106f6578063e30c39781461071e57610224565b80639ee77af3116100f15780639ee77af31461059e578063ad3cb1cc146105c6578063b8715d4d146105f0578063c0ae64f71461062c578063c1c8b7251461065457610224565b80638456cb591461051857806384b0196e1461052e5780638cb967511461055e5780638da5cb5b1461057457610224565b80634d694260116101b05780636a1d51eb116101745780636a1d51eb14610470578063715018a6146104985780637420f3d4146104ae57806379ba5097146104d85780637eaac8f2146104ee57610224565b80634d694260146103885780634f1ef286146103c457806352d1902d146103e05780635c975abb1461040a57806364b00cc51461043457610224565b8063169cac14116101f7578063169cac14146102ce5780632e2d3a82146102f65780633f4ba83a1461031e57806343e37e8a146103345780634965e4551461035e57610224565b80630a50e318146102285780630d8e6e2c146102525780630dd486c01461027c5780631079ebeb146102a6575b5f80fd5b348015610233575f80fd5b5061023c610814565b6040516102499190615621565b60405180910390f35b34801561025d575f80fd5b5061026661082d565b60405161027391906156c4565b60405180910390f35b348015610287575f80fd5b506102906108a8565b60405161029d91906159fd565b60405180910390f35b3480156102b1575f80fd5b506102cc60048036038101906102c79190615ab9565b610d34565b005b3480156102d9575f80fd5b506102f460048036038101906102ef9190615bec565b6112f1565b005b348015610301575f80fd5b5061031c60048036038101906103179190615c96565b6114ba565b005b348015610329575f80fd5b50610332611523565b005b34801561033f575f80fd5b50610348611535565b6040516103559190615621565b60405180910390f35b348015610369575f80fd5b5061037261154e565b60405161037f9190615621565b60405180910390f35b348015610393575f80fd5b506103ae60048036038101906103a99190615c96565b611565565b6040516103bb9190615d34565b60405180910390f35b6103de60048036038101906103d99190615e9f565b611585565b005b3480156103eb575f80fd5b506103f46115a4565b6040516104019190615f11565b60405180910390f35b348015610415575f80fd5b5061041e6115d5565b60405161042b9190615f39565b60405180910390f35b34801561043f575f80fd5b5061045a60048036038101906104559190615c96565b6115f7565b6040516104679190615621565b60405180910390f35b34801561047b575f80fd5b5061049660048036038101906104919190615f70565b611686565b005b3480156104a3575f80fd5b506104ac611903565b005b3480156104b9575f80fd5b506104c2611916565b6040516104cf91906160af565b60405180910390f35b3480156104e3575f80fd5b506104ec6119ca565b005b3480156104f9575f80fd5b50610502611a58565b60405161050f91906160af565b60405180910390f35b348015610523575f80fd5b5061052c611b0c565b005b348015610539575f80fd5b50610542611c47565b60405161055597969594939291906161c0565b60405180910390f35b348015610569575f80fd5b50610572611d50565b005b34801561057f575f80fd5b50610588611f42565b6040516105959190616242565b60405180910390f35b3480156105a9575f80fd5b506105c460048036038101906105bf9190615c96565b611f77565b005b3480156105d1575f80fd5b506105da612086565b6040516105e791906156c4565b60405180910390f35b3480156105fb575f80fd5b5061061660048036038101906106119190615c96565b6120bf565b6040516106239190615621565b60405180910390f35b348015610637575f80fd5b50610652600480360381019061064d9190615c96565b61214e565b005b34801561065f575f80fd5b5061067a60048036038101906106759190615c96565b61225d565b005b348015610687575f80fd5b506106906122bc565b60405161069d9190615621565b60405180910390f35b3480156106b1575f80fd5b506106cc60048036038101906106c7919061625b565b6122d3565b005b3480156106d9575f80fd5b506106f460048036038101906106ef919061625b565b6123e8565b005b348015610701575f80fd5b5061071c60048036038101906107179190615c96565b6124fd565b005b348015610729575f80fd5b5061073261255c565b60405161073f9190616242565b60405180910390f35b348015610753575f80fd5b5061076e60048036038101906107699190616299565b612591565b60405161077b919061638d565b60405180910390f35b34801561078f575f80fd5b50610798612a10565b6040516107a59190616430565b60405180910390f35b3480156107b9575f80fd5b506107d460048036038101906107cf9190615c96565b612a23565b005b3480156107e1575f80fd5b506107ea612a8c565b005b3480156107f7575f80fd5b50610812600480360381019061080d9190616299565b612b79565b005b5f8061081e612c32565b9050805f016004015491505090565b60606040518060400160405280600b81526020017f4b6d73436f6e746578747300000000000000000000000000000000000000000081525061086e5f612c59565b6108786001612c59565b6108815f612c59565b604051602001610894949392919061651e565b604051602081830303815290604052905090565b6108b0615555565b5f6108b9612c32565b90505f6108c4611535565b9050816008015f8281526020019081526020015f206040518060a00160405290815f820154815260200160018201548152602001600282015f9054906101000a900460c01b77ffffffffffffffffffffffffffffffffffffffffffffffff191677ffffffffffffffffffffffffffffffffffffffffffffffff191681526020016003820154815260200160048201805480602002602001604051908101604052809291908181526020015f905b82821015610d25578382905f5260205f209060080201604051806101000160405290815f820180546109a2906165a9565b80601f01602080910402602001604051908101604052809291908181526020018280546109ce906165a9565b8015610a195780601f106109f057610100808354040283529160200191610a19565b820191905f5260205f20905b8154815290600101906020018083116109fc57829003601f168201915b50505050508152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200160038201548152602001600482018054610ae6906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054610b12906165a9565b8015610b5d5780601f10610b3457610100808354040283529160200191610b5d565b820191905f5260205f20905b815481529060010190602001808311610b4057829003601f168201915b50505050508152602001600582018054610b76906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054610ba2906165a9565b8015610bed5780601f10610bc457610100808354040283529160200191610bed565b820191905f5260205f20905b815481529060010190602001808311610bd057829003601f168201915b50505050508152602001600682018054610c06906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054610c32906165a9565b8015610c7d5780601f10610c5457610100808354040283529160200191610c7d565b820191905f5260205f20905b815481529060010190602001808311610c6057829003601f168201915b50505050508152602001600782018054610c96906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054610cc2906165a9565b8015610d0d5780601f10610ce457610100808354040283529160200191610d0d565b820191905f5260205f20905b815481529060010190602001808311610cf057829003601f168201915b50505050508152505081526020019060010190610971565b50505050815250509250505090565b610d3e83336122d3565b5f610d47612c32565b9050610d55815f0185612d23565b610d9657836040517f5e51a2e1000000000000000000000000000000000000000000000000000000008152600401610d8d9190615621565b60405180910390fd5b5f60405180602001604052808681525090505f610db282612d72565b9050610dc086828787612dcd565b5f83600c015f8881526020019081526020015f20905080868690918060018154018082558091505060019003905f5260205f20015f909192909192909192909192509182610e0f929190616780565b505f846008015f8981526020019081526020015f206040518060a00160405290815f820154815260200160018201548152602001600282015f9054906101000a900460c01b77ffffffffffffffffffffffffffffffffffffffffffffffff191677ffffffffffffffffffffffffffffffffffffffffffffffff191681526020016003820154815260200160048201805480602002602001604051908101604052809291908181526020015f905b82821015611270578382905f5260205f209060080201604051806101000160405290815f82018054610eed906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054610f19906165a9565b8015610f645780601f10610f3b57610100808354040283529160200191610f64565b820191905f5260205f20905b815481529060010190602001808311610f4757829003601f168201915b50505050508152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200160038201548152602001600482018054611031906165a9565b80601f016020809104026020016040519081016040528092919081815260200182805461105d906165a9565b80156110a85780601f1061107f576101008083540402835291602001916110a8565b820191905f5260205f20905b81548152906001019060200180831161108b57829003601f168201915b505050505081526020016005820180546110c1906165a9565b80601f01602080910402602001604051908101604052809291908181526020018280546110ed906165a9565b80156111385780601f1061110f57610100808354040283529160200191611138565b820191905f5260205f20905b81548152906001019060200180831161111b57829003601f168201915b50505050508152602001600682018054611151906165a9565b80601f016020809104026020016040519081016040528092919081815260200182805461117d906165a9565b80156111c85780601f1061119f576101008083540402835291602001916111c8565b820191905f5260205f20905b8154815290600101906020018083116111ab57829003601f168201915b505050505081526020016007820180546111e1906165a9565b80601f016020809104026020016040519081016040528092919081815260200182805461120d906165a9565b80156112585780601f1061122f57610100808354040283529160200191611258565b820191905f5260205f20905b81548152906001019060200180831161123b57829003601f168201915b50505050508152505081526020019060010190610ebc565b50505050815250509050611288818380549050612f3f565b156112e7575f856006015f8a81526020019081526020015f205490506112ae8282612f56565b7f68898a98936bf23a56e8ed4b23dcc98cef926bd9ac2ce522f1f9423e3864f2f5826040516112dd91906159fd565b60405180910390a1505b5050505050505050565b6112f9612fd9565b5f611302612c32565b90505f61130d6108a8565b90505f81608001515190505f8686905090508181146113655781816040517fd595a96200000000000000000000000000000000000000000000000000000000815260040161135c92919061684d565b60405180910390fd5b5f61136e610814565b90505f81146113b457806040517f7623d3570000000000000000000000000000000000000000000000000000000081526004016113ab9190615621565b60405180910390fd5b5f6113c6855f01518d8c8c8c8c613060565b90507f3662ec316d76e6a75eb7c45001a8ad74c3eb943e8778111c0225f2a9fd5e00e685826040516113f9929190616874565b60405180910390a1611410865f01825f01516139ae565b8a156114a0578c866006015f835f015181526020019081526020015f20819055505f86600501544361144291906168d6565b905080876012015f845f015181526020019081526020015f20819055507f5dc601065a035d78305cd9ef27c91a009cd8d37297e43bb76319490895a0d05886838360405161149293929190616909565b60405180910390a1506114ab565b6114aa818e612f56565b5b50505050505050505050505050565b6114c2612fd9565b6114ca613a7b565b5f6114d36108a8565b90506114e8815f015183836080015151613abc565b7fe41802af725729adcb8c151e2937380a25c69155757e3af5d3979adab5035800826040516115179190615621565b60405180910390a15050565b61152b612fd9565b611533613b65565b565b5f8061153f612c32565b9050805f016003015491505090565b5f80611558612c32565b9050806005015491505090565b5f8061156f612c32565b905061157d815f0184613bd3565b915050919050565b61158d613bfb565b61159682613ce1565b6115a08282613cec565b5050565b5f6115ad613e0a565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b905090565b5f806115df613e91565b9050805f015f9054906101000a900460ff1691505090565b5f815f611602612c32565b90505f816008015f8481526020019081526020015f205f01540361165d57816040517f82b1fbda0000000000000000000000000000000000000000000000000000000081526004016116549190615621565b60405180910390fd5b5f611666612c32565b9050806016015f8681526020019081526020015f20549350505050919050565b6001611690613eb8565b67ffffffffffffffff16146116d1576040517f6f4f731f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60025f6116dc613edc565b9050805f0160089054906101000a900460ff168061172457508167ffffffffffffffff16815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff1610155b1561175b576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055506001815f0160086101000a81548160ff0219169083151502179055506118146040518060400160405280600b81526020017f4b6d73436f6e74657874730000000000000000000000000000000000000000008152506040518060400160405280600181526020017f3100000000000000000000000000000000000000000000000000000000000000815250613f03565b61182461181f611f42565b613f19565b61182c613f2d565b5f61183b5f888888888e613060565b90505f611846612c32565b9050611857815f01835f0151613f3f565b61186489835f015161403a565b7f016ee9c16213ed67f33222abad4dfe46eb951ead30a10a1a72db3316ffb664e08a8a8a8a8a8a60405161189d96959493929190616d19565b60405180910390a150505f815f0160086101000a81548160ff0219169083151502179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2826040516118f19190616d96565b60405180910390a15050505050505050565b61190b612fd9565b6119145f61407f565b565b60605f611921611535565b90505f61192c612c32565b9050806010015f8381526020019081526020015f208054806020026020016040519081016040528092919081815260200182805480156119be57602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311611975575b50505050509250505090565b5f6119d36140bc565b90508073ffffffffffffffffffffffffffffffffffffffff166119f461255c565b73ffffffffffffffffffffffffffffffffffffffff1614611a4c57806040517f118cdaa7000000000000000000000000000000000000000000000000000000008152600401611a439190616242565b60405180910390fd5b611a558161407f565b50565b60605f611a63611535565b90505f611a6e612c32565b9050806011015f8381526020019081526020015f20805480602002602001604051908101604052809291908181526020018280548015611b0057602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311611ab7575b50505050509250505090565b611b14611f42565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614158015611bfb575073c7d45661a345ec5ca0e8521cfef7e32fda0daa6873ffffffffffffffffffffffffffffffffffffffff16637008b5486040518163ffffffff1660e01b8152600401602060405180830381865afa158015611ba7573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611bcb9190616dc3565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614155b15611c3d57336040517f46c0d9af000000000000000000000000000000000000000000000000000000008152600401611c349190616242565b60405180910390fd5b611c456140c3565b565b5f6060805f805f60605f611c59614132565b90505f801b815f0154148015611c7457505f801b8160010154145b611cb3576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611caa90616e38565b60405180910390fd5b611cbb614159565b611cc36141f7565b46305f801b5f67ffffffffffffffff811115611ce257611ce1615d7b565b5b604051908082528060200260200182016040528015611d105781602001602082028036833780820191505090505b507f0f0000000000000000000000000000000000000000000000000000000000000095949392919097509750975097509750975097505090919293949596565b611d58613a7b565b5f611d61612c32565b90505f815f016001015490505f8114611e0a57816012015f8281526020019081526020015f2054431115611e09577e9fe8f0db45996decf7b06fc7b6ec5f887d5f04db2e0c4ad7f4e4ee5eefc5a381604051611dbd9190615621565b60405180910390a1611dd1825f0182614295565b7f3e8f02dc7af6e3a67f3af0bc99bcf11b4deb46105e9ba7f1ac6da82322e9025e81604051611e009190615621565b60405180910390a15b5b5f825f016002015490505f8114611eca57826013015f8281526020019081526020015f2054431115611ec9575f611e3f611535565b9050611e4d845f0182614362565b7f851a08c16b15959c338ac4b56466d06c9f9d5ff8d715168aa125d5ccaf53832081604051611e7c9190615621565b60405180910390a1611e90845f0183613f3f565b7f4f54a6ac981cc8dc83142b3eb4d120be7c70fc5de6477a14eae3e9ca647644bc82604051611ebf9190615621565b60405180910390a1505b5b5f611ed3610814565b90505f8114611f3c57836014015f8281526020019081526020015f2054431115611f3b57611f03845f0182614438565b7f8fb75858a565aee117342d93196a7f0b54c1c8519885eddda6a01f477359b36381604051611f329190615621565b60405180910390a15b5b50505050565b5f80611f4c61453a565b9050805f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b611f7f612fd9565b805f611f89612c32565b90505f816008015f8481526020019081526020015f205f015403611fe457816040517f82b1fbda000000000000000000000000000000000000000000000000000000008152600401611fdb9190615621565b60405180910390fd5b5f611fed612c32565b9050611ffb815f0185614561565b1561203d57836040517f77d05ea70000000000000000000000000000000000000000000000000000000081526004016120349190615621565b60405180910390fd5b612049815f01856145b0565b7fbc1114fa9a77648cd097ee6cf149c344fa278b9b983f30dd65b6fd6a9d464a07846040516120789190615621565b60405180910390a150505050565b6040518060400160405280600581526020017f352e302e3000000000000000000000000000000000000000000000000000000081525081565b5f815f6120ca612c32565b90505f816008015f8481526020019081526020015f205f01540361212557816040517f82b1fbda00000000000000000000000000000000000000000000000000000000815260040161211c9190615621565b60405180910390fd5b5f61212e612c32565b9050806015015f8681526020019081526020015f20549350505050919050565b612156612fd9565b805f612160612c32565b90505f816008015f8481526020019081526020015f205f0154036121bb57816040517f82b1fbda0000000000000000000000000000000000000000000000000000000081526004016121b29190615621565b60405180910390fd5b5f6121c4612c32565b90506121d2815f0185614561565b1561221457836040517fb25e4eb300000000000000000000000000000000000000000000000000000000815260040161220b9190615621565b60405180910390fd5b612220815f0185614295565b7f3e8f02dc7af6e3a67f3af0bc99bcf11b4deb46105e9ba7f1ac6da82322e9025e8460405161224f9190615621565b60405180910390a150505050565b612265612fd9565b61226d613a7b565b5f612276612c32565b90508181600701819055507f3ad5c22724afab8ed2b578fb9b160c7f65f5abd0aad105752b7ba4e068a3e021826040516122b09190615621565b60405180910390a15050565b5f806122c6612c32565b9050806007015491505090565b815f6122dd612c32565b90505f816008015f8481526020019081526020015f205f01540361233857816040517f82b1fbda00000000000000000000000000000000000000000000000000000000815260040161232f9190615621565b60405180910390fd5b5f612341612c32565b905080600e015f8681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff166123e15784846040517ffdf8a05d0000000000000000000000000000000000000000000000000000000081526004016123d8929190616e56565b60405180910390fd5b5050505050565b815f6123f2612c32565b90505f816008015f8481526020019081526020015f205f01540361244d57816040517f82b1fbda0000000000000000000000000000000000000000000000000000000081526004016124449190615621565b60405180910390fd5b5f612456612c32565b905080600f015f8681526020019081526020015f205f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff166124f65784846040517f89b45e5d0000000000000000000000000000000000000000000000000000000081526004016124ed929190616e56565b60405180910390fd5b5050505050565b612505612fd9565b61250d613a7b565b5f612516612c32565b90508181600501819055507f53cb968d31c28c6504a6e73d9908db6e1c1a386b66dcacec1a0117752c5ab986826040516125509190615621565b60405180910390a15050565b5f806125666146c5565b9050805f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b61259961559b565b5f6125a2611535565b90505f6125ad612c32565b90505f81600d015f8481526020019081526020015f205f8673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20604051806101000160405290815f82018054612619906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054612645906165a9565b80156126905780601f1061266757610100808354040283529160200191612690565b820191905f5260205f20905b81548152906001019060200180831161267357829003601f168201915b50505050508152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020016003820154815260200160048201805461275d906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054612789906165a9565b80156127d45780601f106127ab576101008083540402835291602001916127d4565b820191905f5260205f20905b8154815290600101906020018083116127b757829003601f168201915b505050505081526020016005820180546127ed906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054612819906165a9565b80156128645780601f1061283b57610100808354040283529160200191612864565b820191905f5260205f20905b81548152906001019060200180831161284757829003601f168201915b5050505050815260200160068201805461287d906165a9565b80601f01602080910402602001604051908101604052809291908181526020018280546128a9906165a9565b80156128f45780601f106128cb576101008083540402835291602001916128f4565b820191905f5260205f20905b8154815290600101906020018083116128d757829003601f168201915b5050505050815260200160078201805461290d906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054612939906165a9565b80156129845780601f1061295b57610100808354040283529160200191612984565b820191905f5260205f20905b81548152906001019060200180831161296757829003601f168201915b50505050508152505090505f73ffffffffffffffffffffffffffffffffffffffff16816040015173ffffffffffffffffffffffffffffffffffffffff1603612a055782856040517f0494d3c00000000000000000000000000000000000000000000000000000000081526004016129fc929190616e56565b60405180910390fd5b809350505050919050565b6060612a1a6108a8565b60800151905090565b612a2b612fd9565b612a33613a7b565b5f612a3c6108a8565b9050612a51815f0151838360800151516146ec565b7f837e0a6528dadfa2dc792692c5182e52a9f5bbdeed7b2372927a26c69583961382604051612a809190615621565b60405180910390a15050565b612a94612fd9565b5f612a9d612c32565b90505f612aa8610814565b90505f8103612ae3576040517f207ea3f300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f612aec611535565b9050612afa835f0182614438565b7f8fb75858a565aee117342d93196a7f0b54c1c8519885eddda6a01f477359b36381604051612b299190615621565b60405180910390a1612b3d835f0183613f3f565b7f4f54a6ac981cc8dc83142b3eb4d120be7c70fc5de6477a14eae3e9ca647644bc82604051612b6c9190615621565b60405180910390a1505050565b612b81612fd9565b5f612b8a6146c5565b905081815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff16612bec611f42565b73ffffffffffffffffffffffffffffffffffffffff167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a35050565b5f7f7d8159810a7ebf944e8fa93cc4fbd1cade6c71f8b0b86b37187ac7991777b100905090565b60605f6001612c6784614795565b0190505f8167ffffffffffffffff811115612c8557612c84615d7b565b5b6040519080825280601f01601f191660200182016040528015612cb75781602001600182028036833780820191505090505b5090505f82602001820190505b600115612d18578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a8581612d0d57612d0c616e7d565b5b0494505f8503612cc4575b819350505050919050565b5f60016007811115612d3857612d37615cc1565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115612d6957612d68615cc1565b5b14905092915050565b5f612dc66040518060600160405280602b8152602001617668602b913980519060200120835f0151604051602001612dab929190616eaa565b604051602081830303815290604052805190602001206148e6565b9050919050565b5f612dd6612c32565b90505f612e268585858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f81840152601f19601f820116905080830192505050505050506148ff565b9050612e3286826123e8565b81600a015f8781526020019081526020015f205f8273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff1615612ed15785816040517f99b158c1000000000000000000000000000000000000000000000000000000008152600401612ec8929190616e56565b60405180910390fd5b600182600a015f8881526020019081526020015f205f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550505050505050565b5f8083608001515190508083101591505092915050565b5f612f5f612c32565b9050612f70815f01845f0151614929565b5f8243612f7d91906168d6565b905080826013015f865f015181526020019081526020015f20819055507f4540f7808fcaec86c376a89d2c0c93a5056c21680db54332c7f2959d87fefc8b8482604051612fcb929190616ed1565b60405180910390a150505050565b612fe16140bc565b73ffffffffffffffffffffffffffffffffffffffff16612fff611f42565b73ffffffffffffffffffffffffffffffffffffffff161461305e576130226140bc565b6040517f118cdaa70000000000000000000000000000000000000000000000000000000081526004016130559190616242565b60405180910390fd5b565b613068615555565b5f613071612c32565b90505f85859050036130af576040517f068c8d4000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b806009015f8154809291906130c390616eff565b91905055505f8160090154905080826008015f8381526020019081526020015f205f018190555088826008015f8381526020019081526020015f206001018190555087826008015f8381526020019081526020015f206002015f6101000a81548167ffffffffffffffff021916908360c01c02179055506131488188888890506149ff565b5f5b868690508110156131d157826008015f8381526020019081526020015f2060040187878381811061317e5761317d616f46565b5b90506020028101906131909190616f7f565b908060018154018082558091505060019003905f5260205f2090600802015f9091909190915081816131c29190617401565b5050808060010191505061314a565b505f5b8686905081101561352a578686828181106131f2576131f1616f46565b5b90506020028101906132049190616f7f565b83600d015f8481526020019081526020015f205f89898581811061322b5761322a616f46565b5b905060200281019061323d9190616f7f565b604001602081019061324f9190616299565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f2081816132949190617401565b905050600183600e015f8481526020019081526020015f205f8989858181106132c0576132bf616f46565b5b90506020028101906132d29190616f7f565b60400160208101906132e49190616299565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550826010015f8381526020019081526020015f2087878381811061335957613358616f46565b5b905060200281019061336b9190616f7f565b604001602081019061337d9190616299565b908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600183600f015f8481526020019081526020015f205f89898581811061340357613402616f46565b5b90506020028101906134159190616f7f565b60200160208101906134279190616299565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550826011015f8381526020019081526020015f2087878381811061349c5761349b616f46565b5b90506020028101906134ae9190616f7f565b60200160208101906134c09190616299565b908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080806001019150506131d4565b50613539818588889050614a73565b816008015f8281526020019081526020015f206040518060a00160405290815f820154815260200160018201548152602001600282015f9054906101000a900460c01b77ffffffffffffffffffffffffffffffffffffffffffffffff191677ffffffffffffffffffffffffffffffffffffffffffffffff191681526020016003820154815260200160048201805480602002602001604051908101604052809291908181526020015f905b82821015613998578382905f5260205f209060080201604051806101000160405290815f82018054613615906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054613641906165a9565b801561368c5780601f106136635761010080835404028352916020019161368c565b820191905f5260205f20905b81548152906001019060200180831161366f57829003601f168201915b50505050508152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200160038201548152602001600482018054613759906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054613785906165a9565b80156137d05780601f106137a7576101008083540402835291602001916137d0565b820191905f5260205f20905b8154815290600101906020018083116137b357829003601f168201915b505050505081526020016005820180546137e9906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054613815906165a9565b80156138605780601f1061383757610100808354040283529160200191613860565b820191905f5260205f20905b81548152906001019060200180831161384357829003601f168201915b50505050508152602001600682018054613879906165a9565b80601f01602080910402602001604051908101604052809291908181526020018280546138a5906165a9565b80156138f05780601f106138c7576101008083540402835291602001916138f0565b820191905f5260205f20905b8154815290600101906020018083116138d357829003601f168201915b50505050508152602001600782018054613909906165a9565b80601f0160208091040260200160405190810160405280929190818152602001828054613935906165a9565b80156139805780601f1061395757610100808354040283529160200191613980565b820191905f5260205f20905b81548152906001019060200180831161396357829003601f168201915b505050505081525050815260200190600101906135e4565b5050505081525050925050509695505050505050565b805f81036139e8576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6139f28383614a95565b613a3357816040517f6653f6d7000000000000000000000000000000000000000000000000000000008152600401613a2a9190615621565b60405180910390fd5b6001835f015f8481526020019081526020015f205f6101000a81548160ff02191690836007811115613a6857613a67615cc1565b5b0217905550818360010181905550505050565b613a836115d5565b15613aba576040517fd93c066500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f613ac5612c32565b90505f8303613b00576040517fb1ae92ea00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81831115613b475782826040517f84208f23000000000000000000000000000000000000000000000000000000008152600401613b3e92919061684d565b60405180910390fd5b82816015015f8681526020019081526020015f208190555050505050565b613b6d614ae3565b5f613b76613e91565b90505f815f015f6101000a81548160ff0219169083151502179055507f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa613bbb6140bc565b604051613bc89190616242565b60405180910390a150565b5f825f015f8381526020019081526020015f205f9054906101000a900460ff16905092915050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff161480613ca857507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16613c8f614b23565b73ffffffffffffffffffffffffffffffffffffffff1614155b15613cdf576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b613ce9612fd9565b50565b8173ffffffffffffffffffffffffffffffffffffffff166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015613d5457506040513d601f19601f82011682018060405250810190613d519190617439565b60015b613d9557816040517f4c9c8ce3000000000000000000000000000000000000000000000000000000008152600401613d8c9190616242565b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b8114613dfb57806040517faa1d49a4000000000000000000000000000000000000000000000000000000008152600401613df29190615f11565b60405180910390fd5b613e058383614b76565b505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614613e8f576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f7fcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300905090565b5f613ec1613edc565b5f015f9054906101000a900467ffffffffffffffff16905090565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b613f0b614be8565b613f158282614c28565b5050565b613f21614be8565b613f2a81614c79565b50565b613f35614be8565b613f3d614cfd565b565b805f8103613f79576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b613f838383614d2d565b158015613f975750613f958383614d7c565b155b8015613fa757505f836003015414155b15613fe957816040517f12b49e3d000000000000000000000000000000000000000000000000000000008152600401613fe09190615621565b60405180910390fd5b6003835f015f8481526020019081526020015f205f6101000a81548160ff0219169083600781111561401e5761401d615cc1565b5b02179055508183600301819055505f8360020181905550505050565b5f614043612c32565b9050825f0135816006015f8481526020019081526020015f20819055508260200135816005018190555082604001358160070181905550505050565b5f6140886146c5565b9050805f015f6101000a81549073ffffffffffffffffffffffffffffffffffffffff02191690556140b882614dcb565b5050565b5f33905090565b6140cb613a7b565b5f6140d4613e91565b90506001815f015f6101000a81548160ff0219169083151502179055507f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a25861411a6140bc565b6040516141279190616242565b60405180910390a150565b5f7fa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100905090565b60605f614164614132565b9050806002018054614175906165a9565b80601f01602080910402602001604051908101604052809291908181526020018280546141a1906165a9565b80156141ec5780601f106141c3576101008083540402835291602001916141ec565b820191905f5260205f20905b8154815290600101906020018083116141cf57829003601f168201915b505050505091505090565b60605f614202614132565b9050806003018054614213906165a9565b80601f016020809104026020016040519081016040528092919081815260200182805461423f906165a9565b801561428a5780601f106142615761010080835404028352916020019161428a565b820191905f5260205f20905b81548152906001019060200180831161426d57829003601f168201915b505050505091505090565b805f81036142cf576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6007835f015f8481526020019081526020015f205f6101000a81548160ff0219169083600781111561430457614303615cc1565b5b02179055508183600101540361431e575f83600101819055505b81836002015403614333575f83600201819055505b81836003015403614348575f83600301819055505b8183600401540361435d575f83600401819055505b505050565b805f810361439c576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6143a68383614561565b6143e757816040517f331486b30000000000000000000000000000000000000000000000000000000081526004016143de9190615621565b60405180910390fd5b6004835f015f8481526020019081526020015f205f6101000a81548160ff0219169083600781111561441c5761441b615cc1565b5b02179055508183600401819055505f8360030181905550505050565b805f8103614472576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61447c8383614561565b158061448f575061448d8383614d7c565b155b156144d157816040517f2b3652d10000000000000000000000000000000000000000000000000000000081526004016144c89190615621565b60405180910390fd5b6005835f015f8481526020019081526020015f205f6101000a81548160ff0219169083600781111561450657614505615cc1565b5b021790555081836003015403614520575f83600301819055505b81836004015403614535575f83600401819055505b505050565b5f7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300905090565b5f6003600781111561457657614575615cc1565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff1660078111156145a7576145a6615cc1565b5b14905092915050565b805f81036145ea576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6145f48383614a95565b8061460557506146048383612d23565b5b1561464757816040517fb0c5151d00000000000000000000000000000000000000000000000000000000815260040161463e9190615621565b60405180910390fd5b6006835f015f8481526020019081526020015f205f6101000a81548160ff0219169083600781111561467c5761467b615cc1565b5b021790555081836002015403614696575f83600201819055505b818360030154036146ab575f83600301819055505b818360040154036146c0575f83600401819055505b505050565b5f7f237e158222e3e6968b72b9db0d8043aacf074ad9f650f0d1606b4d82ee432c00905090565b5f6146f5612c32565b90505f8303614730576040517fe60a727100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b818311156147775782826040517fd2535e1100000000000000000000000000000000000000000000000000000000815260040161476e92919061684d565b60405180910390fd5b82816016015f8681526020019081526020015f208190555050505050565b5f805f90507a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083106147f1577a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083816147e7576147e6616e7d565b5b0492506040810190505b6d04ee2d6d415b85acef8100000000831061482e576d04ee2d6d415b85acef8100000000838161482457614823616e7d565b5b0492506020810190505b662386f26fc10000831061485d57662386f26fc10000838161485357614852616e7d565b5b0492506010810190505b6305f5e1008310614886576305f5e100838161487c5761487b616e7d565b5b0492506008810190505b61271083106148ab5761271083816148a1576148a0616e7d565b5b0492506004810190505b606483106148ce57606483816148c4576148c3616e7d565b5b0492506002810190505b600a83106148dd576001810190505b80915050919050565b5f6148f86148f2614e9c565b83614eaa565b9050919050565b5f805f8061490d8686614eea565b92509250925061491d8282614f3f565b82935050505092915050565b805f8103614963576040517fcb17b7a500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61496d8383612d23565b6149ae57816040517fc0b5ee660000000000000000000000000000000000000000000000000000000081526004016149a59190615621565b60405180910390fd5b6002835f015f8481526020019081526020015f205f6101000a81548160ff021916908360078111156149e3576149e2615cc1565b5b02179055508183600201819055505f8360010181905550505050565b5f614a08612c32565b9050818310614a52578383836040517f8789a6ca000000000000000000000000000000000000000000000000000000008152600401614a4993929190617464565b60405180910390fd5b82816008015f8681526020019081526020015f206003018190555050505050565b614a8183835f013583613abc565b614a90838360200135836146ec565b505050565b5f806007811115614aa957614aa8615cc1565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115614ada57614ad9615cc1565b5b14905092915050565b614aeb6115d5565b614b21576040517f8dfc202b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f614b4f7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b6150a1565b5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b614b7f826150aa565b8173ffffffffffffffffffffffffffffffffffffffff167fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b60405160405180910390a25f81511115614bdb57614bd58282615173565b50614be4565b614be36151f3565b5b5050565b614bf061522f565b614c26576040517fd7e6bcf800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b614c30614be8565b5f614c39614132565b905082816002019081614c4c9190617499565b5081816003019081614c5e9190617499565b505f801b815f01819055505f801b8160010181905550505050565b614c81614be8565b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603614cf1575f6040517f1e4fbdf7000000000000000000000000000000000000000000000000000000008152600401614ce89190616242565b60405180910390fd5b614cfa8161407f565b50565b614d05614be8565b5f614d0e613e91565b90505f815f015f6101000a81548160ff02191690831515021790555050565b5f60026007811115614d4257614d41615cc1565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115614d7357614d72615cc1565b5b14905092915050565b5f60046007811115614d9157614d90615cc1565b5b835f015f8481526020019081526020015f205f9054906101000a900460ff166007811115614dc257614dc1615cc1565b5b14905092915050565b5f614dd461453a565b90505f815f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905082825f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a3505050565b5f614ea561524d565b905090565b5f6040517f190100000000000000000000000000000000000000000000000000000000000081528360028201528260228201526042812091505092915050565b5f805f6041845103614f2a575f805f602087015192506040870151915060608701515f1a9050614f1c888285856152b0565b955095509550505050614f38565b5f600285515f1b9250925092505b9250925092565b5f6003811115614f5257614f51615cc1565b5b826003811115614f6557614f64615cc1565b5b031561509d5760016003811115614f7f57614f7e615cc1565b5b826003811115614f9257614f91615cc1565b5b03614fc9576040517ff645eedf00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60026003811115614fdd57614fdc615cc1565b5b826003811115614ff057614fef615cc1565b5b0361503457805f1c6040517ffce698f700000000000000000000000000000000000000000000000000000000815260040161502b9190615621565b60405180910390fd5b60038081111561504757615046615cc1565b5b82600381111561505a57615059615cc1565b5b0361509c57806040517fd78bce0c0000000000000000000000000000000000000000000000000000000081526004016150939190615f11565b60405180910390fd5b5b5050565b5f819050919050565b5f8173ffffffffffffffffffffffffffffffffffffffff163b0361510557806040517f4c9c8ce30000000000000000000000000000000000000000000000000000000081526004016150fc9190616242565b60405180910390fd5b806151317f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b6150a1565b5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60605f808473ffffffffffffffffffffffffffffffffffffffff168460405161519c91906175a2565b5f60405180830381855af49150503d805f81146151d4576040519150601f19603f3d011682016040523d82523d5f602084013e6151d9565b606091505b50915091506151e9858383615397565b9250505092915050565b5f34111561522d576040517fb398979f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f615238613edc565b5f0160089054906101000a900460ff16905090565b5f7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f615277615424565b61527f61549a565b46306040516020016152959594939291906175b8565b60405160208183030381529060405280519060200120905090565b5f805f7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0845f1c11156152ec575f60038592509250925061538d565b5f6001888888886040515f815260200160405260405161530f9493929190617624565b6020604051602081039080840390855afa15801561532f573d5f803e3d5ffd5b5050506020604051035190505f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603615380575f60015f801b9350935093505061538d565b805f805f1b935093509350505b9450945094915050565b6060826153ac576153a782615511565b61541c565b5f82511480156153d257505f8473ffffffffffffffffffffffffffffffffffffffff163b145b1561541457836040517f9996b31500000000000000000000000000000000000000000000000000000000815260040161540b9190616242565b60405180910390fd5b81905061541d565b5b9392505050565b5f8061542e614132565b90505f615439614159565b90505f8151111561545557808051906020012092505050615497565b5f825f015490505f801b811461547057809350505050615497565b7fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a47093505050505b90565b5f806154a4614132565b90505f6154af6141f7565b90505f815111156154cb5780805190602001209250505061550e565b5f826001015490505f801b81146154e75780935050505061550e565b7fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a47093505050505b90565b5f815111156155235780518082602001fd5b6040517fd6bda27500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040518060a001604052805f81526020015f81526020015f77ffffffffffffffffffffffffffffffffffffffffffffffff191681526020015f8152602001606081525090565b604051806101000160405280606081526020015f73ffffffffffffffffffffffffffffffffffffffff1681526020015f73ffffffffffffffffffffffffffffffffffffffff1681526020015f8152602001606081526020016060815260200160608152602001606081525090565b5f819050919050565b61561b81615609565b82525050565b5f6020820190506156345f830184615612565b92915050565b5f81519050919050565b5f82825260208201905092915050565b5f5b83811015615671578082015181840152602081019050615656565b5f8484015250505050565b5f601f19601f8301169050919050565b5f6156968261563a565b6156a08185615644565b93506156b0818560208601615654565b6156b98161567c565b840191505092915050565b5f6020820190508181035f8301526156dc818461568c565b905092915050565b6156ed81615609565b82525050565b5f7fffffffffffffffff00000000000000000000000000000000000000000000000082169050919050565b615727816156f3565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f82825260208201905092915050565b5f6157708261563a565b61577a8185615756565b935061578a818560208601615654565b6157938161567c565b840191505092915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6157c78261579e565b9050919050565b6157d7816157bd565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f615801826157dd565b61580b81856157e7565b935061581b818560208601615654565b6158248161567c565b840191505092915050565b5f61010083015f8301518482035f86015261584a8282615766565b915050602083015161585f60208601826157ce565b50604083015161587260408601826157ce565b50606083015161588560608601826156e4565b506080830151848203608086015261589d82826157f7565b91505060a083015184820360a08601526158b78282615766565b91505060c083015184820360c08601526158d18282615766565b91505060e083015184820360e08601526158eb82826157f7565b9150508091505092915050565b5f615903838361582f565b905092915050565b5f602082019050919050565b5f6159218261572d565b61592b8185615737565b93508360208202850161593d85615747565b805f5b85811015615978578484038952815161595985826158f8565b94506159648361590b565b925060208a01995050600181019050615940565b50829750879550505050505092915050565b5f60a083015f83015161599f5f8601826156e4565b5060208301516159b260208601826156e4565b5060408301516159c5604086018261571e565b5060608301516159d860608601826156e4565b50608083015184820360808601526159f08282615917565b9150508091505092915050565b5f6020820190508181035f830152615a15818461598a565b905092915050565b5f604051905090565b5f80fd5b5f80fd5b615a3781615609565b8114615a41575f80fd5b50565b5f81359050615a5281615a2e565b92915050565b5f80fd5b5f80fd5b5f80fd5b5f8083601f840112615a7957615a78615a58565b5b8235905067ffffffffffffffff811115615a9657615a95615a5c565b5b602083019150836001820283011115615ab257615ab1615a60565b5b9250929050565b5f805f60408486031215615ad057615acf615a26565b5b5f615add86828701615a44565b935050602084013567ffffffffffffffff811115615afe57615afd615a2a565b5b615b0a86828701615a64565b92509250509250925092565b615b1f816156f3565b8114615b29575f80fd5b50565b5f81359050615b3a81615b16565b92915050565b5f8115159050919050565b615b5481615b40565b8114615b5e575f80fd5b50565b5f81359050615b6f81615b4b565b92915050565b5f8083601f840112615b8a57615b89615a58565b5b8235905067ffffffffffffffff811115615ba757615ba6615a5c565b5b602083019150836020820283011115615bc357615bc2615a60565b5b9250929050565b5f80fd5b5f60408284031215615be357615be2615bca565b5b81905092915050565b5f805f805f805f60e0888a031215615c0757615c06615a26565b5b5f615c148a828b01615a44565b9750506020615c258a828b01615b2c565b9650506040615c368a828b01615b61565b9550506060615c478a828b01615a44565b945050608088013567ffffffffffffffff811115615c6857615c67615a2a565b5b615c748a828b01615b75565b935093505060a0615c878a828b01615bce565b91505092959891949750929550565b5f60208284031215615cab57615caa615a26565b5b5f615cb884828501615a44565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b60088110615cff57615cfe615cc1565b5b50565b5f819050615d0f82615cee565b919050565b5f615d1e82615d02565b9050919050565b615d2e81615d14565b82525050565b5f602082019050615d475f830184615d25565b92915050565b615d56816157bd565b8114615d60575f80fd5b50565b5f81359050615d7181615d4d565b92915050565b5f80fd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b615db18261567c565b810181811067ffffffffffffffff82111715615dd057615dcf615d7b565b5b80604052505050565b5f615de2615a1d565b9050615dee8282615da8565b919050565b5f67ffffffffffffffff821115615e0d57615e0c615d7b565b5b615e168261567c565b9050602081019050919050565b828183375f83830152505050565b5f615e43615e3e84615df3565b615dd9565b905082815260208101848484011115615e5f57615e5e615d77565b5b615e6a848285615e23565b509392505050565b5f82601f830112615e8657615e85615a58565b5b8135615e96848260208601615e31565b91505092915050565b5f8060408385031215615eb557615eb4615a26565b5b5f615ec285828601615d63565b925050602083013567ffffffffffffffff811115615ee357615ee2615a2a565b5b615eef85828601615e72565b9150509250929050565b5f819050919050565b615f0b81615ef9565b82525050565b5f602082019050615f245f830184615f02565b92915050565b615f3381615b40565b82525050565b5f602082019050615f4c5f830184615f2a565b92915050565b5f60608284031215615f6757615f66615bca565b5b81905092915050565b5f805f805f806101008789031215615f8b57615f8a615a26565b5b5f615f9889828a01615bce565b9650506040615fa989828a01615f52565b95505060a0615fba89828a01615b2c565b94505060c0615fcb89828a01615a44565b93505060e087013567ffffffffffffffff811115615fec57615feb615a2a565b5b615ff889828a01615b75565b92509250509295509295509295565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f61603b83836157ce565b60208301905092915050565b5f602082019050919050565b5f61605d82616007565b6160678185616011565b935061607283616021565b805f5b838110156160a25781516160898882616030565b975061609483616047565b925050600181019050616075565b5085935050505092915050565b5f6020820190508181035f8301526160c78184616053565b905092915050565b5f7fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b616103816160cf565b82525050565b616112816157bd565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f61614c83836156e4565b60208301905092915050565b5f602082019050919050565b5f61616e82616118565b6161788185616122565b935061618383616132565b805f5b838110156161b357815161619a8882616141565b97506161a583616158565b925050600181019050616186565b5085935050505092915050565b5f60e0820190506161d35f83018a6160fa565b81810360208301526161e5818961568c565b905081810360408301526161f9818861568c565b90506162086060830187615612565b6162156080830186616109565b61622260a0830185615f02565b81810360c08301526162348184616164565b905098975050505050505050565b5f6020820190506162555f830184616109565b92915050565b5f806040838503121561627157616270615a26565b5b5f61627e85828601615a44565b925050602061628f85828601615d63565b9150509250929050565b5f602082840312156162ae576162ad615a26565b5b5f6162bb84828501615d63565b91505092915050565b5f61010083015f8301518482035f8601526162df8282615766565b91505060208301516162f460208601826157ce565b50604083015161630760408601826157ce565b50606083015161631a60608601826156e4565b506080830151848203608086015261633282826157f7565b91505060a083015184820360a086015261634c8282615766565b91505060c083015184820360c08601526163668282615766565b91505060e083015184820360e086015261638082826157f7565b9150508091505092915050565b5f6020820190508181035f8301526163a581846162c4565b905092915050565b5f82825260208201905092915050565b5f6163c78261572d565b6163d181856163ad565b9350836020820285016163e385615747565b805f5b8581101561641e57848403895281516163ff85826158f8565b945061640a8361590b565b925060208a019950506001810190506163e6565b50829750879550505050505092915050565b5f6020820190508181035f83015261644881846163bd565b905092915050565b5f81905092915050565b5f6164648261563a565b61646e8185616450565b935061647e818560208601615654565b80840191505092915050565b7f20760000000000000000000000000000000000000000000000000000000000005f82015250565b5f6164be600283616450565b91506164c98261648a565b600282019050919050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f616508600183616450565b9150616513826164d4565b600182019050919050565b5f616529828761645a565b9150616534826164b2565b9150616540828661645a565b915061654b826164fc565b9150616557828561645a565b9150616562826164fc565b915061656e828461645a565b915081905095945050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f60028204905060018216806165c057607f821691505b6020821081036165d3576165d261657c565b5b50919050565b5f82905092915050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f6008830261663f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82616604565b6166498683616604565b95508019841693508086168417925050509392505050565b5f819050919050565b5f61668461667f61667a84615609565b616661565b615609565b9050919050565b5f819050919050565b61669d8361666a565b6166b16166a98261668b565b848454616610565b825550505050565b5f90565b6166c56166b9565b6166d0818484616694565b505050565b5b818110156166f3576166e85f826166bd565b6001810190506166d6565b5050565b601f82111561673857616709816165e3565b616712846165f5565b81016020851015616721578190505b61673561672d856165f5565b8301826166d5565b50505b505050565b5f82821c905092915050565b5f6167585f198460080261673d565b1980831691505092915050565b5f6167708383616749565b9150826002028217905092915050565b61678a83836165d9565b67ffffffffffffffff8111156167a3576167a2615d7b565b5b6167ad82546165a9565b6167b88282856166f7565b5f601f8311600181146167e5575f84156167d3578287013590505b6167dd8582616765565b865550616844565b601f1984166167f3866165e3565b5f5b8281101561681a578489013582556001820191506020850194506020810190506167f5565b868310156168375784890135616833601f891682616749565b8355505b6001600288020188555050505b50505050505050565b5f6040820190506168605f830185615612565b61686d6020830184615612565b9392505050565b5f6040820190508181035f83015261688c818561598a565b905081810360208301526168a0818461598a565b90509392505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6168e082615609565b91506168eb83615609565b9250828201905080821115616903576169026168a9565b5b92915050565b5f6060820190508181035f830152616921818661598a565b90508181036020830152616935818561598a565b90506169446040830184615612565b949350505050565b5f61695a6020840184615a44565b905092915050565b604082016169725f83018361694c565b61697e5f8501826156e4565b5061698c602083018361694c565b61699960208501826156e4565b50505050565b606082016169af5f83018361694c565b6169bb5f8501826156e4565b506169c9602083018361694c565b6169d660208501826156e4565b506169e4604083018361694c565b6169f160408501826156e4565b50505050565b616a00816156f3565b82525050565b5f819050919050565b5f80fd5b5f80fd5b5f80fd5b5f8083356001602003843603038112616a3757616a36616a17565b5b83810192508235915060208301925067ffffffffffffffff821115616a5f57616a5e616a0f565b5b600182023603831315616a7557616a74616a13565b5b509250929050565b5f616a888385615756565b9350616a95838584615e23565b616a9e8361567c565b840190509392505050565b5f616ab76020840184615d63565b905092915050565b5f8083356001602003843603038112616adb57616ada616a17565b5b83810192508235915060208301925067ffffffffffffffff821115616b0357616b02616a0f565b5b600182023603831315616b1957616b18616a13565b5b509250929050565b5f616b2c83856157e7565b9350616b39838584615e23565b616b428361567c565b840190509392505050565b5f6101008301616b5f5f840184616a1b565b8583035f870152616b71838284616a7d565b92505050616b826020840184616aa9565b616b8f60208601826157ce565b50616b9d6040840184616aa9565b616baa60408601826157ce565b50616bb8606084018461694c565b616bc560608601826156e4565b50616bd36080840184616abf565b8583036080870152616be6838284616b21565b92505050616bf760a0840184616a1b565b85830360a0870152616c0a838284616a7d565b92505050616c1b60c0840184616a1b565b85830360c0870152616c2e838284616a7d565b92505050616c3f60e0840184616abf565b85830360e0870152616c52838284616b21565b925050508091505092915050565b5f616c6b8383616b4d565b905092915050565b5f8235600161010003833603038112616c8f57616c8e616a17565b5b82810191505092915050565b5f602082019050919050565b5f616cb283856163ad565b935083602084028501616cc484616a06565b805f5b87811015616d07578484038952616cde8284616c73565b616ce88582616c60565b9450616cf383616c9b565b925060208a01995050600181019050616cc7565b50829750879450505050509392505050565b5f61010082019050616d2d5f830189616962565b616d3a604083018861699f565b616d4760a08301876169f7565b616d5460c0830186615612565b81810360e0830152616d67818486616ca7565b9050979650505050505050565b5f67ffffffffffffffff82169050919050565b616d9081616d74565b82525050565b5f602082019050616da95f830184616d87565b92915050565b5f81519050616dbd81615d4d565b92915050565b5f60208284031215616dd857616dd7615a26565b5b5f616de584828501616daf565b91505092915050565b7f4549503731323a20556e696e697469616c697a656400000000000000000000005f82015250565b5f616e22601583615644565b9150616e2d82616dee565b602082019050919050565b5f6020820190508181035f830152616e4f81616e16565b9050919050565b5f604082019050616e695f830185615612565b616e766020830184616109565b9392505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f604082019050616ebd5f830185615f02565b616eca6020830184615612565b9392505050565b5f6040820190508181035f830152616ee9818561598a565b9050616ef86020830184615612565b9392505050565b5f616f0982615609565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203616f3b57616f3a6168a9565b5b600182019050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f80fd5b5f80fd5b5f80fd5b5f8235600161010003833603038112616f9b57616f9a616f73565b5b80830191505092915050565b5f8083356001602003843603038112616fc357616fc2616f73565b5b80840192508235915067ffffffffffffffff821115616fe557616fe4616f77565b5b60208301925060018202360383131561700157617000616f7b565b5b509250929050565b5f82905092915050565b5f819050815f5260205f209050919050565b601f8211156170665761703781617013565b617040846165f5565b8101602085101561704f578190505b61706361705b856165f5565b8301826166d5565b50505b505050565b6170758383617009565b67ffffffffffffffff81111561708e5761708d615d7b565b5b61709882546165a9565b6170a3828285617025565b5f601f8311600181146170d0575f84156170be578287013590505b6170c88582616765565b86555061712f565b601f1984166170de86617013565b5f5b82811015617105578489013582556001820191506020850194506020810190506170e0565b86831015617122578489013561711e601f891682616749565b8355505b6001600288020188555050505b50505050505050565b61714383838361706b565b505050565b5f813561715481615d4d565b80915050919050565b5f815f1b9050919050565b5f73ffffffffffffffffffffffffffffffffffffffff6171878461715d565b9350801983169250808416831791505092915050565b5f6171b76171b26171ad8461579e565b616661565b61579e565b9050919050565b5f6171c88261719d565b9050919050565b5f6171d9826171be565b9050919050565b5f819050919050565b6171f2826171cf565b6172056171fe826171e0565b8354617168565b8255505050565b5f813561721881615a2e565b80915050919050565b5f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff61724c8461715d565b9350801983169250808416831791505092915050565b61726b8261666a565b61727e6172778261668b565b8354617221565b8255505050565b5f80833560016020038436030381126172a1576172a0616f73565b5b80840192508235915067ffffffffffffffff8211156172c3576172c2616f77565b5b6020830192506001820236038313156172df576172de616f7b565b5b509250929050565b6172f2838383616780565b505050565b5f81015f83016173078185616fa7565b617312818386617138565b5050505060018101602083018061732881617148565b905061733481846171e9565b50505060028101604083018061734981617148565b905061735581846171e9565b50505060038101606083018061736a8161720c565b90506173768184617262565b505050600481016080830161738b8185617285565b6173968183866172e7565b505050506005810160a083016173ac8185616fa7565b6173b7818386617138565b505050506006810160c083016173cd8185616fa7565b6173d8818386617138565b505050506007810160e083016173ee8185617285565b6173f98183866172e7565b505050505050565b61740b82826172f7565b5050565b61741881615ef9565b8114617422575f80fd5b50565b5f815190506174338161740f565b92915050565b5f6020828403121561744e5761744d615a26565b5b5f61745b84828501617425565b91505092915050565b5f6060820190506174775f830186615612565b6174846020830185615612565b6174916040830184615612565b949350505050565b6174a28261563a565b67ffffffffffffffff8111156174bb576174ba615d7b565b5b6174c582546165a9565b6174d0828285617025565b5f60209050601f831160018114617501575f84156174ef578287015190505b6174f98582616765565b865550617560565b601f19841661750f86617013565b5f5b8281101561753657848901518255600182019150602085019450602081019050617511565b86831015617553578489015161754f601f891682616749565b8355505b6001600288020188555050505b505050505050565b5f81905092915050565b5f61757c826157dd565b6175868185617568565b9350617596818560208601615654565b80840191505092915050565b5f6175ad8284617572565b915081905092915050565b5f60a0820190506175cb5f830188615f02565b6175d86020830187615f02565b6175e56040830186615f02565b6175f26060830185615612565b6175ff6080830184616109565b9695505050505050565b5f60ff82169050919050565b61761e81617609565b82525050565b5f6080820190506176375f830187615f02565b6176446020830186617615565b6176516040830185615f02565b61765e6060830184615f02565b9594505050505056fe4b6579526573686172696e67566572696669636174696f6e2875696e7432353620636f6e74657874496429
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10a\x02$W_5`\xE0\x1C\x80c\x84V\xCBY\x11a\x01\"W\x80c\xD8\xE3\xAE\x01\x11a\0\xAAW\x80c\xE3\xB2\xA8t\x11a\0nW\x80c\xE3\xB2\xA8t\x14a\x07HW\x80c\xE7.\xE9\x91\x14a\x07\x84W\x80c\xEB\x84<\xF6\x14a\x07\xAEW\x80c\xF2|\xB9W\x14a\x07\xD6W\x80c\xF2\xFD\xE3\x8B\x14a\x07\xECWa\x02$V[\x80c\xD8\xE3\xAE\x01\x14a\x06|W\x80c\xDE\xFB\xA0j\x14a\x06\xA6W\x80c\xDF\xE3j\xEE\x14a\x06\xCEW\x80c\xE2K\xA4\xE5\x14a\x06\xF6W\x80c\xE3\x0C9x\x14a\x07\x1EWa\x02$V[\x80c\x9E\xE7z\xF3\x11a\0\xF1W\x80c\x9E\xE7z\xF3\x14a\x05\x9EW\x80c\xAD<\xB1\xCC\x14a\x05\xC6W\x80c\xB8q]M\x14a\x05\xF0W\x80c\xC0\xAEd\xF7\x14a\x06,W\x80c\xC1\xC8\xB7%\x14a\x06TWa\x02$V[\x80c\x84V\xCBY\x14a\x05\x18W\x80c\x84\xB0\x19n\x14a\x05.W\x80c\x8C\xB9gQ\x14a\x05^W\x80c\x8D\xA5\xCB[\x14a\x05tWa\x02$V[\x80cMiB`\x11a\x01\xB0W\x80cj\x1DQ\xEB\x11a\x01tW\x80cj\x1DQ\xEB\x14a\x04pW\x80cqP\x18\xA6\x14a\x04\x98W\x80ct \xF3\xD4\x14a\x04\xAEW\x80cy\xBAP\x97\x14a\x04\xD8W\x80c~\xAA\xC8\xF2\x14a\x04\xEEWa\x02$V[\x80cMiB`\x14a\x03\x88W\x80cO\x1E\xF2\x86\x14a\x03\xC4W\x80cR\xD1\x90-\x14a\x03\xE0W\x80c\\\x97Z\xBB\x14a\x04\nW\x80cd\xB0\x0C\xC5\x14a\x044Wa\x02$V[\x80c\x16\x9C\xAC\x14\x11a\x01\xF7W\x80c\x16\x9C\xAC\x14\x14a\x02\xCEW\x80c.-:\x82\x14a\x02\xF6W\x80c?K\xA8:\x14a\x03\x1EW\x80cC\xE3~\x8A\x14a\x034W\x80cIe\xE4U\x14a\x03^Wa\x02$V[\x80c\nP\xE3\x18\x14a\x02(W\x80c\r\x8En,\x14a\x02RW\x80c\r\xD4\x86\xC0\x14a\x02|W\x80c\x10y\xEB\xEB\x14a\x02\xA6W[_\x80\xFD[4\x80\x15a\x023W_\x80\xFD[Pa\x02<a\x08\x14V[`@Qa\x02I\x91\x90aV!V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02]W_\x80\xFD[Pa\x02fa\x08-V[`@Qa\x02s\x91\x90aV\xC4V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\x87W_\x80\xFD[Pa\x02\x90a\x08\xA8V[`@Qa\x02\x9D\x91\x90aY\xFDV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xB1W_\x80\xFD[Pa\x02\xCC`\x04\x806\x03\x81\x01\x90a\x02\xC7\x91\x90aZ\xB9V[a\r4V[\0[4\x80\x15a\x02\xD9W_\x80\xFD[Pa\x02\xF4`\x04\x806\x03\x81\x01\x90a\x02\xEF\x91\x90a[\xECV[a\x12\xF1V[\0[4\x80\x15a\x03\x01W_\x80\xFD[Pa\x03\x1C`\x04\x806\x03\x81\x01\x90a\x03\x17\x91\x90a\\\x96V[a\x14\xBAV[\0[4\x80\x15a\x03)W_\x80\xFD[Pa\x032a\x15#V[\0[4\x80\x15a\x03?W_\x80\xFD[Pa\x03Ha\x155V[`@Qa\x03U\x91\x90aV!V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03iW_\x80\xFD[Pa\x03ra\x15NV[`@Qa\x03\x7F\x91\x90aV!V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x93W_\x80\xFD[Pa\x03\xAE`\x04\x806\x03\x81\x01\x90a\x03\xA9\x91\x90a\\\x96V[a\x15eV[`@Qa\x03\xBB\x91\x90a]4V[`@Q\x80\x91\x03\x90\xF3[a\x03\xDE`\x04\x806\x03\x81\x01\x90a\x03\xD9\x91\x90a^\x9FV[a\x15\x85V[\0[4\x80\x15a\x03\xEBW_\x80\xFD[Pa\x03\xF4a\x15\xA4V[`@Qa\x04\x01\x91\x90a_\x11V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x15W_\x80\xFD[Pa\x04\x1Ea\x15\xD5V[`@Qa\x04+\x91\x90a_9V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04?W_\x80\xFD[Pa\x04Z`\x04\x806\x03\x81\x01\x90a\x04U\x91\x90a\\\x96V[a\x15\xF7V[`@Qa\x04g\x91\x90aV!V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04{W_\x80\xFD[Pa\x04\x96`\x04\x806\x03\x81\x01\x90a\x04\x91\x91\x90a_pV[a\x16\x86V[\0[4\x80\x15a\x04\xA3W_\x80\xFD[Pa\x04\xACa\x19\x03V[\0[4\x80\x15a\x04\xB9W_\x80\xFD[Pa\x04\xC2a\x19\x16V[`@Qa\x04\xCF\x91\x90a`\xAFV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xE3W_\x80\xFD[Pa\x04\xECa\x19\xCAV[\0[4\x80\x15a\x04\xF9W_\x80\xFD[Pa\x05\x02a\x1AXV[`@Qa\x05\x0F\x91\x90a`\xAFV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05#W_\x80\xFD[Pa\x05,a\x1B\x0CV[\0[4\x80\x15a\x059W_\x80\xFD[Pa\x05Ba\x1CGV[`@Qa\x05U\x97\x96\x95\x94\x93\x92\x91\x90aa\xC0V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05iW_\x80\xFD[Pa\x05ra\x1DPV[\0[4\x80\x15a\x05\x7FW_\x80\xFD[Pa\x05\x88a\x1FBV[`@Qa\x05\x95\x91\x90abBV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xA9W_\x80\xFD[Pa\x05\xC4`\x04\x806\x03\x81\x01\x90a\x05\xBF\x91\x90a\\\x96V[a\x1FwV[\0[4\x80\x15a\x05\xD1W_\x80\xFD[Pa\x05\xDAa \x86V[`@Qa\x05\xE7\x91\x90aV\xC4V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\xFBW_\x80\xFD[Pa\x06\x16`\x04\x806\x03\x81\x01\x90a\x06\x11\x91\x90a\\\x96V[a \xBFV[`@Qa\x06#\x91\x90aV!V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x067W_\x80\xFD[Pa\x06R`\x04\x806\x03\x81\x01\x90a\x06M\x91\x90a\\\x96V[a!NV[\0[4\x80\x15a\x06_W_\x80\xFD[Pa\x06z`\x04\x806\x03\x81\x01\x90a\x06u\x91\x90a\\\x96V[a\"]V[\0[4\x80\x15a\x06\x87W_\x80\xFD[Pa\x06\x90a\"\xBCV[`@Qa\x06\x9D\x91\x90aV!V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xB1W_\x80\xFD[Pa\x06\xCC`\x04\x806\x03\x81\x01\x90a\x06\xC7\x91\x90ab[V[a\"\xD3V[\0[4\x80\x15a\x06\xD9W_\x80\xFD[Pa\x06\xF4`\x04\x806\x03\x81\x01\x90a\x06\xEF\x91\x90ab[V[a#\xE8V[\0[4\x80\x15a\x07\x01W_\x80\xFD[Pa\x07\x1C`\x04\x806\x03\x81\x01\x90a\x07\x17\x91\x90a\\\x96V[a$\xFDV[\0[4\x80\x15a\x07)W_\x80\xFD[Pa\x072a%\\V[`@Qa\x07?\x91\x90abBV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07SW_\x80\xFD[Pa\x07n`\x04\x806\x03\x81\x01\x90a\x07i\x91\x90ab\x99V[a%\x91V[`@Qa\x07{\x91\x90ac\x8DV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\x8FW_\x80\xFD[Pa\x07\x98a*\x10V[`@Qa\x07\xA5\x91\x90ad0V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x07\xB9W_\x80\xFD[Pa\x07\xD4`\x04\x806\x03\x81\x01\x90a\x07\xCF\x91\x90a\\\x96V[a*#V[\0[4\x80\x15a\x07\xE1W_\x80\xFD[Pa\x07\xEAa*\x8CV[\0[4\x80\x15a\x07\xF7W_\x80\xFD[Pa\x08\x12`\x04\x806\x03\x81\x01\x90a\x08\r\x91\x90ab\x99V[a+yV[\0[_\x80a\x08\x1Ea,2V[\x90P\x80_\x01`\x04\x01T\x91PP\x90V[```@Q\x80`@\x01`@R\x80`\x0B\x81R` \x01\x7FKmsContexts\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa\x08n_a,YV[a\x08x`\x01a,YV[a\x08\x81_a,YV[`@Q` \x01a\x08\x94\x94\x93\x92\x91\x90ae\x1EV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P\x90V[a\x08\xB0aUUV[_a\x08\xB9a,2V[\x90P_a\x08\xC4a\x155V[\x90P\x81`\x08\x01_\x82\x81R` \x01\x90\x81R` \x01_ `@Q\x80`\xA0\x01`@R\x90\x81_\x82\x01T\x81R` \x01`\x01\x82\x01T\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04`\xC0\x1Bw\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01_\x90[\x82\x82\x10\x15a\r%W\x83\x82\x90_R` _ \x90`\x08\x02\x01`@Q\x80a\x01\0\x01`@R\x90\x81_\x82\x01\x80Ta\t\xA2\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\t\xCE\x90ae\xA9V[\x80\x15a\n\x19W\x80`\x1F\x10a\t\xF0Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\n\x19V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\t\xFCW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80Ta\n\xE6\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0B\x12\x90ae\xA9V[\x80\x15a\x0B]W\x80`\x1F\x10a\x0B4Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0B]V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0B@W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta\x0Bv\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0B\xA2\x90ae\xA9V[\x80\x15a\x0B\xEDW\x80`\x1F\x10a\x0B\xC4Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0B\xEDV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0B\xD0W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x06\x82\x01\x80Ta\x0C\x06\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0C2\x90ae\xA9V[\x80\x15a\x0C}W\x80`\x1F\x10a\x0CTWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0C}V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0C`W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x07\x82\x01\x80Ta\x0C\x96\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0C\xC2\x90ae\xA9V[\x80\x15a\r\rW\x80`\x1F\x10a\x0C\xE4Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\r\rV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0C\xF0W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x81R` \x01\x90`\x01\x01\x90a\tqV[PPPP\x81RPP\x92PPP\x90V[a\r>\x833a\"\xD3V[_a\rGa,2V[\x90Pa\rU\x81_\x01\x85a-#V[a\r\x96W\x83`@Q\x7F^Q\xA2\xE1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\r\x8D\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[_`@Q\x80` \x01`@R\x80\x86\x81RP\x90P_a\r\xB2\x82a-rV[\x90Pa\r\xC0\x86\x82\x87\x87a-\xCDV[_\x83`\x0C\x01_\x88\x81R` \x01\x90\x81R` \x01_ \x90P\x80\x86\x86\x90\x91\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x92\x90\x91\x92\x90\x91\x92\x90\x91\x92P\x91\x82a\x0E\x0F\x92\x91\x90ag\x80V[P_\x84`\x08\x01_\x89\x81R` \x01\x90\x81R` \x01_ `@Q\x80`\xA0\x01`@R\x90\x81_\x82\x01T\x81R` \x01`\x01\x82\x01T\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04`\xC0\x1Bw\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01_\x90[\x82\x82\x10\x15a\x12pW\x83\x82\x90_R` _ \x90`\x08\x02\x01`@Q\x80a\x01\0\x01`@R\x90\x81_\x82\x01\x80Ta\x0E\xED\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0F\x19\x90ae\xA9V[\x80\x15a\x0FdW\x80`\x1F\x10a\x0F;Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0FdV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0FGW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80Ta\x101\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x10]\x90ae\xA9V[\x80\x15a\x10\xA8W\x80`\x1F\x10a\x10\x7FWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x10\xA8V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x10\x8BW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta\x10\xC1\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x10\xED\x90ae\xA9V[\x80\x15a\x118W\x80`\x1F\x10a\x11\x0FWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x118V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x11\x1BW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x06\x82\x01\x80Ta\x11Q\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x11}\x90ae\xA9V[\x80\x15a\x11\xC8W\x80`\x1F\x10a\x11\x9FWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x11\xC8V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x11\xABW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x07\x82\x01\x80Ta\x11\xE1\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x12\r\x90ae\xA9V[\x80\x15a\x12XW\x80`\x1F\x10a\x12/Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x12XV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x12;W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x81R` \x01\x90`\x01\x01\x90a\x0E\xBCV[PPPP\x81RPP\x90Pa\x12\x88\x81\x83\x80T\x90Pa/?V[\x15a\x12\xE7W_\x85`\x06\x01_\x8A\x81R` \x01\x90\x81R` \x01_ T\x90Pa\x12\xAE\x82\x82a/VV[\x7Fh\x89\x8A\x98\x93k\xF2:V\xE8\xEDK#\xDC\xC9\x8C\xEF\x92k\xD9\xAC,\xE5\"\xF1\xF9B>8d\xF2\xF5\x82`@Qa\x12\xDD\x91\x90aY\xFDV[`@Q\x80\x91\x03\x90\xA1P[PPPPPPPPV[a\x12\xF9a/\xD9V[_a\x13\x02a,2V[\x90P_a\x13\ra\x08\xA8V[\x90P_\x81`\x80\x01QQ\x90P_\x86\x86\x90P\x90P\x81\x81\x14a\x13eW\x81\x81`@Q\x7F\xD5\x95\xA9b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\\\x92\x91\x90ahMV[`@Q\x80\x91\x03\x90\xFD[_a\x13na\x08\x14V[\x90P_\x81\x14a\x13\xB4W\x80`@Q\x7Fv#\xD3W\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\xAB\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[_a\x13\xC6\x85_\x01Q\x8D\x8C\x8C\x8C\x8Ca0`V[\x90P\x7F6b\xEC1mv\xE6\xA7^\xB7\xC4P\x01\xA8\xADt\xC3\xEB\x94>\x87x\x11\x1C\x02%\xF2\xA9\xFD^\0\xE6\x85\x82`@Qa\x13\xF9\x92\x91\x90ahtV[`@Q\x80\x91\x03\x90\xA1a\x14\x10\x86_\x01\x82_\x01Qa9\xAEV[\x8A\x15a\x14\xA0W\x8C\x86`\x06\x01_\x83_\x01Q\x81R` \x01\x90\x81R` \x01_ \x81\x90UP_\x86`\x05\x01TCa\x14B\x91\x90ah\xD6V[\x90P\x80\x87`\x12\x01_\x84_\x01Q\x81R` \x01\x90\x81R` \x01_ \x81\x90UP\x7F]\xC6\x01\x06Z\x03]x0\\\xD9\xEF'\xC9\x1A\0\x9C\xD8\xD3r\x97\xE4;\xB7c\x19I\x08\x95\xA0\xD0X\x86\x83\x83`@Qa\x14\x92\x93\x92\x91\x90ai\tV[`@Q\x80\x91\x03\x90\xA1Pa\x14\xABV[a\x14\xAA\x81\x8Ea/VV[[PPPPPPPPPPPPPV[a\x14\xC2a/\xD9V[a\x14\xCAa:{V[_a\x14\xD3a\x08\xA8V[\x90Pa\x14\xE8\x81_\x01Q\x83\x83`\x80\x01QQa:\xBCV[\x7F\xE4\x18\x02\xAFrW)\xAD\xCB\x8C\x15\x1E)78\n%\xC6\x91Uu~:\xF5\xD3\x97\x9A\xDA\xB5\x03X\0\x82`@Qa\x15\x17\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1PPV[a\x15+a/\xD9V[a\x153a;eV[V[_\x80a\x15?a,2V[\x90P\x80_\x01`\x03\x01T\x91PP\x90V[_\x80a\x15Xa,2V[\x90P\x80`\x05\x01T\x91PP\x90V[_\x80a\x15oa,2V[\x90Pa\x15}\x81_\x01\x84a;\xD3V[\x91PP\x91\x90PV[a\x15\x8Da;\xFBV[a\x15\x96\x82a<\xE1V[a\x15\xA0\x82\x82a<\xECV[PPV[_a\x15\xADa>\nV[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x90P\x90V[_\x80a\x15\xDFa>\x91V[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x91PP\x90V[_\x81_a\x16\x02a,2V[\x90P_\x81`\x08\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a\x16]W\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x16T\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[_a\x16fa,2V[\x90P\x80`\x16\x01_\x86\x81R` \x01\x90\x81R` \x01_ T\x93PPPP\x91\x90PV[`\x01a\x16\x90a>\xB8V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x16\xD1W`@Q\x7FoOs\x1F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02_a\x16\xDCa>\xDCV[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a\x17$WP\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15[\x15a\x17[W`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPa\x18\x14`@Q\x80`@\x01`@R\x80`\x0B\x81R` \x01\x7FKmsContexts\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP`@Q\x80`@\x01`@R\x80`\x01\x81R` \x01\x7F1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa?\x03V[a\x18$a\x18\x1Fa\x1FBV[a?\x19V[a\x18,a?-V[_a\x18;_\x88\x88\x88\x88\x8Ea0`V[\x90P_a\x18Fa,2V[\x90Pa\x18W\x81_\x01\x83_\x01Qa??V[a\x18d\x89\x83_\x01Qa@:V[\x7F\x01n\xE9\xC1b\x13\xEDg\xF32\"\xAB\xADM\xFEF\xEB\x95\x1E\xAD0\xA1\n\x1Ar\xDB3\x16\xFF\xB6d\xE0\x8A\x8A\x8A\x8A\x8A\x8A`@Qa\x18\x9D\x96\x95\x94\x93\x92\x91\x90am\x19V[`@Q\x80\x91\x03\x90\xA1PP_\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x82`@Qa\x18\xF1\x91\x90am\x96V[`@Q\x80\x91\x03\x90\xA1PPPPPPPPV[a\x19\x0Ba/\xD9V[a\x19\x14_a@\x7FV[V[``_a\x19!a\x155V[\x90P_a\x19,a,2V[\x90P\x80`\x10\x01_\x83\x81R` \x01\x90\x81R` \x01_ \x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x19\xBEW` \x02\x82\x01\x91\x90_R` _ \x90[\x81_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x19uW[PPPPP\x92PPP\x90V[_a\x19\xD3a@\xBCV[\x90P\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x19\xF4a%\\V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1ALW\x80`@Q\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1AC\x91\x90abBV[`@Q\x80\x91\x03\x90\xFD[a\x1AU\x81a@\x7FV[PV[``_a\x1Aca\x155V[\x90P_a\x1Ana,2V[\x90P\x80`\x11\x01_\x83\x81R` \x01\x90\x81R` \x01_ \x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x1B\0W` \x02\x82\x01\x91\x90_R` _ \x90[\x81_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x1A\xB7W[PPPPP\x92PPP\x90V[a\x1B\x14a\x1FBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15\x80\x15a\x1B\xFBWPs\xC7\xD4Va\xA3E\xEC\\\xA0\xE8R\x1C\xFE\xF7\xE3/\xDA\r\xAAhs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cp\x08\xB5H`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1B\xA7W=_\x80>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1B\xCB\x91\x90am\xC3V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15a\x1C=W3`@Q\x7FF\xC0\xD9\xAF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1C4\x91\x90abBV[`@Q\x80\x91\x03\x90\xFD[a\x1CEa@\xC3V[V[_``\x80_\x80_``_a\x1CYaA2V[\x90P_\x80\x1B\x81_\x01T\x14\x80\x15a\x1CtWP_\x80\x1B\x81`\x01\x01T\x14[a\x1C\xB3W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1C\xAA\x90an8V[`@Q\x80\x91\x03\x90\xFD[a\x1C\xBBaAYV[a\x1C\xC3aA\xF7V[F0_\x80\x1B_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1C\xE2Wa\x1C\xE1a]{V[[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x1D\x10W\x81` \x01` \x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x7F\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x95\x94\x93\x92\x91\x90\x97P\x97P\x97P\x97P\x97P\x97P\x97PP\x90\x91\x92\x93\x94\x95\x96V[a\x1DXa:{V[_a\x1Daa,2V[\x90P_\x81_\x01`\x01\x01T\x90P_\x81\x14a\x1E\nW\x81`\x12\x01_\x82\x81R` \x01\x90\x81R` \x01_ TC\x11\x15a\x1E\tW~\x9F\xE8\xF0\xDBE\x99m\xEC\xF7\xB0o\xC7\xB6\xEC_\x88}_\x04\xDB.\x0CJ\xD7\xF4\xE4\xEE^\xEF\xC5\xA3\x81`@Qa\x1D\xBD\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1a\x1D\xD1\x82_\x01\x82aB\x95V[\x7F>\x8F\x02\xDCz\xF6\xE3\xA6\x7F:\xF0\xBC\x99\xBC\xF1\x1BM\xEBF\x10^\x9B\xA7\xF1\xACm\xA8#\"\xE9\x02^\x81`@Qa\x1E\0\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1[[_\x82_\x01`\x02\x01T\x90P_\x81\x14a\x1E\xCAW\x82`\x13\x01_\x82\x81R` \x01\x90\x81R` \x01_ TC\x11\x15a\x1E\xC9W_a\x1E?a\x155V[\x90Pa\x1EM\x84_\x01\x82aCbV[\x7F\x85\x1A\x08\xC1k\x15\x95\x9C3\x8A\xC4\xB5df\xD0l\x9F\x9D_\xF8\xD7\x15\x16\x8A\xA1%\xD5\xCC\xAFS\x83 \x81`@Qa\x1E|\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1a\x1E\x90\x84_\x01\x83a??V[\x7FOT\xA6\xAC\x98\x1C\xC8\xDC\x83\x14+>\xB4\xD1 \xBE|p\xFC]\xE6Gz\x14\xEA\xE3\xE9\xCAdvD\xBC\x82`@Qa\x1E\xBF\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1P[[_a\x1E\xD3a\x08\x14V[\x90P_\x81\x14a\x1F<W\x83`\x14\x01_\x82\x81R` \x01\x90\x81R` \x01_ TC\x11\x15a\x1F;Wa\x1F\x03\x84_\x01\x82aD8V[\x7F\x8F\xB7XX\xA5e\xAE\xE1\x174-\x93\x19j\x7F\x0BT\xC1\xC8Q\x98\x85\xED\xDD\xA6\xA0\x1FGsY\xB3c\x81`@Qa\x1F2\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1[[PPPPV[_\x80a\x1FLaE:V[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x90V[a\x1F\x7Fa/\xD9V[\x80_a\x1F\x89a,2V[\x90P_\x81`\x08\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a\x1F\xE4W\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1F\xDB\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[_a\x1F\xEDa,2V[\x90Pa\x1F\xFB\x81_\x01\x85aEaV[\x15a =W\x83`@Q\x7Fw\xD0^\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a 4\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[a I\x81_\x01\x85aE\xB0V[\x7F\xBC\x11\x14\xFA\x9Awd\x8C\xD0\x97\xEEl\xF1I\xC3D\xFA'\x8B\x9B\x98?0\xDDe\xB6\xFDj\x9DFJ\x07\x84`@Qa x\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1PPPPV[`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x81V[_\x81_a \xCAa,2V[\x90P_\x81`\x08\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a!%W\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a!\x1C\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[_a!.a,2V[\x90P\x80`\x15\x01_\x86\x81R` \x01\x90\x81R` \x01_ T\x93PPPP\x91\x90PV[a!Va/\xD9V[\x80_a!`a,2V[\x90P_\x81`\x08\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a!\xBBW\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a!\xB2\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[_a!\xC4a,2V[\x90Pa!\xD2\x81_\x01\x85aEaV[\x15a\"\x14W\x83`@Q\x7F\xB2^N\xB3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\"\x0B\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[a\" \x81_\x01\x85aB\x95V[\x7F>\x8F\x02\xDCz\xF6\xE3\xA6\x7F:\xF0\xBC\x99\xBC\xF1\x1BM\xEBF\x10^\x9B\xA7\xF1\xACm\xA8#\"\xE9\x02^\x84`@Qa\"O\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1PPPPV[a\"ea/\xD9V[a\"ma:{V[_a\"va,2V[\x90P\x81\x81`\x07\x01\x81\x90UP\x7F:\xD5\xC2'$\xAF\xAB\x8E\xD2\xB5x\xFB\x9B\x16\x0C\x7Fe\xF5\xAB\xD0\xAA\xD1\x05u+{\xA4\xE0h\xA3\xE0!\x82`@Qa\"\xB0\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1PPV[_\x80a\"\xC6a,2V[\x90P\x80`\x07\x01T\x91PP\x90V[\x81_a\"\xDDa,2V[\x90P_\x81`\x08\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a#8W\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a#/\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[_a#Aa,2V[\x90P\x80`\x0E\x01_\x86\x81R` \x01\x90\x81R` \x01_ _\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a#\xE1W\x84\x84`@Q\x7F\xFD\xF8\xA0]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a#\xD8\x92\x91\x90anVV[`@Q\x80\x91\x03\x90\xFD[PPPPPV[\x81_a#\xF2a,2V[\x90P_\x81`\x08\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x01T\x03a$MW\x81`@Q\x7F\x82\xB1\xFB\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a$D\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[_a$Va,2V[\x90P\x80`\x0F\x01_\x86\x81R` \x01\x90\x81R` \x01_ _\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a$\xF6W\x84\x84`@Q\x7F\x89\xB4^]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a$\xED\x92\x91\x90anVV[`@Q\x80\x91\x03\x90\xFD[PPPPPV[a%\x05a/\xD9V[a%\ra:{V[_a%\x16a,2V[\x90P\x81\x81`\x05\x01\x81\x90UP\x7FS\xCB\x96\x8D1\xC2\x8Ce\x04\xA6\xE7=\x99\x08\xDBn\x1C\x1A8kf\xDC\xAC\xEC\x1A\x01\x17u,Z\xB9\x86\x82`@Qa%P\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1PPV[_\x80a%faF\xC5V[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x90V[a%\x99aU\x9BV[_a%\xA2a\x155V[\x90P_a%\xADa,2V[\x90P_\x81`\r\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `@Q\x80a\x01\0\x01`@R\x90\x81_\x82\x01\x80Ta&\x19\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta&E\x90ae\xA9V[\x80\x15a&\x90W\x80`\x1F\x10a&gWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a&\x90V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a&sW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80Ta']\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta'\x89\x90ae\xA9V[\x80\x15a'\xD4W\x80`\x1F\x10a'\xABWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a'\xD4V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a'\xB7W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta'\xED\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta(\x19\x90ae\xA9V[\x80\x15a(dW\x80`\x1F\x10a(;Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a(dV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a(GW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x06\x82\x01\x80Ta(}\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta(\xA9\x90ae\xA9V[\x80\x15a(\xF4W\x80`\x1F\x10a(\xCBWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a(\xF4V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a(\xD7W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x07\x82\x01\x80Ta)\r\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta)9\x90ae\xA9V[\x80\x15a)\x84W\x80`\x1F\x10a)[Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a)\x84V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a)gW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x90P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81`@\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a*\x05W\x82\x85`@Q\x7F\x04\x94\xD3\xC0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a)\xFC\x92\x91\x90anVV[`@Q\x80\x91\x03\x90\xFD[\x80\x93PPPP\x91\x90PV[``a*\x1Aa\x08\xA8V[`\x80\x01Q\x90P\x90V[a*+a/\xD9V[a*3a:{V[_a*<a\x08\xA8V[\x90Pa*Q\x81_\x01Q\x83\x83`\x80\x01QQaF\xECV[\x7F\x83~\ne(\xDA\xDF\xA2\xDCy&\x92\xC5\x18.R\xA9\xF5\xBB\xDE\xED{#r\x92z&\xC6\x95\x83\x96\x13\x82`@Qa*\x80\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1PPV[a*\x94a/\xD9V[_a*\x9Da,2V[\x90P_a*\xA8a\x08\x14V[\x90P_\x81\x03a*\xE3W`@Q\x7F ~\xA3\xF3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a*\xECa\x155V[\x90Pa*\xFA\x83_\x01\x82aD8V[\x7F\x8F\xB7XX\xA5e\xAE\xE1\x174-\x93\x19j\x7F\x0BT\xC1\xC8Q\x98\x85\xED\xDD\xA6\xA0\x1FGsY\xB3c\x81`@Qa+)\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1a+=\x83_\x01\x83a??V[\x7FOT\xA6\xAC\x98\x1C\xC8\xDC\x83\x14+>\xB4\xD1 \xBE|p\xFC]\xE6Gz\x14\xEA\xE3\xE9\xCAdvD\xBC\x82`@Qa+l\x91\x90aV!V[`@Q\x80\x91\x03\x90\xA1PPPV[a+\x81a/\xD9V[_a+\x8AaF\xC5V[\x90P\x81\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a+\xECa\x1FBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F8\xD1k\x8C\xAC\"\xD9\x9F\xC7\xC1$\xB9\xCD\r\xE2\xD3\xFA\x1F\xAE\xF4 \xBF\xE7\x91\xD8\xC3b\xD7e\xE2'\0`@Q`@Q\x80\x91\x03\x90\xA3PPV[_\x7F}\x81Y\x81\n~\xBF\x94N\x8F\xA9<\xC4\xFB\xD1\xCA\xDElq\xF8\xB0\xB8k7\x18z\xC7\x99\x17w\xB1\0\x90P\x90V[``_`\x01a,g\x84aG\x95V[\x01\x90P_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a,\x85Wa,\x84a]{V[[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a,\xB7W\x81` \x01`\x01\x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x90P_\x82` \x01\x82\x01\x90P[`\x01\x15a-\x18W\x80\x80`\x01\x90\x03\x91PP\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\n\x86\x06\x1A\x81S`\n\x85\x81a-\rWa-\x0Can}V[[\x04\x94P_\x85\x03a,\xC4W[\x81\x93PPPP\x91\x90PV[_`\x01`\x07\x81\x11\x15a-8Wa-7a\\\xC1V[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15a-iWa-ha\\\xC1V[[\x14\x90P\x92\x91PPV[_a-\xC6`@Q\x80``\x01`@R\x80`+\x81R` \x01avh`+\x919\x80Q\x90` \x01 \x83_\x01Q`@Q` \x01a-\xAB\x92\x91\x90an\xAAV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 aH\xE6V[\x90P\x91\x90PV[_a-\xD6a,2V[\x90P_a.&\x85\x85\x85\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x81\x84\x01R`\x1F\x19`\x1F\x82\x01\x16\x90P\x80\x83\x01\x92PPPPPPPaH\xFFV[\x90Pa.2\x86\x82a#\xE8V[\x81`\n\x01_\x87\x81R` \x01\x90\x81R` \x01_ _\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a.\xD1W\x85\x81`@Q\x7F\x99\xB1X\xC1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a.\xC8\x92\x91\x90anVV[`@Q\x80\x91\x03\x90\xFD[`\x01\x82`\n\x01_\x88\x81R` \x01\x90\x81R` \x01_ _\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPPPPPPPV[_\x80\x83`\x80\x01QQ\x90P\x80\x83\x10\x15\x91PP\x92\x91PPV[_a/_a,2V[\x90Pa/p\x81_\x01\x84_\x01QaI)V[_\x82Ca/}\x91\x90ah\xD6V[\x90P\x80\x82`\x13\x01_\x86_\x01Q\x81R` \x01\x90\x81R` \x01_ \x81\x90UP\x7FE@\xF7\x80\x8F\xCA\xEC\x86\xC3v\xA8\x9D,\x0C\x93\xA5\x05l!h\r\xB5C2\xC7\xF2\x95\x9D\x87\xFE\xFC\x8B\x84\x82`@Qa/\xCB\x92\x91\x90an\xD1V[`@Q\x80\x91\x03\x90\xA1PPPPV[a/\xE1a@\xBCV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a/\xFFa\x1FBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a0^Wa0\"a@\xBCV[`@Q\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a0U\x91\x90abBV[`@Q\x80\x91\x03\x90\xFD[V[a0haUUV[_a0qa,2V[\x90P_\x85\x85\x90P\x03a0\xAFW`@Q\x7F\x06\x8C\x8D@\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80`\t\x01_\x81T\x80\x92\x91\x90a0\xC3\x90an\xFFV[\x91\x90PUP_\x81`\t\x01T\x90P\x80\x82`\x08\x01_\x83\x81R` \x01\x90\x81R` \x01_ _\x01\x81\x90UP\x88\x82`\x08\x01_\x83\x81R` \x01\x90\x81R` \x01_ `\x01\x01\x81\x90UP\x87\x82`\x08\x01_\x83\x81R` \x01\x90\x81R` \x01_ `\x02\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83`\xC0\x1C\x02\x17\x90UPa1H\x81\x88\x88\x88\x90PaI\xFFV[_[\x86\x86\x90P\x81\x10\x15a1\xD1W\x82`\x08\x01_\x83\x81R` \x01\x90\x81R` \x01_ `\x04\x01\x87\x87\x83\x81\x81\x10a1~Wa1}aoFV[[\x90P` \x02\x81\x01\x90a1\x90\x91\x90ao\x7FV[\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x08\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a1\xC2\x91\x90at\x01V[PP\x80\x80`\x01\x01\x91PPa1JV[P_[\x86\x86\x90P\x81\x10\x15a5*W\x86\x86\x82\x81\x81\x10a1\xF2Wa1\xF1aoFV[[\x90P` \x02\x81\x01\x90a2\x04\x91\x90ao\x7FV[\x83`\r\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x89\x89\x85\x81\x81\x10a2+Wa2*aoFV[[\x90P` \x02\x81\x01\x90a2=\x91\x90ao\x7FV[`@\x01` \x81\x01\x90a2O\x91\x90ab\x99V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ \x81\x81a2\x94\x91\x90at\x01V[\x90PP`\x01\x83`\x0E\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x89\x89\x85\x81\x81\x10a2\xC0Wa2\xBFaoFV[[\x90P` \x02\x81\x01\x90a2\xD2\x91\x90ao\x7FV[`@\x01` \x81\x01\x90a2\xE4\x91\x90ab\x99V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x82`\x10\x01_\x83\x81R` \x01\x90\x81R` \x01_ \x87\x87\x83\x81\x81\x10a3YWa3XaoFV[[\x90P` \x02\x81\x01\x90a3k\x91\x90ao\x7FV[`@\x01` \x81\x01\x90a3}\x91\x90ab\x99V[\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x83`\x0F\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x89\x89\x85\x81\x81\x10a4\x03Wa4\x02aoFV[[\x90P` \x02\x81\x01\x90a4\x15\x91\x90ao\x7FV[` \x01` \x81\x01\x90a4'\x91\x90ab\x99V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x82`\x11\x01_\x83\x81R` \x01\x90\x81R` \x01_ \x87\x87\x83\x81\x81\x10a4\x9CWa4\x9BaoFV[[\x90P` \x02\x81\x01\x90a4\xAE\x91\x90ao\x7FV[` \x01` \x81\x01\x90a4\xC0\x91\x90ab\x99V[\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x80\x80`\x01\x01\x91PPa1\xD4V[Pa59\x81\x85\x88\x88\x90PaJsV[\x81`\x08\x01_\x82\x81R` \x01\x90\x81R` \x01_ `@Q\x80`\xA0\x01`@R\x90\x81_\x82\x01T\x81R` \x01`\x01\x82\x01T\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04`\xC0\x1Bw\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01_\x90[\x82\x82\x10\x15a9\x98W\x83\x82\x90_R` _ \x90`\x08\x02\x01`@Q\x80a\x01\0\x01`@R\x90\x81_\x82\x01\x80Ta6\x15\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta6A\x90ae\xA9V[\x80\x15a6\x8CW\x80`\x1F\x10a6cWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a6\x8CV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a6oW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01T\x81R` \x01`\x04\x82\x01\x80Ta7Y\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta7\x85\x90ae\xA9V[\x80\x15a7\xD0W\x80`\x1F\x10a7\xA7Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a7\xD0V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a7\xB3W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x05\x82\x01\x80Ta7\xE9\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta8\x15\x90ae\xA9V[\x80\x15a8`W\x80`\x1F\x10a87Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a8`V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a8CW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x06\x82\x01\x80Ta8y\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta8\xA5\x90ae\xA9V[\x80\x15a8\xF0W\x80`\x1F\x10a8\xC7Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a8\xF0V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a8\xD3W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x07\x82\x01\x80Ta9\t\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta95\x90ae\xA9V[\x80\x15a9\x80W\x80`\x1F\x10a9WWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a9\x80V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a9cW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x81R` \x01\x90`\x01\x01\x90a5\xE4V[PPPP\x81RPP\x92PPP\x96\x95PPPPPPV[\x80_\x81\x03a9\xE8W`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a9\xF2\x83\x83aJ\x95V[a:3W\x81`@Q\x7FfS\xF6\xD7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a:*\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[`\x01\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15a:hWa:ga\\\xC1V[[\x02\x17\x90UP\x81\x83`\x01\x01\x81\x90UPPPPV[a:\x83a\x15\xD5V[\x15a:\xBAW`@Q\x7F\xD9<\x06e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_a:\xC5a,2V[\x90P_\x83\x03a;\0W`@Q\x7F\xB1\xAE\x92\xEA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x83\x11\x15a;GW\x82\x82`@Q\x7F\x84 \x8F#\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a;>\x92\x91\x90ahMV[`@Q\x80\x91\x03\x90\xFD[\x82\x81`\x15\x01_\x86\x81R` \x01\x90\x81R` \x01_ \x81\x90UPPPPPV[a;maJ\xE3V[_a;va>\x91V[\x90P_\x81_\x01_a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAAa;\xBBa@\xBCV[`@Qa;\xC8\x91\x90abBV[`@Q\x80\x91\x03\x90\xA1PV[_\x82_\x01_\x83\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x90P\x92\x91PPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x80a<\xA8WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a<\x8FaK#V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15a<\xDFW`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[a<\xE9a/\xD9V[PV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cR\xD1\x90-`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15a=TWP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a=Q\x91\x90at9V[`\x01[a=\x95W\x81`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a=\x8C\x91\x90abBV[`@Q\x80\x91\x03\x90\xFD[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x81\x14a=\xFBW\x80`@Q\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a=\xF2\x91\x90a_\x11V[`@Q\x80\x91\x03\x90\xFD[a>\x05\x83\x83aKvV[PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a>\x8FW`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_\x7F\xCD^\xD1\\n\x18~w\xE9\xAE\xE8\x81\x84\xC2\x1FO!\x82\xABX'\xCB;~\x07\xFB\xED\xCDc\xF03\0\x90P\x90V[_a>\xC1a>\xDCV[_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[a?\x0BaK\xE8V[a?\x15\x82\x82aL(V[PPV[a?!aK\xE8V[a?*\x81aLyV[PV[a?5aK\xE8V[a?=aL\xFDV[V[\x80_\x81\x03a?yW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a?\x83\x83\x83aM-V[\x15\x80\x15a?\x97WPa?\x95\x83\x83aM|V[\x15[\x80\x15a?\xA7WP_\x83`\x03\x01T\x14\x15[\x15a?\xE9W\x81`@Q\x7F\x12\xB4\x9E=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a?\xE0\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[`\x03\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15a@\x1EWa@\x1Da\\\xC1V[[\x02\x17\x90UP\x81\x83`\x03\x01\x81\x90UP_\x83`\x02\x01\x81\x90UPPPPV[_a@Ca,2V[\x90P\x82_\x015\x81`\x06\x01_\x84\x81R` \x01\x90\x81R` \x01_ \x81\x90UP\x82` \x015\x81`\x05\x01\x81\x90UP\x82`@\x015\x81`\x07\x01\x81\x90UPPPPV[_a@\x88aF\xC5V[\x90P\x80_\x01_a\x01\0\n\x81T\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90Ua@\xB8\x82aM\xCBV[PPV[_3\x90P\x90V[a@\xCBa:{V[_a@\xD4a>\x91V[\x90P`\x01\x81_\x01_a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2XaA\x1Aa@\xBCV[`@QaA'\x91\x90abBV[`@Q\x80\x91\x03\x90\xA1PV[_\x7F\xA1jF\xD9Ba\xC7Q|\xC8\xFF\x89\xF6\x1C\x0C\xE95\x98\xE3\xC8I\x80\x10\x11\xDE\xE6I\xA6\xA5W\xD1\0\x90P\x90V[``_aAdaA2V[\x90P\x80`\x02\x01\x80TaAu\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80TaA\xA1\x90ae\xA9V[\x80\x15aA\xECW\x80`\x1F\x10aA\xC3Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91aA\xECV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11aA\xCFW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x91PP\x90V[``_aB\x02aA2V[\x90P\x80`\x03\x01\x80TaB\x13\x90ae\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80TaB?\x90ae\xA9V[\x80\x15aB\x8AW\x80`\x1F\x10aBaWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91aB\x8AV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11aBmW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x91PP\x90V[\x80_\x81\x03aB\xCFW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x07\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aC\x04WaC\x03a\\\xC1V[[\x02\x17\x90UP\x81\x83`\x01\x01T\x03aC\x1EW_\x83`\x01\x01\x81\x90UP[\x81\x83`\x02\x01T\x03aC3W_\x83`\x02\x01\x81\x90UP[\x81\x83`\x03\x01T\x03aCHW_\x83`\x03\x01\x81\x90UP[\x81\x83`\x04\x01T\x03aC]W_\x83`\x04\x01\x81\x90UP[PPPV[\x80_\x81\x03aC\x9CW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aC\xA6\x83\x83aEaV[aC\xE7W\x81`@Q\x7F3\x14\x86\xB3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aC\xDE\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[`\x04\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aD\x1CWaD\x1Ba\\\xC1V[[\x02\x17\x90UP\x81\x83`\x04\x01\x81\x90UP_\x83`\x03\x01\x81\x90UPPPPV[\x80_\x81\x03aDrW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aD|\x83\x83aEaV[\x15\x80aD\x8FWPaD\x8D\x83\x83aM|V[\x15[\x15aD\xD1W\x81`@Q\x7F+6R\xD1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aD\xC8\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[`\x05\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aE\x06WaE\x05a\\\xC1V[[\x02\x17\x90UP\x81\x83`\x03\x01T\x03aE W_\x83`\x03\x01\x81\x90UP[\x81\x83`\x04\x01T\x03aE5W_\x83`\x04\x01\x81\x90UP[PPPV[_\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0\x90P\x90V[_`\x03`\x07\x81\x11\x15aEvWaEua\\\xC1V[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15aE\xA7WaE\xA6a\\\xC1V[[\x14\x90P\x92\x91PPV[\x80_\x81\x03aE\xEAW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aE\xF4\x83\x83aJ\x95V[\x80aF\x05WPaF\x04\x83\x83a-#V[[\x15aFGW\x81`@Q\x7F\xB0\xC5\x15\x1D\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aF>\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[`\x06\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aF|WaF{a\\\xC1V[[\x02\x17\x90UP\x81\x83`\x02\x01T\x03aF\x96W_\x83`\x02\x01\x81\x90UP[\x81\x83`\x03\x01T\x03aF\xABW_\x83`\x03\x01\x81\x90UP[\x81\x83`\x04\x01T\x03aF\xC0W_\x83`\x04\x01\x81\x90UP[PPPV[_\x7F#~\x15\x82\"\xE3\xE6\x96\x8Br\xB9\xDB\r\x80C\xAA\xCF\x07J\xD9\xF6P\xF0\xD1`kM\x82\xEEC,\0\x90P\x90V[_aF\xF5a,2V[\x90P_\x83\x03aG0W`@Q\x7F\xE6\nrq\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x83\x11\x15aGwW\x82\x82`@Q\x7F\xD2S^\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aGn\x92\x91\x90ahMV[`@Q\x80\x91\x03\x90\xFD[\x82\x81`\x16\x01_\x86\x81R` \x01\x90\x81R` \x01_ \x81\x90UPPPPPV[_\x80_\x90Pz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x10aG\xF1Wz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x81aG\xE7WaG\xE6an}V[[\x04\x92P`@\x81\x01\x90P[m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x10aH.Wm\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x81aH$WaH#an}V[[\x04\x92P` \x81\x01\x90P[f#\x86\xF2o\xC1\0\0\x83\x10aH]Wf#\x86\xF2o\xC1\0\0\x83\x81aHSWaHRan}V[[\x04\x92P`\x10\x81\x01\x90P[c\x05\xF5\xE1\0\x83\x10aH\x86Wc\x05\xF5\xE1\0\x83\x81aH|WaH{an}V[[\x04\x92P`\x08\x81\x01\x90P[a'\x10\x83\x10aH\xABWa'\x10\x83\x81aH\xA1WaH\xA0an}V[[\x04\x92P`\x04\x81\x01\x90P[`d\x83\x10aH\xCEW`d\x83\x81aH\xC4WaH\xC3an}V[[\x04\x92P`\x02\x81\x01\x90P[`\n\x83\x10aH\xDDW`\x01\x81\x01\x90P[\x80\x91PP\x91\x90PV[_aH\xF8aH\xF2aN\x9CV[\x83aN\xAAV[\x90P\x91\x90PV[_\x80_\x80aI\r\x86\x86aN\xEAV[\x92P\x92P\x92PaI\x1D\x82\x82aO?V[\x82\x93PPPP\x92\x91PPV[\x80_\x81\x03aIcW`@Q\x7F\xCB\x17\xB7\xA5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aIm\x83\x83a-#V[aI\xAEW\x81`@Q\x7F\xC0\xB5\xEEf\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aI\xA5\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[`\x02\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\x07\x81\x11\x15aI\xE3WaI\xE2a\\\xC1V[[\x02\x17\x90UP\x81\x83`\x02\x01\x81\x90UP_\x83`\x01\x01\x81\x90UPPPPV[_aJ\x08a,2V[\x90P\x81\x83\x10aJRW\x83\x83\x83`@Q\x7F\x87\x89\xA6\xCA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aJI\x93\x92\x91\x90atdV[`@Q\x80\x91\x03\x90\xFD[\x82\x81`\x08\x01_\x86\x81R` \x01\x90\x81R` \x01_ `\x03\x01\x81\x90UPPPPPV[aJ\x81\x83\x83_\x015\x83a:\xBCV[aJ\x90\x83\x83` \x015\x83aF\xECV[PPPV[_\x80`\x07\x81\x11\x15aJ\xA9WaJ\xA8a\\\xC1V[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15aJ\xDAWaJ\xD9a\\\xC1V[[\x14\x90P\x92\x91PPV[aJ\xEBa\x15\xD5V[aK!W`@Q\x7F\x8D\xFC +\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_aKO\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1BaP\xA1V[_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[aK\x7F\x82aP\xAAV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;`@Q`@Q\x80\x91\x03\x90\xA2_\x81Q\x11\x15aK\xDBWaK\xD5\x82\x82aQsV[PaK\xE4V[aK\xE3aQ\xF3V[[PPV[aK\xF0aR/V[aL&W`@Q\x7F\xD7\xE6\xBC\xF8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[aL0aK\xE8V[_aL9aA2V[\x90P\x82\x81`\x02\x01\x90\x81aLL\x91\x90at\x99V[P\x81\x81`\x03\x01\x90\x81aL^\x91\x90at\x99V[P_\x80\x1B\x81_\x01\x81\x90UP_\x80\x1B\x81`\x01\x01\x81\x90UPPPPV[aL\x81aK\xE8V[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03aL\xF1W_`@Q\x7F\x1EO\xBD\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aL\xE8\x91\x90abBV[`@Q\x80\x91\x03\x90\xFD[aL\xFA\x81a@\x7FV[PV[aM\x05aK\xE8V[_aM\x0Ea>\x91V[\x90P_\x81_\x01_a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPPV[_`\x02`\x07\x81\x11\x15aMBWaMAa\\\xC1V[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15aMsWaMra\\\xC1V[[\x14\x90P\x92\x91PPV[_`\x04`\x07\x81\x11\x15aM\x91WaM\x90a\\\xC1V[[\x83_\x01_\x84\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16`\x07\x81\x11\x15aM\xC2WaM\xC1a\\\xC1V[[\x14\x90P\x92\x91PPV[_aM\xD4aE:V[\x90P_\x81_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x82\x82_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPPV[_aN\xA5aRMV[\x90P\x90V[_`@Q\x7F\x19\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\x83`\x02\x82\x01R\x82`\"\x82\x01R`B\x81 \x91PP\x92\x91PPV[_\x80_`A\x84Q\x03aO*W_\x80_` \x87\x01Q\x92P`@\x87\x01Q\x91P``\x87\x01Q_\x1A\x90PaO\x1C\x88\x82\x85\x85aR\xB0V[\x95P\x95P\x95PPPPaO8V[_`\x02\x85Q_\x1B\x92P\x92P\x92P[\x92P\x92P\x92V[_`\x03\x81\x11\x15aORWaOQa\\\xC1V[[\x82`\x03\x81\x11\x15aOeWaOda\\\xC1V[[\x03\x15aP\x9DW`\x01`\x03\x81\x11\x15aO\x7FWaO~a\\\xC1V[[\x82`\x03\x81\x11\x15aO\x92WaO\x91a\\\xC1V[[\x03aO\xC9W`@Q\x7F\xF6E\xEE\xDF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x02`\x03\x81\x11\x15aO\xDDWaO\xDCa\\\xC1V[[\x82`\x03\x81\x11\x15aO\xF0WaO\xEFa\\\xC1V[[\x03aP4W\x80_\x1C`@Q\x7F\xFC\xE6\x98\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aP+\x91\x90aV!V[`@Q\x80\x91\x03\x90\xFD[`\x03\x80\x81\x11\x15aPGWaPFa\\\xC1V[[\x82`\x03\x81\x11\x15aPZWaPYa\\\xC1V[[\x03aP\x9CW\x80`@Q\x7F\xD7\x8B\xCE\x0C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aP\x93\x91\x90a_\x11V[`@Q\x80\x91\x03\x90\xFD[[PPV[_\x81\x90P\x91\x90PV[_\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x03aQ\x05W\x80`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aP\xFC\x91\x90abBV[`@Q\x80\x91\x03\x90\xFD[\x80aQ1\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1BaP\xA1V[_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[``_\x80\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84`@QaQ\x9C\x91\x90au\xA2V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14aQ\xD4W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>aQ\xD9V[``\x91P[P\x91P\x91PaQ\xE9\x85\x83\x83aS\x97V[\x92PPP\x92\x91PPV[_4\x11\x15aR-W`@Q\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_aR8a>\xDCV[_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x90P\x90V[_\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0FaRwaT$V[aR\x7FaT\x9AV[F0`@Q` \x01aR\x95\x95\x94\x93\x92\x91\x90au\xB8V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x90V[_\x80_\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0\x84_\x1C\x11\x15aR\xECW_`\x03\x85\x92P\x92P\x92PaS\x8DV[_`\x01\x88\x88\x88\x88`@Q_\x81R` \x01`@R`@QaS\x0F\x94\x93\x92\x91\x90av$V[` `@Q` \x81\x03\x90\x80\x84\x03\x90\x85Z\xFA\x15\x80\x15aS/W=_\x80>=_\xFD[PPP` `@Q\x03Q\x90P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03aS\x80W_`\x01_\x80\x1B\x93P\x93P\x93PPaS\x8DV[\x80_\x80_\x1B\x93P\x93P\x93PP[\x94P\x94P\x94\x91PPV[``\x82aS\xACWaS\xA7\x82aU\x11V[aT\x1CV[_\x82Q\x14\x80\x15aS\xD2WP_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x14[\x15aT\x14W\x83`@Q\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01aT\x0B\x91\x90abBV[`@Q\x80\x91\x03\x90\xFD[\x81\x90PaT\x1DV[[\x93\x92PPPV[_\x80aT.aA2V[\x90P_aT9aAYV[\x90P_\x81Q\x11\x15aTUW\x80\x80Q\x90` \x01 \x92PPPaT\x97V[_\x82_\x01T\x90P_\x80\x1B\x81\x14aTpW\x80\x93PPPPaT\x97V[\x7F\xC5\xD2F\x01\x86\xF7#<\x92~}\xB2\xDC\xC7\x03\xC0\xE5\0\xB6S\xCA\x82';{\xFA\xD8\x04]\x85\xA4p\x93PPPP[\x90V[_\x80aT\xA4aA2V[\x90P_aT\xAFaA\xF7V[\x90P_\x81Q\x11\x15aT\xCBW\x80\x80Q\x90` \x01 \x92PPPaU\x0EV[_\x82`\x01\x01T\x90P_\x80\x1B\x81\x14aT\xE7W\x80\x93PPPPaU\x0EV[\x7F\xC5\xD2F\x01\x86\xF7#<\x92~}\xB2\xDC\xC7\x03\xC0\xE5\0\xB6S\xCA\x82';{\xFA\xD8\x04]\x85\xA4p\x93PPPP[\x90V[_\x81Q\x11\x15aU#W\x80Q\x80\x82` \x01\xFD[`@Q\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Q\x80`\xA0\x01`@R\x80_\x81R` \x01_\x81R` \x01_w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x81R` \x01_\x81R` \x01``\x81RP\x90V[`@Q\x80a\x01\0\x01`@R\x80``\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_\x81R` \x01``\x81R` \x01``\x81R` \x01``\x81R` \x01``\x81RP\x90V[_\x81\x90P\x91\x90PV[aV\x1B\x81aV\tV[\x82RPPV[_` \x82\x01\x90PaV4_\x83\x01\x84aV\x12V[\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_[\x83\x81\x10\x15aVqW\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90PaVVV[_\x84\x84\x01RPPPPV[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[_aV\x96\x82aV:V[aV\xA0\x81\x85aVDV[\x93PaV\xB0\x81\x85` \x86\x01aVTV[aV\xB9\x81aV|V[\x84\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01RaV\xDC\x81\x84aV\x8CV[\x90P\x92\x91PPV[aV\xED\x81aV\tV[\x82RPPV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[aW'\x81aV\xF3V[\x82RPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_aWp\x82aV:V[aWz\x81\x85aWVV[\x93PaW\x8A\x81\x85` \x86\x01aVTV[aW\x93\x81aV|V[\x84\x01\x91PP\x92\x91PPV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_aW\xC7\x82aW\x9EV[\x90P\x91\x90PV[aW\xD7\x81aW\xBDV[\x82RPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_aX\x01\x82aW\xDDV[aX\x0B\x81\x85aW\xE7V[\x93PaX\x1B\x81\x85` \x86\x01aVTV[aX$\x81aV|V[\x84\x01\x91PP\x92\x91PPV[_a\x01\0\x83\x01_\x83\x01Q\x84\x82\x03_\x86\x01RaXJ\x82\x82aWfV[\x91PP` \x83\x01QaX_` \x86\x01\x82aW\xCEV[P`@\x83\x01QaXr`@\x86\x01\x82aW\xCEV[P``\x83\x01QaX\x85``\x86\x01\x82aV\xE4V[P`\x80\x83\x01Q\x84\x82\x03`\x80\x86\x01RaX\x9D\x82\x82aW\xF7V[\x91PP`\xA0\x83\x01Q\x84\x82\x03`\xA0\x86\x01RaX\xB7\x82\x82aWfV[\x91PP`\xC0\x83\x01Q\x84\x82\x03`\xC0\x86\x01RaX\xD1\x82\x82aWfV[\x91PP`\xE0\x83\x01Q\x84\x82\x03`\xE0\x86\x01RaX\xEB\x82\x82aW\xF7V[\x91PP\x80\x91PP\x92\x91PPV[_aY\x03\x83\x83aX/V[\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_aY!\x82aW-V[aY+\x81\x85aW7V[\x93P\x83` \x82\x02\x85\x01aY=\x85aWGV[\x80_[\x85\x81\x10\x15aYxW\x84\x84\x03\x89R\x81QaYY\x85\x82aX\xF8V[\x94PaYd\x83aY\x0BV[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90PaY@V[P\x82\x97P\x87\x95PPPPPP\x92\x91PPV[_`\xA0\x83\x01_\x83\x01QaY\x9F_\x86\x01\x82aV\xE4V[P` \x83\x01QaY\xB2` \x86\x01\x82aV\xE4V[P`@\x83\x01QaY\xC5`@\x86\x01\x82aW\x1EV[P``\x83\x01QaY\xD8``\x86\x01\x82aV\xE4V[P`\x80\x83\x01Q\x84\x82\x03`\x80\x86\x01RaY\xF0\x82\x82aY\x17V[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01RaZ\x15\x81\x84aY\x8AV[\x90P\x92\x91PPV[_`@Q\x90P\x90V[_\x80\xFD[_\x80\xFD[aZ7\x81aV\tV[\x81\x14aZAW_\x80\xFD[PV[_\x815\x90PaZR\x81aZ.V[\x92\x91PPV[_\x80\xFD[_\x80\xFD[_\x80\xFD[_\x80\x83`\x1F\x84\x01\x12aZyWaZxaZXV[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aZ\x96WaZ\x95aZ\\V[[` \x83\x01\x91P\x83`\x01\x82\x02\x83\x01\x11\x15aZ\xB2WaZ\xB1aZ`V[[\x92P\x92\x90PV[_\x80_`@\x84\x86\x03\x12\x15aZ\xD0WaZ\xCFaZ&V[[_aZ\xDD\x86\x82\x87\x01aZDV[\x93PP` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aZ\xFEWaZ\xFDaZ*V[[a[\n\x86\x82\x87\x01aZdV[\x92P\x92PP\x92P\x92P\x92V[a[\x1F\x81aV\xF3V[\x81\x14a[)W_\x80\xFD[PV[_\x815\x90Pa[:\x81a[\x16V[\x92\x91PPV[_\x81\x15\x15\x90P\x91\x90PV[a[T\x81a[@V[\x81\x14a[^W_\x80\xFD[PV[_\x815\x90Pa[o\x81a[KV[\x92\x91PPV[_\x80\x83`\x1F\x84\x01\x12a[\x8AWa[\x89aZXV[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a[\xA7Wa[\xA6aZ\\V[[` \x83\x01\x91P\x83` \x82\x02\x83\x01\x11\x15a[\xC3Wa[\xC2aZ`V[[\x92P\x92\x90PV[_\x80\xFD[_`@\x82\x84\x03\x12\x15a[\xE3Wa[\xE2a[\xCAV[[\x81\x90P\x92\x91PPV[_\x80_\x80_\x80_`\xE0\x88\x8A\x03\x12\x15a\\\x07Wa\\\x06aZ&V[[_a\\\x14\x8A\x82\x8B\x01aZDV[\x97PP` a\\%\x8A\x82\x8B\x01a[,V[\x96PP`@a\\6\x8A\x82\x8B\x01a[aV[\x95PP``a\\G\x8A\x82\x8B\x01aZDV[\x94PP`\x80\x88\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\\hWa\\gaZ*V[[a\\t\x8A\x82\x8B\x01a[uV[\x93P\x93PP`\xA0a\\\x87\x8A\x82\x8B\x01a[\xCEV[\x91PP\x92\x95\x98\x91\x94\x97P\x92\x95PV[_` \x82\x84\x03\x12\x15a\\\xABWa\\\xAAaZ&V[[_a\\\xB8\x84\x82\x85\x01aZDV[\x91PP\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`!`\x04R`$_\xFD[`\x08\x81\x10a\\\xFFWa\\\xFEa\\\xC1V[[PV[_\x81\x90Pa]\x0F\x82a\\\xEEV[\x91\x90PV[_a]\x1E\x82a]\x02V[\x90P\x91\x90PV[a].\x81a]\x14V[\x82RPPV[_` \x82\x01\x90Pa]G_\x83\x01\x84a]%V[\x92\x91PPV[a]V\x81aW\xBDV[\x81\x14a]`W_\x80\xFD[PV[_\x815\x90Pa]q\x81a]MV[\x92\x91PPV[_\x80\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[a]\xB1\x82aV|V[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a]\xD0Wa]\xCFa]{V[[\x80`@RPPPV[_a]\xE2aZ\x1DV[\x90Pa]\xEE\x82\x82a]\xA8V[\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a^\rWa^\x0Ca]{V[[a^\x16\x82aV|V[\x90P` \x81\x01\x90P\x91\x90PV[\x82\x81\x837_\x83\x83\x01RPPPV[_a^Ca^>\x84a]\xF3V[a]\xD9V[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a^_Wa^^a]wV[[a^j\x84\x82\x85a^#V[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a^\x86Wa^\x85aZXV[[\x815a^\x96\x84\x82` \x86\x01a^1V[\x91PP\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15a^\xB5Wa^\xB4aZ&V[[_a^\xC2\x85\x82\x86\x01a]cV[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a^\xE3Wa^\xE2aZ*V[[a^\xEF\x85\x82\x86\x01a^rV[\x91PP\x92P\x92\x90PV[_\x81\x90P\x91\x90PV[a_\x0B\x81a^\xF9V[\x82RPPV[_` \x82\x01\x90Pa_$_\x83\x01\x84a_\x02V[\x92\x91PPV[a_3\x81a[@V[\x82RPPV[_` \x82\x01\x90Pa_L_\x83\x01\x84a_*V[\x92\x91PPV[_``\x82\x84\x03\x12\x15a_gWa_fa[\xCAV[[\x81\x90P\x92\x91PPV[_\x80_\x80_\x80a\x01\0\x87\x89\x03\x12\x15a_\x8BWa_\x8AaZ&V[[_a_\x98\x89\x82\x8A\x01a[\xCEV[\x96PP`@a_\xA9\x89\x82\x8A\x01a_RV[\x95PP`\xA0a_\xBA\x89\x82\x8A\x01a[,V[\x94PP`\xC0a_\xCB\x89\x82\x8A\x01aZDV[\x93PP`\xE0\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a_\xECWa_\xEBaZ*V[[a_\xF8\x89\x82\x8A\x01a[uV[\x92P\x92PP\x92\x95P\x92\x95P\x92\x95V[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_a`;\x83\x83aW\xCEV[` \x83\x01\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_a`]\x82a`\x07V[a`g\x81\x85a`\x11V[\x93Pa`r\x83a`!V[\x80_[\x83\x81\x10\x15a`\xA2W\x81Qa`\x89\x88\x82a`0V[\x97Pa`\x94\x83a`GV[\x92PP`\x01\x81\x01\x90Pa`uV[P\x85\x93PPPP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra`\xC7\x81\x84a`SV[\x90P\x92\x91PPV[_\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x90P\x91\x90PV[aa\x03\x81a`\xCFV[\x82RPPV[aa\x12\x81aW\xBDV[\x82RPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_aaL\x83\x83aV\xE4V[` \x83\x01\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_aan\x82aa\x18V[aax\x81\x85aa\"V[\x93Paa\x83\x83aa2V[\x80_[\x83\x81\x10\x15aa\xB3W\x81Qaa\x9A\x88\x82aaAV[\x97Paa\xA5\x83aaXV[\x92PP`\x01\x81\x01\x90Paa\x86V[P\x85\x93PPPP\x92\x91PPV[_`\xE0\x82\x01\x90Paa\xD3_\x83\x01\x8Aa`\xFAV[\x81\x81\x03` \x83\x01Raa\xE5\x81\x89aV\x8CV[\x90P\x81\x81\x03`@\x83\x01Raa\xF9\x81\x88aV\x8CV[\x90Pab\x08``\x83\x01\x87aV\x12V[ab\x15`\x80\x83\x01\x86aa\tV[ab\"`\xA0\x83\x01\x85a_\x02V[\x81\x81\x03`\xC0\x83\x01Rab4\x81\x84aadV[\x90P\x98\x97PPPPPPPPV[_` \x82\x01\x90PabU_\x83\x01\x84aa\tV[\x92\x91PPV[_\x80`@\x83\x85\x03\x12\x15abqWabpaZ&V[[_ab~\x85\x82\x86\x01aZDV[\x92PP` ab\x8F\x85\x82\x86\x01a]cV[\x91PP\x92P\x92\x90PV[_` \x82\x84\x03\x12\x15ab\xAEWab\xADaZ&V[[_ab\xBB\x84\x82\x85\x01a]cV[\x91PP\x92\x91PPV[_a\x01\0\x83\x01_\x83\x01Q\x84\x82\x03_\x86\x01Rab\xDF\x82\x82aWfV[\x91PP` \x83\x01Qab\xF4` \x86\x01\x82aW\xCEV[P`@\x83\x01Qac\x07`@\x86\x01\x82aW\xCEV[P``\x83\x01Qac\x1A``\x86\x01\x82aV\xE4V[P`\x80\x83\x01Q\x84\x82\x03`\x80\x86\x01Rac2\x82\x82aW\xF7V[\x91PP`\xA0\x83\x01Q\x84\x82\x03`\xA0\x86\x01RacL\x82\x82aWfV[\x91PP`\xC0\x83\x01Q\x84\x82\x03`\xC0\x86\x01Racf\x82\x82aWfV[\x91PP`\xE0\x83\x01Q\x84\x82\x03`\xE0\x86\x01Rac\x80\x82\x82aW\xF7V[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Rac\xA5\x81\x84ab\xC4V[\x90P\x92\x91PPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_ac\xC7\x82aW-V[ac\xD1\x81\x85ac\xADV[\x93P\x83` \x82\x02\x85\x01ac\xE3\x85aWGV[\x80_[\x85\x81\x10\x15ad\x1EW\x84\x84\x03\x89R\x81Qac\xFF\x85\x82aX\xF8V[\x94Pad\n\x83aY\x0BV[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90Pac\xE6V[P\x82\x97P\x87\x95PPPPPP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01RadH\x81\x84ac\xBDV[\x90P\x92\x91PPV[_\x81\x90P\x92\x91PPV[_add\x82aV:V[adn\x81\x85adPV[\x93Pad~\x81\x85` \x86\x01aVTV[\x80\x84\x01\x91PP\x92\x91PPV[\x7F v\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_ad\xBE`\x02\x83adPV[\x91Pad\xC9\x82ad\x8AV[`\x02\x82\x01\x90P\x91\x90PV[\x7F.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_ae\x08`\x01\x83adPV[\x91Pae\x13\x82ad\xD4V[`\x01\x82\x01\x90P\x91\x90PV[_ae)\x82\x87adZV[\x91Pae4\x82ad\xB2V[\x91Pae@\x82\x86adZV[\x91PaeK\x82ad\xFCV[\x91PaeW\x82\x85adZV[\x91Paeb\x82ad\xFCV[\x91Paen\x82\x84adZV[\x91P\x81\x90P\x95\x94PPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\"`\x04R`$_\xFD[_`\x02\x82\x04\x90P`\x01\x82\x16\x80ae\xC0W`\x7F\x82\x16\x91P[` \x82\x10\x81\x03ae\xD3Wae\xD2ae|V[[P\x91\x90PV[_\x82\x90P\x92\x91PPV[_\x81\x90P\x81_R` _ \x90P\x91\x90PV[_` `\x1F\x83\x01\x04\x90P\x91\x90PV[_\x82\x82\x1B\x90P\x92\x91PPV[_`\x08\x83\x02af?\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82af\x04V[afI\x86\x83af\x04V[\x95P\x80\x19\x84\x16\x93P\x80\x86\x16\x84\x17\x92PPP\x93\x92PPPV[_\x81\x90P\x91\x90PV[_af\x84af\x7Fafz\x84aV\tV[afaV[aV\tV[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[af\x9D\x83afjV[af\xB1af\xA9\x82af\x8BV[\x84\x84Taf\x10V[\x82UPPPPV[_\x90V[af\xC5af\xB9V[af\xD0\x81\x84\x84af\x94V[PPPV[[\x81\x81\x10\x15af\xF3Waf\xE8_\x82af\xBDV[`\x01\x81\x01\x90Paf\xD6V[PPV[`\x1F\x82\x11\x15ag8Wag\t\x81ae\xE3V[ag\x12\x84ae\xF5V[\x81\x01` \x85\x10\x15ag!W\x81\x90P[ag5ag-\x85ae\xF5V[\x83\x01\x82af\xD5V[PP[PPPV[_\x82\x82\x1C\x90P\x92\x91PPV[_agX_\x19\x84`\x08\x02ag=V[\x19\x80\x83\x16\x91PP\x92\x91PPV[_agp\x83\x83agIV[\x91P\x82`\x02\x02\x82\x17\x90P\x92\x91PPV[ag\x8A\x83\x83ae\xD9V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ag\xA3Wag\xA2a]{V[[ag\xAD\x82Tae\xA9V[ag\xB8\x82\x82\x85af\xF7V[_`\x1F\x83\x11`\x01\x81\x14ag\xE5W_\x84\x15ag\xD3W\x82\x87\x015\x90P[ag\xDD\x85\x82ageV[\x86UPahDV[`\x1F\x19\x84\x16ag\xF3\x86ae\xE3V[_[\x82\x81\x10\x15ah\x1AW\x84\x89\x015\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Pag\xF5V[\x86\x83\x10\x15ah7W\x84\x89\x015ah3`\x1F\x89\x16\x82agIV[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPPV[_`@\x82\x01\x90Pah`_\x83\x01\x85aV\x12V[ahm` \x83\x01\x84aV\x12V[\x93\x92PPPV[_`@\x82\x01\x90P\x81\x81\x03_\x83\x01Rah\x8C\x81\x85aY\x8AV[\x90P\x81\x81\x03` \x83\x01Rah\xA0\x81\x84aY\x8AV[\x90P\x93\x92PPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_ah\xE0\x82aV\tV[\x91Pah\xEB\x83aV\tV[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15ai\x03Wai\x02ah\xA9V[[\x92\x91PPV[_``\x82\x01\x90P\x81\x81\x03_\x83\x01Rai!\x81\x86aY\x8AV[\x90P\x81\x81\x03` \x83\x01Rai5\x81\x85aY\x8AV[\x90PaiD`@\x83\x01\x84aV\x12V[\x94\x93PPPPV[_aiZ` \x84\x01\x84aZDV[\x90P\x92\x91PPV[`@\x82\x01air_\x83\x01\x83aiLV[ai~_\x85\x01\x82aV\xE4V[Pai\x8C` \x83\x01\x83aiLV[ai\x99` \x85\x01\x82aV\xE4V[PPPPV[``\x82\x01ai\xAF_\x83\x01\x83aiLV[ai\xBB_\x85\x01\x82aV\xE4V[Pai\xC9` \x83\x01\x83aiLV[ai\xD6` \x85\x01\x82aV\xE4V[Pai\xE4`@\x83\x01\x83aiLV[ai\xF1`@\x85\x01\x82aV\xE4V[PPPPV[aj\0\x81aV\xF3V[\x82RPPV[_\x81\x90P\x91\x90PV[_\x80\xFD[_\x80\xFD[_\x80\xFD[_\x80\x835`\x01` \x03\x846\x03\x03\x81\x12aj7Waj6aj\x17V[[\x83\x81\x01\x92P\x825\x91P` \x83\x01\x92Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15aj_Waj^aj\x0FV[[`\x01\x82\x026\x03\x83\x13\x15ajuWajtaj\x13V[[P\x92P\x92\x90PV[_aj\x88\x83\x85aWVV[\x93Paj\x95\x83\x85\x84a^#V[aj\x9E\x83aV|V[\x84\x01\x90P\x93\x92PPPV[_aj\xB7` \x84\x01\x84a]cV[\x90P\x92\x91PPV[_\x80\x835`\x01` \x03\x846\x03\x03\x81\x12aj\xDBWaj\xDAaj\x17V[[\x83\x81\x01\x92P\x825\x91P` \x83\x01\x92Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15ak\x03Wak\x02aj\x0FV[[`\x01\x82\x026\x03\x83\x13\x15ak\x19Wak\x18aj\x13V[[P\x92P\x92\x90PV[_ak,\x83\x85aW\xE7V[\x93Pak9\x83\x85\x84a^#V[akB\x83aV|V[\x84\x01\x90P\x93\x92PPPV[_a\x01\0\x83\x01ak__\x84\x01\x84aj\x1BV[\x85\x83\x03_\x87\x01Rakq\x83\x82\x84aj}V[\x92PPPak\x82` \x84\x01\x84aj\xA9V[ak\x8F` \x86\x01\x82aW\xCEV[Pak\x9D`@\x84\x01\x84aj\xA9V[ak\xAA`@\x86\x01\x82aW\xCEV[Pak\xB8``\x84\x01\x84aiLV[ak\xC5``\x86\x01\x82aV\xE4V[Pak\xD3`\x80\x84\x01\x84aj\xBFV[\x85\x83\x03`\x80\x87\x01Rak\xE6\x83\x82\x84ak!V[\x92PPPak\xF7`\xA0\x84\x01\x84aj\x1BV[\x85\x83\x03`\xA0\x87\x01Ral\n\x83\x82\x84aj}V[\x92PPPal\x1B`\xC0\x84\x01\x84aj\x1BV[\x85\x83\x03`\xC0\x87\x01Ral.\x83\x82\x84aj}V[\x92PPPal?`\xE0\x84\x01\x84aj\xBFV[\x85\x83\x03`\xE0\x87\x01RalR\x83\x82\x84ak!V[\x92PPP\x80\x91PP\x92\x91PPV[_alk\x83\x83akMV[\x90P\x92\x91PPV[_\x825`\x01a\x01\0\x03\x836\x03\x03\x81\x12al\x8FWal\x8Eaj\x17V[[\x82\x81\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_al\xB2\x83\x85ac\xADV[\x93P\x83` \x84\x02\x85\x01al\xC4\x84aj\x06V[\x80_[\x87\x81\x10\x15am\x07W\x84\x84\x03\x89Ral\xDE\x82\x84alsV[al\xE8\x85\x82al`V[\x94Pal\xF3\x83al\x9BV[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90Pal\xC7V[P\x82\x97P\x87\x94PPPPP\x93\x92PPPV[_a\x01\0\x82\x01\x90Pam-_\x83\x01\x89aibV[am:`@\x83\x01\x88ai\x9FV[amG`\xA0\x83\x01\x87ai\xF7V[amT`\xC0\x83\x01\x86aV\x12V[\x81\x81\x03`\xE0\x83\x01Ramg\x81\x84\x86al\xA7V[\x90P\x97\x96PPPPPPPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[am\x90\x81amtV[\x82RPPV[_` \x82\x01\x90Pam\xA9_\x83\x01\x84am\x87V[\x92\x91PPV[_\x81Q\x90Pam\xBD\x81a]MV[\x92\x91PPV[_` \x82\x84\x03\x12\x15am\xD8Wam\xD7aZ&V[[_am\xE5\x84\x82\x85\x01am\xAFV[\x91PP\x92\x91PPV[\x7FEIP712: Uninitialized\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_an\"`\x15\x83aVDV[\x91Pan-\x82am\xEEV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01RanO\x81an\x16V[\x90P\x91\x90PV[_`@\x82\x01\x90Pani_\x83\x01\x85aV\x12V[anv` \x83\x01\x84aa\tV[\x93\x92PPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_`@\x82\x01\x90Pan\xBD_\x83\x01\x85a_\x02V[an\xCA` \x83\x01\x84aV\x12V[\x93\x92PPPV[_`@\x82\x01\x90P\x81\x81\x03_\x83\x01Ran\xE9\x81\x85aY\x8AV[\x90Pan\xF8` \x83\x01\x84aV\x12V[\x93\x92PPPV[_ao\t\x82aV\tV[\x91P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03ao;Wao:ah\xA9V[[`\x01\x82\x01\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[_\x80\xFD[_\x80\xFD[_\x80\xFD[_\x825`\x01a\x01\0\x03\x836\x03\x03\x81\x12ao\x9BWao\x9AaosV[[\x80\x83\x01\x91PP\x92\x91PPV[_\x80\x835`\x01` \x03\x846\x03\x03\x81\x12ao\xC3Wao\xC2aosV[[\x80\x84\x01\x92P\x825\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15ao\xE5Wao\xE4aowV[[` \x83\x01\x92P`\x01\x82\x026\x03\x83\x13\x15ap\x01Wap\0ao{V[[P\x92P\x92\x90PV[_\x82\x90P\x92\x91PPV[_\x81\x90P\x81_R` _ \x90P\x91\x90PV[`\x1F\x82\x11\x15apfWap7\x81ap\x13V[ap@\x84ae\xF5V[\x81\x01` \x85\x10\x15apOW\x81\x90P[apcap[\x85ae\xF5V[\x83\x01\x82af\xD5V[PP[PPPV[apu\x83\x83ap\tV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15ap\x8EWap\x8Da]{V[[ap\x98\x82Tae\xA9V[ap\xA3\x82\x82\x85ap%V[_`\x1F\x83\x11`\x01\x81\x14ap\xD0W_\x84\x15ap\xBEW\x82\x87\x015\x90P[ap\xC8\x85\x82ageV[\x86UPaq/V[`\x1F\x19\x84\x16ap\xDE\x86ap\x13V[_[\x82\x81\x10\x15aq\x05W\x84\x89\x015\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Pap\xE0V[\x86\x83\x10\x15aq\"W\x84\x89\x015aq\x1E`\x1F\x89\x16\x82agIV[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPPV[aqC\x83\x83\x83apkV[PPPV[_\x815aqT\x81a]MV[\x80\x91PP\x91\x90PV[_\x81_\x1B\x90P\x91\x90PV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFaq\x87\x84aq]V[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[_aq\xB7aq\xB2aq\xAD\x84aW\x9EV[afaV[aW\x9EV[\x90P\x91\x90PV[_aq\xC8\x82aq\x9DV[\x90P\x91\x90PV[_aq\xD9\x82aq\xBEV[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[aq\xF2\x82aq\xCFV[ar\x05aq\xFE\x82aq\xE0V[\x83TaqhV[\x82UPPPV[_\x815ar\x18\x81aZ.V[\x80\x91PP\x91\x90PV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFarL\x84aq]V[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[ark\x82afjV[ar~arw\x82af\x8BV[\x83Tar!V[\x82UPPPV[_\x80\x835`\x01` \x03\x846\x03\x03\x81\x12ar\xA1War\xA0aosV[[\x80\x84\x01\x92P\x825\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15ar\xC3War\xC2aowV[[` \x83\x01\x92P`\x01\x82\x026\x03\x83\x13\x15ar\xDFWar\xDEao{V[[P\x92P\x92\x90PV[ar\xF2\x83\x83\x83ag\x80V[PPPV[_\x81\x01_\x83\x01as\x07\x81\x85ao\xA7V[as\x12\x81\x83\x86aq8V[PPPP`\x01\x81\x01` \x83\x01\x80as(\x81aqHV[\x90Pas4\x81\x84aq\xE9V[PPP`\x02\x81\x01`@\x83\x01\x80asI\x81aqHV[\x90PasU\x81\x84aq\xE9V[PPP`\x03\x81\x01``\x83\x01\x80asj\x81ar\x0CV[\x90Pasv\x81\x84arbV[PPP`\x04\x81\x01`\x80\x83\x01as\x8B\x81\x85ar\x85V[as\x96\x81\x83\x86ar\xE7V[PPPP`\x05\x81\x01`\xA0\x83\x01as\xAC\x81\x85ao\xA7V[as\xB7\x81\x83\x86aq8V[PPPP`\x06\x81\x01`\xC0\x83\x01as\xCD\x81\x85ao\xA7V[as\xD8\x81\x83\x86aq8V[PPPP`\x07\x81\x01`\xE0\x83\x01as\xEE\x81\x85ar\x85V[as\xF9\x81\x83\x86ar\xE7V[PPPPPPV[at\x0B\x82\x82ar\xF7V[PPV[at\x18\x81a^\xF9V[\x81\x14at\"W_\x80\xFD[PV[_\x81Q\x90Pat3\x81at\x0FV[\x92\x91PPV[_` \x82\x84\x03\x12\x15atNWatMaZ&V[[_at[\x84\x82\x85\x01at%V[\x91PP\x92\x91PPV[_``\x82\x01\x90Patw_\x83\x01\x86aV\x12V[at\x84` \x83\x01\x85aV\x12V[at\x91`@\x83\x01\x84aV\x12V[\x94\x93PPPPV[at\xA2\x82aV:V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15at\xBBWat\xBAa]{V[[at\xC5\x82Tae\xA9V[at\xD0\x82\x82\x85ap%V[_` \x90P`\x1F\x83\x11`\x01\x81\x14au\x01W_\x84\x15at\xEFW\x82\x87\x01Q\x90P[at\xF9\x85\x82ageV[\x86UPau`V[`\x1F\x19\x84\x16au\x0F\x86ap\x13V[_[\x82\x81\x10\x15au6W\x84\x89\x01Q\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Pau\x11V[\x86\x83\x10\x15auSW\x84\x89\x01QauO`\x1F\x89\x16\x82agIV[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPV[_\x81\x90P\x92\x91PPV[_au|\x82aW\xDDV[au\x86\x81\x85auhV[\x93Pau\x96\x81\x85` \x86\x01aVTV[\x80\x84\x01\x91PP\x92\x91PPV[_au\xAD\x82\x84aurV[\x91P\x81\x90P\x92\x91PPV[_`\xA0\x82\x01\x90Pau\xCB_\x83\x01\x88a_\x02V[au\xD8` \x83\x01\x87a_\x02V[au\xE5`@\x83\x01\x86a_\x02V[au\xF2``\x83\x01\x85aV\x12V[au\xFF`\x80\x83\x01\x84aa\tV[\x96\x95PPPPPPV[_`\xFF\x82\x16\x90P\x91\x90PV[av\x1E\x81av\tV[\x82RPPV[_`\x80\x82\x01\x90Pav7_\x83\x01\x87a_\x02V[avD` \x83\x01\x86av\x15V[avQ`@\x83\x01\x85a_\x02V[av^``\x83\x01\x84a_\x02V[\x95\x94PPPPPV\xFEKeyResharingVerification(uint256 contextId)",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ContextStatus(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<ContextStatus> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl ContextStatus {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ContextStatus {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ContextStatus {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct DecryptionThresholds { uint256 publicDecryptionThreshold; uint256 userDecryptionThreshold; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DecryptionThresholds {
        #[allow(missing_docs)]
        pub publicDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub userDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DecryptionThresholds> for UnderlyingRustTuple<'_> {
            fn from(value: DecryptionThresholds) -> Self {
                (value.publicDecryptionThreshold, value.userDecryptionThreshold)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for DecryptionThresholds {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    publicDecryptionThreshold: tuple.0,
                    userDecryptionThreshold: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for DecryptionThresholds {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for DecryptionThresholds {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.publicDecryptionThreshold,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.userDecryptionThreshold,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for DecryptionThresholds {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for DecryptionThresholds {
            const NAME: &'static str = "DecryptionThresholds";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "DecryptionThresholds(uint256 publicDecryptionThreshold,uint256 userDecryptionThreshold)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.publicDecryptionThreshold,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.userDecryptionThreshold,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for DecryptionThresholds {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.publicDecryptionThreshold,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.userDecryptionThreshold,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.publicDecryptionThreshold,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.userDecryptionThreshold,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct KmsBlockPeriods { uint256 preActivationBlockPeriod; uint256 generationBlockPeriod; uint256 suspensionBlockPeriod; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KmsBlockPeriods {
        #[allow(missing_docs)]
        pub preActivationBlockPeriod: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub generationBlockPeriod: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub suspensionBlockPeriod: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KmsBlockPeriods> for UnderlyingRustTuple<'_> {
            fn from(value: KmsBlockPeriods) -> Self {
                (
                    value.preActivationBlockPeriod,
                    value.generationBlockPeriod,
                    value.suspensionBlockPeriod,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for KmsBlockPeriods {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    preActivationBlockPeriod: tuple.0,
                    generationBlockPeriod: tuple.1,
                    suspensionBlockPeriod: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for KmsBlockPeriods {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for KmsBlockPeriods {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.preActivationBlockPeriod,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.generationBlockPeriod,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.suspensionBlockPeriod),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for KmsBlockPeriods {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for KmsBlockPeriods {
            const NAME: &'static str = "KmsBlockPeriods";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "KmsBlockPeriods(uint256 preActivationBlockPeriod,uint256 generationBlockPeriod,uint256 suspensionBlockPeriod)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.preActivationBlockPeriod,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.generationBlockPeriod,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.suspensionBlockPeriod,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for KmsBlockPeriods {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.preActivationBlockPeriod,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.generationBlockPeriod,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.suspensionBlockPeriod,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.preActivationBlockPeriod,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.generationBlockPeriod,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.suspensionBlockPeriod,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct KmsContext { uint256 contextId; uint256 previousContextId; bytes8 softwareVersion; uint256 mpcThreshold; KmsNode[] kmsNodes; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KmsContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub previousContextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub softwareVersion: alloy::sol_types::private::FixedBytes<8>,
        #[allow(missing_docs)]
        pub mpcThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub kmsNodes: alloy::sol_types::private::Vec<
            <KmsNode as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<8>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<KmsNode>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<8>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <KmsNode as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KmsContext> for UnderlyingRustTuple<'_> {
            fn from(value: KmsContext) -> Self {
                (
                    value.contextId,
                    value.previousContextId,
                    value.softwareVersion,
                    value.mpcThreshold,
                    value.kmsNodes,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for KmsContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    contextId: tuple.0,
                    previousContextId: tuple.1,
                    softwareVersion: tuple.2,
                    mpcThreshold: tuple.3,
                    kmsNodes: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for KmsContext {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for KmsContext {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.previousContextId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.softwareVersion),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.mpcThreshold),
                    <alloy::sol_types::sol_data::Array<
                        KmsNode,
                    > as alloy_sol_types::SolType>::tokenize(&self.kmsNodes),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for KmsContext {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for KmsContext {
            const NAME: &'static str = "KmsContext";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "KmsContext(uint256 contextId,uint256 previousContextId,bytes8 softwareVersion,uint256 mpcThreshold,KmsNode[] kmsNodes)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(<KmsNode as alloy_sol_types::SolStruct>::eip712_root_type());
                components
                    .extend(
                        <KmsNode as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.contextId)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.previousContextId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        8,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.softwareVersion,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.mpcThreshold)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        KmsNode,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.kmsNodes)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for KmsContext {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.contextId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.previousContextId,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        8,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.softwareVersion,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.mpcThreshold,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        KmsNode,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.kmsNodes,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.contextId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.previousContextId,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.softwareVersion,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.mpcThreshold,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    KmsNode,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.kmsNodes,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct KmsNode { string name; address signerAddress; address txSenderAddress; uint256 partyId; bytes backupEncryptionKey; string externalUrl; string publicStorageUrl; bytes tlsCertificate; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KmsNode {
        #[allow(missing_docs)]
        pub name: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub signerAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub txSenderAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub partyId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub backupEncryptionKey: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub externalUrl: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub publicStorageUrl: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub tlsCertificate: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Bytes,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::String,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::String,
            alloy::sol_types::private::String,
            alloy::sol_types::private::Bytes,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KmsNode> for UnderlyingRustTuple<'_> {
            fn from(value: KmsNode) -> Self {
                (
                    value.name,
                    value.signerAddress,
                    value.txSenderAddress,
                    value.partyId,
                    value.backupEncryptionKey,
                    value.externalUrl,
                    value.publicStorageUrl,
                    value.tlsCertificate,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for KmsNode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    name: tuple.0,
                    signerAddress: tuple.1,
                    txSenderAddress: tuple.2,
                    partyId: tuple.3,
                    backupEncryptionKey: tuple.4,
                    externalUrl: tuple.5,
                    publicStorageUrl: tuple.6,
                    tlsCertificate: tuple.7,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for KmsNode {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for KmsNode {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signerAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.txSenderAddress,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.partyId),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.backupEncryptionKey,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.externalUrl,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.publicStorageUrl,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.tlsCertificate,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for KmsNode {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for KmsNode {
            const NAME: &'static str = "KmsNode";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "KmsNode(string name,address signerAddress,address txSenderAddress,uint256 partyId,bytes backupEncryptionKey,string externalUrl,string publicStorageUrl,bytes tlsCertificate)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.name,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.signerAddress,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.txSenderAddress,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.partyId)
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.backupEncryptionKey,
                        )
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.externalUrl,
                        )
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.publicStorageUrl,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.tlsCertificate,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for KmsNode {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.name,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.signerAddress,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.txSenderAddress,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.partyId,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.backupEncryptionKey,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.externalUrl,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.publicStorageUrl,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.tlsCertificate,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.name,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.signerAddress,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.txSenderAddress,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.partyId,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.backupEncryptionKey,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.externalUrl,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.publicStorageUrl,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.tlsCertificate,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AddressEmptyCode(address)` and selector `0x9996b315`.
```solidity
error AddressEmptyCode(address target);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AddressEmptyCode {
        #[allow(missing_docs)]
        pub target: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AddressEmptyCode> for UnderlyingRustTuple<'_> {
            fn from(value: AddressEmptyCode) -> Self {
                (value.target,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AddressEmptyCode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { target: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AddressEmptyCode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AddressEmptyCode(address)";
            const SELECTOR: [u8; 4] = [153u8, 150u8, 179u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `CompromiseActiveKmsContextNotAllowed(uint256)` and selector `0x77d05ea7`.
```solidity
error CompromiseActiveKmsContextNotAllowed(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CompromiseActiveKmsContextNotAllowed {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CompromiseActiveKmsContextNotAllowed>
        for UnderlyingRustTuple<'_> {
            fn from(value: CompromiseActiveKmsContextNotAllowed) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for CompromiseActiveKmsContextNotAllowed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CompromiseActiveKmsContextNotAllowed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CompromiseActiveKmsContextNotAllowed(uint256)";
            const SELECTOR: [u8; 4] = [119u8, 208u8, 94u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ContextAlreadyExists(uint256)` and selector `0x6653f6d7`.
```solidity
error ContextAlreadyExists(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ContextAlreadyExists {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ContextAlreadyExists> for UnderlyingRustTuple<'_> {
            fn from(value: ContextAlreadyExists) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ContextAlreadyExists {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ContextAlreadyExists {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ContextAlreadyExists(uint256)";
            const SELECTOR: [u8; 4] = [102u8, 83u8, 246u8, 215u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ContextNotActive(uint256)` and selector `0x331486b3`.
```solidity
error ContextNotActive(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ContextNotActive {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ContextNotActive> for UnderlyingRustTuple<'_> {
            fn from(value: ContextNotActive) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ContextNotActive {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ContextNotActive {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ContextNotActive(uint256)";
            const SELECTOR: [u8; 4] = [51u8, 20u8, 134u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ContextNotActiveOrSuspended(uint256)` and selector `0x2b3652d1`.
```solidity
error ContextNotActiveOrSuspended(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ContextNotActiveOrSuspended {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ContextNotActiveOrSuspended>
        for UnderlyingRustTuple<'_> {
            fn from(value: ContextNotActiveOrSuspended) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ContextNotActiveOrSuspended {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ContextNotActiveOrSuspended {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ContextNotActiveOrSuspended(uint256)";
            const SELECTOR: [u8; 4] = [43u8, 54u8, 82u8, 209u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ContextNotGenerated(uint256)` and selector `0xc0b5ee66`.
```solidity
error ContextNotGenerated(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ContextNotGenerated {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ContextNotGenerated> for UnderlyingRustTuple<'_> {
            fn from(value: ContextNotGenerated) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ContextNotGenerated {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ContextNotGenerated {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ContextNotGenerated(uint256)";
            const SELECTOR: [u8; 4] = [192u8, 181u8, 238u8, 102u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ContextNotInitializedOrIsGenerating(uint256)` and selector `0xb0c5151d`.
```solidity
error ContextNotInitializedOrIsGenerating(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ContextNotInitializedOrIsGenerating {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ContextNotInitializedOrIsGenerating>
        for UnderlyingRustTuple<'_> {
            fn from(value: ContextNotInitializedOrIsGenerating) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ContextNotInitializedOrIsGenerating {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ContextNotInitializedOrIsGenerating {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ContextNotInitializedOrIsGenerating(uint256)";
            const SELECTOR: [u8; 4] = [176u8, 197u8, 21u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ContextNotPreActivatedOrSuspended(uint256)` and selector `0x12b49e3d`.
```solidity
error ContextNotPreActivatedOrSuspended(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ContextNotPreActivatedOrSuspended {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ContextNotPreActivatedOrSuspended>
        for UnderlyingRustTuple<'_> {
            fn from(value: ContextNotPreActivatedOrSuspended) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ContextNotPreActivatedOrSuspended {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ContextNotPreActivatedOrSuspended {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ContextNotPreActivatedOrSuspended(uint256)";
            const SELECTOR: [u8; 4] = [18u8, 180u8, 158u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `DestroyActiveKmsContextNotAllowed(uint256)` and selector `0xb25e4eb3`.
```solidity
error DestroyActiveKmsContextNotAllowed(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DestroyActiveKmsContextNotAllowed {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DestroyActiveKmsContextNotAllowed>
        for UnderlyingRustTuple<'_> {
            fn from(value: DestroyActiveKmsContextNotAllowed) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for DestroyActiveKmsContextNotAllowed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for DestroyActiveKmsContextNotAllowed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DestroyActiveKmsContextNotAllowed(uint256)";
            const SELECTOR: [u8; 4] = [178u8, 94u8, 78u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ECDSAInvalidSignature()` and selector `0xf645eedf`.
```solidity
error ECDSAInvalidSignature();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignature {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignature> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignature) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignature()";
            const SELECTOR: [u8; 4] = [246u8, 69u8, 238u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ECDSAInvalidSignatureLength(uint256)` and selector `0xfce698f7`.
```solidity
error ECDSAInvalidSignatureLength(uint256 length);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureLength {
        #[allow(missing_docs)]
        pub length: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureLength>
        for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureLength) -> Self {
                (value.length,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ECDSAInvalidSignatureLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { length: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureLength(uint256)";
            const SELECTOR: [u8; 4] = [252u8, 230u8, 152u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.length),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ECDSAInvalidSignatureS(bytes32)` and selector `0xd78bce0c`.
```solidity
error ECDSAInvalidSignatureS(bytes32 s);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureS {
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureS> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureS) -> Self {
                (value.s,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignatureS {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { s: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureS {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureS(bytes32)";
            const SELECTOR: [u8; 4] = [215u8, 139u8, 206u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ERC1967InvalidImplementation(address)` and selector `0x4c9c8ce3`.
```solidity
error ERC1967InvalidImplementation(address implementation);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967InvalidImplementation {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967InvalidImplementation>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967InvalidImplementation) -> Self {
                (value.implementation,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC1967InvalidImplementation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { implementation: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967InvalidImplementation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967InvalidImplementation(address)";
            const SELECTOR: [u8; 4] = [76u8, 156u8, 140u8, 227u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ERC1967NonPayable()` and selector `0xb398979f`.
```solidity
error ERC1967NonPayable();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967NonPayable {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967NonPayable> for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967NonPayable) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC1967NonPayable {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967NonPayable {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967NonPayable()";
            const SELECTOR: [u8; 4] = [179u8, 152u8, 151u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `EmptyKmsNodes()` and selector `0x068c8d40`.
```solidity
error EmptyKmsNodes();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyKmsNodes {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyKmsNodes> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyKmsNodes) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyKmsNodes {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyKmsNodes {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyKmsNodes()";
            const SELECTOR: [u8; 4] = [6u8, 140u8, 141u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `EnforcedPause()` and selector `0xd93c0665`.
```solidity
error EnforcedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EnforcedPause {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EnforcedPause> for UnderlyingRustTuple<'_> {
            fn from(value: EnforcedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EnforcedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EnforcedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EnforcedPause()";
            const SELECTOR: [u8; 4] = [217u8, 60u8, 6u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ExpectedPause()` and selector `0x8dfc202b`.
```solidity
error ExpectedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExpectedPause {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExpectedPause> for UnderlyingRustTuple<'_> {
            fn from(value: ExpectedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ExpectedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ExpectedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ExpectedPause()";
            const SELECTOR: [u8; 4] = [141u8, 252u8, 32u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FailedCall()` and selector `0xd6bda275`.
```solidity
error FailedCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FailedCall {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedCall> for UnderlyingRustTuple<'_> {
            fn from(value: FailedCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FailedCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedCall()";
            const SELECTOR: [u8; 4] = [214u8, 189u8, 162u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidHighMpcThreshold(uint256,uint256,uint256)` and selector `0x8789a6ca`.
```solidity
error InvalidHighMpcThreshold(uint256 contextId, uint256 mpcThreshold, uint256 nKmsNodes);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidHighMpcThreshold {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub mpcThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nKmsNodes: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidHighMpcThreshold> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidHighMpcThreshold) -> Self {
                (value.contextId, value.mpcThreshold, value.nKmsNodes)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidHighMpcThreshold {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    contextId: tuple.0,
                    mpcThreshold: tuple.1,
                    nKmsNodes: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidHighMpcThreshold {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidHighMpcThreshold(uint256,uint256,uint256)";
            const SELECTOR: [u8; 4] = [135u8, 137u8, 166u8, 202u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.mpcThreshold),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nKmsNodes),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidHighPublicDecryptionThreshold(uint256,uint256)` and selector `0x84208f23`.
```solidity
error InvalidHighPublicDecryptionThreshold(uint256 publicDecryptionThreshold, uint256 nKmsNodes);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidHighPublicDecryptionThreshold {
        #[allow(missing_docs)]
        pub publicDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nKmsNodes: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidHighPublicDecryptionThreshold>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidHighPublicDecryptionThreshold) -> Self {
                (value.publicDecryptionThreshold, value.nKmsNodes)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidHighPublicDecryptionThreshold {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    publicDecryptionThreshold: tuple.0,
                    nKmsNodes: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidHighPublicDecryptionThreshold {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidHighPublicDecryptionThreshold(uint256,uint256)";
            const SELECTOR: [u8; 4] = [132u8, 32u8, 143u8, 35u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.publicDecryptionThreshold,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nKmsNodes),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidHighUserDecryptionThreshold(uint256,uint256)` and selector `0xd2535e11`.
```solidity
error InvalidHighUserDecryptionThreshold(uint256 userDecryptionThreshold, uint256 nKmsNodes);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidHighUserDecryptionThreshold {
        #[allow(missing_docs)]
        pub userDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nKmsNodes: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidHighUserDecryptionThreshold>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidHighUserDecryptionThreshold) -> Self {
                (value.userDecryptionThreshold, value.nKmsNodes)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidHighUserDecryptionThreshold {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    userDecryptionThreshold: tuple.0,
                    nKmsNodes: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidHighUserDecryptionThreshold {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidHighUserDecryptionThreshold(uint256,uint256)";
            const SELECTOR: [u8; 4] = [210u8, 83u8, 94u8, 17u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.userDecryptionThreshold,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nKmsNodes),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidInitialization()` and selector `0xf92ee8a9`.
```solidity
error InvalidInitialization();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidInitialization {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidInitialization> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidInitialization) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidInitialization {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidInitialization {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidInitialization()";
            const SELECTOR: [u8; 4] = [249u8, 46u8, 232u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidNullContextId()` and selector `0xcb17b7a5`.
```solidity
error InvalidNullContextId();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidNullContextId {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidNullContextId> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidNullContextId) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidNullContextId {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidNullContextId {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidNullContextId()";
            const SELECTOR: [u8; 4] = [203u8, 23u8, 183u8, 165u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidNullPublicDecryptionThreshold()` and selector `0xb1ae92ea`.
```solidity
error InvalidNullPublicDecryptionThreshold();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidNullPublicDecryptionThreshold {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidNullPublicDecryptionThreshold>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidNullPublicDecryptionThreshold) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidNullPublicDecryptionThreshold {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidNullPublicDecryptionThreshold {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidNullPublicDecryptionThreshold()";
            const SELECTOR: [u8; 4] = [177u8, 174u8, 146u8, 234u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidNullUserDecryptionThreshold()` and selector `0xe60a7271`.
```solidity
error InvalidNullUserDecryptionThreshold();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidNullUserDecryptionThreshold {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidNullUserDecryptionThreshold>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidNullUserDecryptionThreshold) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidNullUserDecryptionThreshold {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidNullUserDecryptionThreshold {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidNullUserDecryptionThreshold()";
            const SELECTOR: [u8; 4] = [230u8, 10u8, 114u8, 113u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `KmsContextNotGenerating(uint256)` and selector `0x5e51a2e1`.
```solidity
error KmsContextNotGenerating(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KmsContextNotGenerating {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KmsContextNotGenerating> for UnderlyingRustTuple<'_> {
            fn from(value: KmsContextNotGenerating) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for KmsContextNotGenerating {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for KmsContextNotGenerating {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "KmsContextNotGenerating(uint256)";
            const SELECTOR: [u8; 4] = [94u8, 81u8, 162u8, 225u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `KmsContextNotInitialized(uint256)` and selector `0x82b1fbda`.
```solidity
error KmsContextNotInitialized(uint256 contextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KmsContextNotInitialized {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KmsContextNotInitialized>
        for UnderlyingRustTuple<'_> {
            fn from(value: KmsContextNotInitialized) -> Self {
                (value.contextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for KmsContextNotInitialized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { contextId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for KmsContextNotInitialized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "KmsContextNotInitialized(uint256)";
            const SELECTOR: [u8; 4] = [130u8, 177u8, 251u8, 218u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `KmsNodeAlreadyValidatedKeyResharing(uint256,address)` and selector `0x99b158c1`.
```solidity
error KmsNodeAlreadyValidatedKeyResharing(uint256 contextId, address kmsSigner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KmsNodeAlreadyValidatedKeyResharing {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub kmsSigner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KmsNodeAlreadyValidatedKeyResharing>
        for UnderlyingRustTuple<'_> {
            fn from(value: KmsNodeAlreadyValidatedKeyResharing) -> Self {
                (value.contextId, value.kmsSigner)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for KmsNodeAlreadyValidatedKeyResharing {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    contextId: tuple.0,
                    kmsSigner: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for KmsNodeAlreadyValidatedKeyResharing {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "KmsNodeAlreadyValidatedKeyResharing(uint256,address)";
            const SELECTOR: [u8; 4] = [153u8, 177u8, 88u8, 193u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.kmsSigner,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NoSuspendedKmsContext()` and selector `0x207ea3f3`.
```solidity
error NoSuspendedKmsContext();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NoSuspendedKmsContext {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NoSuspendedKmsContext> for UnderlyingRustTuple<'_> {
            fn from(value: NoSuspendedKmsContext) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NoSuspendedKmsContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NoSuspendedKmsContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NoSuspendedKmsContext()";
            const SELECTOR: [u8; 4] = [32u8, 126u8, 163u8, 243u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotInitializing()` and selector `0xd7e6bcf8`.
```solidity
error NotInitializing();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotInitializing {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotInitializing> for UnderlyingRustTuple<'_> {
            fn from(value: NotInitializing) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotInitializing {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotInitializing {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotInitializing()";
            const SELECTOR: [u8; 4] = [215u8, 230u8, 188u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotInitializingFromEmptyProxy()` and selector `0x6f4f731f`.
```solidity
error NotInitializingFromEmptyProxy();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotInitializingFromEmptyProxy {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotInitializingFromEmptyProxy>
        for UnderlyingRustTuple<'_> {
            fn from(value: NotInitializingFromEmptyProxy) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for NotInitializingFromEmptyProxy {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotInitializingFromEmptyProxy {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotInitializingFromEmptyProxy()";
            const SELECTOR: [u8; 4] = [111u8, 79u8, 115u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotKmsNodeFromContext(uint256,address)` and selector `0x0494d3c0`.
```solidity
error NotKmsNodeFromContext(uint256 contextId, address kmsTxSenderAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotKmsNodeFromContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub kmsTxSenderAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotKmsNodeFromContext> for UnderlyingRustTuple<'_> {
            fn from(value: NotKmsNodeFromContext) -> Self {
                (value.contextId, value.kmsTxSenderAddress)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotKmsNodeFromContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    contextId: tuple.0,
                    kmsTxSenderAddress: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotKmsNodeFromContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotKmsNodeFromContext(uint256,address)";
            const SELECTOR: [u8; 4] = [4u8, 148u8, 211u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.kmsTxSenderAddress,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotKmsSignerFromContext(uint256,address)` and selector `0x89b45e5d`.
```solidity
error NotKmsSignerFromContext(uint256 contextId, address signerAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotKmsSignerFromContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub signerAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotKmsSignerFromContext> for UnderlyingRustTuple<'_> {
            fn from(value: NotKmsSignerFromContext) -> Self {
                (value.contextId, value.signerAddress)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotKmsSignerFromContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    contextId: tuple.0,
                    signerAddress: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotKmsSignerFromContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotKmsSignerFromContext(uint256,address)";
            const SELECTOR: [u8; 4] = [137u8, 180u8, 94u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signerAddress,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotKmsTxSenderFromContext(uint256,address)` and selector `0xfdf8a05d`.
```solidity
error NotKmsTxSenderFromContext(uint256 contextId, address txSenderAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotKmsTxSenderFromContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub txSenderAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotKmsTxSenderFromContext>
        for UnderlyingRustTuple<'_> {
            fn from(value: NotKmsTxSenderFromContext) -> Self {
                (value.contextId, value.txSenderAddress)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for NotKmsTxSenderFromContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    contextId: tuple.0,
                    txSenderAddress: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotKmsTxSenderFromContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotKmsTxSenderFromContext(uint256,address)";
            const SELECTOR: [u8; 4] = [253u8, 248u8, 160u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.txSenderAddress,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotOwnerOrPauser(address)` and selector `0x46c0d9af`.
```solidity
error NotOwnerOrPauser(address notOwnerOrPauser);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotOwnerOrPauser {
        #[allow(missing_docs)]
        pub notOwnerOrPauser: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotOwnerOrPauser> for UnderlyingRustTuple<'_> {
            fn from(value: NotOwnerOrPauser) -> Self {
                (value.notOwnerOrPauser,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotOwnerOrPauser {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { notOwnerOrPauser: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotOwnerOrPauser {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotOwnerOrPauser(address)";
            const SELECTOR: [u8; 4] = [70u8, 192u8, 217u8, 175u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.notOwnerOrPauser,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NumberOfKmsNodesChanged(uint256,uint256)` and selector `0xd595a962`.
```solidity
error NumberOfKmsNodesChanged(uint256 activeKmsNodesLength, uint256 newKmsNodesLength);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NumberOfKmsNodesChanged {
        #[allow(missing_docs)]
        pub activeKmsNodesLength: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub newKmsNodesLength: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NumberOfKmsNodesChanged> for UnderlyingRustTuple<'_> {
            fn from(value: NumberOfKmsNodesChanged) -> Self {
                (value.activeKmsNodesLength, value.newKmsNodesLength)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NumberOfKmsNodesChanged {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    activeKmsNodesLength: tuple.0,
                    newKmsNodesLength: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NumberOfKmsNodesChanged {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NumberOfKmsNodesChanged(uint256,uint256)";
            const SELECTOR: [u8; 4] = [213u8, 149u8, 169u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.activeKmsNodesLength),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newKmsNodesLength),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `OwnableInvalidOwner(address)` and selector `0x1e4fbdf7`.
```solidity
error OwnableInvalidOwner(address owner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OwnableInvalidOwner {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OwnableInvalidOwner> for UnderlyingRustTuple<'_> {
            fn from(value: OwnableInvalidOwner) -> Self {
                (value.owner,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OwnableInvalidOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { owner: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OwnableInvalidOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OwnableInvalidOwner(address)";
            const SELECTOR: [u8; 4] = [30u8, 79u8, 189u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `OwnableUnauthorizedAccount(address)` and selector `0x118cdaa7`.
```solidity
error OwnableUnauthorizedAccount(address account);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OwnableUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OwnableUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: OwnableUnauthorizedAccount) -> Self {
                (value.account,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for OwnableUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { account: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OwnableUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OwnableUnauthorizedAccount(address)";
            const SELECTOR: [u8; 4] = [17u8, 140u8, 218u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `SuspendedKmsContextOngoing(uint256)` and selector `0x7623d357`.
```solidity
error SuspendedKmsContextOngoing(uint256 suspendedContextId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SuspendedKmsContextOngoing {
        #[allow(missing_docs)]
        pub suspendedContextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SuspendedKmsContextOngoing>
        for UnderlyingRustTuple<'_> {
            fn from(value: SuspendedKmsContextOngoing) -> Self {
                (value.suspendedContextId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SuspendedKmsContextOngoing {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    suspendedContextId: tuple.0,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SuspendedKmsContextOngoing {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SuspendedKmsContextOngoing(uint256)";
            const SELECTOR: [u8; 4] = [118u8, 35u8, 211u8, 87u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.suspendedContextId),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UUPSUnauthorizedCallContext()` and selector `0xe07c8dba`.
```solidity
error UUPSUnauthorizedCallContext();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnauthorizedCallContext {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnauthorizedCallContext>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnauthorizedCallContext) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnauthorizedCallContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnauthorizedCallContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnauthorizedCallContext()";
            const SELECTOR: [u8; 4] = [224u8, 124u8, 141u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UUPSUnsupportedProxiableUUID(bytes32)` and selector `0xaa1d49a4`.
```solidity
error UUPSUnsupportedProxiableUUID(bytes32 slot);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnsupportedProxiableUUID {
        #[allow(missing_docs)]
        pub slot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnsupportedProxiableUUID>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnsupportedProxiableUUID) -> Self {
                (value.slot,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnsupportedProxiableUUID {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { slot: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnsupportedProxiableUUID {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnsupportedProxiableUUID(bytes32)";
            const SELECTOR: [u8; 4] = [170u8, 29u8, 73u8, 164u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ActivateKmsContext(uint256)` and selector `0x4f54a6ac981cc8dc83142b3eb4d120be7c70fc5de6477a14eae3e9ca647644bc`.
```solidity
event ActivateKmsContext(uint256 contextId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ActivateKmsContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ActivateKmsContext {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ActivateKmsContext(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                79u8, 84u8, 166u8, 172u8, 152u8, 28u8, 200u8, 220u8, 131u8, 20u8, 43u8,
                62u8, 180u8, 209u8, 32u8, 190u8, 124u8, 112u8, 252u8, 93u8, 230u8, 71u8,
                122u8, 20u8, 234u8, 227u8, 233u8, 202u8, 100u8, 118u8, 68u8, 188u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { contextId: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ActivateKmsContext {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ActivateKmsContext> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ActivateKmsContext) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `CompromiseKmsContext(uint256)` and selector `0xbc1114fa9a77648cd097ee6cf149c344fa278b9b983f30dd65b6fd6a9d464a07`.
```solidity
event CompromiseKmsContext(uint256 contextId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct CompromiseKmsContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for CompromiseKmsContext {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "CompromiseKmsContext(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                188u8, 17u8, 20u8, 250u8, 154u8, 119u8, 100u8, 140u8, 208u8, 151u8,
                238u8, 108u8, 241u8, 73u8, 195u8, 68u8, 250u8, 39u8, 139u8, 155u8, 152u8,
                63u8, 48u8, 221u8, 101u8, 182u8, 253u8, 106u8, 157u8, 70u8, 74u8, 7u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { contextId: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for CompromiseKmsContext {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&CompromiseKmsContext> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &CompromiseKmsContext) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `DeactivateKmsContext(uint256)` and selector `0x8fb75858a565aee117342d93196a7f0b54c1c8519885eddda6a01f477359b363`.
```solidity
event DeactivateKmsContext(uint256 contextId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DeactivateKmsContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DeactivateKmsContext {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "DeactivateKmsContext(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                143u8, 183u8, 88u8, 88u8, 165u8, 101u8, 174u8, 225u8, 23u8, 52u8, 45u8,
                147u8, 25u8, 106u8, 127u8, 11u8, 84u8, 193u8, 200u8, 81u8, 152u8, 133u8,
                237u8, 221u8, 166u8, 160u8, 31u8, 71u8, 115u8, 89u8, 179u8, 99u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { contextId: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DeactivateKmsContext {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DeactivateKmsContext> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DeactivateKmsContext) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `DestroyKmsContext(uint256)` and selector `0x3e8f02dc7af6e3a67f3af0bc99bcf11b4deb46105e9ba7f1ac6da82322e9025e`.
```solidity
event DestroyKmsContext(uint256 contextId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DestroyKmsContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DestroyKmsContext {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "DestroyKmsContext(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                62u8, 143u8, 2u8, 220u8, 122u8, 246u8, 227u8, 166u8, 127u8, 58u8, 240u8,
                188u8, 153u8, 188u8, 241u8, 27u8, 77u8, 235u8, 70u8, 16u8, 94u8, 155u8,
                167u8, 241u8, 172u8, 109u8, 168u8, 35u8, 34u8, 233u8, 2u8, 94u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { contextId: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DestroyKmsContext {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DestroyKmsContext> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DestroyKmsContext) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `EIP712DomainChanged()` and selector `0x0a6387c9ea3628b88a633bb4f3b151770f70085117a15f9bf3787cda53f13d31`.
```solidity
event EIP712DomainChanged();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EIP712DomainChanged {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EIP712DomainChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EIP712DomainChanged()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                10u8, 99u8, 135u8, 201u8, 234u8, 54u8, 40u8, 184u8, 138u8, 99u8, 59u8,
                180u8, 243u8, 177u8, 81u8, 119u8, 15u8, 112u8, 8u8, 81u8, 23u8, 161u8,
                95u8, 155u8, 243u8, 120u8, 124u8, 218u8, 83u8, 241u8, 61u8, 49u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EIP712DomainChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EIP712DomainChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EIP712DomainChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Initialization((uint256,uint256),(uint256,uint256,uint256),bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[])` and selector `0x016ee9c16213ed67f33222abad4dfe46eb951ead30a10a1a72db3316ffb664e0`.
```solidity
event Initialization(DecryptionThresholds decryptionThresholds, KmsBlockPeriods blockPeriods, bytes8 softwareVersion, uint256 mpcThreshold, KmsNode[] kmsNodes);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialization {
        #[allow(missing_docs)]
        pub decryptionThresholds: <DecryptionThresholds as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub blockPeriods: <KmsBlockPeriods as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub softwareVersion: alloy::sol_types::private::FixedBytes<8>,
        #[allow(missing_docs)]
        pub mpcThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub kmsNodes: alloy::sol_types::private::Vec<
            <KmsNode as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialization {
            type DataTuple<'a> = (
                DecryptionThresholds,
                KmsBlockPeriods,
                alloy::sol_types::sol_data::FixedBytes<8>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<KmsNode>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialization((uint256,uint256),(uint256,uint256,uint256),bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[])";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                1u8, 110u8, 233u8, 193u8, 98u8, 19u8, 237u8, 103u8, 243u8, 50u8, 34u8,
                171u8, 173u8, 77u8, 254u8, 70u8, 235u8, 149u8, 30u8, 173u8, 48u8, 161u8,
                10u8, 26u8, 114u8, 219u8, 51u8, 22u8, 255u8, 182u8, 100u8, 224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    decryptionThresholds: data.0,
                    blockPeriods: data.1,
                    softwareVersion: data.2,
                    mpcThreshold: data.3,
                    kmsNodes: data.4,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <DecryptionThresholds as alloy_sol_types::SolType>::tokenize(
                        &self.decryptionThresholds,
                    ),
                    <KmsBlockPeriods as alloy_sol_types::SolType>::tokenize(
                        &self.blockPeriods,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.softwareVersion),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.mpcThreshold),
                    <alloy::sol_types::sol_data::Array<
                        KmsNode,
                    > as alloy_sol_types::SolType>::tokenize(&self.kmsNodes),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialization {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialization> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialization) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Initialized(uint64)` and selector `0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2`.
```solidity
event Initialized(uint64 version);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.version),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `InvalidateKeyResharing(uint256)` and selector `0x009fe8f0db45996decf7b06fc7b6ec5f887d5f04db2e0c4ad7f4e4ee5eefc5a3`.
```solidity
event InvalidateKeyResharing(uint256 contextId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct InvalidateKeyResharing {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for InvalidateKeyResharing {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "InvalidateKeyResharing(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                0u8, 159u8, 232u8, 240u8, 219u8, 69u8, 153u8, 109u8, 236u8, 247u8, 176u8,
                111u8, 199u8, 182u8, 236u8, 95u8, 136u8, 125u8, 95u8, 4u8, 219u8, 46u8,
                12u8, 74u8, 215u8, 244u8, 228u8, 238u8, 94u8, 239u8, 197u8, 163u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { contextId: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for InvalidateKeyResharing {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&InvalidateKeyResharing> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &InvalidateKeyResharing) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `NewKmsContext((uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),(uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]))` and selector `0x3662ec316d76e6a75eb7c45001a8ad74c3eb943e8778111c0225f2a9fd5e00e6`.
```solidity
event NewKmsContext(KmsContext activeKmsContext, KmsContext newKmsContext);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct NewKmsContext {
        #[allow(missing_docs)]
        pub activeKmsContext: <KmsContext as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub newKmsContext: <KmsContext as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for NewKmsContext {
            type DataTuple<'a> = (KmsContext, KmsContext);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "NewKmsContext((uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),(uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]))";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                54u8, 98u8, 236u8, 49u8, 109u8, 118u8, 230u8, 167u8, 94u8, 183u8, 196u8,
                80u8, 1u8, 168u8, 173u8, 116u8, 195u8, 235u8, 148u8, 62u8, 135u8, 120u8,
                17u8, 28u8, 2u8, 37u8, 242u8, 169u8, 253u8, 94u8, 0u8, 230u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    activeKmsContext: data.0,
                    newKmsContext: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <KmsContext as alloy_sol_types::SolType>::tokenize(
                        &self.activeKmsContext,
                    ),
                    <KmsContext as alloy_sol_types::SolType>::tokenize(
                        &self.newKmsContext,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for NewKmsContext {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&NewKmsContext> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &NewKmsContext) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OwnershipTransferStarted(address,address)` and selector `0x38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e22700`.
```solidity
event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferStarted {
        #[allow(missing_docs)]
        pub previousOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferStarted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferStarted(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                56u8, 209u8, 107u8, 140u8, 172u8, 34u8, 217u8, 159u8, 199u8, 193u8, 36u8,
                185u8, 205u8, 13u8, 226u8, 211u8, 250u8, 31u8, 174u8, 244u8, 32u8, 191u8,
                231u8, 145u8, 216u8, 195u8, 98u8, 215u8, 101u8, 226u8, 39u8, 0u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferStarted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferStarted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &OwnershipTransferStarted,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
```solidity
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub previousOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Paused(address)` and selector `0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258`.
```solidity
event Paused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Paused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Paused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Paused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                98u8, 231u8, 140u8, 234u8, 1u8, 190u8, 227u8, 32u8, 205u8, 78u8, 66u8,
                2u8, 112u8, 181u8, 234u8, 116u8, 0u8, 13u8, 17u8, 176u8, 201u8, 247u8,
                71u8, 84u8, 235u8, 219u8, 252u8, 84u8, 75u8, 5u8, 162u8, 88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Paused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Paused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Paused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `PreActivateKmsContext((uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),uint256)` and selector `0x4540f7808fcaec86c376a89d2c0c93a5056c21680db54332c7f2959d87fefc8b`.
```solidity
event PreActivateKmsContext(KmsContext newKmsContext, uint256 preActivationBlockNumber);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct PreActivateKmsContext {
        #[allow(missing_docs)]
        pub newKmsContext: <KmsContext as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub preActivationBlockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for PreActivateKmsContext {
            type DataTuple<'a> = (KmsContext, alloy::sol_types::sol_data::Uint<256>);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "PreActivateKmsContext((uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                69u8, 64u8, 247u8, 128u8, 143u8, 202u8, 236u8, 134u8, 195u8, 118u8,
                168u8, 157u8, 44u8, 12u8, 147u8, 165u8, 5u8, 108u8, 33u8, 104u8, 13u8,
                181u8, 67u8, 50u8, 199u8, 242u8, 149u8, 157u8, 135u8, 254u8, 252u8, 139u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    newKmsContext: data.0,
                    preActivationBlockNumber: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <KmsContext as alloy_sol_types::SolType>::tokenize(
                        &self.newKmsContext,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.preActivationBlockNumber,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for PreActivateKmsContext {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&PreActivateKmsContext> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &PreActivateKmsContext) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `StartKeyResharing((uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),(uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),uint256)` and selector `0x5dc601065a035d78305cd9ef27c91a009cd8d37297e43bb76319490895a0d058`.
```solidity
event StartKeyResharing(KmsContext activeKmsContext, KmsContext newKmsContext, uint256 generationBlockNumber);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct StartKeyResharing {
        #[allow(missing_docs)]
        pub activeKmsContext: <KmsContext as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub newKmsContext: <KmsContext as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub generationBlockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for StartKeyResharing {
            type DataTuple<'a> = (
                KmsContext,
                KmsContext,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "StartKeyResharing((uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),(uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]),uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                93u8, 198u8, 1u8, 6u8, 90u8, 3u8, 93u8, 120u8, 48u8, 92u8, 217u8, 239u8,
                39u8, 201u8, 26u8, 0u8, 156u8, 216u8, 211u8, 114u8, 151u8, 228u8, 59u8,
                183u8, 99u8, 25u8, 73u8, 8u8, 149u8, 160u8, 208u8, 88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    activeKmsContext: data.0,
                    newKmsContext: data.1,
                    generationBlockNumber: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <KmsContext as alloy_sol_types::SolType>::tokenize(
                        &self.activeKmsContext,
                    ),
                    <KmsContext as alloy_sol_types::SolType>::tokenize(
                        &self.newKmsContext,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.generationBlockNumber),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for StartKeyResharing {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&StartKeyResharing> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &StartKeyResharing) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `SuspendKmsContext(uint256)` and selector `0x851a08c16b15959c338ac4b56466d06c9f9d5ff8d715168aa125d5ccaf538320`.
```solidity
event SuspendKmsContext(uint256 contextId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SuspendKmsContext {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SuspendKmsContext {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "SuspendKmsContext(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                133u8, 26u8, 8u8, 193u8, 107u8, 21u8, 149u8, 156u8, 51u8, 138u8, 196u8,
                181u8, 100u8, 102u8, 208u8, 108u8, 159u8, 157u8, 95u8, 248u8, 215u8,
                21u8, 22u8, 138u8, 161u8, 37u8, 213u8, 204u8, 175u8, 83u8, 131u8, 32u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { contextId: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SuspendKmsContext {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SuspendKmsContext> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SuspendKmsContext) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Unpaused(address)` and selector `0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa`.
```solidity
event Unpaused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Unpaused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Unpaused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Unpaused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                93u8, 185u8, 238u8, 10u8, 73u8, 91u8, 242u8, 230u8, 255u8, 156u8, 145u8,
                167u8, 131u8, 76u8, 27u8, 164u8, 253u8, 210u8, 68u8, 165u8, 232u8, 170u8,
                78u8, 83u8, 123u8, 211u8, 138u8, 234u8, 228u8, 176u8, 115u8, 170u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Unpaused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Unpaused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Unpaused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `UpdateKmsContextGenerationBlockPeriod(uint256)` and selector `0x53cb968d31c28c6504a6e73d9908db6e1c1a386b66dcacec1a0117752c5ab986`.
```solidity
event UpdateKmsContextGenerationBlockPeriod(uint256 newKmsContextGenerationBlockPeriod);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct UpdateKmsContextGenerationBlockPeriod {
        #[allow(missing_docs)]
        pub newKmsContextGenerationBlockPeriod: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for UpdateKmsContextGenerationBlockPeriod {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "UpdateKmsContextGenerationBlockPeriod(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                83u8, 203u8, 150u8, 141u8, 49u8, 194u8, 140u8, 101u8, 4u8, 166u8, 231u8,
                61u8, 153u8, 8u8, 219u8, 110u8, 28u8, 26u8, 56u8, 107u8, 102u8, 220u8,
                172u8, 236u8, 26u8, 1u8, 23u8, 117u8, 44u8, 90u8, 185u8, 134u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    newKmsContextGenerationBlockPeriod: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.newKmsContextGenerationBlockPeriod,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData
        for UpdateKmsContextGenerationBlockPeriod {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&UpdateKmsContextGenerationBlockPeriod>
        for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &UpdateKmsContextGenerationBlockPeriod,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `UpdateKmsContextSuspensionBlockPeriod(uint256)` and selector `0x3ad5c22724afab8ed2b578fb9b160c7f65f5abd0aad105752b7ba4e068a3e021`.
```solidity
event UpdateKmsContextSuspensionBlockPeriod(uint256 newKmsContextSuspensionBlockPeriod);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct UpdateKmsContextSuspensionBlockPeriod {
        #[allow(missing_docs)]
        pub newKmsContextSuspensionBlockPeriod: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for UpdateKmsContextSuspensionBlockPeriod {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "UpdateKmsContextSuspensionBlockPeriod(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                58u8, 213u8, 194u8, 39u8, 36u8, 175u8, 171u8, 142u8, 210u8, 181u8, 120u8,
                251u8, 155u8, 22u8, 12u8, 127u8, 101u8, 245u8, 171u8, 208u8, 170u8,
                209u8, 5u8, 117u8, 43u8, 123u8, 164u8, 224u8, 104u8, 163u8, 224u8, 33u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    newKmsContextSuspensionBlockPeriod: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.newKmsContextSuspensionBlockPeriod,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData
        for UpdateKmsContextSuspensionBlockPeriod {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&UpdateKmsContextSuspensionBlockPeriod>
        for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &UpdateKmsContextSuspensionBlockPeriod,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `UpdatePublicDecryptionThreshold(uint256)` and selector `0xe41802af725729adcb8c151e2937380a25c69155757e3af5d3979adab5035800`.
```solidity
event UpdatePublicDecryptionThreshold(uint256 newPublicDecryptionThreshold);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct UpdatePublicDecryptionThreshold {
        #[allow(missing_docs)]
        pub newPublicDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for UpdatePublicDecryptionThreshold {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "UpdatePublicDecryptionThreshold(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                228u8, 24u8, 2u8, 175u8, 114u8, 87u8, 41u8, 173u8, 203u8, 140u8, 21u8,
                30u8, 41u8, 55u8, 56u8, 10u8, 37u8, 198u8, 145u8, 85u8, 117u8, 126u8,
                58u8, 245u8, 211u8, 151u8, 154u8, 218u8, 181u8, 3u8, 88u8, 0u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    newPublicDecryptionThreshold: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.newPublicDecryptionThreshold,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for UpdatePublicDecryptionThreshold {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&UpdatePublicDecryptionThreshold>
        for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &UpdatePublicDecryptionThreshold,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `UpdateUserDecryptionThreshold(uint256)` and selector `0x837e0a6528dadfa2dc792692c5182e52a9f5bbdeed7b2372927a26c695839613`.
```solidity
event UpdateUserDecryptionThreshold(uint256 newUserDecryptionThreshold);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct UpdateUserDecryptionThreshold {
        #[allow(missing_docs)]
        pub newUserDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for UpdateUserDecryptionThreshold {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "UpdateUserDecryptionThreshold(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                131u8, 126u8, 10u8, 101u8, 40u8, 218u8, 223u8, 162u8, 220u8, 121u8, 38u8,
                146u8, 197u8, 24u8, 46u8, 82u8, 169u8, 245u8, 187u8, 222u8, 237u8, 123u8,
                35u8, 114u8, 146u8, 122u8, 38u8, 198u8, 149u8, 131u8, 150u8, 19u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    newUserDecryptionThreshold: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.newUserDecryptionThreshold,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for UpdateUserDecryptionThreshold {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&UpdateUserDecryptionThreshold> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &UpdateUserDecryptionThreshold,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Upgraded(address)` and selector `0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b`.
```solidity
event Upgraded(address indexed implementation);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Upgraded {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Upgraded {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Upgraded(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                188u8, 124u8, 215u8, 90u8, 32u8, 238u8, 39u8, 253u8, 154u8, 222u8, 186u8,
                179u8, 32u8, 65u8, 247u8, 85u8, 33u8, 77u8, 188u8, 107u8, 255u8, 169u8,
                12u8, 192u8, 34u8, 91u8, 57u8, 218u8, 46u8, 92u8, 45u8, 59u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { implementation: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.implementation.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.implementation,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Upgraded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Upgraded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Upgraded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ValidateKeyResharing((uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]))` and selector `0x68898a98936bf23a56e8ed4b23dcc98cef926bd9ac2ce522f1f9423e3864f2f5`.
```solidity
event ValidateKeyResharing(KmsContext newKmsContext);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ValidateKeyResharing {
        #[allow(missing_docs)]
        pub newKmsContext: <KmsContext as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ValidateKeyResharing {
            type DataTuple<'a> = (KmsContext,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ValidateKeyResharing((uint256,uint256,bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[]))";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                104u8, 137u8, 138u8, 152u8, 147u8, 107u8, 242u8, 58u8, 86u8, 232u8,
                237u8, 75u8, 35u8, 220u8, 201u8, 140u8, 239u8, 146u8, 107u8, 217u8,
                172u8, 44u8, 229u8, 34u8, 241u8, 249u8, 66u8, 62u8, 56u8, 100u8, 242u8,
                245u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { newKmsContext: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <KmsContext as alloy_sol_types::SolType>::tokenize(
                        &self.newKmsContext,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ValidateKeyResharing {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ValidateKeyResharing> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ValidateKeyResharing) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {}
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `UPGRADE_INTERFACE_VERSION()` and selector `0xad3cb1cc`.
```solidity
function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`UPGRADE_INTERFACE_VERSION()`](UPGRADE_INTERFACE_VERSIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for UPGRADE_INTERFACE_VERSIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = UPGRADE_INTERFACE_VERSIONReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UPGRADE_INTERFACE_VERSION()";
            const SELECTOR: [u8; 4] = [173u8, 60u8, 177u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `acceptOwnership()` and selector `0x79ba5097`.
```solidity
function acceptOwnership() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct acceptOwnershipCall {}
    ///Container type for the return parameters of the [`acceptOwnership()`](acceptOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct acceptOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<acceptOwnershipCall> for UnderlyingRustTuple<'_> {
                fn from(value: acceptOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for acceptOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<acceptOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: acceptOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for acceptOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for acceptOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = acceptOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "acceptOwnership()";
            const SELECTOR: [u8; 4] = [121u8, 186u8, 80u8, 151u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `addKmsContext(uint256,bytes8,bool,uint256,(string,address,address,uint256,bytes,string,string,bytes)[],(uint256,uint256))` and selector `0x169cac14`.
```solidity
function addKmsContext(uint256 preActivationBlockPeriod, bytes8 softwareVersion, bool reshareKeys, uint256 mpcThreshold, KmsNode[] memory kmsNodes, DecryptionThresholds memory decryptionThresholds) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addKmsContextCall {
        #[allow(missing_docs)]
        pub preActivationBlockPeriod: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub softwareVersion: alloy::sol_types::private::FixedBytes<8>,
        #[allow(missing_docs)]
        pub reshareKeys: bool,
        #[allow(missing_docs)]
        pub mpcThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub kmsNodes: alloy::sol_types::private::Vec<
            <KmsNode as alloy::sol_types::SolType>::RustType,
        >,
        #[allow(missing_docs)]
        pub decryptionThresholds: <DecryptionThresholds as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`addKmsContext(uint256,bytes8,bool,uint256,(string,address,address,uint256,bytes,string,string,bytes)[],(uint256,uint256))`](addKmsContextCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addKmsContextReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<8>,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<KmsNode>,
                DecryptionThresholds,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<8>,
                bool,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Vec<
                    <KmsNode as alloy::sol_types::SolType>::RustType,
                >,
                <DecryptionThresholds as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addKmsContextCall> for UnderlyingRustTuple<'_> {
                fn from(value: addKmsContextCall) -> Self {
                    (
                        value.preActivationBlockPeriod,
                        value.softwareVersion,
                        value.reshareKeys,
                        value.mpcThreshold,
                        value.kmsNodes,
                        value.decryptionThresholds,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addKmsContextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        preActivationBlockPeriod: tuple.0,
                        softwareVersion: tuple.1,
                        reshareKeys: tuple.2,
                        mpcThreshold: tuple.3,
                        kmsNodes: tuple.4,
                        decryptionThresholds: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addKmsContextReturn> for UnderlyingRustTuple<'_> {
                fn from(value: addKmsContextReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addKmsContextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addKmsContextCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<8>,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<KmsNode>,
                DecryptionThresholds,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addKmsContextReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addKmsContext(uint256,bytes8,bool,uint256,(string,address,address,uint256,bytes,string,string,bytes)[],(uint256,uint256))";
            const SELECTOR: [u8; 4] = [22u8, 156u8, 172u8, 20u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.preActivationBlockPeriod,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.softwareVersion),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.reshareKeys,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.mpcThreshold),
                    <alloy::sol_types::sol_data::Array<
                        KmsNode,
                    > as alloy_sol_types::SolType>::tokenize(&self.kmsNodes),
                    <DecryptionThresholds as alloy_sol_types::SolType>::tokenize(
                        &self.decryptionThresholds,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkIsKmsSignerFromContext(uint256,address)` and selector `0xdfe36aee`.
```solidity
function checkIsKmsSignerFromContext(uint256 contextId, address signerAddress) external view;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsKmsSignerFromContextCall {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub signerAddress: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkIsKmsSignerFromContext(uint256,address)`](checkIsKmsSignerFromContextCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsKmsSignerFromContextReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsKmsSignerFromContextCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsKmsSignerFromContextCall) -> Self {
                    (value.contextId, value.signerAddress)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsKmsSignerFromContextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        contextId: tuple.0,
                        signerAddress: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsKmsSignerFromContextReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsKmsSignerFromContextReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsKmsSignerFromContextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkIsKmsSignerFromContextCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkIsKmsSignerFromContextReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkIsKmsSignerFromContext(uint256,address)";
            const SELECTOR: [u8; 4] = [223u8, 227u8, 106u8, 238u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signerAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `checkIsKmsTxSenderFromContext(uint256,address)` and selector `0xdefba06a`.
```solidity
function checkIsKmsTxSenderFromContext(uint256 contextId, address txSenderAddress) external view;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsKmsTxSenderFromContextCall {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub txSenderAddress: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkIsKmsTxSenderFromContext(uint256,address)`](checkIsKmsTxSenderFromContextCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsKmsTxSenderFromContextReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsKmsTxSenderFromContextCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsKmsTxSenderFromContextCall) -> Self {
                    (value.contextId, value.txSenderAddress)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsKmsTxSenderFromContextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        contextId: tuple.0,
                        txSenderAddress: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsKmsTxSenderFromContextReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsKmsTxSenderFromContextReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsKmsTxSenderFromContextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkIsKmsTxSenderFromContextCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkIsKmsTxSenderFromContextReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkIsKmsTxSenderFromContext(uint256,address)";
            const SELECTOR: [u8; 4] = [222u8, 251u8, 160u8, 106u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.txSenderAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `compromiseKmsContext(uint256)` and selector `0x9ee77af3`.
```solidity
function compromiseKmsContext(uint256 contextId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct compromiseKmsContextCall {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`compromiseKmsContext(uint256)`](compromiseKmsContextCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct compromiseKmsContextReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<compromiseKmsContextCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: compromiseKmsContextCall) -> Self {
                    (value.contextId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for compromiseKmsContextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { contextId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<compromiseKmsContextReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: compromiseKmsContextReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for compromiseKmsContextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for compromiseKmsContextCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = compromiseKmsContextReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "compromiseKmsContext(uint256)";
            const SELECTOR: [u8; 4] = [158u8, 231u8, 122u8, 243u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `destroyKmsContext(uint256)` and selector `0xc0ae64f7`.
```solidity
function destroyKmsContext(uint256 contextId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct destroyKmsContextCall {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`destroyKmsContext(uint256)`](destroyKmsContextCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct destroyKmsContextReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<destroyKmsContextCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: destroyKmsContextCall) -> Self {
                    (value.contextId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for destroyKmsContextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { contextId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<destroyKmsContextReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: destroyKmsContextReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for destroyKmsContextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for destroyKmsContextCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = destroyKmsContextReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "destroyKmsContext(uint256)";
            const SELECTOR: [u8; 4] = [192u8, 174u8, 100u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `eip712Domain()` and selector `0x84b0196e`.
```solidity
function eip712Domain() external view returns (bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] memory extensions);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eip712DomainCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`eip712Domain()`](eip712DomainCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eip712DomainReturn {
        #[allow(missing_docs)]
        pub fields: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub name: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub version: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub verifyingContract: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub salt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub extensions: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eip712DomainCall> for UnderlyingRustTuple<'_> {
                fn from(value: eip712DomainCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eip712DomainCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eip712DomainReturn> for UnderlyingRustTuple<'_> {
                fn from(value: eip712DomainReturn) -> Self {
                    (
                        value.fields,
                        value.name,
                        value.version,
                        value.chainId,
                        value.verifyingContract,
                        value.salt,
                        value.extensions,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eip712DomainReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        fields: tuple.0,
                        name: tuple.1,
                        version: tuple.2,
                        chainId: tuple.3,
                        verifyingContract: tuple.4,
                        salt: tuple.5,
                        extensions: tuple.6,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for eip712DomainCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = eip712DomainReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "eip712Domain()";
            const SELECTOR: [u8; 4] = [132u8, 176u8, 25u8, 110u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getActiveKmsContext()` and selector `0x0dd486c0`.
```solidity
function getActiveKmsContext() external view returns (KmsContext memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getActiveKmsContextCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getActiveKmsContext()`](getActiveKmsContextCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getActiveKmsContextReturn {
        #[allow(missing_docs)]
        pub _0: <KmsContext as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getActiveKmsContextCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getActiveKmsContextCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getActiveKmsContextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (KmsContext,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <KmsContext as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getActiveKmsContextReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getActiveKmsContextReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getActiveKmsContextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getActiveKmsContextCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getActiveKmsContextReturn;
            type ReturnTuple<'a> = (KmsContext,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getActiveKmsContext()";
            const SELECTOR: [u8; 4] = [13u8, 212u8, 134u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getActiveKmsContextId()` and selector `0x43e37e8a`.
```solidity
function getActiveKmsContextId() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getActiveKmsContextIdCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getActiveKmsContextId()`](getActiveKmsContextIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getActiveKmsContextIdReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getActiveKmsContextIdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getActiveKmsContextIdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getActiveKmsContextIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getActiveKmsContextIdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getActiveKmsContextIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getActiveKmsContextIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getActiveKmsContextIdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getActiveKmsContextIdReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getActiveKmsContextId()";
            const SELECTOR: [u8; 4] = [67u8, 227u8, 126u8, 138u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getKmsContextGenerationBlockPeriod()` and selector `0x4965e455`.
```solidity
function getKmsContextGenerationBlockPeriod() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsContextGenerationBlockPeriodCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getKmsContextGenerationBlockPeriod()`](getKmsContextGenerationBlockPeriodCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsContextGenerationBlockPeriodReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsContextGenerationBlockPeriodCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsContextGenerationBlockPeriodCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsContextGenerationBlockPeriodCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsContextGenerationBlockPeriodReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsContextGenerationBlockPeriodReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsContextGenerationBlockPeriodReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsContextGenerationBlockPeriodCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsContextGenerationBlockPeriodReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsContextGenerationBlockPeriod()";
            const SELECTOR: [u8; 4] = [73u8, 101u8, 228u8, 85u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getKmsContextStatus(uint256)` and selector `0x4d694260`.
```solidity
function getKmsContextStatus(uint256 contextId) external view returns (ContextStatus);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsContextStatusCall {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getKmsContextStatus(uint256)`](getKmsContextStatusCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsContextStatusReturn {
        #[allow(missing_docs)]
        pub _0: <ContextStatus as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsContextStatusCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsContextStatusCall) -> Self {
                    (value.contextId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsContextStatusCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { contextId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ContextStatus,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ContextStatus as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsContextStatusReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsContextStatusReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsContextStatusReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsContextStatusCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsContextStatusReturn;
            type ReturnTuple<'a> = (ContextStatus,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsContextStatus(uint256)";
            const SELECTOR: [u8; 4] = [77u8, 105u8, 66u8, 96u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getKmsContextSuspensionBlockPeriod()` and selector `0xd8e3ae01`.
```solidity
function getKmsContextSuspensionBlockPeriod() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsContextSuspensionBlockPeriodCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getKmsContextSuspensionBlockPeriod()`](getKmsContextSuspensionBlockPeriodCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsContextSuspensionBlockPeriodReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsContextSuspensionBlockPeriodCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsContextSuspensionBlockPeriodCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsContextSuspensionBlockPeriodCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsContextSuspensionBlockPeriodReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsContextSuspensionBlockPeriodReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsContextSuspensionBlockPeriodReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsContextSuspensionBlockPeriodCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsContextSuspensionBlockPeriodReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsContextSuspensionBlockPeriod()";
            const SELECTOR: [u8; 4] = [216u8, 227u8, 174u8, 1u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getKmsNode(address)` and selector `0xe3b2a874`.
```solidity
function getKmsNode(address kmsTxSenderAddress) external view returns (KmsNode memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsNodeCall {
        #[allow(missing_docs)]
        pub kmsTxSenderAddress: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getKmsNode(address)`](getKmsNodeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsNodeReturn {
        #[allow(missing_docs)]
        pub _0: <KmsNode as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsNodeCall> for UnderlyingRustTuple<'_> {
                fn from(value: getKmsNodeCall) -> Self {
                    (value.kmsTxSenderAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getKmsNodeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        kmsTxSenderAddress: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (KmsNode,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <KmsNode as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsNodeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getKmsNodeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getKmsNodeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsNodeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsNodeReturn;
            type ReturnTuple<'a> = (KmsNode,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsNode(address)";
            const SELECTOR: [u8; 4] = [227u8, 178u8, 168u8, 116u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.kmsTxSenderAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getKmsNodes()` and selector `0xe72ee991`.
```solidity
function getKmsNodes() external view returns (KmsNode[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsNodesCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getKmsNodes()`](getKmsNodesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsNodesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<
            <KmsNode as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsNodesCall> for UnderlyingRustTuple<'_> {
                fn from(value: getKmsNodesCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getKmsNodesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Array<KmsNode>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    <KmsNode as alloy::sol_types::SolType>::RustType,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsNodesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getKmsNodesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getKmsNodesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsNodesCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsNodesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Array<KmsNode>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsNodes()";
            const SELECTOR: [u8; 4] = [231u8, 46u8, 233u8, 145u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getKmsSigners()` and selector `0x7eaac8f2`.
```solidity
function getKmsSigners() external view returns (address[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsSignersCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getKmsSigners()`](getKmsSignersCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsSignersReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsSignersCall> for UnderlyingRustTuple<'_> {
                fn from(value: getKmsSignersCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getKmsSignersCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsSignersReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getKmsSignersReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getKmsSignersReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsSignersCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsSignersReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsSigners()";
            const SELECTOR: [u8; 4] = [126u8, 170u8, 200u8, 242u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getKmsTxSenders()` and selector `0x7420f3d4`.
```solidity
function getKmsTxSenders() external view returns (address[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsTxSendersCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getKmsTxSenders()`](getKmsTxSendersCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsTxSendersReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsTxSendersCall> for UnderlyingRustTuple<'_> {
                fn from(value: getKmsTxSendersCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getKmsTxSendersCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsTxSendersReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsTxSendersReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsTxSendersReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsTxSendersCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsTxSendersReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsTxSenders()";
            const SELECTOR: [u8; 4] = [116u8, 32u8, 243u8, 212u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getPublicDecryptionThresholdFromContext(uint256)` and selector `0xb8715d4d`.
```solidity
function getPublicDecryptionThresholdFromContext(uint256 contextId) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPublicDecryptionThresholdFromContextCall {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getPublicDecryptionThresholdFromContext(uint256)`](getPublicDecryptionThresholdFromContextCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPublicDecryptionThresholdFromContextReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPublicDecryptionThresholdFromContextCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPublicDecryptionThresholdFromContextCall) -> Self {
                    (value.contextId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPublicDecryptionThresholdFromContextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { contextId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPublicDecryptionThresholdFromContextReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPublicDecryptionThresholdFromContextReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPublicDecryptionThresholdFromContextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPublicDecryptionThresholdFromContextCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPublicDecryptionThresholdFromContextReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPublicDecryptionThresholdFromContext(uint256)";
            const SELECTOR: [u8; 4] = [184u8, 113u8, 93u8, 77u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getSuspendedKmsContextId()` and selector `0x0a50e318`.
```solidity
function getSuspendedKmsContextId() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSuspendedKmsContextIdCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getSuspendedKmsContextId()`](getSuspendedKmsContextIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSuspendedKmsContextIdReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSuspendedKmsContextIdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getSuspendedKmsContextIdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getSuspendedKmsContextIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSuspendedKmsContextIdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getSuspendedKmsContextIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getSuspendedKmsContextIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getSuspendedKmsContextIdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getSuspendedKmsContextIdReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getSuspendedKmsContextId()";
            const SELECTOR: [u8; 4] = [10u8, 80u8, 227u8, 24u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getUserDecryptionThresholdFromContext(uint256)` and selector `0x64b00cc5`.
```solidity
function getUserDecryptionThresholdFromContext(uint256 contextId) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUserDecryptionThresholdFromContextCall {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getUserDecryptionThresholdFromContext(uint256)`](getUserDecryptionThresholdFromContextCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUserDecryptionThresholdFromContextReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUserDecryptionThresholdFromContextCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getUserDecryptionThresholdFromContextCall) -> Self {
                    (value.contextId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getUserDecryptionThresholdFromContextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { contextId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUserDecryptionThresholdFromContextReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getUserDecryptionThresholdFromContextReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getUserDecryptionThresholdFromContextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getUserDecryptionThresholdFromContextCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getUserDecryptionThresholdFromContextReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getUserDecryptionThresholdFromContext(uint256)";
            const SELECTOR: [u8; 4] = [100u8, 176u8, 12u8, 197u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getVersion()` and selector `0x0d8e6e2c`.
```solidity
function getVersion() external pure returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVersionCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getVersion()`](getVersionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVersionReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVersionCall> for UnderlyingRustTuple<'_> {
                fn from(value: getVersionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVersionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVersionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getVersionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVersionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getVersionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getVersionReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getVersion()";
            const SELECTOR: [u8; 4] = [13u8, 142u8, 110u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `initializeFromEmptyProxy((uint256,uint256),(uint256,uint256,uint256),bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[])` and selector `0x6a1d51eb`.
```solidity
function initializeFromEmptyProxy(DecryptionThresholds memory initialDecryptionThresholds, KmsBlockPeriods memory initialBlockPeriods, bytes8 initialSoftwareVersion, uint256 initialMpcThreshold, KmsNode[] memory initialKmsNodes) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeFromEmptyProxyCall {
        #[allow(missing_docs)]
        pub initialDecryptionThresholds: <DecryptionThresholds as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub initialBlockPeriods: <KmsBlockPeriods as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub initialSoftwareVersion: alloy::sol_types::private::FixedBytes<8>,
        #[allow(missing_docs)]
        pub initialMpcThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub initialKmsNodes: alloy::sol_types::private::Vec<
            <KmsNode as alloy::sol_types::SolType>::RustType,
        >,
    }
    ///Container type for the return parameters of the [`initializeFromEmptyProxy((uint256,uint256),(uint256,uint256,uint256),bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[])`](initializeFromEmptyProxyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeFromEmptyProxyReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                DecryptionThresholds,
                KmsBlockPeriods,
                alloy::sol_types::sol_data::FixedBytes<8>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<KmsNode>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <DecryptionThresholds as alloy::sol_types::SolType>::RustType,
                <KmsBlockPeriods as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<8>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Vec<
                    <KmsNode as alloy::sol_types::SolType>::RustType,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeFromEmptyProxyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeFromEmptyProxyCall) -> Self {
                    (
                        value.initialDecryptionThresholds,
                        value.initialBlockPeriods,
                        value.initialSoftwareVersion,
                        value.initialMpcThreshold,
                        value.initialKmsNodes,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeFromEmptyProxyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        initialDecryptionThresholds: tuple.0,
                        initialBlockPeriods: tuple.1,
                        initialSoftwareVersion: tuple.2,
                        initialMpcThreshold: tuple.3,
                        initialKmsNodes: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeFromEmptyProxyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: initializeFromEmptyProxyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initializeFromEmptyProxyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeFromEmptyProxyCall {
            type Parameters<'a> = (
                DecryptionThresholds,
                KmsBlockPeriods,
                alloy::sol_types::sol_data::FixedBytes<8>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<KmsNode>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeFromEmptyProxyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initializeFromEmptyProxy((uint256,uint256),(uint256,uint256,uint256),bytes8,uint256,(string,address,address,uint256,bytes,string,string,bytes)[])";
            const SELECTOR: [u8; 4] = [106u8, 29u8, 81u8, 235u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <DecryptionThresholds as alloy_sol_types::SolType>::tokenize(
                        &self.initialDecryptionThresholds,
                    ),
                    <KmsBlockPeriods as alloy_sol_types::SolType>::tokenize(
                        &self.initialBlockPeriods,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.initialSoftwareVersion,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.initialMpcThreshold),
                    <alloy::sol_types::sol_data::Array<
                        KmsNode,
                    > as alloy_sol_types::SolType>::tokenize(&self.initialKmsNodes),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `moveSuspendedKmsContextToActive()` and selector `0xf27cb957`.
```solidity
function moveSuspendedKmsContextToActive() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct moveSuspendedKmsContextToActiveCall {}
    ///Container type for the return parameters of the [`moveSuspendedKmsContextToActive()`](moveSuspendedKmsContextToActiveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct moveSuspendedKmsContextToActiveReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<moveSuspendedKmsContextToActiveCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: moveSuspendedKmsContextToActiveCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for moveSuspendedKmsContextToActiveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<moveSuspendedKmsContextToActiveReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: moveSuspendedKmsContextToActiveReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for moveSuspendedKmsContextToActiveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for moveSuspendedKmsContextToActiveCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = moveSuspendedKmsContextToActiveReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "moveSuspendedKmsContextToActive()";
            const SELECTOR: [u8; 4] = [242u8, 124u8, 185u8, 87u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ownerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `pause()` and selector `0x8456cb59`.
```solidity
function pause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseCall {}
    ///Container type for the return parameters of the [`pause()`](pauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pause()";
            const SELECTOR: [u8; 4] = [132u8, 86u8, 203u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `paused()` and selector `0x5c975abb`.
```solidity
function paused() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`paused()`](pausedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedCall> for UnderlyingRustTuple<'_> {
                fn from(value: pausedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pausedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pausedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pausedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "paused()";
            const SELECTOR: [u8; 4] = [92u8, 151u8, 90u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `pendingOwner()` and selector `0xe30c3978`.
```solidity
function pendingOwner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingOwnerCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`pendingOwner()`](pendingOwnerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingOwnerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingOwnerCall> for UnderlyingRustTuple<'_> {
                fn from(value: pendingOwnerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pendingOwnerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingOwnerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pendingOwnerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pendingOwnerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pendingOwnerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pendingOwnerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pendingOwner()";
            const SELECTOR: [u8; 4] = [227u8, 12u8, 57u8, 120u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `proxiableUUID()` and selector `0x52d1902d`.
```solidity
function proxiableUUID() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDCall {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`proxiableUUID()`](proxiableUUIDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDCall> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proxiableUUIDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = proxiableUUIDReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "proxiableUUID()";
            const SELECTOR: [u8; 4] = [82u8, 209u8, 144u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `refreshKmsContextStatuses()` and selector `0x8cb96751`.
```solidity
function refreshKmsContextStatuses() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct refreshKmsContextStatusesCall {}
    ///Container type for the return parameters of the [`refreshKmsContextStatuses()`](refreshKmsContextStatusesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct refreshKmsContextStatusesReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<refreshKmsContextStatusesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: refreshKmsContextStatusesCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for refreshKmsContextStatusesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<refreshKmsContextStatusesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: refreshKmsContextStatusesReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for refreshKmsContextStatusesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for refreshKmsContextStatusesCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = refreshKmsContextStatusesReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "refreshKmsContextStatuses()";
            const SELECTOR: [u8; 4] = [140u8, 185u8, 103u8, 81u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `renounceOwnership()` and selector `0x715018a6`.
```solidity
function renounceOwnership() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall {}
    ///Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address newOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `unpause()` and selector `0x3f4ba83a`.
```solidity
function unpause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseCall {}
    ///Container type for the return parameters of the [`unpause()`](unpauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unpauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = unpauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unpause()";
            const SELECTOR: [u8; 4] = [63u8, 75u8, 168u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `updateKmsContextGenerationBlockPeriod(uint256)` and selector `0xe24ba4e5`.
```solidity
function updateKmsContextGenerationBlockPeriod(uint256 newKmsContextGenerationBlockPeriod) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateKmsContextGenerationBlockPeriodCall {
        #[allow(missing_docs)]
        pub newKmsContextGenerationBlockPeriod: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`updateKmsContextGenerationBlockPeriod(uint256)`](updateKmsContextGenerationBlockPeriodCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateKmsContextGenerationBlockPeriodReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateKmsContextGenerationBlockPeriodCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateKmsContextGenerationBlockPeriodCall) -> Self {
                    (value.newKmsContextGenerationBlockPeriod,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateKmsContextGenerationBlockPeriodCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newKmsContextGenerationBlockPeriod: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateKmsContextGenerationBlockPeriodReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateKmsContextGenerationBlockPeriodReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateKmsContextGenerationBlockPeriodReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateKmsContextGenerationBlockPeriodCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateKmsContextGenerationBlockPeriodReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateKmsContextGenerationBlockPeriod(uint256)";
            const SELECTOR: [u8; 4] = [226u8, 75u8, 164u8, 229u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.newKmsContextGenerationBlockPeriod,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `updateKmsContextSuspensionBlockPeriod(uint256)` and selector `0xc1c8b725`.
```solidity
function updateKmsContextSuspensionBlockPeriod(uint256 newKmsContextSuspensionBlockPeriod) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateKmsContextSuspensionBlockPeriodCall {
        #[allow(missing_docs)]
        pub newKmsContextSuspensionBlockPeriod: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`updateKmsContextSuspensionBlockPeriod(uint256)`](updateKmsContextSuspensionBlockPeriodCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateKmsContextSuspensionBlockPeriodReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateKmsContextSuspensionBlockPeriodCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateKmsContextSuspensionBlockPeriodCall) -> Self {
                    (value.newKmsContextSuspensionBlockPeriod,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateKmsContextSuspensionBlockPeriodCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newKmsContextSuspensionBlockPeriod: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateKmsContextSuspensionBlockPeriodReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateKmsContextSuspensionBlockPeriodReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateKmsContextSuspensionBlockPeriodReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateKmsContextSuspensionBlockPeriodCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateKmsContextSuspensionBlockPeriodReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateKmsContextSuspensionBlockPeriod(uint256)";
            const SELECTOR: [u8; 4] = [193u8, 200u8, 183u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.newKmsContextSuspensionBlockPeriod,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `updatePublicDecryptionThreshold(uint256)` and selector `0x2e2d3a82`.
```solidity
function updatePublicDecryptionThreshold(uint256 newPublicDecryptionThreshold) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updatePublicDecryptionThresholdCall {
        #[allow(missing_docs)]
        pub newPublicDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`updatePublicDecryptionThreshold(uint256)`](updatePublicDecryptionThresholdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updatePublicDecryptionThresholdReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updatePublicDecryptionThresholdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updatePublicDecryptionThresholdCall) -> Self {
                    (value.newPublicDecryptionThreshold,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updatePublicDecryptionThresholdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newPublicDecryptionThreshold: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updatePublicDecryptionThresholdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updatePublicDecryptionThresholdReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updatePublicDecryptionThresholdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updatePublicDecryptionThresholdCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updatePublicDecryptionThresholdReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updatePublicDecryptionThreshold(uint256)";
            const SELECTOR: [u8; 4] = [46u8, 45u8, 58u8, 130u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.newPublicDecryptionThreshold,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `updateUserDecryptionThreshold(uint256)` and selector `0xeb843cf6`.
```solidity
function updateUserDecryptionThreshold(uint256 newUserDecryptionThreshold) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateUserDecryptionThresholdCall {
        #[allow(missing_docs)]
        pub newUserDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`updateUserDecryptionThreshold(uint256)`](updateUserDecryptionThresholdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateUserDecryptionThresholdReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateUserDecryptionThresholdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateUserDecryptionThresholdCall) -> Self {
                    (value.newUserDecryptionThreshold,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateUserDecryptionThresholdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newUserDecryptionThreshold: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateUserDecryptionThresholdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateUserDecryptionThresholdReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateUserDecryptionThresholdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateUserDecryptionThresholdCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateUserDecryptionThresholdReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateUserDecryptionThreshold(uint256)";
            const SELECTOR: [u8; 4] = [235u8, 132u8, 60u8, 246u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.newUserDecryptionThreshold,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `upgradeToAndCall(address,bytes)` and selector `0x4f1ef286`.
```solidity
function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallCall {
        #[allow(missing_docs)]
        pub newImplementation: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`upgradeToAndCall(address,bytes)`](upgradeToAndCallCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallCall) -> Self {
                    (value.newImplementation, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newImplementation: tuple.0,
                        data: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for upgradeToAndCallCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = upgradeToAndCallReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "upgradeToAndCall(address,bytes)";
            const SELECTOR: [u8; 4] = [79u8, 30u8, 242u8, 134u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newImplementation,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `validateKeyResharing(uint256,bytes)` and selector `0x1079ebeb`.
```solidity
function validateKeyResharing(uint256 contextId, bytes memory signature) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct validateKeyResharingCall {
        #[allow(missing_docs)]
        pub contextId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub signature: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`validateKeyResharing(uint256,bytes)`](validateKeyResharingCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct validateKeyResharingReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<validateKeyResharingCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: validateKeyResharingCall) -> Self {
                    (value.contextId, value.signature)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for validateKeyResharingCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        contextId: tuple.0,
                        signature: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<validateKeyResharingReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: validateKeyResharingReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for validateKeyResharingReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for validateKeyResharingCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = validateKeyResharingReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "validateKeyResharing(uint256,bytes)";
            const SELECTOR: [u8; 4] = [16u8, 121u8, 235u8, 235u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.contextId),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.signature,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`KmsContexts`](self) function calls.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum KmsContextsCalls {
        #[allow(missing_docs)]
        UPGRADE_INTERFACE_VERSION(UPGRADE_INTERFACE_VERSIONCall),
        #[allow(missing_docs)]
        acceptOwnership(acceptOwnershipCall),
        #[allow(missing_docs)]
        addKmsContext(addKmsContextCall),
        #[allow(missing_docs)]
        checkIsKmsSignerFromContext(checkIsKmsSignerFromContextCall),
        #[allow(missing_docs)]
        checkIsKmsTxSenderFromContext(checkIsKmsTxSenderFromContextCall),
        #[allow(missing_docs)]
        compromiseKmsContext(compromiseKmsContextCall),
        #[allow(missing_docs)]
        destroyKmsContext(destroyKmsContextCall),
        #[allow(missing_docs)]
        eip712Domain(eip712DomainCall),
        #[allow(missing_docs)]
        getActiveKmsContext(getActiveKmsContextCall),
        #[allow(missing_docs)]
        getActiveKmsContextId(getActiveKmsContextIdCall),
        #[allow(missing_docs)]
        getKmsContextGenerationBlockPeriod(getKmsContextGenerationBlockPeriodCall),
        #[allow(missing_docs)]
        getKmsContextStatus(getKmsContextStatusCall),
        #[allow(missing_docs)]
        getKmsContextSuspensionBlockPeriod(getKmsContextSuspensionBlockPeriodCall),
        #[allow(missing_docs)]
        getKmsNode(getKmsNodeCall),
        #[allow(missing_docs)]
        getKmsNodes(getKmsNodesCall),
        #[allow(missing_docs)]
        getKmsSigners(getKmsSignersCall),
        #[allow(missing_docs)]
        getKmsTxSenders(getKmsTxSendersCall),
        #[allow(missing_docs)]
        getPublicDecryptionThresholdFromContext(
            getPublicDecryptionThresholdFromContextCall,
        ),
        #[allow(missing_docs)]
        getSuspendedKmsContextId(getSuspendedKmsContextIdCall),
        #[allow(missing_docs)]
        getUserDecryptionThresholdFromContext(getUserDecryptionThresholdFromContextCall),
        #[allow(missing_docs)]
        getVersion(getVersionCall),
        #[allow(missing_docs)]
        initializeFromEmptyProxy(initializeFromEmptyProxyCall),
        #[allow(missing_docs)]
        moveSuspendedKmsContextToActive(moveSuspendedKmsContextToActiveCall),
        #[allow(missing_docs)]
        owner(ownerCall),
        #[allow(missing_docs)]
        pause(pauseCall),
        #[allow(missing_docs)]
        paused(pausedCall),
        #[allow(missing_docs)]
        pendingOwner(pendingOwnerCall),
        #[allow(missing_docs)]
        proxiableUUID(proxiableUUIDCall),
        #[allow(missing_docs)]
        refreshKmsContextStatuses(refreshKmsContextStatusesCall),
        #[allow(missing_docs)]
        renounceOwnership(renounceOwnershipCall),
        #[allow(missing_docs)]
        transferOwnership(transferOwnershipCall),
        #[allow(missing_docs)]
        unpause(unpauseCall),
        #[allow(missing_docs)]
        updateKmsContextGenerationBlockPeriod(updateKmsContextGenerationBlockPeriodCall),
        #[allow(missing_docs)]
        updateKmsContextSuspensionBlockPeriod(updateKmsContextSuspensionBlockPeriodCall),
        #[allow(missing_docs)]
        updatePublicDecryptionThreshold(updatePublicDecryptionThresholdCall),
        #[allow(missing_docs)]
        updateUserDecryptionThreshold(updateUserDecryptionThresholdCall),
        #[allow(missing_docs)]
        upgradeToAndCall(upgradeToAndCallCall),
        #[allow(missing_docs)]
        validateKeyResharing(validateKeyResharingCall),
    }
    #[automatically_derived]
    impl KmsContextsCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [10u8, 80u8, 227u8, 24u8],
            [13u8, 142u8, 110u8, 44u8],
            [13u8, 212u8, 134u8, 192u8],
            [16u8, 121u8, 235u8, 235u8],
            [22u8, 156u8, 172u8, 20u8],
            [46u8, 45u8, 58u8, 130u8],
            [63u8, 75u8, 168u8, 58u8],
            [67u8, 227u8, 126u8, 138u8],
            [73u8, 101u8, 228u8, 85u8],
            [77u8, 105u8, 66u8, 96u8],
            [79u8, 30u8, 242u8, 134u8],
            [82u8, 209u8, 144u8, 45u8],
            [92u8, 151u8, 90u8, 187u8],
            [100u8, 176u8, 12u8, 197u8],
            [106u8, 29u8, 81u8, 235u8],
            [113u8, 80u8, 24u8, 166u8],
            [116u8, 32u8, 243u8, 212u8],
            [121u8, 186u8, 80u8, 151u8],
            [126u8, 170u8, 200u8, 242u8],
            [132u8, 86u8, 203u8, 89u8],
            [132u8, 176u8, 25u8, 110u8],
            [140u8, 185u8, 103u8, 81u8],
            [141u8, 165u8, 203u8, 91u8],
            [158u8, 231u8, 122u8, 243u8],
            [173u8, 60u8, 177u8, 204u8],
            [184u8, 113u8, 93u8, 77u8],
            [192u8, 174u8, 100u8, 247u8],
            [193u8, 200u8, 183u8, 37u8],
            [216u8, 227u8, 174u8, 1u8],
            [222u8, 251u8, 160u8, 106u8],
            [223u8, 227u8, 106u8, 238u8],
            [226u8, 75u8, 164u8, 229u8],
            [227u8, 12u8, 57u8, 120u8],
            [227u8, 178u8, 168u8, 116u8],
            [231u8, 46u8, 233u8, 145u8],
            [235u8, 132u8, 60u8, 246u8],
            [242u8, 124u8, 185u8, 87u8],
            [242u8, 253u8, 227u8, 139u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for KmsContextsCalls {
        const NAME: &'static str = "KmsContextsCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 38usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(_) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::acceptOwnership(_) => {
                    <acceptOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::addKmsContext(_) => {
                    <addKmsContextCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkIsKmsSignerFromContext(_) => {
                    <checkIsKmsSignerFromContextCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkIsKmsTxSenderFromContext(_) => {
                    <checkIsKmsTxSenderFromContextCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::compromiseKmsContext(_) => {
                    <compromiseKmsContextCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::destroyKmsContext(_) => {
                    <destroyKmsContextCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::eip712Domain(_) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getActiveKmsContext(_) => {
                    <getActiveKmsContextCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getActiveKmsContextId(_) => {
                    <getActiveKmsContextIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsContextGenerationBlockPeriod(_) => {
                    <getKmsContextGenerationBlockPeriodCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsContextStatus(_) => {
                    <getKmsContextStatusCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsContextSuspensionBlockPeriod(_) => {
                    <getKmsContextSuspensionBlockPeriodCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsNode(_) => {
                    <getKmsNodeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsNodes(_) => {
                    <getKmsNodesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsSigners(_) => {
                    <getKmsSignersCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsTxSenders(_) => {
                    <getKmsTxSendersCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPublicDecryptionThresholdFromContext(_) => {
                    <getPublicDecryptionThresholdFromContextCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getSuspendedKmsContextId(_) => {
                    <getSuspendedKmsContextIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getUserDecryptionThresholdFromContext(_) => {
                    <getUserDecryptionThresholdFromContextCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getVersion(_) => {
                    <getVersionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initializeFromEmptyProxy(_) => {
                    <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::moveSuspendedKmsContextToActive(_) => {
                    <moveSuspendedKmsContextToActiveCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pause(_) => <pauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::paused(_) => <pausedCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pendingOwner(_) => {
                    <pendingOwnerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::proxiableUUID(_) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::refreshKmsContextStatuses(_) => {
                    <refreshKmsContextStatusesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceOwnership(_) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::unpause(_) => <unpauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::updateKmsContextGenerationBlockPeriod(_) => {
                    <updateKmsContextGenerationBlockPeriodCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateKmsContextSuspensionBlockPeriod(_) => {
                    <updateKmsContextSuspensionBlockPeriodCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updatePublicDecryptionThreshold(_) => {
                    <updatePublicDecryptionThresholdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateUserDecryptionThreshold(_) => {
                    <updateUserDecryptionThresholdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::upgradeToAndCall(_) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::validateKeyResharing(_) => {
                    <validateKeyResharingCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<KmsContextsCalls>] = &[
                {
                    fn getSuspendedKmsContextId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getSuspendedKmsContextIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getSuspendedKmsContextId)
                    }
                    getSuspendedKmsContextId
                },
                {
                    fn getVersion(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getVersionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getVersion)
                    }
                    getVersion
                },
                {
                    fn getActiveKmsContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getActiveKmsContextCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getActiveKmsContext)
                    }
                    getActiveKmsContext
                },
                {
                    fn validateKeyResharing(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <validateKeyResharingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::validateKeyResharing)
                    }
                    validateKeyResharing
                },
                {
                    fn addKmsContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <addKmsContextCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::addKmsContext)
                    }
                    addKmsContext
                },
                {
                    fn updatePublicDecryptionThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <updatePublicDecryptionThresholdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::updatePublicDecryptionThreshold)
                    }
                    updatePublicDecryptionThreshold
                },
                {
                    fn unpause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <unpauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::unpause)
                    }
                    unpause
                },
                {
                    fn getActiveKmsContextId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getActiveKmsContextIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getActiveKmsContextId)
                    }
                    getActiveKmsContextId
                },
                {
                    fn getKmsContextGenerationBlockPeriod(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getKmsContextGenerationBlockPeriodCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getKmsContextGenerationBlockPeriod)
                    }
                    getKmsContextGenerationBlockPeriod
                },
                {
                    fn getKmsContextStatus(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getKmsContextStatusCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getKmsContextStatus)
                    }
                    getKmsContextStatus
                },
                {
                    fn upgradeToAndCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::upgradeToAndCall)
                    }
                    upgradeToAndCall
                },
                {
                    fn proxiableUUID(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::proxiableUUID)
                    }
                    proxiableUUID
                },
                {
                    fn paused(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <pausedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::paused)
                    }
                    paused
                },
                {
                    fn getUserDecryptionThresholdFromContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getUserDecryptionThresholdFromContextCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getUserDecryptionThresholdFromContext)
                    }
                    getUserDecryptionThresholdFromContext
                },
                {
                    fn initializeFromEmptyProxy(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::initializeFromEmptyProxy)
                    }
                    initializeFromEmptyProxy
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn getKmsTxSenders(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getKmsTxSendersCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getKmsTxSenders)
                    }
                    getKmsTxSenders
                },
                {
                    fn acceptOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <acceptOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::acceptOwnership)
                    }
                    acceptOwnership
                },
                {
                    fn getKmsSigners(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getKmsSignersCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getKmsSigners)
                    }
                    getKmsSigners
                },
                {
                    fn pause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::pause)
                    }
                    pause
                },
                {
                    fn eip712Domain(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <eip712DomainCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::eip712Domain)
                    }
                    eip712Domain
                },
                {
                    fn refreshKmsContextStatuses(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <refreshKmsContextStatusesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::refreshKmsContextStatuses)
                    }
                    refreshKmsContextStatuses
                },
                {
                    fn owner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::owner)
                    }
                    owner
                },
                {
                    fn compromiseKmsContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <compromiseKmsContextCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::compromiseKmsContext)
                    }
                    compromiseKmsContext
                },
                {
                    fn UPGRADE_INTERFACE_VERSION(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::UPGRADE_INTERFACE_VERSION)
                    }
                    UPGRADE_INTERFACE_VERSION
                },
                {
                    fn getPublicDecryptionThresholdFromContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getPublicDecryptionThresholdFromContextCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                KmsContextsCalls::getPublicDecryptionThresholdFromContext,
                            )
                    }
                    getPublicDecryptionThresholdFromContext
                },
                {
                    fn destroyKmsContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <destroyKmsContextCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::destroyKmsContext)
                    }
                    destroyKmsContext
                },
                {
                    fn updateKmsContextSuspensionBlockPeriod(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <updateKmsContextSuspensionBlockPeriodCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::updateKmsContextSuspensionBlockPeriod)
                    }
                    updateKmsContextSuspensionBlockPeriod
                },
                {
                    fn getKmsContextSuspensionBlockPeriod(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getKmsContextSuspensionBlockPeriodCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getKmsContextSuspensionBlockPeriod)
                    }
                    getKmsContextSuspensionBlockPeriod
                },
                {
                    fn checkIsKmsTxSenderFromContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <checkIsKmsTxSenderFromContextCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::checkIsKmsTxSenderFromContext)
                    }
                    checkIsKmsTxSenderFromContext
                },
                {
                    fn checkIsKmsSignerFromContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <checkIsKmsSignerFromContextCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::checkIsKmsSignerFromContext)
                    }
                    checkIsKmsSignerFromContext
                },
                {
                    fn updateKmsContextGenerationBlockPeriod(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <updateKmsContextGenerationBlockPeriodCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::updateKmsContextGenerationBlockPeriod)
                    }
                    updateKmsContextGenerationBlockPeriod
                },
                {
                    fn pendingOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <pendingOwnerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::pendingOwner)
                    }
                    pendingOwner
                },
                {
                    fn getKmsNode(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getKmsNodeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getKmsNode)
                    }
                    getKmsNode
                },
                {
                    fn getKmsNodes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <getKmsNodesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::getKmsNodes)
                    }
                    getKmsNodes
                },
                {
                    fn updateUserDecryptionThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <updateUserDecryptionThresholdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::updateUserDecryptionThreshold)
                    }
                    updateUserDecryptionThreshold
                },
                {
                    fn moveSuspendedKmsContextToActive(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <moveSuspendedKmsContextToActiveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::moveSuspendedKmsContextToActive)
                    }
                    moveSuspendedKmsContextToActive
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsCalls::transferOwnership)
                    }
                    transferOwnership
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::acceptOwnership(inner) => {
                    <acceptOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::addKmsContext(inner) => {
                    <addKmsContextCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkIsKmsSignerFromContext(inner) => {
                    <checkIsKmsSignerFromContextCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkIsKmsTxSenderFromContext(inner) => {
                    <checkIsKmsTxSenderFromContextCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::compromiseKmsContext(inner) => {
                    <compromiseKmsContextCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::destroyKmsContext(inner) => {
                    <destroyKmsContextCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::eip712Domain(inner) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getActiveKmsContext(inner) => {
                    <getActiveKmsContextCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getActiveKmsContextId(inner) => {
                    <getActiveKmsContextIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKmsContextGenerationBlockPeriod(inner) => {
                    <getKmsContextGenerationBlockPeriodCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKmsContextStatus(inner) => {
                    <getKmsContextStatusCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKmsContextSuspensionBlockPeriod(inner) => {
                    <getKmsContextSuspensionBlockPeriodCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKmsNode(inner) => {
                    <getKmsNodeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getKmsNodes(inner) => {
                    <getKmsNodesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKmsSigners(inner) => {
                    <getKmsSignersCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKmsTxSenders(inner) => {
                    <getKmsTxSendersCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPublicDecryptionThresholdFromContext(inner) => {
                    <getPublicDecryptionThresholdFromContextCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getSuspendedKmsContextId(inner) => {
                    <getSuspendedKmsContextIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getUserDecryptionThresholdFromContext(inner) => {
                    <getUserDecryptionThresholdFromContextCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getVersion(inner) => {
                    <getVersionCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::initializeFromEmptyProxy(inner) => {
                    <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::moveSuspendedKmsContextToActive(inner) => {
                    <moveSuspendedKmsContextToActiveCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pendingOwner(inner) => {
                    <pendingOwnerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::refreshKmsContextStatuses(inner) => {
                    <refreshKmsContextStatusesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::updateKmsContextGenerationBlockPeriod(inner) => {
                    <updateKmsContextGenerationBlockPeriodCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateKmsContextSuspensionBlockPeriod(inner) => {
                    <updateKmsContextSuspensionBlockPeriodCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updatePublicDecryptionThreshold(inner) => {
                    <updatePublicDecryptionThresholdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateUserDecryptionThreshold(inner) => {
                    <updateUserDecryptionThresholdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::validateKeyResharing(inner) => {
                    <validateKeyResharingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::acceptOwnership(inner) => {
                    <acceptOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::addKmsContext(inner) => {
                    <addKmsContextCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkIsKmsSignerFromContext(inner) => {
                    <checkIsKmsSignerFromContextCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkIsKmsTxSenderFromContext(inner) => {
                    <checkIsKmsTxSenderFromContextCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::compromiseKmsContext(inner) => {
                    <compromiseKmsContextCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::destroyKmsContext(inner) => {
                    <destroyKmsContextCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::eip712Domain(inner) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getActiveKmsContext(inner) => {
                    <getActiveKmsContextCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getActiveKmsContextId(inner) => {
                    <getActiveKmsContextIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsContextGenerationBlockPeriod(inner) => {
                    <getKmsContextGenerationBlockPeriodCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsContextStatus(inner) => {
                    <getKmsContextStatusCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsContextSuspensionBlockPeriod(inner) => {
                    <getKmsContextSuspensionBlockPeriodCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsNode(inner) => {
                    <getKmsNodeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsNodes(inner) => {
                    <getKmsNodesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsSigners(inner) => {
                    <getKmsSignersCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsTxSenders(inner) => {
                    <getKmsTxSendersCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPublicDecryptionThresholdFromContext(inner) => {
                    <getPublicDecryptionThresholdFromContextCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getSuspendedKmsContextId(inner) => {
                    <getSuspendedKmsContextIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getUserDecryptionThresholdFromContext(inner) => {
                    <getUserDecryptionThresholdFromContextCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getVersion(inner) => {
                    <getVersionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initializeFromEmptyProxy(inner) => {
                    <initializeFromEmptyProxyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::moveSuspendedKmsContextToActive(inner) => {
                    <moveSuspendedKmsContextToActiveCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pendingOwner(inner) => {
                    <pendingOwnerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::refreshKmsContextStatuses(inner) => {
                    <refreshKmsContextStatusesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::updateKmsContextGenerationBlockPeriod(inner) => {
                    <updateKmsContextGenerationBlockPeriodCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateKmsContextSuspensionBlockPeriod(inner) => {
                    <updateKmsContextSuspensionBlockPeriodCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updatePublicDecryptionThreshold(inner) => {
                    <updatePublicDecryptionThresholdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateUserDecryptionThreshold(inner) => {
                    <updateUserDecryptionThresholdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::validateKeyResharing(inner) => {
                    <validateKeyResharingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`KmsContexts`](self) custom errors.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum KmsContextsErrors {
        #[allow(missing_docs)]
        AddressEmptyCode(AddressEmptyCode),
        #[allow(missing_docs)]
        CompromiseActiveKmsContextNotAllowed(CompromiseActiveKmsContextNotAllowed),
        #[allow(missing_docs)]
        ContextAlreadyExists(ContextAlreadyExists),
        #[allow(missing_docs)]
        ContextNotActive(ContextNotActive),
        #[allow(missing_docs)]
        ContextNotActiveOrSuspended(ContextNotActiveOrSuspended),
        #[allow(missing_docs)]
        ContextNotGenerated(ContextNotGenerated),
        #[allow(missing_docs)]
        ContextNotInitializedOrIsGenerating(ContextNotInitializedOrIsGenerating),
        #[allow(missing_docs)]
        ContextNotPreActivatedOrSuspended(ContextNotPreActivatedOrSuspended),
        #[allow(missing_docs)]
        DestroyActiveKmsContextNotAllowed(DestroyActiveKmsContextNotAllowed),
        #[allow(missing_docs)]
        ECDSAInvalidSignature(ECDSAInvalidSignature),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureLength(ECDSAInvalidSignatureLength),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureS(ECDSAInvalidSignatureS),
        #[allow(missing_docs)]
        ERC1967InvalidImplementation(ERC1967InvalidImplementation),
        #[allow(missing_docs)]
        ERC1967NonPayable(ERC1967NonPayable),
        #[allow(missing_docs)]
        EmptyKmsNodes(EmptyKmsNodes),
        #[allow(missing_docs)]
        EnforcedPause(EnforcedPause),
        #[allow(missing_docs)]
        ExpectedPause(ExpectedPause),
        #[allow(missing_docs)]
        FailedCall(FailedCall),
        #[allow(missing_docs)]
        InvalidHighMpcThreshold(InvalidHighMpcThreshold),
        #[allow(missing_docs)]
        InvalidHighPublicDecryptionThreshold(InvalidHighPublicDecryptionThreshold),
        #[allow(missing_docs)]
        InvalidHighUserDecryptionThreshold(InvalidHighUserDecryptionThreshold),
        #[allow(missing_docs)]
        InvalidInitialization(InvalidInitialization),
        #[allow(missing_docs)]
        InvalidNullContextId(InvalidNullContextId),
        #[allow(missing_docs)]
        InvalidNullPublicDecryptionThreshold(InvalidNullPublicDecryptionThreshold),
        #[allow(missing_docs)]
        InvalidNullUserDecryptionThreshold(InvalidNullUserDecryptionThreshold),
        #[allow(missing_docs)]
        KmsContextNotGenerating(KmsContextNotGenerating),
        #[allow(missing_docs)]
        KmsContextNotInitialized(KmsContextNotInitialized),
        #[allow(missing_docs)]
        KmsNodeAlreadyValidatedKeyResharing(KmsNodeAlreadyValidatedKeyResharing),
        #[allow(missing_docs)]
        NoSuspendedKmsContext(NoSuspendedKmsContext),
        #[allow(missing_docs)]
        NotInitializing(NotInitializing),
        #[allow(missing_docs)]
        NotInitializingFromEmptyProxy(NotInitializingFromEmptyProxy),
        #[allow(missing_docs)]
        NotKmsNodeFromContext(NotKmsNodeFromContext),
        #[allow(missing_docs)]
        NotKmsSignerFromContext(NotKmsSignerFromContext),
        #[allow(missing_docs)]
        NotKmsTxSenderFromContext(NotKmsTxSenderFromContext),
        #[allow(missing_docs)]
        NotOwnerOrPauser(NotOwnerOrPauser),
        #[allow(missing_docs)]
        NumberOfKmsNodesChanged(NumberOfKmsNodesChanged),
        #[allow(missing_docs)]
        OwnableInvalidOwner(OwnableInvalidOwner),
        #[allow(missing_docs)]
        OwnableUnauthorizedAccount(OwnableUnauthorizedAccount),
        #[allow(missing_docs)]
        SuspendedKmsContextOngoing(SuspendedKmsContextOngoing),
        #[allow(missing_docs)]
        UUPSUnauthorizedCallContext(UUPSUnauthorizedCallContext),
        #[allow(missing_docs)]
        UUPSUnsupportedProxiableUUID(UUPSUnsupportedProxiableUUID),
    }
    #[automatically_derived]
    impl KmsContextsErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [4u8, 148u8, 211u8, 192u8],
            [6u8, 140u8, 141u8, 64u8],
            [17u8, 140u8, 218u8, 167u8],
            [18u8, 180u8, 158u8, 61u8],
            [30u8, 79u8, 189u8, 247u8],
            [32u8, 126u8, 163u8, 243u8],
            [43u8, 54u8, 82u8, 209u8],
            [51u8, 20u8, 134u8, 179u8],
            [70u8, 192u8, 217u8, 175u8],
            [76u8, 156u8, 140u8, 227u8],
            [94u8, 81u8, 162u8, 225u8],
            [102u8, 83u8, 246u8, 215u8],
            [111u8, 79u8, 115u8, 31u8],
            [118u8, 35u8, 211u8, 87u8],
            [119u8, 208u8, 94u8, 167u8],
            [130u8, 177u8, 251u8, 218u8],
            [132u8, 32u8, 143u8, 35u8],
            [135u8, 137u8, 166u8, 202u8],
            [137u8, 180u8, 94u8, 93u8],
            [141u8, 252u8, 32u8, 43u8],
            [153u8, 150u8, 179u8, 21u8],
            [153u8, 177u8, 88u8, 193u8],
            [170u8, 29u8, 73u8, 164u8],
            [176u8, 197u8, 21u8, 29u8],
            [177u8, 174u8, 146u8, 234u8],
            [178u8, 94u8, 78u8, 179u8],
            [179u8, 152u8, 151u8, 159u8],
            [192u8, 181u8, 238u8, 102u8],
            [203u8, 23u8, 183u8, 165u8],
            [210u8, 83u8, 94u8, 17u8],
            [213u8, 149u8, 169u8, 98u8],
            [214u8, 189u8, 162u8, 117u8],
            [215u8, 139u8, 206u8, 12u8],
            [215u8, 230u8, 188u8, 248u8],
            [217u8, 60u8, 6u8, 101u8],
            [224u8, 124u8, 141u8, 186u8],
            [230u8, 10u8, 114u8, 113u8],
            [246u8, 69u8, 238u8, 223u8],
            [249u8, 46u8, 232u8, 169u8],
            [252u8, 230u8, 152u8, 247u8],
            [253u8, 248u8, 160u8, 93u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for KmsContextsErrors {
        const NAME: &'static str = "KmsContextsErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 41usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AddressEmptyCode(_) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CompromiseActiveKmsContextNotAllowed(_) => {
                    <CompromiseActiveKmsContextNotAllowed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ContextAlreadyExists(_) => {
                    <ContextAlreadyExists as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ContextNotActive(_) => {
                    <ContextNotActive as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ContextNotActiveOrSuspended(_) => {
                    <ContextNotActiveOrSuspended as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ContextNotGenerated(_) => {
                    <ContextNotGenerated as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ContextNotInitializedOrIsGenerating(_) => {
                    <ContextNotInitializedOrIsGenerating as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ContextNotPreActivatedOrSuspended(_) => {
                    <ContextNotPreActivatedOrSuspended as alloy_sol_types::SolError>::SELECTOR
                }
                Self::DestroyActiveKmsContextNotAllowed(_) => {
                    <DestroyActiveKmsContextNotAllowed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignature(_) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureLength(_) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureS(_) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967InvalidImplementation(_) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967NonPayable(_) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyKmsNodes(_) => {
                    <EmptyKmsNodes as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EnforcedPause(_) => {
                    <EnforcedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ExpectedPause(_) => {
                    <ExpectedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FailedCall(_) => {
                    <FailedCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidHighMpcThreshold(_) => {
                    <InvalidHighMpcThreshold as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidHighPublicDecryptionThreshold(_) => {
                    <InvalidHighPublicDecryptionThreshold as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidHighUserDecryptionThreshold(_) => {
                    <InvalidHighUserDecryptionThreshold as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidInitialization(_) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidNullContextId(_) => {
                    <InvalidNullContextId as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidNullPublicDecryptionThreshold(_) => {
                    <InvalidNullPublicDecryptionThreshold as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidNullUserDecryptionThreshold(_) => {
                    <InvalidNullUserDecryptionThreshold as alloy_sol_types::SolError>::SELECTOR
                }
                Self::KmsContextNotGenerating(_) => {
                    <KmsContextNotGenerating as alloy_sol_types::SolError>::SELECTOR
                }
                Self::KmsContextNotInitialized(_) => {
                    <KmsContextNotInitialized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::KmsNodeAlreadyValidatedKeyResharing(_) => {
                    <KmsNodeAlreadyValidatedKeyResharing as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NoSuspendedKmsContext(_) => {
                    <NoSuspendedKmsContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotInitializing(_) => {
                    <NotInitializing as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotInitializingFromEmptyProxy(_) => {
                    <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotKmsNodeFromContext(_) => {
                    <NotKmsNodeFromContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotKmsSignerFromContext(_) => {
                    <NotKmsSignerFromContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotKmsTxSenderFromContext(_) => {
                    <NotKmsTxSenderFromContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotOwnerOrPauser(_) => {
                    <NotOwnerOrPauser as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NumberOfKmsNodesChanged(_) => {
                    <NumberOfKmsNodesChanged as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OwnableInvalidOwner(_) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OwnableUnauthorizedAccount(_) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SuspendedKmsContextOngoing(_) => {
                    <SuspendedKmsContextOngoing as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnauthorizedCallContext(_) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnsupportedProxiableUUID(_) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<KmsContextsErrors>] = &[
                {
                    fn NotKmsNodeFromContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <NotKmsNodeFromContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::NotKmsNodeFromContext)
                    }
                    NotKmsNodeFromContext
                },
                {
                    fn EmptyKmsNodes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <EmptyKmsNodes as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::EmptyKmsNodes)
                    }
                    EmptyKmsNodes
                },
                {
                    fn OwnableUnauthorizedAccount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::OwnableUnauthorizedAccount)
                    }
                    OwnableUnauthorizedAccount
                },
                {
                    fn ContextNotPreActivatedOrSuspended(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ContextNotPreActivatedOrSuspended as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ContextNotPreActivatedOrSuspended)
                    }
                    ContextNotPreActivatedOrSuspended
                },
                {
                    fn OwnableInvalidOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::OwnableInvalidOwner)
                    }
                    OwnableInvalidOwner
                },
                {
                    fn NoSuspendedKmsContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <NoSuspendedKmsContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::NoSuspendedKmsContext)
                    }
                    NoSuspendedKmsContext
                },
                {
                    fn ContextNotActiveOrSuspended(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ContextNotActiveOrSuspended as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ContextNotActiveOrSuspended)
                    }
                    ContextNotActiveOrSuspended
                },
                {
                    fn ContextNotActive(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ContextNotActive as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ContextNotActive)
                    }
                    ContextNotActive
                },
                {
                    fn NotOwnerOrPauser(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <NotOwnerOrPauser as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::NotOwnerOrPauser)
                    }
                    NotOwnerOrPauser
                },
                {
                    fn ERC1967InvalidImplementation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ERC1967InvalidImplementation)
                    }
                    ERC1967InvalidImplementation
                },
                {
                    fn KmsContextNotGenerating(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <KmsContextNotGenerating as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::KmsContextNotGenerating)
                    }
                    KmsContextNotGenerating
                },
                {
                    fn ContextAlreadyExists(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ContextAlreadyExists as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ContextAlreadyExists)
                    }
                    ContextAlreadyExists
                },
                {
                    fn NotInitializingFromEmptyProxy(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::NotInitializingFromEmptyProxy)
                    }
                    NotInitializingFromEmptyProxy
                },
                {
                    fn SuspendedKmsContextOngoing(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <SuspendedKmsContextOngoing as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::SuspendedKmsContextOngoing)
                    }
                    SuspendedKmsContextOngoing
                },
                {
                    fn CompromiseActiveKmsContextNotAllowed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <CompromiseActiveKmsContextNotAllowed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::CompromiseActiveKmsContextNotAllowed)
                    }
                    CompromiseActiveKmsContextNotAllowed
                },
                {
                    fn KmsContextNotInitialized(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <KmsContextNotInitialized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::KmsContextNotInitialized)
                    }
                    KmsContextNotInitialized
                },
                {
                    fn InvalidHighPublicDecryptionThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <InvalidHighPublicDecryptionThreshold as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::InvalidHighPublicDecryptionThreshold)
                    }
                    InvalidHighPublicDecryptionThreshold
                },
                {
                    fn InvalidHighMpcThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <InvalidHighMpcThreshold as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::InvalidHighMpcThreshold)
                    }
                    InvalidHighMpcThreshold
                },
                {
                    fn NotKmsSignerFromContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <NotKmsSignerFromContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::NotKmsSignerFromContext)
                    }
                    NotKmsSignerFromContext
                },
                {
                    fn ExpectedPause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ExpectedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ExpectedPause)
                    }
                    ExpectedPause
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn KmsNodeAlreadyValidatedKeyResharing(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <KmsNodeAlreadyValidatedKeyResharing as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::KmsNodeAlreadyValidatedKeyResharing)
                    }
                    KmsNodeAlreadyValidatedKeyResharing
                },
                {
                    fn UUPSUnsupportedProxiableUUID(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::UUPSUnsupportedProxiableUUID)
                    }
                    UUPSUnsupportedProxiableUUID
                },
                {
                    fn ContextNotInitializedOrIsGenerating(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ContextNotInitializedOrIsGenerating as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ContextNotInitializedOrIsGenerating)
                    }
                    ContextNotInitializedOrIsGenerating
                },
                {
                    fn InvalidNullPublicDecryptionThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <InvalidNullPublicDecryptionThreshold as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::InvalidNullPublicDecryptionThreshold)
                    }
                    InvalidNullPublicDecryptionThreshold
                },
                {
                    fn DestroyActiveKmsContextNotAllowed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <DestroyActiveKmsContextNotAllowed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::DestroyActiveKmsContextNotAllowed)
                    }
                    DestroyActiveKmsContextNotAllowed
                },
                {
                    fn ERC1967NonPayable(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ERC1967NonPayable as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ERC1967NonPayable)
                    }
                    ERC1967NonPayable
                },
                {
                    fn ContextNotGenerated(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ContextNotGenerated as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ContextNotGenerated)
                    }
                    ContextNotGenerated
                },
                {
                    fn InvalidNullContextId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <InvalidNullContextId as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::InvalidNullContextId)
                    }
                    InvalidNullContextId
                },
                {
                    fn InvalidHighUserDecryptionThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <InvalidHighUserDecryptionThreshold as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::InvalidHighUserDecryptionThreshold)
                    }
                    InvalidHighUserDecryptionThreshold
                },
                {
                    fn NumberOfKmsNodesChanged(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <NumberOfKmsNodesChanged as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::NumberOfKmsNodesChanged)
                    }
                    NumberOfKmsNodesChanged
                },
                {
                    fn FailedCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn ECDSAInvalidSignatureS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ECDSAInvalidSignatureS)
                    }
                    ECDSAInvalidSignatureS
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn EnforcedPause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <EnforcedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::EnforcedPause)
                    }
                    EnforcedPause
                },
                {
                    fn UUPSUnauthorizedCallContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::UUPSUnauthorizedCallContext)
                    }
                    UUPSUnauthorizedCallContext
                },
                {
                    fn InvalidNullUserDecryptionThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <InvalidNullUserDecryptionThreshold as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::InvalidNullUserDecryptionThreshold)
                    }
                    InvalidNullUserDecryptionThreshold
                },
                {
                    fn ECDSAInvalidSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ECDSAInvalidSignature)
                    }
                    ECDSAInvalidSignature
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::InvalidInitialization)
                    }
                    InvalidInitialization
                },
                {
                    fn ECDSAInvalidSignatureLength(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::ECDSAInvalidSignatureLength)
                    }
                    ECDSAInvalidSignatureLength
                },
                {
                    fn NotKmsTxSenderFromContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KmsContextsErrors> {
                        <NotKmsTxSenderFromContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KmsContextsErrors::NotKmsTxSenderFromContext)
                    }
                    NotKmsTxSenderFromContext
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CompromiseActiveKmsContextNotAllowed(inner) => {
                    <CompromiseActiveKmsContextNotAllowed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ContextAlreadyExists(inner) => {
                    <ContextAlreadyExists as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ContextNotActive(inner) => {
                    <ContextNotActive as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ContextNotActiveOrSuspended(inner) => {
                    <ContextNotActiveOrSuspended as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ContextNotGenerated(inner) => {
                    <ContextNotGenerated as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ContextNotInitializedOrIsGenerating(inner) => {
                    <ContextNotInitializedOrIsGenerating as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ContextNotPreActivatedOrSuspended(inner) => {
                    <ContextNotPreActivatedOrSuspended as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DestroyActiveKmsContextNotAllowed(inner) => {
                    <DestroyActiveKmsContextNotAllowed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyKmsNodes(inner) => {
                    <EmptyKmsNodes as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidHighMpcThreshold(inner) => {
                    <InvalidHighMpcThreshold as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidHighPublicDecryptionThreshold(inner) => {
                    <InvalidHighPublicDecryptionThreshold as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidHighUserDecryptionThreshold(inner) => {
                    <InvalidHighUserDecryptionThreshold as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidNullContextId(inner) => {
                    <InvalidNullContextId as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidNullPublicDecryptionThreshold(inner) => {
                    <InvalidNullPublicDecryptionThreshold as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidNullUserDecryptionThreshold(inner) => {
                    <InvalidNullUserDecryptionThreshold as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::KmsContextNotGenerating(inner) => {
                    <KmsContextNotGenerating as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::KmsContextNotInitialized(inner) => {
                    <KmsContextNotInitialized as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::KmsNodeAlreadyValidatedKeyResharing(inner) => {
                    <KmsNodeAlreadyValidatedKeyResharing as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NoSuspendedKmsContext(inner) => {
                    <NoSuspendedKmsContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotInitializingFromEmptyProxy(inner) => {
                    <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotKmsNodeFromContext(inner) => {
                    <NotKmsNodeFromContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotKmsSignerFromContext(inner) => {
                    <NotKmsSignerFromContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotKmsTxSenderFromContext(inner) => {
                    <NotKmsTxSenderFromContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotOwnerOrPauser(inner) => {
                    <NotOwnerOrPauser as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NumberOfKmsNodesChanged(inner) => {
                    <NumberOfKmsNodesChanged as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OwnableInvalidOwner(inner) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OwnableUnauthorizedAccount(inner) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SuspendedKmsContextOngoing(inner) => {
                    <SuspendedKmsContextOngoing as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CompromiseActiveKmsContextNotAllowed(inner) => {
                    <CompromiseActiveKmsContextNotAllowed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ContextAlreadyExists(inner) => {
                    <ContextAlreadyExists as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ContextNotActive(inner) => {
                    <ContextNotActive as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ContextNotActiveOrSuspended(inner) => {
                    <ContextNotActiveOrSuspended as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ContextNotGenerated(inner) => {
                    <ContextNotGenerated as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ContextNotInitializedOrIsGenerating(inner) => {
                    <ContextNotInitializedOrIsGenerating as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ContextNotPreActivatedOrSuspended(inner) => {
                    <ContextNotPreActivatedOrSuspended as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DestroyActiveKmsContextNotAllowed(inner) => {
                    <DestroyActiveKmsContextNotAllowed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyKmsNodes(inner) => {
                    <EmptyKmsNodes as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::InvalidHighMpcThreshold(inner) => {
                    <InvalidHighMpcThreshold as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidHighPublicDecryptionThreshold(inner) => {
                    <InvalidHighPublicDecryptionThreshold as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidHighUserDecryptionThreshold(inner) => {
                    <InvalidHighUserDecryptionThreshold as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidNullContextId(inner) => {
                    <InvalidNullContextId as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidNullPublicDecryptionThreshold(inner) => {
                    <InvalidNullPublicDecryptionThreshold as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidNullUserDecryptionThreshold(inner) => {
                    <InvalidNullUserDecryptionThreshold as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::KmsContextNotGenerating(inner) => {
                    <KmsContextNotGenerating as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::KmsContextNotInitialized(inner) => {
                    <KmsContextNotInitialized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::KmsNodeAlreadyValidatedKeyResharing(inner) => {
                    <KmsNodeAlreadyValidatedKeyResharing as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NoSuspendedKmsContext(inner) => {
                    <NoSuspendedKmsContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotInitializingFromEmptyProxy(inner) => {
                    <NotInitializingFromEmptyProxy as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotKmsNodeFromContext(inner) => {
                    <NotKmsNodeFromContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotKmsSignerFromContext(inner) => {
                    <NotKmsSignerFromContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotKmsTxSenderFromContext(inner) => {
                    <NotKmsTxSenderFromContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotOwnerOrPauser(inner) => {
                    <NotOwnerOrPauser as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NumberOfKmsNodesChanged(inner) => {
                    <NumberOfKmsNodesChanged as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OwnableInvalidOwner(inner) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OwnableUnauthorizedAccount(inner) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SuspendedKmsContextOngoing(inner) => {
                    <SuspendedKmsContextOngoing as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`KmsContexts`](self) events.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum KmsContextsEvents {
        #[allow(missing_docs)]
        ActivateKmsContext(ActivateKmsContext),
        #[allow(missing_docs)]
        CompromiseKmsContext(CompromiseKmsContext),
        #[allow(missing_docs)]
        DeactivateKmsContext(DeactivateKmsContext),
        #[allow(missing_docs)]
        DestroyKmsContext(DestroyKmsContext),
        #[allow(missing_docs)]
        EIP712DomainChanged(EIP712DomainChanged),
        #[allow(missing_docs)]
        Initialization(Initialization),
        #[allow(missing_docs)]
        Initialized(Initialized),
        #[allow(missing_docs)]
        InvalidateKeyResharing(InvalidateKeyResharing),
        #[allow(missing_docs)]
        NewKmsContext(NewKmsContext),
        #[allow(missing_docs)]
        OwnershipTransferStarted(OwnershipTransferStarted),
        #[allow(missing_docs)]
        OwnershipTransferred(OwnershipTransferred),
        #[allow(missing_docs)]
        Paused(Paused),
        #[allow(missing_docs)]
        PreActivateKmsContext(PreActivateKmsContext),
        #[allow(missing_docs)]
        StartKeyResharing(StartKeyResharing),
        #[allow(missing_docs)]
        SuspendKmsContext(SuspendKmsContext),
        #[allow(missing_docs)]
        Unpaused(Unpaused),
        #[allow(missing_docs)]
        UpdateKmsContextGenerationBlockPeriod(UpdateKmsContextGenerationBlockPeriod),
        #[allow(missing_docs)]
        UpdateKmsContextSuspensionBlockPeriod(UpdateKmsContextSuspensionBlockPeriod),
        #[allow(missing_docs)]
        UpdatePublicDecryptionThreshold(UpdatePublicDecryptionThreshold),
        #[allow(missing_docs)]
        UpdateUserDecryptionThreshold(UpdateUserDecryptionThreshold),
        #[allow(missing_docs)]
        Upgraded(Upgraded),
        #[allow(missing_docs)]
        ValidateKeyResharing(ValidateKeyResharing),
    }
    #[automatically_derived]
    impl KmsContextsEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                0u8, 159u8, 232u8, 240u8, 219u8, 69u8, 153u8, 109u8, 236u8, 247u8, 176u8,
                111u8, 199u8, 182u8, 236u8, 95u8, 136u8, 125u8, 95u8, 4u8, 219u8, 46u8,
                12u8, 74u8, 215u8, 244u8, 228u8, 238u8, 94u8, 239u8, 197u8, 163u8,
            ],
            [
                1u8, 110u8, 233u8, 193u8, 98u8, 19u8, 237u8, 103u8, 243u8, 50u8, 34u8,
                171u8, 173u8, 77u8, 254u8, 70u8, 235u8, 149u8, 30u8, 173u8, 48u8, 161u8,
                10u8, 26u8, 114u8, 219u8, 51u8, 22u8, 255u8, 182u8, 100u8, 224u8,
            ],
            [
                10u8, 99u8, 135u8, 201u8, 234u8, 54u8, 40u8, 184u8, 138u8, 99u8, 59u8,
                180u8, 243u8, 177u8, 81u8, 119u8, 15u8, 112u8, 8u8, 81u8, 23u8, 161u8,
                95u8, 155u8, 243u8, 120u8, 124u8, 218u8, 83u8, 241u8, 61u8, 49u8,
            ],
            [
                54u8, 98u8, 236u8, 49u8, 109u8, 118u8, 230u8, 167u8, 94u8, 183u8, 196u8,
                80u8, 1u8, 168u8, 173u8, 116u8, 195u8, 235u8, 148u8, 62u8, 135u8, 120u8,
                17u8, 28u8, 2u8, 37u8, 242u8, 169u8, 253u8, 94u8, 0u8, 230u8,
            ],
            [
                56u8, 209u8, 107u8, 140u8, 172u8, 34u8, 217u8, 159u8, 199u8, 193u8, 36u8,
                185u8, 205u8, 13u8, 226u8, 211u8, 250u8, 31u8, 174u8, 244u8, 32u8, 191u8,
                231u8, 145u8, 216u8, 195u8, 98u8, 215u8, 101u8, 226u8, 39u8, 0u8,
            ],
            [
                58u8, 213u8, 194u8, 39u8, 36u8, 175u8, 171u8, 142u8, 210u8, 181u8, 120u8,
                251u8, 155u8, 22u8, 12u8, 127u8, 101u8, 245u8, 171u8, 208u8, 170u8,
                209u8, 5u8, 117u8, 43u8, 123u8, 164u8, 224u8, 104u8, 163u8, 224u8, 33u8,
            ],
            [
                62u8, 143u8, 2u8, 220u8, 122u8, 246u8, 227u8, 166u8, 127u8, 58u8, 240u8,
                188u8, 153u8, 188u8, 241u8, 27u8, 77u8, 235u8, 70u8, 16u8, 94u8, 155u8,
                167u8, 241u8, 172u8, 109u8, 168u8, 35u8, 34u8, 233u8, 2u8, 94u8,
            ],
            [
                69u8, 64u8, 247u8, 128u8, 143u8, 202u8, 236u8, 134u8, 195u8, 118u8,
                168u8, 157u8, 44u8, 12u8, 147u8, 165u8, 5u8, 108u8, 33u8, 104u8, 13u8,
                181u8, 67u8, 50u8, 199u8, 242u8, 149u8, 157u8, 135u8, 254u8, 252u8, 139u8,
            ],
            [
                79u8, 84u8, 166u8, 172u8, 152u8, 28u8, 200u8, 220u8, 131u8, 20u8, 43u8,
                62u8, 180u8, 209u8, 32u8, 190u8, 124u8, 112u8, 252u8, 93u8, 230u8, 71u8,
                122u8, 20u8, 234u8, 227u8, 233u8, 202u8, 100u8, 118u8, 68u8, 188u8,
            ],
            [
                83u8, 203u8, 150u8, 141u8, 49u8, 194u8, 140u8, 101u8, 4u8, 166u8, 231u8,
                61u8, 153u8, 8u8, 219u8, 110u8, 28u8, 26u8, 56u8, 107u8, 102u8, 220u8,
                172u8, 236u8, 26u8, 1u8, 23u8, 117u8, 44u8, 90u8, 185u8, 134u8,
            ],
            [
                93u8, 185u8, 238u8, 10u8, 73u8, 91u8, 242u8, 230u8, 255u8, 156u8, 145u8,
                167u8, 131u8, 76u8, 27u8, 164u8, 253u8, 210u8, 68u8, 165u8, 232u8, 170u8,
                78u8, 83u8, 123u8, 211u8, 138u8, 234u8, 228u8, 176u8, 115u8, 170u8,
            ],
            [
                93u8, 198u8, 1u8, 6u8, 90u8, 3u8, 93u8, 120u8, 48u8, 92u8, 217u8, 239u8,
                39u8, 201u8, 26u8, 0u8, 156u8, 216u8, 211u8, 114u8, 151u8, 228u8, 59u8,
                183u8, 99u8, 25u8, 73u8, 8u8, 149u8, 160u8, 208u8, 88u8,
            ],
            [
                98u8, 231u8, 140u8, 234u8, 1u8, 190u8, 227u8, 32u8, 205u8, 78u8, 66u8,
                2u8, 112u8, 181u8, 234u8, 116u8, 0u8, 13u8, 17u8, 176u8, 201u8, 247u8,
                71u8, 84u8, 235u8, 219u8, 252u8, 84u8, 75u8, 5u8, 162u8, 88u8,
            ],
            [
                104u8, 137u8, 138u8, 152u8, 147u8, 107u8, 242u8, 58u8, 86u8, 232u8,
                237u8, 75u8, 35u8, 220u8, 201u8, 140u8, 239u8, 146u8, 107u8, 217u8,
                172u8, 44u8, 229u8, 34u8, 241u8, 249u8, 66u8, 62u8, 56u8, 100u8, 242u8,
                245u8,
            ],
            [
                131u8, 126u8, 10u8, 101u8, 40u8, 218u8, 223u8, 162u8, 220u8, 121u8, 38u8,
                146u8, 197u8, 24u8, 46u8, 82u8, 169u8, 245u8, 187u8, 222u8, 237u8, 123u8,
                35u8, 114u8, 146u8, 122u8, 38u8, 198u8, 149u8, 131u8, 150u8, 19u8,
            ],
            [
                133u8, 26u8, 8u8, 193u8, 107u8, 21u8, 149u8, 156u8, 51u8, 138u8, 196u8,
                181u8, 100u8, 102u8, 208u8, 108u8, 159u8, 157u8, 95u8, 248u8, 215u8,
                21u8, 22u8, 138u8, 161u8, 37u8, 213u8, 204u8, 175u8, 83u8, 131u8, 32u8,
            ],
            [
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ],
            [
                143u8, 183u8, 88u8, 88u8, 165u8, 101u8, 174u8, 225u8, 23u8, 52u8, 45u8,
                147u8, 25u8, 106u8, 127u8, 11u8, 84u8, 193u8, 200u8, 81u8, 152u8, 133u8,
                237u8, 221u8, 166u8, 160u8, 31u8, 71u8, 115u8, 89u8, 179u8, 99u8,
            ],
            [
                188u8, 17u8, 20u8, 250u8, 154u8, 119u8, 100u8, 140u8, 208u8, 151u8,
                238u8, 108u8, 241u8, 73u8, 195u8, 68u8, 250u8, 39u8, 139u8, 155u8, 152u8,
                63u8, 48u8, 221u8, 101u8, 182u8, 253u8, 106u8, 157u8, 70u8, 74u8, 7u8,
            ],
            [
                188u8, 124u8, 215u8, 90u8, 32u8, 238u8, 39u8, 253u8, 154u8, 222u8, 186u8,
                179u8, 32u8, 65u8, 247u8, 85u8, 33u8, 77u8, 188u8, 107u8, 255u8, 169u8,
                12u8, 192u8, 34u8, 91u8, 57u8, 218u8, 46u8, 92u8, 45u8, 59u8,
            ],
            [
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ],
            [
                228u8, 24u8, 2u8, 175u8, 114u8, 87u8, 41u8, 173u8, 203u8, 140u8, 21u8,
                30u8, 41u8, 55u8, 56u8, 10u8, 37u8, 198u8, 145u8, 85u8, 117u8, 126u8,
                58u8, 245u8, 211u8, 151u8, 154u8, 218u8, 181u8, 3u8, 88u8, 0u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for KmsContextsEvents {
        const NAME: &'static str = "KmsContextsEvents";
        const COUNT: usize = 22usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <ActivateKmsContext as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ActivateKmsContext as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ActivateKmsContext)
                }
                Some(
                    <CompromiseKmsContext as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <CompromiseKmsContext as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::CompromiseKmsContext)
                }
                Some(
                    <DeactivateKmsContext as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <DeactivateKmsContext as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::DeactivateKmsContext)
                }
                Some(
                    <DestroyKmsContext as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <DestroyKmsContext as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::DestroyKmsContext)
                }
                Some(
                    <EIP712DomainChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <EIP712DomainChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EIP712DomainChanged)
                }
                Some(<Initialization as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialization as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Initialization)
                }
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Initialized)
                }
                Some(
                    <InvalidateKeyResharing as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <InvalidateKeyResharing as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::InvalidateKeyResharing)
                }
                Some(<NewKmsContext as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <NewKmsContext as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::NewKmsContext)
                }
                Some(
                    <OwnershipTransferStarted as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferStarted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OwnershipTransferStarted)
                }
                Some(
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OwnershipTransferred)
                }
                Some(<Paused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Paused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Paused)
                }
                Some(
                    <PreActivateKmsContext as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <PreActivateKmsContext as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::PreActivateKmsContext)
                }
                Some(
                    <StartKeyResharing as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <StartKeyResharing as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::StartKeyResharing)
                }
                Some(
                    <SuspendKmsContext as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <SuspendKmsContext as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::SuspendKmsContext)
                }
                Some(<Unpaused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Unpaused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Unpaused)
                }
                Some(
                    <UpdateKmsContextGenerationBlockPeriod as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <UpdateKmsContextGenerationBlockPeriod as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::UpdateKmsContextGenerationBlockPeriod)
                }
                Some(
                    <UpdateKmsContextSuspensionBlockPeriod as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <UpdateKmsContextSuspensionBlockPeriod as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::UpdateKmsContextSuspensionBlockPeriod)
                }
                Some(
                    <UpdatePublicDecryptionThreshold as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <UpdatePublicDecryptionThreshold as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::UpdatePublicDecryptionThreshold)
                }
                Some(
                    <UpdateUserDecryptionThreshold as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <UpdateUserDecryptionThreshold as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::UpdateUserDecryptionThreshold)
                }
                Some(<Upgraded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Upgraded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Upgraded)
                }
                Some(
                    <ValidateKeyResharing as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ValidateKeyResharing as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ValidateKeyResharing)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for KmsContextsEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ActivateKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::CompromiseKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DeactivateKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DestroyKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EIP712DomainChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialization(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::InvalidateKeyResharing(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::NewKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::PreActivateKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::StartKeyResharing(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SuspendKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::UpdateKmsContextGenerationBlockPeriod(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::UpdateKmsContextSuspensionBlockPeriod(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::UpdatePublicDecryptionThreshold(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::UpdateUserDecryptionThreshold(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ValidateKeyResharing(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ActivateKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::CompromiseKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DeactivateKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DestroyKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EIP712DomainChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialization(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::InvalidateKeyResharing(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::NewKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::PreActivateKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::StartKeyResharing(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SuspendKmsContext(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::UpdateKmsContextGenerationBlockPeriod(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::UpdateKmsContextSuspensionBlockPeriod(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::UpdatePublicDecryptionThreshold(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::UpdateUserDecryptionThreshold(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ValidateKeyResharing(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`KmsContexts`](self) contract instance.

See the [wrapper's documentation](`KmsContextsInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> KmsContextsInstance<T, P, N> {
        KmsContextsInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<KmsContextsInstance<T, P, N>>,
    > {
        KmsContextsInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        KmsContextsInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`KmsContexts`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`KmsContexts`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct KmsContextsInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for KmsContextsInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("KmsContextsInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > KmsContextsInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`KmsContexts`](self) contract instance.

See the [wrapper's documentation](`KmsContextsInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<KmsContextsInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> KmsContextsInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> KmsContextsInstance<T, P, N> {
            KmsContextsInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > KmsContextsInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`UPGRADE_INTERFACE_VERSION`] function.
        pub fn UPGRADE_INTERFACE_VERSION(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, UPGRADE_INTERFACE_VERSIONCall, N> {
            self.call_builder(&UPGRADE_INTERFACE_VERSIONCall {})
        }
        ///Creates a new call builder for the [`acceptOwnership`] function.
        pub fn acceptOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, acceptOwnershipCall, N> {
            self.call_builder(&acceptOwnershipCall {})
        }
        ///Creates a new call builder for the [`addKmsContext`] function.
        pub fn addKmsContext(
            &self,
            preActivationBlockPeriod: alloy::sol_types::private::primitives::aliases::U256,
            softwareVersion: alloy::sol_types::private::FixedBytes<8>,
            reshareKeys: bool,
            mpcThreshold: alloy::sol_types::private::primitives::aliases::U256,
            kmsNodes: alloy::sol_types::private::Vec<
                <KmsNode as alloy::sol_types::SolType>::RustType,
            >,
            decryptionThresholds: <DecryptionThresholds as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, addKmsContextCall, N> {
            self.call_builder(
                &addKmsContextCall {
                    preActivationBlockPeriod,
                    softwareVersion,
                    reshareKeys,
                    mpcThreshold,
                    kmsNodes,
                    decryptionThresholds,
                },
            )
        }
        ///Creates a new call builder for the [`checkIsKmsSignerFromContext`] function.
        pub fn checkIsKmsSignerFromContext(
            &self,
            contextId: alloy::sol_types::private::primitives::aliases::U256,
            signerAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkIsKmsSignerFromContextCall, N> {
            self.call_builder(
                &checkIsKmsSignerFromContextCall {
                    contextId,
                    signerAddress,
                },
            )
        }
        ///Creates a new call builder for the [`checkIsKmsTxSenderFromContext`] function.
        pub fn checkIsKmsTxSenderFromContext(
            &self,
            contextId: alloy::sol_types::private::primitives::aliases::U256,
            txSenderAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            checkIsKmsTxSenderFromContextCall,
            N,
        > {
            self.call_builder(
                &checkIsKmsTxSenderFromContextCall {
                    contextId,
                    txSenderAddress,
                },
            )
        }
        ///Creates a new call builder for the [`compromiseKmsContext`] function.
        pub fn compromiseKmsContext(
            &self,
            contextId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, compromiseKmsContextCall, N> {
            self.call_builder(
                &compromiseKmsContextCall {
                    contextId,
                },
            )
        }
        ///Creates a new call builder for the [`destroyKmsContext`] function.
        pub fn destroyKmsContext(
            &self,
            contextId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, destroyKmsContextCall, N> {
            self.call_builder(&destroyKmsContextCall { contextId })
        }
        ///Creates a new call builder for the [`eip712Domain`] function.
        pub fn eip712Domain(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, eip712DomainCall, N> {
            self.call_builder(&eip712DomainCall {})
        }
        ///Creates a new call builder for the [`getActiveKmsContext`] function.
        pub fn getActiveKmsContext(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getActiveKmsContextCall, N> {
            self.call_builder(&getActiveKmsContextCall {})
        }
        ///Creates a new call builder for the [`getActiveKmsContextId`] function.
        pub fn getActiveKmsContextId(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getActiveKmsContextIdCall, N> {
            self.call_builder(&getActiveKmsContextIdCall {})
        }
        ///Creates a new call builder for the [`getKmsContextGenerationBlockPeriod`] function.
        pub fn getKmsContextGenerationBlockPeriod(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            getKmsContextGenerationBlockPeriodCall,
            N,
        > {
            self.call_builder(
                &getKmsContextGenerationBlockPeriodCall {
                },
            )
        }
        ///Creates a new call builder for the [`getKmsContextStatus`] function.
        pub fn getKmsContextStatus(
            &self,
            contextId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getKmsContextStatusCall, N> {
            self.call_builder(
                &getKmsContextStatusCall {
                    contextId,
                },
            )
        }
        ///Creates a new call builder for the [`getKmsContextSuspensionBlockPeriod`] function.
        pub fn getKmsContextSuspensionBlockPeriod(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            getKmsContextSuspensionBlockPeriodCall,
            N,
        > {
            self.call_builder(
                &getKmsContextSuspensionBlockPeriodCall {
                },
            )
        }
        ///Creates a new call builder for the [`getKmsNode`] function.
        pub fn getKmsNode(
            &self,
            kmsTxSenderAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getKmsNodeCall, N> {
            self.call_builder(
                &getKmsNodeCall {
                    kmsTxSenderAddress,
                },
            )
        }
        ///Creates a new call builder for the [`getKmsNodes`] function.
        pub fn getKmsNodes(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getKmsNodesCall, N> {
            self.call_builder(&getKmsNodesCall {})
        }
        ///Creates a new call builder for the [`getKmsSigners`] function.
        pub fn getKmsSigners(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getKmsSignersCall, N> {
            self.call_builder(&getKmsSignersCall {})
        }
        ///Creates a new call builder for the [`getKmsTxSenders`] function.
        pub fn getKmsTxSenders(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getKmsTxSendersCall, N> {
            self.call_builder(&getKmsTxSendersCall {})
        }
        ///Creates a new call builder for the [`getPublicDecryptionThresholdFromContext`] function.
        pub fn getPublicDecryptionThresholdFromContext(
            &self,
            contextId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            getPublicDecryptionThresholdFromContextCall,
            N,
        > {
            self.call_builder(
                &getPublicDecryptionThresholdFromContextCall {
                    contextId,
                },
            )
        }
        ///Creates a new call builder for the [`getSuspendedKmsContextId`] function.
        pub fn getSuspendedKmsContextId(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getSuspendedKmsContextIdCall, N> {
            self.call_builder(&getSuspendedKmsContextIdCall {})
        }
        ///Creates a new call builder for the [`getUserDecryptionThresholdFromContext`] function.
        pub fn getUserDecryptionThresholdFromContext(
            &self,
            contextId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            getUserDecryptionThresholdFromContextCall,
            N,
        > {
            self.call_builder(
                &getUserDecryptionThresholdFromContextCall {
                    contextId,
                },
            )
        }
        ///Creates a new call builder for the [`getVersion`] function.
        pub fn getVersion(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getVersionCall, N> {
            self.call_builder(&getVersionCall {})
        }
        ///Creates a new call builder for the [`initializeFromEmptyProxy`] function.
        pub fn initializeFromEmptyProxy(
            &self,
            initialDecryptionThresholds: <DecryptionThresholds as alloy::sol_types::SolType>::RustType,
            initialBlockPeriods: <KmsBlockPeriods as alloy::sol_types::SolType>::RustType,
            initialSoftwareVersion: alloy::sol_types::private::FixedBytes<8>,
            initialMpcThreshold: alloy::sol_types::private::primitives::aliases::U256,
            initialKmsNodes: alloy::sol_types::private::Vec<
                <KmsNode as alloy::sol_types::SolType>::RustType,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, initializeFromEmptyProxyCall, N> {
            self.call_builder(
                &initializeFromEmptyProxyCall {
                    initialDecryptionThresholds,
                    initialBlockPeriods,
                    initialSoftwareVersion,
                    initialMpcThreshold,
                    initialKmsNodes,
                },
            )
        }
        ///Creates a new call builder for the [`moveSuspendedKmsContextToActive`] function.
        pub fn moveSuspendedKmsContextToActive(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            moveSuspendedKmsContextToActiveCall,
            N,
        > {
            self.call_builder(
                &moveSuspendedKmsContextToActiveCall {
                },
            )
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<T, &P, ownerCall, N> {
            self.call_builder(&ownerCall {})
        }
        ///Creates a new call builder for the [`pause`] function.
        pub fn pause(&self) -> alloy_contract::SolCallBuilder<T, &P, pauseCall, N> {
            self.call_builder(&pauseCall {})
        }
        ///Creates a new call builder for the [`paused`] function.
        pub fn paused(&self) -> alloy_contract::SolCallBuilder<T, &P, pausedCall, N> {
            self.call_builder(&pausedCall {})
        }
        ///Creates a new call builder for the [`pendingOwner`] function.
        pub fn pendingOwner(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, pendingOwnerCall, N> {
            self.call_builder(&pendingOwnerCall {})
        }
        ///Creates a new call builder for the [`proxiableUUID`] function.
        pub fn proxiableUUID(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, proxiableUUIDCall, N> {
            self.call_builder(&proxiableUUIDCall {})
        }
        ///Creates a new call builder for the [`refreshKmsContextStatuses`] function.
        pub fn refreshKmsContextStatuses(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, refreshKmsContextStatusesCall, N> {
            self.call_builder(&refreshKmsContextStatusesCall {})
        }
        ///Creates a new call builder for the [`renounceOwnership`] function.
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall {})
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
        ///Creates a new call builder for the [`unpause`] function.
        pub fn unpause(&self) -> alloy_contract::SolCallBuilder<T, &P, unpauseCall, N> {
            self.call_builder(&unpauseCall {})
        }
        ///Creates a new call builder for the [`updateKmsContextGenerationBlockPeriod`] function.
        pub fn updateKmsContextGenerationBlockPeriod(
            &self,
            newKmsContextGenerationBlockPeriod: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            updateKmsContextGenerationBlockPeriodCall,
            N,
        > {
            self.call_builder(
                &updateKmsContextGenerationBlockPeriodCall {
                    newKmsContextGenerationBlockPeriod,
                },
            )
        }
        ///Creates a new call builder for the [`updateKmsContextSuspensionBlockPeriod`] function.
        pub fn updateKmsContextSuspensionBlockPeriod(
            &self,
            newKmsContextSuspensionBlockPeriod: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            updateKmsContextSuspensionBlockPeriodCall,
            N,
        > {
            self.call_builder(
                &updateKmsContextSuspensionBlockPeriodCall {
                    newKmsContextSuspensionBlockPeriod,
                },
            )
        }
        ///Creates a new call builder for the [`updatePublicDecryptionThreshold`] function.
        pub fn updatePublicDecryptionThreshold(
            &self,
            newPublicDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            updatePublicDecryptionThresholdCall,
            N,
        > {
            self.call_builder(
                &updatePublicDecryptionThresholdCall {
                    newPublicDecryptionThreshold,
                },
            )
        }
        ///Creates a new call builder for the [`updateUserDecryptionThreshold`] function.
        pub fn updateUserDecryptionThreshold(
            &self,
            newUserDecryptionThreshold: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            updateUserDecryptionThresholdCall,
            N,
        > {
            self.call_builder(
                &updateUserDecryptionThresholdCall {
                    newUserDecryptionThreshold,
                },
            )
        }
        ///Creates a new call builder for the [`upgradeToAndCall`] function.
        pub fn upgradeToAndCall(
            &self,
            newImplementation: alloy::sol_types::private::Address,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, upgradeToAndCallCall, N> {
            self.call_builder(
                &upgradeToAndCallCall {
                    newImplementation,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`validateKeyResharing`] function.
        pub fn validateKeyResharing(
            &self,
            contextId: alloy::sol_types::private::primitives::aliases::U256,
            signature: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, validateKeyResharingCall, N> {
            self.call_builder(
                &validateKeyResharingCall {
                    contextId,
                    signature,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > KmsContextsInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`ActivateKmsContext`] event.
        pub fn ActivateKmsContext_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ActivateKmsContext, N> {
            self.event_filter::<ActivateKmsContext>()
        }
        ///Creates a new event filter for the [`CompromiseKmsContext`] event.
        pub fn CompromiseKmsContext_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, CompromiseKmsContext, N> {
            self.event_filter::<CompromiseKmsContext>()
        }
        ///Creates a new event filter for the [`DeactivateKmsContext`] event.
        pub fn DeactivateKmsContext_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, DeactivateKmsContext, N> {
            self.event_filter::<DeactivateKmsContext>()
        }
        ///Creates a new event filter for the [`DestroyKmsContext`] event.
        pub fn DestroyKmsContext_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, DestroyKmsContext, N> {
            self.event_filter::<DestroyKmsContext>()
        }
        ///Creates a new event filter for the [`EIP712DomainChanged`] event.
        pub fn EIP712DomainChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EIP712DomainChanged, N> {
            self.event_filter::<EIP712DomainChanged>()
        }
        ///Creates a new event filter for the [`Initialization`] event.
        pub fn Initialization_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, Initialization, N> {
            self.event_filter::<Initialization>()
        }
        ///Creates a new event filter for the [`Initialized`] event.
        pub fn Initialized_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        ///Creates a new event filter for the [`InvalidateKeyResharing`] event.
        pub fn InvalidateKeyResharing_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, InvalidateKeyResharing, N> {
            self.event_filter::<InvalidateKeyResharing>()
        }
        ///Creates a new event filter for the [`NewKmsContext`] event.
        pub fn NewKmsContext_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, NewKmsContext, N> {
            self.event_filter::<NewKmsContext>()
        }
        ///Creates a new event filter for the [`OwnershipTransferStarted`] event.
        pub fn OwnershipTransferStarted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipTransferStarted, N> {
            self.event_filter::<OwnershipTransferStarted>()
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        ///Creates a new event filter for the [`Paused`] event.
        pub fn Paused_filter(&self) -> alloy_contract::Event<T, &P, Paused, N> {
            self.event_filter::<Paused>()
        }
        ///Creates a new event filter for the [`PreActivateKmsContext`] event.
        pub fn PreActivateKmsContext_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, PreActivateKmsContext, N> {
            self.event_filter::<PreActivateKmsContext>()
        }
        ///Creates a new event filter for the [`StartKeyResharing`] event.
        pub fn StartKeyResharing_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, StartKeyResharing, N> {
            self.event_filter::<StartKeyResharing>()
        }
        ///Creates a new event filter for the [`SuspendKmsContext`] event.
        pub fn SuspendKmsContext_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, SuspendKmsContext, N> {
            self.event_filter::<SuspendKmsContext>()
        }
        ///Creates a new event filter for the [`Unpaused`] event.
        pub fn Unpaused_filter(&self) -> alloy_contract::Event<T, &P, Unpaused, N> {
            self.event_filter::<Unpaused>()
        }
        ///Creates a new event filter for the [`UpdateKmsContextGenerationBlockPeriod`] event.
        pub fn UpdateKmsContextGenerationBlockPeriod_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, UpdateKmsContextGenerationBlockPeriod, N> {
            self.event_filter::<UpdateKmsContextGenerationBlockPeriod>()
        }
        ///Creates a new event filter for the [`UpdateKmsContextSuspensionBlockPeriod`] event.
        pub fn UpdateKmsContextSuspensionBlockPeriod_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, UpdateKmsContextSuspensionBlockPeriod, N> {
            self.event_filter::<UpdateKmsContextSuspensionBlockPeriod>()
        }
        ///Creates a new event filter for the [`UpdatePublicDecryptionThreshold`] event.
        pub fn UpdatePublicDecryptionThreshold_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, UpdatePublicDecryptionThreshold, N> {
            self.event_filter::<UpdatePublicDecryptionThreshold>()
        }
        ///Creates a new event filter for the [`UpdateUserDecryptionThreshold`] event.
        pub fn UpdateUserDecryptionThreshold_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, UpdateUserDecryptionThreshold, N> {
            self.event_filter::<UpdateUserDecryptionThreshold>()
        }
        ///Creates a new event filter for the [`Upgraded`] event.
        pub fn Upgraded_filter(&self) -> alloy_contract::Event<T, &P, Upgraded, N> {
            self.event_filter::<Upgraded>()
        }
        ///Creates a new event filter for the [`ValidateKeyResharing`] event.
        pub fn ValidateKeyResharing_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ValidateKeyResharing, N> {
            self.event_filter::<ValidateKeyResharing>()
        }
    }
}
