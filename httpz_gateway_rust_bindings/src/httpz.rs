/**

Generated by the following Solidity interface...
```solidity
interface HTTPZ {
    struct Coprocessor {
        address txSenderAddress;
        address signerAddress;
        string s3BucketUrl;
    }
    struct KmsNode {
        address txSenderAddress;
        address signerAddress;
        string ipAddress;
    }
    struct Network {
        uint256 chainId;
        address httpzExecutor;
        address aclAddress;
        string name;
        string website;
    }
    struct ProtocolMetadata {
        string name;
        string website;
    }

    error AddressEmptyCode(address target);
    error ERC1967InvalidImplementation(address implementation);
    error ERC1967NonPayable();
    error FailedCall();
    error InvalidInitialization();
    error InvalidNullChainId();
    error InvalidNullPauser();
    error KmsThresholdTooHigh(uint256 threshold, uint256 nParties);
    error NetworkAlreadyRegistered(uint256 chainId);
    error NetworkNotRegistered(uint256 chainId);
    error NotCoprocessorSigner(address signerAddress);
    error NotCoprocessorTxSender(address txSenderAddress);
    error NotInitializing();
    error NotKmsSigner(address signerAddress);
    error NotKmsTxSender(address txSenderAddress);
    error NotPauser(address pauserAddress);
    error OwnableInvalidOwner(address owner);
    error OwnableUnauthorizedAccount(address account);
    error UUPSUnauthorizedCallContext();
    error UUPSUnsupportedProxiableUUID(bytes32 slot);

    event AddNetwork(Network network);
    event Initialization(address pauser, ProtocolMetadata metadata, uint256 kmsThreshold, KmsNode[] kmsNodes, Coprocessor[] coprocessors);
    event Initialized(uint64 version);
    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event UpdateKmsThreshold(uint256 newKmsThreshold);
    event UpdatePauser(address newPauser);
    event Upgraded(address indexed implementation);

    constructor();

    function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
    function acceptOwnership() external;
    function addNetwork(Network memory network) external;
    function checkIsCoprocessorSigner(address signerAddress) external view;
    function checkIsCoprocessorTxSender(address txSenderAddress) external view;
    function checkIsKmsSigner(address signerAddress) external view;
    function checkIsKmsTxSender(address txSenderAddress) external view;
    function checkIsPauser(address pauserAddress) external view;
    function checkNetworkIsRegistered(uint256 chainId) external view;
    function coprocessorTxSenderAddresses(uint256 index) external view returns (address);
    function coprocessors(address coprocessorTxSenderAddress) external view returns (Coprocessor memory);
    function getAllCoprocessorTxSenderAddresses() external view returns (address[] memory);
    function getAllKmsTxSenderAddresses() external view returns (address[] memory);
    function getCoprocessorMajorityThreshold() external view returns (uint256);
    function getKmsMajorityThreshold() external view returns (uint256);
    function getKmsReconstructionThreshold() external view returns (uint256);
    function getKmsThreshold() external view returns (uint256);
    function getProtocolMetadata() external view returns (ProtocolMetadata memory);
    function getVersion() external pure returns (string memory);
    function initialize(address initialPauser, ProtocolMetadata memory initialMetadata, uint256 initialKmsThreshold, KmsNode[] memory initialKmsNodes, Coprocessor[] memory initialCoprocessors) external;
    function kmsNodes(address kmsTxSenderAddress) external view returns (KmsNode memory);
    function kmsTxSenderAddresses(uint256 index) external view returns (address);
    function networks(uint256 index) external view returns (Network memory);
    function owner() external view returns (address);
    function pendingOwner() external view returns (address);
    function proxiableUUID() external view returns (bytes32);
    function renounceOwnership() external;
    function transferOwnership(address newOwner) external;
    function updateKmsThreshold(uint256 newKmsThreshold) external;
    function updatePauser(address newPauser) external;
    function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "UPGRADE_INTERFACE_VERSION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "acceptOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "addNetwork",
    "inputs": [
      {
        "name": "network",
        "type": "tuple",
        "internalType": "struct Network",
        "components": [
          {
            "name": "chainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "httpzExecutor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "aclAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "website",
            "type": "string",
            "internalType": "string"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkIsCoprocessorSigner",
    "inputs": [
      {
        "name": "signerAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "checkIsCoprocessorTxSender",
    "inputs": [
      {
        "name": "txSenderAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "checkIsKmsSigner",
    "inputs": [
      {
        "name": "signerAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "checkIsKmsTxSender",
    "inputs": [
      {
        "name": "txSenderAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "checkIsPauser",
    "inputs": [
      {
        "name": "pauserAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "checkNetworkIsRegistered",
    "inputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "coprocessorTxSenderAddresses",
    "inputs": [
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "coprocessors",
    "inputs": [
      {
        "name": "coprocessorTxSenderAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct Coprocessor",
        "components": [
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "s3BucketUrl",
            "type": "string",
            "internalType": "string"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAllCoprocessorTxSenderAddresses",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAllKmsTxSenderAddresses",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCoprocessorMajorityThreshold",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsMajorityThreshold",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsReconstructionThreshold",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsThreshold",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getProtocolMetadata",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct ProtocolMetadata",
        "components": [
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "website",
            "type": "string",
            "internalType": "string"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getVersion",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "initialize",
    "inputs": [
      {
        "name": "initialPauser",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "initialMetadata",
        "type": "tuple",
        "internalType": "struct ProtocolMetadata",
        "components": [
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "website",
            "type": "string",
            "internalType": "string"
          }
        ]
      },
      {
        "name": "initialKmsThreshold",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "initialKmsNodes",
        "type": "tuple[]",
        "internalType": "struct KmsNode[]",
        "components": [
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "ipAddress",
            "type": "string",
            "internalType": "string"
          }
        ]
      },
      {
        "name": "initialCoprocessors",
        "type": "tuple[]",
        "internalType": "struct Coprocessor[]",
        "components": [
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "s3BucketUrl",
            "type": "string",
            "internalType": "string"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "kmsNodes",
    "inputs": [
      {
        "name": "kmsTxSenderAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct KmsNode",
        "components": [
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "ipAddress",
            "type": "string",
            "internalType": "string"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "kmsTxSenderAddresses",
    "inputs": [
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "networks",
    "inputs": [
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct Network",
        "components": [
          {
            "name": "chainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "httpzExecutor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "aclAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "website",
            "type": "string",
            "internalType": "string"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pendingOwner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "proxiableUUID",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateKmsThreshold",
    "inputs": [
      {
        "name": "newKmsThreshold",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updatePauser",
    "inputs": [
      {
        "name": "newPauser",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "upgradeToAndCall",
    "inputs": [
      {
        "name": "newImplementation",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "event",
    "name": "AddNetwork",
    "inputs": [
      {
        "name": "network",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct Network",
        "components": [
          {
            "name": "chainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "httpzExecutor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "aclAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "website",
            "type": "string",
            "internalType": "string"
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialization",
    "inputs": [
      {
        "name": "pauser",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "metadata",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct ProtocolMetadata",
        "components": [
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "website",
            "type": "string",
            "internalType": "string"
          }
        ]
      },
      {
        "name": "kmsThreshold",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "kmsNodes",
        "type": "tuple[]",
        "indexed": false,
        "internalType": "struct KmsNode[]",
        "components": [
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "ipAddress",
            "type": "string",
            "internalType": "string"
          }
        ]
      },
      {
        "name": "coprocessors",
        "type": "tuple[]",
        "indexed": false,
        "internalType": "struct Coprocessor[]",
        "components": [
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "s3BucketUrl",
            "type": "string",
            "internalType": "string"
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      {
        "name": "version",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferStarted",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "UpdateKmsThreshold",
    "inputs": [
      {
        "name": "newKmsThreshold",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "UpdatePauser",
    "inputs": [
      {
        "name": "newPauser",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Upgraded",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AddressEmptyCode",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1967InvalidImplementation",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1967NonPayable",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FailedCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidInitialization",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidNullChainId",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidNullPauser",
    "inputs": []
  },
  {
    "type": "error",
    "name": "KmsThresholdTooHigh",
    "inputs": [
      {
        "name": "threshold",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nParties",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "NetworkAlreadyRegistered",
    "inputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "NetworkNotRegistered",
    "inputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotCoprocessorSigner",
    "inputs": [
      {
        "name": "signerAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotCoprocessorTxSender",
    "inputs": [
      {
        "name": "txSenderAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotInitializing",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotKmsSigner",
    "inputs": [
      {
        "name": "signerAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotKmsTxSender",
    "inputs": [
      {
        "name": "txSenderAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotPauser",
    "inputs": [
      {
        "name": "pauserAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "OwnableInvalidOwner",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "OwnableUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "UUPSUnauthorizedCallContext",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UUPSUnsupportedProxiableUUID",
    "inputs": [
      {
        "name": "slot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod HTTPZ {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a06040523073ffffffffffffffffffffffffffffffffffffffff1660809073ffffffffffffffffffffffffffffffffffffffff16815250348015610042575f5ffd5b5061005161005660201b60201c565b6101b6565b5f61006561015460201b60201c565b9050805f0160089054906101000a900460ff16156100af576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b67ffffffffffffffff8016815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff16146101515767ffffffffffffffff815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d267ffffffffffffffff604051610148919061019d565b60405180910390a15b50565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b5f67ffffffffffffffff82169050919050565b6101978161017b565b82525050565b5f6020820190506101b05f83018461018e565b92915050565b6080516146366101dc5f395f818161224b015281816122a0015261245a01526146365ff3fe6080604052600436106101d7575f3560e01c8063715018a611610101578063c6b3024d11610094578063d98189a411610063578063d98189a414610649578063e30c397814610671578063ecbd96ab1461069b578063f2fde38b146106d7576101d7565b8063c6b3024d14610595578063cb661755146105bd578063cdb4c2b9146105e5578063d5244bf11461060d576101d7565b80638f4a7f5e116100d05780638f4a7f5e146104ef578063ad3cb1cc14610519578063bda0b94814610543578063c62752581461056d576101d7565b8063715018a61461045d57806379ba5097146104735780638bb0a17c146104895780638da5cb5b146104c5576101d7565b80634f1ef286116101795780635ab6d3ab116101485780635ab6d3ab146103a75780636799ef52146103e35780636c88eb431461040d57806370cc9a3c14610435576101d7565b80634f1ef286146102fd57806352d1902d1461031957806354d3f67514610343578063554bab3c1461037f576101d7565b806347cd4b3e116101b557806347cd4b3e1461025557806348144c611461027f578063490413aa146102a95780634921a3bd146102d3576101d7565b80630219150f146101db5780630d8e6e2c14610203578063195afde61461022d575b5f5ffd5b3480156101e6575f5ffd5b5061020160048036038101906101fc9190612d20565b6106ff565b005b34801561020e575f5ffd5b506102176107ab565b6040516102249190612dbb565b60405180910390f35b348015610238575f5ffd5b50610253600480360381019061024e9190612e35565b610826565b005b348015610260575f5ffd5b506102696108c7565b6040516102769190612e6f565b60405180910390f35b34801561028a575f5ffd5b506102936108ea565b6040516102a09190612f11565b60405180910390f35b3480156102b4575f5ffd5b506102bd610a31565b6040516102ca9190612e6f565b60405180910390f35b3480156102de575f5ffd5b506102e7610a60565b6040516102f49190612e6f565b60405180910390f35b6103176004803603810190610312919061305d565b610a77565b005b348015610324575f5ffd5b5061032d610a96565b60405161033a91906130cf565b60405180910390f35b34801561034e575f5ffd5b5061036960048036038101906103649190612e35565b610ac7565b6040516103769190613144565b60405180910390f35b34801561038a575f5ffd5b506103a560048036038101906103a09190612e35565b610c65565b005b3480156103b2575f5ffd5b506103cd60048036038101906103c89190612d20565b610d59565b6040516103da9190613173565b60405180910390f35b3480156103ee575f5ffd5b506103f7610dab565b6040516104049190612e6f565b60405180910390f35b348015610418575f5ffd5b50610433600480360381019061042e9190612e35565b610ddd565b005b348015610440575f5ffd5b5061045b600480360381019061045691906131ae565b610e79565b005b348015610468575f5ffd5b50610471610fca565b005b34801561047e575f5ffd5b50610487610fdd565b005b348015610494575f5ffd5b506104af60048036038101906104aa9190612d20565b61106b565b6040516104bc919061327e565b60405180910390f35b3480156104d0575f5ffd5b506104d9611286565b6040516104e69190613173565b60405180910390f35b3480156104fa575f5ffd5b506105036112bb565b6040516105109190613346565b60405180910390f35b348015610524575f5ffd5b5061052d611354565b60405161053a9190612dbb565b60405180910390f35b34801561054e575f5ffd5b5061055761138d565b6040516105649190613346565b60405180910390f35b348015610578575f5ffd5b50610593600480360381019061058e9190612e35565b611426565b005b3480156105a0575f5ffd5b506105bb60048036038101906105b69190612d20565b6114c2565b005b3480156105c8575f5ffd5b506105e360048036038101906105de9190612e35565b611532565b005b3480156105f0575f5ffd5b5061060b60048036038101906106069190612e35565b6115ce565b005b348015610618575f5ffd5b50610633600480360381019061062e9190612d20565b61166a565b6040516106409190613173565b60405180910390f35b348015610654575f5ffd5b5061066f600480360381019061066a919061374b565b6116bc565b005b34801561067c575f5ffd5b50610685611e45565b6040516106929190613173565b60405180910390f35b3480156106a6575f5ffd5b506106c160048036038101906106bc9190612e35565b611e7a565b6040516106ce9190613863565b60405180910390f35b3480156106e2575f5ffd5b506106fd60048036038101906106f89190612e35565b612018565b005b6107076120d1565b5f610710612158565b90508060090180549050821115610767578181600901805490506040517f48676fe000000000000000000000000000000000000000000000000000000000815260040161075e929190613883565b60405180910390fd5b8181600a01819055507fea6c6521bc495731082e23ad12c7b1207d13ca0bd38d1d511081ab568917cb848260405161079f9190612e6f565b60405180910390a15050565b60606040518060400160405280600581526020017f485454505a0000000000000000000000000000000000000000000000000000008152506107ec5f61217f565b6107f6600161217f565b6107ff5f61217f565b6040516020016108129493929190613978565b604051602081830303815290604052905090565b5f61082f612158565b90508173ffffffffffffffffffffffffffffffffffffffff16815f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16146108c357816040517f206a346e0000000000000000000000000000000000000000000000000000000081526004016108ba9190613173565b60405180910390fd5b5050565b5f5f6108d1612158565b9050600181600a01546108e49190613a03565b91505090565b6108f2612bd4565b5f6108fb612158565b9050806006016040518060400160405290815f8201805461091b90613a63565b80601f016020809104026020016040519081016040528092919081815260200182805461094790613a63565b80156109925780601f1061096957610100808354040283529160200191610992565b820191905f5260205f20905b81548152906001019060200180831161097557829003601f168201915b505050505081526020016001820180546109ab90613a63565b80601f01602080910402602001604051908101604052809291908181526020018280546109d790613a63565b8015610a225780601f106109f957610100808354040283529160200191610a22565b820191905f5260205f20905b815481529060010190602001808311610a0557829003601f168201915b50505050508152505091505090565b5f5f610a3b612158565b9050600181600a01546002610a509190613a93565b610a5a9190613a03565b91505090565b5f5f610a6a612158565b905080600a015491505090565b610a7f612249565b610a888261232f565b610a92828261233a565b5050565b5f610a9f612458565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b905090565b610acf612bee565b5f610ad8612158565b9050806008015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f206040518060600160405290815f82015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282018054610bdd90613a63565b80601f0160208091040260200160405190810160405280929190818152602001828054610c0990613a63565b8015610c545780601f10610c2b57610100808354040283529160200191610c54565b820191905f5260205f20905b815481529060010190602001808311610c3757829003601f168201915b505050505081525050915050919050565b610c6d6120d1565b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603610cd2576040517f3555aed100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f610cdb612158565b905081815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507fa690668c24d277243ff6fa650d3fd6e3d331a99ca0a8857c82e7f89452fc665d82604051610d4d9190613173565b60405180910390a15050565b5f5f610d63612158565b905080600c018381548110610d7b57610d7a613ad4565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16915050919050565b5f5f610db5612158565b90506001600282600c0180549050610dcd9190613b2e565b610dd79190613a03565b91505090565b5f610de6612158565b9050806002015f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff16610e7557816040517f2a7c6ef6000000000000000000000000000000000000000000000000000000008152600401610e6c9190613173565b60405180910390fd5b5050565b5f815f013503610eb5576040517f22f73fea00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f610ebe612158565b9050806005015f835f013581526020019081526020015f205f9054906101000a900460ff1615610f2857815f01356040517fb1825c5e000000000000000000000000000000000000000000000000000000008152600401610f1f9190612e6f565b60405180910390fd5b80600d0182908060018154018082558091505060019003905f5260205f2090600502015f909190919091508181610f5f9190614037565b50506001816005015f845f013581526020019081526020015f205f6101000a81548160ff0219169083151502179055507fb8207b5bb791730ae8f0534fa4c7be7da49dd75d701f9c7acf51c94b8ace96b282604051610fbe91906141b1565b60405180910390a15050565b610fd26120d1565b610fdb5f6124df565b565b5f610fe661251c565b90508073ffffffffffffffffffffffffffffffffffffffff16611007611e45565b73ffffffffffffffffffffffffffffffffffffffff161461105f57806040517f118cdaa70000000000000000000000000000000000000000000000000000000081526004016110569190613173565b60405180910390fd5b611068816124df565b50565b611073612c39565b5f61107c612158565b905080600d01838154811061109457611093613ad4565b5b905f5260205f2090600502016040518060a00160405290815f8201548152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200160038201805461116e90613a63565b80601f016020809104026020016040519081016040528092919081815260200182805461119a90613a63565b80156111e55780601f106111bc576101008083540402835291602001916111e5565b820191905f5260205f20905b8154815290600101906020018083116111c857829003601f168201915b505050505081526020016004820180546111fe90613a63565b80601f016020809104026020016040519081016040528092919081815260200182805461122a90613a63565b80156112755780601f1061124c57610100808354040283529160200191611275565b820191905f5260205f20905b81548152906001019060200180831161125857829003601f168201915b505050505081525050915050919050565b5f5f611290612523565b9050805f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b60605f6112c6612158565b905080600c0180548060200260200160405190810160405280929190818152602001828054801561134957602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311611300575b505050505091505090565b6040518060400160405280600581526020017f352e302e3000000000000000000000000000000000000000000000000000000081525081565b60605f611398612158565b90508060090180548060200260200160405190810160405280929190818152602001828054801561141b57602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190600101908083116113d2575b505050505091505090565b5f61142f612158565b9050806001015f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff166114be57816040517faee863230000000000000000000000000000000000000000000000000000000081526004016114b59190613173565b60405180910390fd5b5050565b5f6114cb612158565b9050806005015f8381526020019081526020015f205f9054906101000a900460ff1661152e57816040517f6df6fe890000000000000000000000000000000000000000000000000000000081526004016115259190612e6f565b60405180910390fd5b5050565b5f61153b612158565b9050806003015f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff166115ca57816040517f52d725f50000000000000000000000000000000000000000000000000000000081526004016115c19190613173565b60405180910390fd5b5050565b5f6115d7612158565b9050806004015f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff1661166657816040517f26cd75dc00000000000000000000000000000000000000000000000000000000815260040161165d9190613173565b60405180910390fd5b5050565b5f5f611674612158565b905080600901838154811061168c5761168b613ad4565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16915050919050565b60025f6116c761254a565b9050805f0160089054906101000a900460ff168061170f57508167ffffffffffffffff16815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff1610155b15611746576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055506001815f0160086101000a81548160ff02191690831515021790555061179b611796611286565b612571565b5f6117a4612158565b905086816006015f820151815f0190816117be91906141d1565b5060208201518160010190816117d491906141d1565b5090505087815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505f85519050808711156118655786816040517f48676fe000000000000000000000000000000000000000000000000000000000815260040161185c929190613883565b60405180910390fd5b8682600a01819055505f5f90505b81811015611b0a576001836001015f89848151811061189557611894613ad4565b5b60200260200101515f015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff02191690831515021790555086818151811061190257611901613ad4565b5b6020026020010151836008015f89848151811061192257611921613ad4565b5b60200260200101515f015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f820151815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506020820151816001015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506040820151816002019081611a0591906141d1565b5090505082600901878281518110611a2057611a1f613ad4565b5b60200260200101515f0151908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506001836002015f898481518110611aa257611aa1613ad4565b5b60200260200101516020015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff0219169083151502179055508080600101915050611873565b505f5f90505b8551811015611da8576001836003015f888481518110611b3357611b32613ad4565b5b60200260200101515f015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550858181518110611ba057611b9f613ad4565b5b602002602001015183600b015f888481518110611bc057611bbf613ad4565b5b60200260200101515f015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f820151815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506020820151816001015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506040820151816002019081611ca391906141d1565b5090505082600c01868281518110611cbe57611cbd613ad4565b5b60200260200101515f0151908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506001836004015f888481518110611d4057611d3f613ad4565b5b60200260200101516020015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff0219169083151502179055508080600101915050611b10565b507ff33d908c4a8b532fe64df20b726f11405c11b9772d31b66f5eef6887a43c3fde8989898989604051611de09594939291906144b0565b60405180910390a150505f815f0160086101000a81548160ff0219169083151502179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d282604051611e349190614538565b60405180910390a150505050505050565b5f5f611e4f612585565b9050805f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b611e82612c91565b5f611e8b612158565b905080600b015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f206040518060600160405290815f82015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282018054611f9090613a63565b80601f0160208091040260200160405190810160405280929190818152602001828054611fbc90613a63565b80156120075780601f10611fde57610100808354040283529160200191612007565b820191905f5260205f20905b815481529060010190602001808311611fea57829003601f168201915b505050505081525050915050919050565b6120206120d1565b5f612029612585565b905081815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff1661208b611286565b73ffffffffffffffffffffffffffffffffffffffff167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a35050565b6120d961251c565b73ffffffffffffffffffffffffffffffffffffffff166120f7611286565b73ffffffffffffffffffffffffffffffffffffffff16146121565761211a61251c565b6040517f118cdaa700000000000000000000000000000000000000000000000000000000815260040161214d9190613173565b60405180910390fd5b565b5f7f827176a45e1aad1f3a6539fee60c06126c40427b4849e7301bf2cf0f1f8e9500905090565b60605f600161218d846125ac565b0190505f8167ffffffffffffffff8111156121ab576121aa612f39565b5b6040519080825280601f01601f1916602001820160405280156121dd5781602001600182028036833780820191505090505b5090505f82602001820190505b60011561223e578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a858161223357612232613b01565b5b0494505f85036121ea575b819350505050919050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614806122f657507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166122dd6126fd565b73ffffffffffffffffffffffffffffffffffffffff1614155b1561232d576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b6123376120d1565b50565b8173ffffffffffffffffffffffffffffffffffffffff166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa9250505080156123a257506040513d601f19601f8201168201806040525081019061239f919061457b565b60015b6123e357816040517f4c9c8ce30000000000000000000000000000000000000000000000000000000081526004016123da9190613173565b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b811461244957806040517faa1d49a400000000000000000000000000000000000000000000000000000000815260040161244091906130cf565b60405180910390fd5b6124538383612750565b505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff16146124dd576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f6124e8612585565b9050805f015f6101000a81549073ffffffffffffffffffffffffffffffffffffffff0219169055612518826127c2565b5050565b5f33905090565b5f7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300905090565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b612579612893565b612582816128d3565b50565b5f7f237e158222e3e6968b72b9db0d8043aacf074ad9f650f0d1606b4d82ee432c00905090565b5f5f5f90507a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008310612608577a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083816125fe576125fd613b01565b5b0492506040810190505b6d04ee2d6d415b85acef81000000008310612645576d04ee2d6d415b85acef8100000000838161263b5761263a613b01565b5b0492506020810190505b662386f26fc10000831061267457662386f26fc10000838161266a57612669613b01565b5b0492506010810190505b6305f5e100831061269d576305f5e100838161269357612692613b01565b5b0492506008810190505b61271083106126c25761271083816126b8576126b7613b01565b5b0492506004810190505b606483106126e557606483816126db576126da613b01565b5b0492506002810190505b600a83106126f4576001810190505b80915050919050565b5f6127297f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b612957565b5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b61275982612960565b8173ffffffffffffffffffffffffffffffffffffffff167fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b60405160405180910390a25f815111156127b5576127af8282612a29565b506127be565b6127bd612aa9565b5b5050565b5f6127cb612523565b90505f815f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905082825f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a3505050565b61289b612ae5565b6128d1576040517fd7e6bcf800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b6128db612893565b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff160361294b575f6040517f1e4fbdf70000000000000000000000000000000000000000000000000000000081526004016129429190613173565b60405180910390fd5b612954816124df565b50565b5f819050919050565b5f8173ffffffffffffffffffffffffffffffffffffffff163b036129bb57806040517f4c9c8ce30000000000000000000000000000000000000000000000000000000081526004016129b29190613173565b60405180910390fd5b806129e77f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b612957565b5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60605f5f8473ffffffffffffffffffffffffffffffffffffffff1684604051612a5291906145ea565b5f60405180830381855af49150503d805f8114612a8a576040519150601f19603f3d011682016040523d82523d5f602084013e612a8f565b606091505b5091509150612a9f858383612b03565b9250505092915050565b5f341115612ae3576040517fb398979f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f612aee61254a565b5f0160089054906101000a900460ff16905090565b606082612b1857612b1382612b90565b612b88565b5f8251148015612b3e57505f8473ffffffffffffffffffffffffffffffffffffffff163b145b15612b8057836040517f9996b315000000000000000000000000000000000000000000000000000000008152600401612b779190613173565b60405180910390fd5b819050612b89565b5b9392505050565b5f81511115612ba25780518082602001fd5b6040517fd6bda27500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b604051806040016040528060608152602001606081525090565b60405180606001604052805f73ffffffffffffffffffffffffffffffffffffffff1681526020015f73ffffffffffffffffffffffffffffffffffffffff168152602001606081525090565b6040518060a001604052805f81526020015f73ffffffffffffffffffffffffffffffffffffffff1681526020015f73ffffffffffffffffffffffffffffffffffffffff16815260200160608152602001606081525090565b60405180606001604052805f73ffffffffffffffffffffffffffffffffffffffff1681526020015f73ffffffffffffffffffffffffffffffffffffffff168152602001606081525090565b5f604051905090565b5f5ffd5b5f5ffd5b5f819050919050565b612cff81612ced565b8114612d09575f5ffd5b50565b5f81359050612d1a81612cf6565b92915050565b5f60208284031215612d3557612d34612ce5565b5b5f612d4284828501612d0c565b91505092915050565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f601f19601f8301169050919050565b5f612d8d82612d4b565b612d978185612d55565b9350612da7818560208601612d65565b612db081612d73565b840191505092915050565b5f6020820190508181035f830152612dd38184612d83565b905092915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f612e0482612ddb565b9050919050565b612e1481612dfa565b8114612e1e575f5ffd5b50565b5f81359050612e2f81612e0b565b92915050565b5f60208284031215612e4a57612e49612ce5565b5b5f612e5784828501612e21565b91505092915050565b612e6981612ced565b82525050565b5f602082019050612e825f830184612e60565b92915050565b5f82825260208201905092915050565b5f612ea282612d4b565b612eac8185612e88565b9350612ebc818560208601612d65565b612ec581612d73565b840191505092915050565b5f604083015f8301518482035f860152612eea8282612e98565b91505060208301518482036020860152612f048282612e98565b9150508091505092915050565b5f6020820190508181035f830152612f298184612ed0565b905092915050565b5f5ffd5b5f5ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b612f6f82612d73565b810181811067ffffffffffffffff82111715612f8e57612f8d612f39565b5b80604052505050565b5f612fa0612cdc565b9050612fac8282612f66565b919050565b5f67ffffffffffffffff821115612fcb57612fca612f39565b5b612fd482612d73565b9050602081019050919050565b828183375f83830152505050565b5f613001612ffc84612fb1565b612f97565b90508281526020810184848401111561301d5761301c612f35565b5b613028848285612fe1565b509392505050565b5f82601f83011261304457613043612f31565b5b8135613054848260208601612fef565b91505092915050565b5f5f6040838503121561307357613072612ce5565b5b5f61308085828601612e21565b925050602083013567ffffffffffffffff8111156130a1576130a0612ce9565b5b6130ad85828601613030565b9150509250929050565b5f819050919050565b6130c9816130b7565b82525050565b5f6020820190506130e25f8301846130c0565b92915050565b6130f181612dfa565b82525050565b5f606083015f83015161310c5f8601826130e8565b50602083015161311f60208601826130e8565b50604083015184820360408601526131378282612e98565b9150508091505092915050565b5f6020820190508181035f83015261315c81846130f7565b905092915050565b61316d81612dfa565b82525050565b5f6020820190506131865f830184613164565b92915050565b5f5ffd5b5f60a082840312156131a5576131a461318c565b5b81905092915050565b5f602082840312156131c3576131c2612ce5565b5b5f82013567ffffffffffffffff8111156131e0576131df612ce9565b5b6131ec84828501613190565b91505092915050565b6131fe81612ced565b82525050565b5f60a083015f8301516132195f8601826131f5565b50602083015161322c60208601826130e8565b50604083015161323f60408601826130e8565b50606083015184820360608601526132578282612e98565b915050608083015184820360808601526132718282612e98565b9150508091505092915050565b5f6020820190508181035f8301526132968184613204565b905092915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f6132d283836130e8565b60208301905092915050565b5f602082019050919050565b5f6132f48261329e565b6132fe81856132a8565b9350613309836132b8565b805f5b8381101561333957815161332088826132c7565b975061332b836132de565b92505060018101905061330c565b5085935050505092915050565b5f6020820190508181035f83015261335e81846132ea565b905092915050565b5f5ffd5b5f5ffd5b5f67ffffffffffffffff82111561338857613387612f39565b5b61339182612d73565b9050602081019050919050565b5f6133b06133ab8461336e565b612f97565b9050828152602081018484840111156133cc576133cb612f35565b5b6133d7848285612fe1565b509392505050565b5f82601f8301126133f3576133f2612f31565b5b813561340384826020860161339e565b91505092915050565b5f6040828403121561342157613420613366565b5b61342b6040612f97565b90505f82013567ffffffffffffffff81111561344a5761344961336a565b5b613456848285016133df565b5f83015250602082013567ffffffffffffffff8111156134795761347861336a565b5b613485848285016133df565b60208301525092915050565b5f67ffffffffffffffff8211156134ab576134aa612f39565b5b602082029050602081019050919050565b5f5ffd5b5f606082840312156134d5576134d4613366565b5b6134df6060612f97565b90505f6134ee84828501612e21565b5f83015250602061350184828501612e21565b602083015250604082013567ffffffffffffffff8111156135255761352461336a565b5b613531848285016133df565b60408301525092915050565b5f61354f61354a84613491565b612f97565b90508083825260208201905060208402830185811115613572576135716134bc565b5b835b818110156135b957803567ffffffffffffffff81111561359757613596612f31565b5b8086016135a489826134c0565b85526020850194505050602081019050613574565b5050509392505050565b5f82601f8301126135d7576135d6612f31565b5b81356135e784826020860161353d565b91505092915050565b5f67ffffffffffffffff82111561360a57613609612f39565b5b602082029050602081019050919050565b5f606082840312156136305761362f613366565b5b61363a6060612f97565b90505f61364984828501612e21565b5f83015250602061365c84828501612e21565b602083015250604082013567ffffffffffffffff8111156136805761367f61336a565b5b61368c848285016133df565b60408301525092915050565b5f6136aa6136a5846135f0565b612f97565b905080838252602082019050602084028301858111156136cd576136cc6134bc565b5b835b8181101561371457803567ffffffffffffffff8111156136f2576136f1612f31565b5b8086016136ff898261361b565b855260208501945050506020810190506136cf565b5050509392505050565b5f82601f83011261373257613731612f31565b5b8135613742848260208601613698565b91505092915050565b5f5f5f5f5f60a0868803121561376457613763612ce5565b5b5f61377188828901612e21565b955050602086013567ffffffffffffffff81111561379257613791612ce9565b5b61379e8882890161340c565b94505060406137af88828901612d0c565b935050606086013567ffffffffffffffff8111156137d0576137cf612ce9565b5b6137dc888289016135c3565b925050608086013567ffffffffffffffff8111156137fd576137fc612ce9565b5b6138098882890161371e565b9150509295509295909350565b5f606083015f83015161382b5f8601826130e8565b50602083015161383e60208601826130e8565b50604083015184820360408601526138568282612e98565b9150508091505092915050565b5f6020820190508181035f83015261387b8184613816565b905092915050565b5f6040820190506138965f830185612e60565b6138a36020830184612e60565b9392505050565b5f81905092915050565b5f6138be82612d4b565b6138c881856138aa565b93506138d8818560208601612d65565b80840191505092915050565b7f20760000000000000000000000000000000000000000000000000000000000005f82015250565b5f6139186002836138aa565b9150613923826138e4565b600282019050919050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f6139626001836138aa565b915061396d8261392e565b600182019050919050565b5f61398382876138b4565b915061398e8261390c565b915061399a82866138b4565b91506139a582613956565b91506139b182856138b4565b91506139bc82613956565b91506139c882846138b4565b915081905095945050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f613a0d82612ced565b9150613a1883612ced565b9250828201905080821115613a3057613a2f6139d6565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f6002820490506001821680613a7a57607f821691505b602082108103613a8d57613a8c613a36565b5b50919050565b5f613a9d82612ced565b9150613aa883612ced565b9250828202613ab681612ced565b91508282048414831517613acd57613acc6139d6565b5b5092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f613b3882612ced565b9150613b4383612ced565b925082613b5357613b52613b01565b5b828204905092915050565b5f8135613b6a81612cf6565b80915050919050565b5f815f1b9050919050565b5f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff613ba984613b73565b9350801983169250808416831791505092915050565b5f819050919050565b5f613be2613bdd613bd884612ced565b613bbf565b612ced565b9050919050565b5f819050919050565b613bfb82613bc8565b613c0e613c0782613be9565b8354613b7e565b8255505050565b5f8135613c2181612e0b565b80915050919050565b5f73ffffffffffffffffffffffffffffffffffffffff613c4984613b73565b9350801983169250808416831791505092915050565b5f613c79613c74613c6f84612ddb565b613bbf565b612ddb565b9050919050565b5f613c8a82613c5f565b9050919050565b5f613c9b82613c80565b9050919050565b5f819050919050565b613cb482613c91565b613cc7613cc082613ca2565b8354613c2a565b8255505050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f83356001602003843603038112613cf657613cf5613cce565b5b80840192508235915067ffffffffffffffff821115613d1857613d17613cd2565b5b602083019250600182023603831315613d3457613d33613cd6565b5b509250929050565b5f82905092915050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f60088302613da27fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82613d67565b613dac8683613d67565b95508019841693508086168417925050509392505050565b613dcd83613bc8565b613de1613dd982613be9565b848454613d73565b825550505050565b5f5f905090565b613df8613de9565b613e03818484613dc4565b505050565b5b81811015613e2657613e1b5f82613df0565b600181019050613e09565b5050565b601f821115613e6b57613e3c81613d46565b613e4584613d58565b81016020851015613e54578190505b613e68613e6085613d58565b830182613e08565b50505b505050565b5f82821c905092915050565b5f613e8b5f1984600802613e70565b1980831691505092915050565b5f613ea38383613e7c565b9150826002028217905092915050565b613ebd8383613d3c565b67ffffffffffffffff811115613ed657613ed5612f39565b5b613ee08254613a63565b613eeb828285613e2a565b5f601f831160018114613f18575f8415613f06578287013590505b613f108582613e98565b865550613f77565b601f198416613f2686613d46565b5f5b82811015613f4d57848901358255600182019150602085019450602081019050613f28565b86831015613f6a5784890135613f66601f891682613e7c565b8355505b6001600288020188555050505b50505050505050565b613f8b838383613eb3565b505050565b5f81015f830180613fa081613b5e565b9050613fac8184613bf2565b505050600181016020830180613fc181613c15565b9050613fcd8184613cab565b505050600281016040830180613fe281613c15565b9050613fee8184613cab565b50505060038101606083016140038185613cda565b61400e818386613f80565b5050505060048101608083016140248185613cda565b61402f818386613f80565b505050505050565b6140418282613f90565b5050565b5f6140536020840184612d0c565b905092915050565b5f6140696020840184612e21565b905092915050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f8335600160200384360303811261409957614098614079565b5b83810192508235915060208301925067ffffffffffffffff8211156140c1576140c0614071565b5b6001820236038313156140d7576140d6614075565b5b509250929050565b5f6140ea8385612e88565b93506140f7838584612fe1565b61410083612d73565b840190509392505050565b5f60a0830161411c5f840184614045565b6141285f8601826131f5565b50614136602084018461405b565b61414360208601826130e8565b50614151604084018461405b565b61415e60408601826130e8565b5061416c606084018461407d565b858303606087015261417f8382846140df565b92505050614190608084018461407d565b85830360808701526141a38382846140df565b925050508091505092915050565b5f6020820190508181035f8301526141c9818461410b565b905092915050565b6141da82612d4b565b67ffffffffffffffff8111156141f3576141f2612f39565b5b6141fd8254613a63565b614208828285613e2a565b5f60209050601f831160018114614239575f8415614227578287015190505b6142318582613e98565b865550614298565b601f19841661424786613d46565b5f5b8281101561426e57848901518255600182019150602085019450602081019050614249565b8683101561428b5784890151614287601f891682613e7c565b8355505b6001600288020188555050505b505050505050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f606083015f8301516142de5f8601826130e8565b5060208301516142f160208601826130e8565b50604083015184820360408601526143098282612e98565b9150508091505092915050565b5f61432183836142c9565b905092915050565b5f602082019050919050565b5f61433f826142a0565b61434981856142aa565b93508360208202850161435b856142ba565b805f5b8581101561439657848403895281516143778582614316565b945061438283614329565b925060208a0199505060018101905061435e565b50829750879550505050505092915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f606083015f8301516143e65f8601826130e8565b5060208301516143f960208601826130e8565b50604083015184820360408601526144118282612e98565b9150508091505092915050565b5f61442983836143d1565b905092915050565b5f602082019050919050565b5f614447826143a8565b61445181856143b2565b935083602082028501614463856143c2565b805f5b8581101561449e578484038952815161447f858261441e565b945061448a83614431565b925060208a01995050600181019050614466565b50829750879550505050505092915050565b5f60a0820190506144c35f830188613164565b81810360208301526144d58187612ed0565b90506144e46040830186612e60565b81810360608301526144f68185614335565b9050818103608083015261450a818461443d565b90509695505050505050565b5f67ffffffffffffffff82169050919050565b61453281614516565b82525050565b5f60208201905061454b5f830184614529565b92915050565b61455a816130b7565b8114614564575f5ffd5b50565b5f8151905061457581614551565b92915050565b5f602082840312156145905761458f612ce5565b5b5f61459d84828501614567565b91505092915050565b5f81519050919050565b5f81905092915050565b5f6145c4826145a6565b6145ce81856145b0565b93506145de818560208601612d65565b80840191505092915050565b5f6145f582846145ba565b91508190509291505056fea2646970667358221220742305e2295ae132c833c9a018fb9ddbe4760bef0426d506482e2e7856c9482064736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0`@R0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x80\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP4\x80\x15a\0BW__\xFD[Pa\0Qa\0V` \x1B` \x1CV[a\x01\xB6V[_a\0ea\x01T` \x1B` \x1CV[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a\0\xAFW`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x01QWg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@Qa\x01H\x91\x90a\x01\x9DV[`@Q\x80\x91\x03\x90\xA1[PV[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a\x01\x97\x81a\x01{V[\x82RPPV[_` \x82\x01\x90Pa\x01\xB0_\x83\x01\x84a\x01\x8EV[\x92\x91PPV[`\x80QaF6a\x01\xDC_9_\x81\x81a\"K\x01R\x81\x81a\"\xA0\x01Ra$Z\x01RaF6_\xF3\xFE`\x80`@R`\x046\x10a\x01\xD7W_5`\xE0\x1C\x80cqP\x18\xA6\x11a\x01\x01W\x80c\xC6\xB3\x02M\x11a\0\x94W\x80c\xD9\x81\x89\xA4\x11a\0cW\x80c\xD9\x81\x89\xA4\x14a\x06IW\x80c\xE3\x0C9x\x14a\x06qW\x80c\xEC\xBD\x96\xAB\x14a\x06\x9BW\x80c\xF2\xFD\xE3\x8B\x14a\x06\xD7Wa\x01\xD7V[\x80c\xC6\xB3\x02M\x14a\x05\x95W\x80c\xCBf\x17U\x14a\x05\xBDW\x80c\xCD\xB4\xC2\xB9\x14a\x05\xE5W\x80c\xD5$K\xF1\x14a\x06\rWa\x01\xD7V[\x80c\x8FJ\x7F^\x11a\0\xD0W\x80c\x8FJ\x7F^\x14a\x04\xEFW\x80c\xAD<\xB1\xCC\x14a\x05\x19W\x80c\xBD\xA0\xB9H\x14a\x05CW\x80c\xC6'RX\x14a\x05mWa\x01\xD7V[\x80cqP\x18\xA6\x14a\x04]W\x80cy\xBAP\x97\x14a\x04sW\x80c\x8B\xB0\xA1|\x14a\x04\x89W\x80c\x8D\xA5\xCB[\x14a\x04\xC5Wa\x01\xD7V[\x80cO\x1E\xF2\x86\x11a\x01yW\x80cZ\xB6\xD3\xAB\x11a\x01HW\x80cZ\xB6\xD3\xAB\x14a\x03\xA7W\x80cg\x99\xEFR\x14a\x03\xE3W\x80cl\x88\xEBC\x14a\x04\rW\x80cp\xCC\x9A<\x14a\x045Wa\x01\xD7V[\x80cO\x1E\xF2\x86\x14a\x02\xFDW\x80cR\xD1\x90-\x14a\x03\x19W\x80cT\xD3\xF6u\x14a\x03CW\x80cUK\xAB<\x14a\x03\x7FWa\x01\xD7V[\x80cG\xCDK>\x11a\x01\xB5W\x80cG\xCDK>\x14a\x02UW\x80cH\x14La\x14a\x02\x7FW\x80cI\x04\x13\xAA\x14a\x02\xA9W\x80cI!\xA3\xBD\x14a\x02\xD3Wa\x01\xD7V[\x80c\x02\x19\x15\x0F\x14a\x01\xDBW\x80c\r\x8En,\x14a\x02\x03W\x80c\x19Z\xFD\xE6\x14a\x02-W[__\xFD[4\x80\x15a\x01\xE6W__\xFD[Pa\x02\x01`\x04\x806\x03\x81\x01\x90a\x01\xFC\x91\x90a- V[a\x06\xFFV[\0[4\x80\x15a\x02\x0EW__\xFD[Pa\x02\x17a\x07\xABV[`@Qa\x02$\x91\x90a-\xBBV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x028W__\xFD[Pa\x02S`\x04\x806\x03\x81\x01\x90a\x02N\x91\x90a.5V[a\x08&V[\0[4\x80\x15a\x02`W__\xFD[Pa\x02ia\x08\xC7V[`@Qa\x02v\x91\x90a.oV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\x8AW__\xFD[Pa\x02\x93a\x08\xEAV[`@Qa\x02\xA0\x91\x90a/\x11V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xB4W__\xFD[Pa\x02\xBDa\n1V[`@Qa\x02\xCA\x91\x90a.oV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xDEW__\xFD[Pa\x02\xE7a\n`V[`@Qa\x02\xF4\x91\x90a.oV[`@Q\x80\x91\x03\x90\xF3[a\x03\x17`\x04\x806\x03\x81\x01\x90a\x03\x12\x91\x90a0]V[a\nwV[\0[4\x80\x15a\x03$W__\xFD[Pa\x03-a\n\x96V[`@Qa\x03:\x91\x90a0\xCFV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03NW__\xFD[Pa\x03i`\x04\x806\x03\x81\x01\x90a\x03d\x91\x90a.5V[a\n\xC7V[`@Qa\x03v\x91\x90a1DV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x8AW__\xFD[Pa\x03\xA5`\x04\x806\x03\x81\x01\x90a\x03\xA0\x91\x90a.5V[a\x0CeV[\0[4\x80\x15a\x03\xB2W__\xFD[Pa\x03\xCD`\x04\x806\x03\x81\x01\x90a\x03\xC8\x91\x90a- V[a\rYV[`@Qa\x03\xDA\x91\x90a1sV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xEEW__\xFD[Pa\x03\xF7a\r\xABV[`@Qa\x04\x04\x91\x90a.oV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x18W__\xFD[Pa\x043`\x04\x806\x03\x81\x01\x90a\x04.\x91\x90a.5V[a\r\xDDV[\0[4\x80\x15a\x04@W__\xFD[Pa\x04[`\x04\x806\x03\x81\x01\x90a\x04V\x91\x90a1\xAEV[a\x0EyV[\0[4\x80\x15a\x04hW__\xFD[Pa\x04qa\x0F\xCAV[\0[4\x80\x15a\x04~W__\xFD[Pa\x04\x87a\x0F\xDDV[\0[4\x80\x15a\x04\x94W__\xFD[Pa\x04\xAF`\x04\x806\x03\x81\x01\x90a\x04\xAA\x91\x90a- V[a\x10kV[`@Qa\x04\xBC\x91\x90a2~V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xD0W__\xFD[Pa\x04\xD9a\x12\x86V[`@Qa\x04\xE6\x91\x90a1sV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xFAW__\xFD[Pa\x05\x03a\x12\xBBV[`@Qa\x05\x10\x91\x90a3FV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05$W__\xFD[Pa\x05-a\x13TV[`@Qa\x05:\x91\x90a-\xBBV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05NW__\xFD[Pa\x05Wa\x13\x8DV[`@Qa\x05d\x91\x90a3FV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05xW__\xFD[Pa\x05\x93`\x04\x806\x03\x81\x01\x90a\x05\x8E\x91\x90a.5V[a\x14&V[\0[4\x80\x15a\x05\xA0W__\xFD[Pa\x05\xBB`\x04\x806\x03\x81\x01\x90a\x05\xB6\x91\x90a- V[a\x14\xC2V[\0[4\x80\x15a\x05\xC8W__\xFD[Pa\x05\xE3`\x04\x806\x03\x81\x01\x90a\x05\xDE\x91\x90a.5V[a\x152V[\0[4\x80\x15a\x05\xF0W__\xFD[Pa\x06\x0B`\x04\x806\x03\x81\x01\x90a\x06\x06\x91\x90a.5V[a\x15\xCEV[\0[4\x80\x15a\x06\x18W__\xFD[Pa\x063`\x04\x806\x03\x81\x01\x90a\x06.\x91\x90a- V[a\x16jV[`@Qa\x06@\x91\x90a1sV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06TW__\xFD[Pa\x06o`\x04\x806\x03\x81\x01\x90a\x06j\x91\x90a7KV[a\x16\xBCV[\0[4\x80\x15a\x06|W__\xFD[Pa\x06\x85a\x1EEV[`@Qa\x06\x92\x91\x90a1sV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xA6W__\xFD[Pa\x06\xC1`\x04\x806\x03\x81\x01\x90a\x06\xBC\x91\x90a.5V[a\x1EzV[`@Qa\x06\xCE\x91\x90a8cV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xE2W__\xFD[Pa\x06\xFD`\x04\x806\x03\x81\x01\x90a\x06\xF8\x91\x90a.5V[a \x18V[\0[a\x07\x07a \xD1V[_a\x07\x10a!XV[\x90P\x80`\t\x01\x80T\x90P\x82\x11\x15a\x07gW\x81\x81`\t\x01\x80T\x90P`@Q\x7FHgo\xE0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x07^\x92\x91\x90a8\x83V[`@Q\x80\x91\x03\x90\xFD[\x81\x81`\n\x01\x81\x90UP\x7F\xEAle!\xBCIW1\x08.#\xAD\x12\xC7\xB1 }\x13\xCA\x0B\xD3\x8D\x1DQ\x10\x81\xABV\x89\x17\xCB\x84\x82`@Qa\x07\x9F\x91\x90a.oV[`@Q\x80\x91\x03\x90\xA1PPV[```@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7FHTTPZ\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa\x07\xEC_a!\x7FV[a\x07\xF6`\x01a!\x7FV[a\x07\xFF_a!\x7FV[`@Q` \x01a\x08\x12\x94\x93\x92\x91\x90a9xV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P\x90V[_a\x08/a!XV[\x90P\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x08\xC3W\x81`@Q\x7F j4n\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x08\xBA\x91\x90a1sV[`@Q\x80\x91\x03\x90\xFD[PPV[__a\x08\xD1a!XV[\x90P`\x01\x81`\n\x01Ta\x08\xE4\x91\x90a:\x03V[\x91PP\x90V[a\x08\xF2a+\xD4V[_a\x08\xFBa!XV[\x90P\x80`\x06\x01`@Q\x80`@\x01`@R\x90\x81_\x82\x01\x80Ta\t\x1B\x90a:cV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\tG\x90a:cV[\x80\x15a\t\x92W\x80`\x1F\x10a\tiWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\t\x92V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\tuW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01\x80Ta\t\xAB\x90a:cV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\t\xD7\x90a:cV[\x80\x15a\n\"W\x80`\x1F\x10a\t\xF9Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\n\"V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\n\x05W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x91PP\x90V[__a\n;a!XV[\x90P`\x01\x81`\n\x01T`\x02a\nP\x91\x90a:\x93V[a\nZ\x91\x90a:\x03V[\x91PP\x90V[__a\nja!XV[\x90P\x80`\n\x01T\x91PP\x90V[a\n\x7Fa\"IV[a\n\x88\x82a#/V[a\n\x92\x82\x82a#:V[PPV[_a\n\x9Fa$XV[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x90P\x90V[a\n\xCFa+\xEEV[_a\n\xD8a!XV[\x90P\x80`\x08\x01_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `@Q\x80``\x01`@R\x90\x81_\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01\x80Ta\x0B\xDD\x90a:cV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0C\t\x90a:cV[\x80\x15a\x0CTW\x80`\x1F\x10a\x0C+Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0CTV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0C7W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x91PP\x91\x90PV[a\x0Cma \xD1V[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x0C\xD2W`@Q\x7F5U\xAE\xD1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a\x0C\xDBa!XV[\x90P\x81\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x7F\xA6\x90f\x8C$\xD2w$?\xF6\xFAe\r?\xD6\xE3\xD31\xA9\x9C\xA0\xA8\x85|\x82\xE7\xF8\x94R\xFCf]\x82`@Qa\rM\x91\x90a1sV[`@Q\x80\x91\x03\x90\xA1PPV[__a\rca!XV[\x90P\x80`\x0C\x01\x83\x81T\x81\x10a\r{Wa\rza:\xD4V[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x91\x90PV[__a\r\xB5a!XV[\x90P`\x01`\x02\x82`\x0C\x01\x80T\x90Pa\r\xCD\x91\x90a;.V[a\r\xD7\x91\x90a:\x03V[\x91PP\x90V[_a\r\xE6a!XV[\x90P\x80`\x02\x01_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x0EuW\x81`@Q\x7F*|n\xF6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0El\x91\x90a1sV[`@Q\x80\x91\x03\x90\xFD[PPV[_\x81_\x015\x03a\x0E\xB5W`@Q\x7F\"\xF7?\xEA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a\x0E\xBEa!XV[\x90P\x80`\x05\x01_\x83_\x015\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a\x0F(W\x81_\x015`@Q\x7F\xB1\x82\\^\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0F\x1F\x91\x90a.oV[`@Q\x80\x91\x03\x90\xFD[\x80`\r\x01\x82\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x05\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a\x0F_\x91\x90a@7V[PP`\x01\x81`\x05\x01_\x84_\x015\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xB8 {[\xB7\x91s\n\xE8\xF0SO\xA4\xC7\xBE}\xA4\x9D\xD7]p\x1F\x9Cz\xCFQ\xC9K\x8A\xCE\x96\xB2\x82`@Qa\x0F\xBE\x91\x90aA\xB1V[`@Q\x80\x91\x03\x90\xA1PPV[a\x0F\xD2a \xD1V[a\x0F\xDB_a$\xDFV[V[_a\x0F\xE6a%\x1CV[\x90P\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x10\x07a\x1EEV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x10_W\x80`@Q\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x10V\x91\x90a1sV[`@Q\x80\x91\x03\x90\xFD[a\x10h\x81a$\xDFV[PV[a\x10sa,9V[_a\x10|a!XV[\x90P\x80`\r\x01\x83\x81T\x81\x10a\x10\x94Wa\x10\x93a:\xD4V[[\x90_R` _ \x90`\x05\x02\x01`@Q\x80`\xA0\x01`@R\x90\x81_\x82\x01T\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01\x80Ta\x11n\x90a:cV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x11\x9A\x90a:cV[\x80\x15a\x11\xE5W\x80`\x1F\x10a\x11\xBCWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x11\xE5V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x11\xC8W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x04\x82\x01\x80Ta\x11\xFE\x90a:cV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x12*\x90a:cV[\x80\x15a\x12uW\x80`\x1F\x10a\x12LWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x12uV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x12XW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x91PP\x91\x90PV[__a\x12\x90a%#V[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x90V[``_a\x12\xC6a!XV[\x90P\x80`\x0C\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x13IW` \x02\x82\x01\x91\x90_R` _ \x90[\x81_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x13\0W[PPPPP\x91PP\x90V[`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x81V[``_a\x13\x98a!XV[\x90P\x80`\t\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x14\x1BW` \x02\x82\x01\x91\x90_R` _ \x90[\x81_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x13\xD2W[PPPPP\x91PP\x90V[_a\x14/a!XV[\x90P\x80`\x01\x01_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x14\xBEW\x81`@Q\x7F\xAE\xE8c#\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14\xB5\x91\x90a1sV[`@Q\x80\x91\x03\x90\xFD[PPV[_a\x14\xCBa!XV[\x90P\x80`\x05\x01_\x83\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x15.W\x81`@Q\x7Fm\xF6\xFE\x89\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x15%\x91\x90a.oV[`@Q\x80\x91\x03\x90\xFD[PPV[_a\x15;a!XV[\x90P\x80`\x03\x01_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x15\xCAW\x81`@Q\x7FR\xD7%\xF5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x15\xC1\x91\x90a1sV[`@Q\x80\x91\x03\x90\xFD[PPV[_a\x15\xD7a!XV[\x90P\x80`\x04\x01_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x16fW\x81`@Q\x7F&\xCDu\xDC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x16]\x91\x90a1sV[`@Q\x80\x91\x03\x90\xFD[PPV[__a\x16ta!XV[\x90P\x80`\t\x01\x83\x81T\x81\x10a\x16\x8CWa\x16\x8Ba:\xD4V[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x91\x90PV[`\x02_a\x16\xC7a%JV[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a\x17\x0FWP\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15[\x15a\x17FW`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPa\x17\x9Ba\x17\x96a\x12\x86V[a%qV[_a\x17\xA4a!XV[\x90P\x86\x81`\x06\x01_\x82\x01Q\x81_\x01\x90\x81a\x17\xBE\x91\x90aA\xD1V[P` \x82\x01Q\x81`\x01\x01\x90\x81a\x17\xD4\x91\x90aA\xD1V[P\x90PP\x87\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP_\x85Q\x90P\x80\x87\x11\x15a\x18eW\x86\x81`@Q\x7FHgo\xE0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x18\\\x92\x91\x90a8\x83V[`@Q\x80\x91\x03\x90\xFD[\x86\x82`\n\x01\x81\x90UP__\x90P[\x81\x81\x10\x15a\x1B\nW`\x01\x83`\x01\x01_\x89\x84\x81Q\x81\x10a\x18\x95Wa\x18\x94a:\xD4V[[` \x02` \x01\x01Q_\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x86\x81\x81Q\x81\x10a\x19\x02Wa\x19\x01a:\xD4V[[` \x02` \x01\x01Q\x83`\x08\x01_\x89\x84\x81Q\x81\x10a\x19\"Wa\x19!a:\xD4V[[` \x02` \x01\x01Q_\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x82\x01Q\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP` \x82\x01Q\x81`\x01\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`@\x82\x01Q\x81`\x02\x01\x90\x81a\x1A\x05\x91\x90aA\xD1V[P\x90PP\x82`\t\x01\x87\x82\x81Q\x81\x10a\x1A Wa\x1A\x1Fa:\xD4V[[` \x02` \x01\x01Q_\x01Q\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x83`\x02\x01_\x89\x84\x81Q\x81\x10a\x1A\xA2Wa\x1A\xA1a:\xD4V[[` \x02` \x01\x01Q` \x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x80\x80`\x01\x01\x91PPa\x18sV[P__\x90P[\x85Q\x81\x10\x15a\x1D\xA8W`\x01\x83`\x03\x01_\x88\x84\x81Q\x81\x10a\x1B3Wa\x1B2a:\xD4V[[` \x02` \x01\x01Q_\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x85\x81\x81Q\x81\x10a\x1B\xA0Wa\x1B\x9Fa:\xD4V[[` \x02` \x01\x01Q\x83`\x0B\x01_\x88\x84\x81Q\x81\x10a\x1B\xC0Wa\x1B\xBFa:\xD4V[[` \x02` \x01\x01Q_\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x82\x01Q\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP` \x82\x01Q\x81`\x01\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`@\x82\x01Q\x81`\x02\x01\x90\x81a\x1C\xA3\x91\x90aA\xD1V[P\x90PP\x82`\x0C\x01\x86\x82\x81Q\x81\x10a\x1C\xBEWa\x1C\xBDa:\xD4V[[` \x02` \x01\x01Q_\x01Q\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x83`\x04\x01_\x88\x84\x81Q\x81\x10a\x1D@Wa\x1D?a:\xD4V[[` \x02` \x01\x01Q` \x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x80\x80`\x01\x01\x91PPa\x1B\x10V[P\x7F\xF3=\x90\x8CJ\x8BS/\xE6M\xF2\x0Bro\x11@\\\x11\xB9w-1\xB6o^\xEFh\x87\xA4<?\xDE\x89\x89\x89\x89\x89`@Qa\x1D\xE0\x95\x94\x93\x92\x91\x90aD\xB0V[`@Q\x80\x91\x03\x90\xA1PP_\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x82`@Qa\x1E4\x91\x90aE8V[`@Q\x80\x91\x03\x90\xA1PPPPPPPV[__a\x1EOa%\x85V[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x90V[a\x1E\x82a,\x91V[_a\x1E\x8Ba!XV[\x90P\x80`\x0B\x01_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `@Q\x80``\x01`@R\x90\x81_\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01\x80Ta\x1F\x90\x90a:cV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x1F\xBC\x90a:cV[\x80\x15a \x07W\x80`\x1F\x10a\x1F\xDEWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a \x07V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x1F\xEAW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x91PP\x91\x90PV[a  a \xD1V[_a )a%\x85V[\x90P\x81\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a \x8Ba\x12\x86V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F8\xD1k\x8C\xAC\"\xD9\x9F\xC7\xC1$\xB9\xCD\r\xE2\xD3\xFA\x1F\xAE\xF4 \xBF\xE7\x91\xD8\xC3b\xD7e\xE2'\0`@Q`@Q\x80\x91\x03\x90\xA3PPV[a \xD9a%\x1CV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a \xF7a\x12\x86V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a!VWa!\x1Aa%\x1CV[`@Q\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a!M\x91\x90a1sV[`@Q\x80\x91\x03\x90\xFD[V[_\x7F\x82qv\xA4^\x1A\xAD\x1F:e9\xFE\xE6\x0C\x06\x12l@B{HI\xE70\x1B\xF2\xCF\x0F\x1F\x8E\x95\0\x90P\x90V[``_`\x01a!\x8D\x84a%\xACV[\x01\x90P_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a!\xABWa!\xAAa/9V[[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a!\xDDW\x81` \x01`\x01\x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x90P_\x82` \x01\x82\x01\x90P[`\x01\x15a\">W\x80\x80`\x01\x90\x03\x91PP\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\n\x86\x06\x1A\x81S`\n\x85\x81a\"3Wa\"2a;\x01V[[\x04\x94P_\x85\x03a!\xEAW[\x81\x93PPPP\x91\x90PV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x80a\"\xF6WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\"\xDDa&\xFDV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15a#-W`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[a#7a \xD1V[PV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cR\xD1\x90-`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15a#\xA2WP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a#\x9F\x91\x90aE{V[`\x01[a#\xE3W\x81`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a#\xDA\x91\x90a1sV[`@Q\x80\x91\x03\x90\xFD[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x81\x14a$IW\x80`@Q\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a$@\x91\x90a0\xCFV[`@Q\x80\x91\x03\x90\xFD[a$S\x83\x83a'PV[PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a$\xDDW`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_a$\xE8a%\x85V[\x90P\x80_\x01_a\x01\0\n\x81T\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90Ua%\x18\x82a'\xC2V[PPV[_3\x90P\x90V[_\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0\x90P\x90V[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[a%ya(\x93V[a%\x82\x81a(\xD3V[PV[_\x7F#~\x15\x82\"\xE3\xE6\x96\x8Br\xB9\xDB\r\x80C\xAA\xCF\x07J\xD9\xF6P\xF0\xD1`kM\x82\xEEC,\0\x90P\x90V[___\x90Pz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x10a&\x08Wz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x81a%\xFEWa%\xFDa;\x01V[[\x04\x92P`@\x81\x01\x90P[m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x10a&EWm\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x81a&;Wa&:a;\x01V[[\x04\x92P` \x81\x01\x90P[f#\x86\xF2o\xC1\0\0\x83\x10a&tWf#\x86\xF2o\xC1\0\0\x83\x81a&jWa&ia;\x01V[[\x04\x92P`\x10\x81\x01\x90P[c\x05\xF5\xE1\0\x83\x10a&\x9DWc\x05\xF5\xE1\0\x83\x81a&\x93Wa&\x92a;\x01V[[\x04\x92P`\x08\x81\x01\x90P[a'\x10\x83\x10a&\xC2Wa'\x10\x83\x81a&\xB8Wa&\xB7a;\x01V[[\x04\x92P`\x04\x81\x01\x90P[`d\x83\x10a&\xE5W`d\x83\x81a&\xDBWa&\xDAa;\x01V[[\x04\x92P`\x02\x81\x01\x90P[`\n\x83\x10a&\xF4W`\x01\x81\x01\x90P[\x80\x91PP\x91\x90PV[_a')\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Ba)WV[_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[a'Y\x82a)`V[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;`@Q`@Q\x80\x91\x03\x90\xA2_\x81Q\x11\x15a'\xB5Wa'\xAF\x82\x82a*)V[Pa'\xBEV[a'\xBDa*\xA9V[[PPV[_a'\xCBa%#V[\x90P_\x81_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x82\x82_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPPV[a(\x9Ba*\xE5V[a(\xD1W`@Q\x7F\xD7\xE6\xBC\xF8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[a(\xDBa(\x93V[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a)KW_`@Q\x7F\x1EO\xBD\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a)B\x91\x90a1sV[`@Q\x80\x91\x03\x90\xFD[a)T\x81a$\xDFV[PV[_\x81\x90P\x91\x90PV[_\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x03a)\xBBW\x80`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a)\xB2\x91\x90a1sV[`@Q\x80\x91\x03\x90\xFD[\x80a)\xE7\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Ba)WV[_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[``__\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84`@Qa*R\x91\x90aE\xEAV[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a*\x8AW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a*\x8FV[``\x91P[P\x91P\x91Pa*\x9F\x85\x83\x83a+\x03V[\x92PPP\x92\x91PPV[_4\x11\x15a*\xE3W`@Q\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_a*\xEEa%JV[_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x90P\x90V[``\x82a+\x18Wa+\x13\x82a+\x90V[a+\x88V[_\x82Q\x14\x80\x15a+>WP_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x14[\x15a+\x80W\x83`@Q\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a+w\x91\x90a1sV[`@Q\x80\x91\x03\x90\xFD[\x81\x90Pa+\x89V[[\x93\x92PPPV[_\x81Q\x11\x15a+\xA2W\x80Q\x80\x82` \x01\xFD[`@Q\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Q\x80`@\x01`@R\x80``\x81R` \x01``\x81RP\x90V[`@Q\x80``\x01`@R\x80_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01``\x81RP\x90V[`@Q\x80`\xA0\x01`@R\x80_\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01``\x81R` \x01``\x81RP\x90V[`@Q\x80``\x01`@R\x80_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01``\x81RP\x90V[_`@Q\x90P\x90V[__\xFD[__\xFD[_\x81\x90P\x91\x90PV[a,\xFF\x81a,\xEDV[\x81\x14a-\tW__\xFD[PV[_\x815\x90Pa-\x1A\x81a,\xF6V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a-5Wa-4a,\xE5V[[_a-B\x84\x82\x85\x01a-\x0CV[\x91PP\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x82\x81\x83^_\x83\x83\x01RPPPV[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[_a-\x8D\x82a-KV[a-\x97\x81\x85a-UV[\x93Pa-\xA7\x81\x85` \x86\x01a-eV[a-\xB0\x81a-sV[\x84\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra-\xD3\x81\x84a-\x83V[\x90P\x92\x91PPV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a.\x04\x82a-\xDBV[\x90P\x91\x90PV[a.\x14\x81a-\xFAV[\x81\x14a.\x1EW__\xFD[PV[_\x815\x90Pa./\x81a.\x0BV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a.JWa.Ia,\xE5V[[_a.W\x84\x82\x85\x01a.!V[\x91PP\x92\x91PPV[a.i\x81a,\xEDV[\x82RPPV[_` \x82\x01\x90Pa.\x82_\x83\x01\x84a.`V[\x92\x91PPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_a.\xA2\x82a-KV[a.\xAC\x81\x85a.\x88V[\x93Pa.\xBC\x81\x85` \x86\x01a-eV[a.\xC5\x81a-sV[\x84\x01\x91PP\x92\x91PPV[_`@\x83\x01_\x83\x01Q\x84\x82\x03_\x86\x01Ra.\xEA\x82\x82a.\x98V[\x91PP` \x83\x01Q\x84\x82\x03` \x86\x01Ra/\x04\x82\x82a.\x98V[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra/)\x81\x84a.\xD0V[\x90P\x92\x91PPV[__\xFD[__\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[a/o\x82a-sV[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a/\x8EWa/\x8Da/9V[[\x80`@RPPPV[_a/\xA0a,\xDCV[\x90Pa/\xAC\x82\x82a/fV[\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a/\xCBWa/\xCAa/9V[[a/\xD4\x82a-sV[\x90P` \x81\x01\x90P\x91\x90PV[\x82\x81\x837_\x83\x83\x01RPPPV[_a0\x01a/\xFC\x84a/\xB1V[a/\x97V[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a0\x1DWa0\x1Ca/5V[[a0(\x84\x82\x85a/\xE1V[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a0DWa0Ca/1V[[\x815a0T\x84\x82` \x86\x01a/\xEFV[\x91PP\x92\x91PPV[__`@\x83\x85\x03\x12\x15a0sWa0ra,\xE5V[[_a0\x80\x85\x82\x86\x01a.!V[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a0\xA1Wa0\xA0a,\xE9V[[a0\xAD\x85\x82\x86\x01a00V[\x91PP\x92P\x92\x90PV[_\x81\x90P\x91\x90PV[a0\xC9\x81a0\xB7V[\x82RPPV[_` \x82\x01\x90Pa0\xE2_\x83\x01\x84a0\xC0V[\x92\x91PPV[a0\xF1\x81a-\xFAV[\x82RPPV[_``\x83\x01_\x83\x01Qa1\x0C_\x86\x01\x82a0\xE8V[P` \x83\x01Qa1\x1F` \x86\x01\x82a0\xE8V[P`@\x83\x01Q\x84\x82\x03`@\x86\x01Ra17\x82\x82a.\x98V[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra1\\\x81\x84a0\xF7V[\x90P\x92\x91PPV[a1m\x81a-\xFAV[\x82RPPV[_` \x82\x01\x90Pa1\x86_\x83\x01\x84a1dV[\x92\x91PPV[__\xFD[_`\xA0\x82\x84\x03\x12\x15a1\xA5Wa1\xA4a1\x8CV[[\x81\x90P\x92\x91PPV[_` \x82\x84\x03\x12\x15a1\xC3Wa1\xC2a,\xE5V[[_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a1\xE0Wa1\xDFa,\xE9V[[a1\xEC\x84\x82\x85\x01a1\x90V[\x91PP\x92\x91PPV[a1\xFE\x81a,\xEDV[\x82RPPV[_`\xA0\x83\x01_\x83\x01Qa2\x19_\x86\x01\x82a1\xF5V[P` \x83\x01Qa2,` \x86\x01\x82a0\xE8V[P`@\x83\x01Qa2?`@\x86\x01\x82a0\xE8V[P``\x83\x01Q\x84\x82\x03``\x86\x01Ra2W\x82\x82a.\x98V[\x91PP`\x80\x83\x01Q\x84\x82\x03`\x80\x86\x01Ra2q\x82\x82a.\x98V[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra2\x96\x81\x84a2\x04V[\x90P\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_a2\xD2\x83\x83a0\xE8V[` \x83\x01\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_a2\xF4\x82a2\x9EV[a2\xFE\x81\x85a2\xA8V[\x93Pa3\t\x83a2\xB8V[\x80_[\x83\x81\x10\x15a39W\x81Qa3 \x88\x82a2\xC7V[\x97Pa3+\x83a2\xDEV[\x92PP`\x01\x81\x01\x90Pa3\x0CV[P\x85\x93PPPP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra3^\x81\x84a2\xEAV[\x90P\x92\x91PPV[__\xFD[__\xFD[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a3\x88Wa3\x87a/9V[[a3\x91\x82a-sV[\x90P` \x81\x01\x90P\x91\x90PV[_a3\xB0a3\xAB\x84a3nV[a/\x97V[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a3\xCCWa3\xCBa/5V[[a3\xD7\x84\x82\x85a/\xE1V[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a3\xF3Wa3\xF2a/1V[[\x815a4\x03\x84\x82` \x86\x01a3\x9EV[\x91PP\x92\x91PPV[_`@\x82\x84\x03\x12\x15a4!Wa4 a3fV[[a4+`@a/\x97V[\x90P_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a4JWa4Ia3jV[[a4V\x84\x82\x85\x01a3\xDFV[_\x83\x01RP` \x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a4yWa4xa3jV[[a4\x85\x84\x82\x85\x01a3\xDFV[` \x83\x01RP\x92\x91PPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a4\xABWa4\xAAa/9V[[` \x82\x02\x90P` \x81\x01\x90P\x91\x90PV[__\xFD[_``\x82\x84\x03\x12\x15a4\xD5Wa4\xD4a3fV[[a4\xDF``a/\x97V[\x90P_a4\xEE\x84\x82\x85\x01a.!V[_\x83\x01RP` a5\x01\x84\x82\x85\x01a.!V[` \x83\x01RP`@\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a5%Wa5$a3jV[[a51\x84\x82\x85\x01a3\xDFV[`@\x83\x01RP\x92\x91PPV[_a5Oa5J\x84a4\x91V[a/\x97V[\x90P\x80\x83\x82R` \x82\x01\x90P` \x84\x02\x83\x01\x85\x81\x11\x15a5rWa5qa4\xBCV[[\x83[\x81\x81\x10\x15a5\xB9W\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a5\x97Wa5\x96a/1V[[\x80\x86\x01a5\xA4\x89\x82a4\xC0V[\x85R` \x85\x01\x94PPP` \x81\x01\x90Pa5tV[PPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a5\xD7Wa5\xD6a/1V[[\x815a5\xE7\x84\x82` \x86\x01a5=V[\x91PP\x92\x91PPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a6\nWa6\ta/9V[[` \x82\x02\x90P` \x81\x01\x90P\x91\x90PV[_``\x82\x84\x03\x12\x15a60Wa6/a3fV[[a6:``a/\x97V[\x90P_a6I\x84\x82\x85\x01a.!V[_\x83\x01RP` a6\\\x84\x82\x85\x01a.!V[` \x83\x01RP`@\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a6\x80Wa6\x7Fa3jV[[a6\x8C\x84\x82\x85\x01a3\xDFV[`@\x83\x01RP\x92\x91PPV[_a6\xAAa6\xA5\x84a5\xF0V[a/\x97V[\x90P\x80\x83\x82R` \x82\x01\x90P` \x84\x02\x83\x01\x85\x81\x11\x15a6\xCDWa6\xCCa4\xBCV[[\x83[\x81\x81\x10\x15a7\x14W\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a6\xF2Wa6\xF1a/1V[[\x80\x86\x01a6\xFF\x89\x82a6\x1BV[\x85R` \x85\x01\x94PPP` \x81\x01\x90Pa6\xCFV[PPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a72Wa71a/1V[[\x815a7B\x84\x82` \x86\x01a6\x98V[\x91PP\x92\x91PPV[_____`\xA0\x86\x88\x03\x12\x15a7dWa7ca,\xE5V[[_a7q\x88\x82\x89\x01a.!V[\x95PP` \x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a7\x92Wa7\x91a,\xE9V[[a7\x9E\x88\x82\x89\x01a4\x0CV[\x94PP`@a7\xAF\x88\x82\x89\x01a-\x0CV[\x93PP``\x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a7\xD0Wa7\xCFa,\xE9V[[a7\xDC\x88\x82\x89\x01a5\xC3V[\x92PP`\x80\x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a7\xFDWa7\xFCa,\xE9V[[a8\t\x88\x82\x89\x01a7\x1EV[\x91PP\x92\x95P\x92\x95\x90\x93PV[_``\x83\x01_\x83\x01Qa8+_\x86\x01\x82a0\xE8V[P` \x83\x01Qa8>` \x86\x01\x82a0\xE8V[P`@\x83\x01Q\x84\x82\x03`@\x86\x01Ra8V\x82\x82a.\x98V[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra8{\x81\x84a8\x16V[\x90P\x92\x91PPV[_`@\x82\x01\x90Pa8\x96_\x83\x01\x85a.`V[a8\xA3` \x83\x01\x84a.`V[\x93\x92PPPV[_\x81\x90P\x92\x91PPV[_a8\xBE\x82a-KV[a8\xC8\x81\x85a8\xAAV[\x93Pa8\xD8\x81\x85` \x86\x01a-eV[\x80\x84\x01\x91PP\x92\x91PPV[\x7F v\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a9\x18`\x02\x83a8\xAAV[\x91Pa9#\x82a8\xE4V[`\x02\x82\x01\x90P\x91\x90PV[\x7F.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a9b`\x01\x83a8\xAAV[\x91Pa9m\x82a9.V[`\x01\x82\x01\x90P\x91\x90PV[_a9\x83\x82\x87a8\xB4V[\x91Pa9\x8E\x82a9\x0CV[\x91Pa9\x9A\x82\x86a8\xB4V[\x91Pa9\xA5\x82a9VV[\x91Pa9\xB1\x82\x85a8\xB4V[\x91Pa9\xBC\x82a9VV[\x91Pa9\xC8\x82\x84a8\xB4V[\x91P\x81\x90P\x95\x94PPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_a:\r\x82a,\xEDV[\x91Pa:\x18\x83a,\xEDV[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15a:0Wa:/a9\xD6V[[\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\"`\x04R`$_\xFD[_`\x02\x82\x04\x90P`\x01\x82\x16\x80a:zW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a:\x8DWa:\x8Ca:6V[[P\x91\x90PV[_a:\x9D\x82a,\xEDV[\x91Pa:\xA8\x83a,\xEDV[\x92P\x82\x82\x02a:\xB6\x81a,\xEDV[\x91P\x82\x82\x04\x84\x14\x83\x15\x17a:\xCDWa:\xCCa9\xD6V[[P\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_a;8\x82a,\xEDV[\x91Pa;C\x83a,\xEDV[\x92P\x82a;SWa;Ra;\x01V[[\x82\x82\x04\x90P\x92\x91PPV[_\x815a;j\x81a,\xF6V[\x80\x91PP\x91\x90PV[_\x81_\x1B\x90P\x91\x90PV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa;\xA9\x84a;sV[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[_\x81\x90P\x91\x90PV[_a;\xE2a;\xDDa;\xD8\x84a,\xEDV[a;\xBFV[a,\xEDV[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a;\xFB\x82a;\xC8V[a<\x0Ea<\x07\x82a;\xE9V[\x83Ta;~V[\x82UPPPV[_\x815a<!\x81a.\x0BV[\x80\x91PP\x91\x90PV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa<I\x84a;sV[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[_a<ya<ta<o\x84a-\xDBV[a;\xBFV[a-\xDBV[\x90P\x91\x90PV[_a<\x8A\x82a<_V[\x90P\x91\x90PV[_a<\x9B\x82a<\x80V[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a<\xB4\x82a<\x91V[a<\xC7a<\xC0\x82a<\xA2V[\x83Ta<*V[\x82UPPPV[__\xFD[__\xFD[__\xFD[__\x835`\x01` \x03\x846\x03\x03\x81\x12a<\xF6Wa<\xF5a<\xCEV[[\x80\x84\x01\x92P\x825\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a=\x18Wa=\x17a<\xD2V[[` \x83\x01\x92P`\x01\x82\x026\x03\x83\x13\x15a=4Wa=3a<\xD6V[[P\x92P\x92\x90PV[_\x82\x90P\x92\x91PPV[_\x81\x90P\x81_R` _ \x90P\x91\x90PV[_` `\x1F\x83\x01\x04\x90P\x91\x90PV[_\x82\x82\x1B\x90P\x92\x91PPV[_`\x08\x83\x02a=\xA2\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82a=gV[a=\xAC\x86\x83a=gV[\x95P\x80\x19\x84\x16\x93P\x80\x86\x16\x84\x17\x92PPP\x93\x92PPPV[a=\xCD\x83a;\xC8V[a=\xE1a=\xD9\x82a;\xE9V[\x84\x84Ta=sV[\x82UPPPPV[__\x90P\x90V[a=\xF8a=\xE9V[a>\x03\x81\x84\x84a=\xC4V[PPPV[[\x81\x81\x10\x15a>&Wa>\x1B_\x82a=\xF0V[`\x01\x81\x01\x90Pa>\tV[PPV[`\x1F\x82\x11\x15a>kWa><\x81a=FV[a>E\x84a=XV[\x81\x01` \x85\x10\x15a>TW\x81\x90P[a>ha>`\x85a=XV[\x83\x01\x82a>\x08V[PP[PPPV[_\x82\x82\x1C\x90P\x92\x91PPV[_a>\x8B_\x19\x84`\x08\x02a>pV[\x19\x80\x83\x16\x91PP\x92\x91PPV[_a>\xA3\x83\x83a>|V[\x91P\x82`\x02\x02\x82\x17\x90P\x92\x91PPV[a>\xBD\x83\x83a=<V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a>\xD6Wa>\xD5a/9V[[a>\xE0\x82Ta:cV[a>\xEB\x82\x82\x85a>*V[_`\x1F\x83\x11`\x01\x81\x14a?\x18W_\x84\x15a?\x06W\x82\x87\x015\x90P[a?\x10\x85\x82a>\x98V[\x86UPa?wV[`\x1F\x19\x84\x16a?&\x86a=FV[_[\x82\x81\x10\x15a?MW\x84\x89\x015\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Pa?(V[\x86\x83\x10\x15a?jW\x84\x89\x015a?f`\x1F\x89\x16\x82a>|V[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPPV[a?\x8B\x83\x83\x83a>\xB3V[PPPV[_\x81\x01_\x83\x01\x80a?\xA0\x81a;^V[\x90Pa?\xAC\x81\x84a;\xF2V[PPP`\x01\x81\x01` \x83\x01\x80a?\xC1\x81a<\x15V[\x90Pa?\xCD\x81\x84a<\xABV[PPP`\x02\x81\x01`@\x83\x01\x80a?\xE2\x81a<\x15V[\x90Pa?\xEE\x81\x84a<\xABV[PPP`\x03\x81\x01``\x83\x01a@\x03\x81\x85a<\xDAV[a@\x0E\x81\x83\x86a?\x80V[PPPP`\x04\x81\x01`\x80\x83\x01a@$\x81\x85a<\xDAV[a@/\x81\x83\x86a?\x80V[PPPPPPV[a@A\x82\x82a?\x90V[PPV[_a@S` \x84\x01\x84a-\x0CV[\x90P\x92\x91PPV[_a@i` \x84\x01\x84a.!V[\x90P\x92\x91PPV[__\xFD[__\xFD[__\xFD[__\x835`\x01` \x03\x846\x03\x03\x81\x12a@\x99Wa@\x98a@yV[[\x83\x81\x01\x92P\x825\x91P` \x83\x01\x92Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a@\xC1Wa@\xC0a@qV[[`\x01\x82\x026\x03\x83\x13\x15a@\xD7Wa@\xD6a@uV[[P\x92P\x92\x90PV[_a@\xEA\x83\x85a.\x88V[\x93Pa@\xF7\x83\x85\x84a/\xE1V[aA\0\x83a-sV[\x84\x01\x90P\x93\x92PPPV[_`\xA0\x83\x01aA\x1C_\x84\x01\x84a@EV[aA(_\x86\x01\x82a1\xF5V[PaA6` \x84\x01\x84a@[V[aAC` \x86\x01\x82a0\xE8V[PaAQ`@\x84\x01\x84a@[V[aA^`@\x86\x01\x82a0\xE8V[PaAl``\x84\x01\x84a@}V[\x85\x83\x03``\x87\x01RaA\x7F\x83\x82\x84a@\xDFV[\x92PPPaA\x90`\x80\x84\x01\x84a@}V[\x85\x83\x03`\x80\x87\x01RaA\xA3\x83\x82\x84a@\xDFV[\x92PPP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01RaA\xC9\x81\x84aA\x0BV[\x90P\x92\x91PPV[aA\xDA\x82a-KV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aA\xF3WaA\xF2a/9V[[aA\xFD\x82Ta:cV[aB\x08\x82\x82\x85a>*V[_` \x90P`\x1F\x83\x11`\x01\x81\x14aB9W_\x84\x15aB'W\x82\x87\x01Q\x90P[aB1\x85\x82a>\x98V[\x86UPaB\x98V[`\x1F\x19\x84\x16aBG\x86a=FV[_[\x82\x81\x10\x15aBnW\x84\x89\x01Q\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90PaBIV[\x86\x83\x10\x15aB\x8BW\x84\x89\x01QaB\x87`\x1F\x89\x16\x82a>|V[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_``\x83\x01_\x83\x01QaB\xDE_\x86\x01\x82a0\xE8V[P` \x83\x01QaB\xF1` \x86\x01\x82a0\xE8V[P`@\x83\x01Q\x84\x82\x03`@\x86\x01RaC\t\x82\x82a.\x98V[\x91PP\x80\x91PP\x92\x91PPV[_aC!\x83\x83aB\xC9V[\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_aC?\x82aB\xA0V[aCI\x81\x85aB\xAAV[\x93P\x83` \x82\x02\x85\x01aC[\x85aB\xBAV[\x80_[\x85\x81\x10\x15aC\x96W\x84\x84\x03\x89R\x81QaCw\x85\x82aC\x16V[\x94PaC\x82\x83aC)V[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90PaC^V[P\x82\x97P\x87\x95PPPPPP\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_``\x83\x01_\x83\x01QaC\xE6_\x86\x01\x82a0\xE8V[P` \x83\x01QaC\xF9` \x86\x01\x82a0\xE8V[P`@\x83\x01Q\x84\x82\x03`@\x86\x01RaD\x11\x82\x82a.\x98V[\x91PP\x80\x91PP\x92\x91PPV[_aD)\x83\x83aC\xD1V[\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_aDG\x82aC\xA8V[aDQ\x81\x85aC\xB2V[\x93P\x83` \x82\x02\x85\x01aDc\x85aC\xC2V[\x80_[\x85\x81\x10\x15aD\x9EW\x84\x84\x03\x89R\x81QaD\x7F\x85\x82aD\x1EV[\x94PaD\x8A\x83aD1V[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90PaDfV[P\x82\x97P\x87\x95PPPPPP\x92\x91PPV[_`\xA0\x82\x01\x90PaD\xC3_\x83\x01\x88a1dV[\x81\x81\x03` \x83\x01RaD\xD5\x81\x87a.\xD0V[\x90PaD\xE4`@\x83\x01\x86a.`V[\x81\x81\x03``\x83\x01RaD\xF6\x81\x85aC5V[\x90P\x81\x81\x03`\x80\x83\x01RaE\n\x81\x84aD=V[\x90P\x96\x95PPPPPPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[aE2\x81aE\x16V[\x82RPPV[_` \x82\x01\x90PaEK_\x83\x01\x84aE)V[\x92\x91PPV[aEZ\x81a0\xB7V[\x81\x14aEdW__\xFD[PV[_\x81Q\x90PaEu\x81aEQV[\x92\x91PPV[_` \x82\x84\x03\x12\x15aE\x90WaE\x8Fa,\xE5V[[_aE\x9D\x84\x82\x85\x01aEgV[\x91PP\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x81\x90P\x92\x91PPV[_aE\xC4\x82aE\xA6V[aE\xCE\x81\x85aE\xB0V[\x93PaE\xDE\x81\x85` \x86\x01a-eV[\x80\x84\x01\x91PP\x92\x91PPV[_aE\xF5\x82\x84aE\xBAV[\x91P\x81\x90P\x92\x91PPV\xFE\xA2dipfsX\"\x12 t#\x05\xE2)Z\xE12\xC83\xC9\xA0\x18\xFB\x9D\xDB\xE4v\x0B\xEF\x04&\xD5\x06H..xV\xC9H dsolcC\0\x08\x1C\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x6080604052600436106101d7575f3560e01c8063715018a611610101578063c6b3024d11610094578063d98189a411610063578063d98189a414610649578063e30c397814610671578063ecbd96ab1461069b578063f2fde38b146106d7576101d7565b8063c6b3024d14610595578063cb661755146105bd578063cdb4c2b9146105e5578063d5244bf11461060d576101d7565b80638f4a7f5e116100d05780638f4a7f5e146104ef578063ad3cb1cc14610519578063bda0b94814610543578063c62752581461056d576101d7565b8063715018a61461045d57806379ba5097146104735780638bb0a17c146104895780638da5cb5b146104c5576101d7565b80634f1ef286116101795780635ab6d3ab116101485780635ab6d3ab146103a75780636799ef52146103e35780636c88eb431461040d57806370cc9a3c14610435576101d7565b80634f1ef286146102fd57806352d1902d1461031957806354d3f67514610343578063554bab3c1461037f576101d7565b806347cd4b3e116101b557806347cd4b3e1461025557806348144c611461027f578063490413aa146102a95780634921a3bd146102d3576101d7565b80630219150f146101db5780630d8e6e2c14610203578063195afde61461022d575b5f5ffd5b3480156101e6575f5ffd5b5061020160048036038101906101fc9190612d20565b6106ff565b005b34801561020e575f5ffd5b506102176107ab565b6040516102249190612dbb565b60405180910390f35b348015610238575f5ffd5b50610253600480360381019061024e9190612e35565b610826565b005b348015610260575f5ffd5b506102696108c7565b6040516102769190612e6f565b60405180910390f35b34801561028a575f5ffd5b506102936108ea565b6040516102a09190612f11565b60405180910390f35b3480156102b4575f5ffd5b506102bd610a31565b6040516102ca9190612e6f565b60405180910390f35b3480156102de575f5ffd5b506102e7610a60565b6040516102f49190612e6f565b60405180910390f35b6103176004803603810190610312919061305d565b610a77565b005b348015610324575f5ffd5b5061032d610a96565b60405161033a91906130cf565b60405180910390f35b34801561034e575f5ffd5b5061036960048036038101906103649190612e35565b610ac7565b6040516103769190613144565b60405180910390f35b34801561038a575f5ffd5b506103a560048036038101906103a09190612e35565b610c65565b005b3480156103b2575f5ffd5b506103cd60048036038101906103c89190612d20565b610d59565b6040516103da9190613173565b60405180910390f35b3480156103ee575f5ffd5b506103f7610dab565b6040516104049190612e6f565b60405180910390f35b348015610418575f5ffd5b50610433600480360381019061042e9190612e35565b610ddd565b005b348015610440575f5ffd5b5061045b600480360381019061045691906131ae565b610e79565b005b348015610468575f5ffd5b50610471610fca565b005b34801561047e575f5ffd5b50610487610fdd565b005b348015610494575f5ffd5b506104af60048036038101906104aa9190612d20565b61106b565b6040516104bc919061327e565b60405180910390f35b3480156104d0575f5ffd5b506104d9611286565b6040516104e69190613173565b60405180910390f35b3480156104fa575f5ffd5b506105036112bb565b6040516105109190613346565b60405180910390f35b348015610524575f5ffd5b5061052d611354565b60405161053a9190612dbb565b60405180910390f35b34801561054e575f5ffd5b5061055761138d565b6040516105649190613346565b60405180910390f35b348015610578575f5ffd5b50610593600480360381019061058e9190612e35565b611426565b005b3480156105a0575f5ffd5b506105bb60048036038101906105b69190612d20565b6114c2565b005b3480156105c8575f5ffd5b506105e360048036038101906105de9190612e35565b611532565b005b3480156105f0575f5ffd5b5061060b60048036038101906106069190612e35565b6115ce565b005b348015610618575f5ffd5b50610633600480360381019061062e9190612d20565b61166a565b6040516106409190613173565b60405180910390f35b348015610654575f5ffd5b5061066f600480360381019061066a919061374b565b6116bc565b005b34801561067c575f5ffd5b50610685611e45565b6040516106929190613173565b60405180910390f35b3480156106a6575f5ffd5b506106c160048036038101906106bc9190612e35565b611e7a565b6040516106ce9190613863565b60405180910390f35b3480156106e2575f5ffd5b506106fd60048036038101906106f89190612e35565b612018565b005b6107076120d1565b5f610710612158565b90508060090180549050821115610767578181600901805490506040517f48676fe000000000000000000000000000000000000000000000000000000000815260040161075e929190613883565b60405180910390fd5b8181600a01819055507fea6c6521bc495731082e23ad12c7b1207d13ca0bd38d1d511081ab568917cb848260405161079f9190612e6f565b60405180910390a15050565b60606040518060400160405280600581526020017f485454505a0000000000000000000000000000000000000000000000000000008152506107ec5f61217f565b6107f6600161217f565b6107ff5f61217f565b6040516020016108129493929190613978565b604051602081830303815290604052905090565b5f61082f612158565b90508173ffffffffffffffffffffffffffffffffffffffff16815f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16146108c357816040517f206a346e0000000000000000000000000000000000000000000000000000000081526004016108ba9190613173565b60405180910390fd5b5050565b5f5f6108d1612158565b9050600181600a01546108e49190613a03565b91505090565b6108f2612bd4565b5f6108fb612158565b9050806006016040518060400160405290815f8201805461091b90613a63565b80601f016020809104026020016040519081016040528092919081815260200182805461094790613a63565b80156109925780601f1061096957610100808354040283529160200191610992565b820191905f5260205f20905b81548152906001019060200180831161097557829003601f168201915b505050505081526020016001820180546109ab90613a63565b80601f01602080910402602001604051908101604052809291908181526020018280546109d790613a63565b8015610a225780601f106109f957610100808354040283529160200191610a22565b820191905f5260205f20905b815481529060010190602001808311610a0557829003601f168201915b50505050508152505091505090565b5f5f610a3b612158565b9050600181600a01546002610a509190613a93565b610a5a9190613a03565b91505090565b5f5f610a6a612158565b905080600a015491505090565b610a7f612249565b610a888261232f565b610a92828261233a565b5050565b5f610a9f612458565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b905090565b610acf612bee565b5f610ad8612158565b9050806008015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f206040518060600160405290815f82015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282018054610bdd90613a63565b80601f0160208091040260200160405190810160405280929190818152602001828054610c0990613a63565b8015610c545780601f10610c2b57610100808354040283529160200191610c54565b820191905f5260205f20905b815481529060010190602001808311610c3757829003601f168201915b505050505081525050915050919050565b610c6d6120d1565b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603610cd2576040517f3555aed100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f610cdb612158565b905081815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507fa690668c24d277243ff6fa650d3fd6e3d331a99ca0a8857c82e7f89452fc665d82604051610d4d9190613173565b60405180910390a15050565b5f5f610d63612158565b905080600c018381548110610d7b57610d7a613ad4565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16915050919050565b5f5f610db5612158565b90506001600282600c0180549050610dcd9190613b2e565b610dd79190613a03565b91505090565b5f610de6612158565b9050806002015f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff16610e7557816040517f2a7c6ef6000000000000000000000000000000000000000000000000000000008152600401610e6c9190613173565b60405180910390fd5b5050565b5f815f013503610eb5576040517f22f73fea00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f610ebe612158565b9050806005015f835f013581526020019081526020015f205f9054906101000a900460ff1615610f2857815f01356040517fb1825c5e000000000000000000000000000000000000000000000000000000008152600401610f1f9190612e6f565b60405180910390fd5b80600d0182908060018154018082558091505060019003905f5260205f2090600502015f909190919091508181610f5f9190614037565b50506001816005015f845f013581526020019081526020015f205f6101000a81548160ff0219169083151502179055507fb8207b5bb791730ae8f0534fa4c7be7da49dd75d701f9c7acf51c94b8ace96b282604051610fbe91906141b1565b60405180910390a15050565b610fd26120d1565b610fdb5f6124df565b565b5f610fe661251c565b90508073ffffffffffffffffffffffffffffffffffffffff16611007611e45565b73ffffffffffffffffffffffffffffffffffffffff161461105f57806040517f118cdaa70000000000000000000000000000000000000000000000000000000081526004016110569190613173565b60405180910390fd5b611068816124df565b50565b611073612c39565b5f61107c612158565b905080600d01838154811061109457611093613ad4565b5b905f5260205f2090600502016040518060a00160405290815f8201548152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200160038201805461116e90613a63565b80601f016020809104026020016040519081016040528092919081815260200182805461119a90613a63565b80156111e55780601f106111bc576101008083540402835291602001916111e5565b820191905f5260205f20905b8154815290600101906020018083116111c857829003601f168201915b505050505081526020016004820180546111fe90613a63565b80601f016020809104026020016040519081016040528092919081815260200182805461122a90613a63565b80156112755780601f1061124c57610100808354040283529160200191611275565b820191905f5260205f20905b81548152906001019060200180831161125857829003601f168201915b505050505081525050915050919050565b5f5f611290612523565b9050805f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b60605f6112c6612158565b905080600c0180548060200260200160405190810160405280929190818152602001828054801561134957602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311611300575b505050505091505090565b6040518060400160405280600581526020017f352e302e3000000000000000000000000000000000000000000000000000000081525081565b60605f611398612158565b90508060090180548060200260200160405190810160405280929190818152602001828054801561141b57602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190600101908083116113d2575b505050505091505090565b5f61142f612158565b9050806001015f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff166114be57816040517faee863230000000000000000000000000000000000000000000000000000000081526004016114b59190613173565b60405180910390fd5b5050565b5f6114cb612158565b9050806005015f8381526020019081526020015f205f9054906101000a900460ff1661152e57816040517f6df6fe890000000000000000000000000000000000000000000000000000000081526004016115259190612e6f565b60405180910390fd5b5050565b5f61153b612158565b9050806003015f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff166115ca57816040517f52d725f50000000000000000000000000000000000000000000000000000000081526004016115c19190613173565b60405180910390fd5b5050565b5f6115d7612158565b9050806004015f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff1661166657816040517f26cd75dc00000000000000000000000000000000000000000000000000000000815260040161165d9190613173565b60405180910390fd5b5050565b5f5f611674612158565b905080600901838154811061168c5761168b613ad4565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16915050919050565b60025f6116c761254a565b9050805f0160089054906101000a900460ff168061170f57508167ffffffffffffffff16815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff1610155b15611746576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055506001815f0160086101000a81548160ff02191690831515021790555061179b611796611286565b612571565b5f6117a4612158565b905086816006015f820151815f0190816117be91906141d1565b5060208201518160010190816117d491906141d1565b5090505087815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505f85519050808711156118655786816040517f48676fe000000000000000000000000000000000000000000000000000000000815260040161185c929190613883565b60405180910390fd5b8682600a01819055505f5f90505b81811015611b0a576001836001015f89848151811061189557611894613ad4565b5b60200260200101515f015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff02191690831515021790555086818151811061190257611901613ad4565b5b6020026020010151836008015f89848151811061192257611921613ad4565b5b60200260200101515f015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f820151815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506020820151816001015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506040820151816002019081611a0591906141d1565b5090505082600901878281518110611a2057611a1f613ad4565b5b60200260200101515f0151908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506001836002015f898481518110611aa257611aa1613ad4565b5b60200260200101516020015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff0219169083151502179055508080600101915050611873565b505f5f90505b8551811015611da8576001836003015f888481518110611b3357611b32613ad4565b5b60200260200101515f015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550858181518110611ba057611b9f613ad4565b5b602002602001015183600b015f888481518110611bc057611bbf613ad4565b5b60200260200101515f015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f820151815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506020820151816001015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506040820151816002019081611ca391906141d1565b5090505082600c01868281518110611cbe57611cbd613ad4565b5b60200260200101515f0151908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506001836004015f888481518110611d4057611d3f613ad4565b5b60200260200101516020015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff0219169083151502179055508080600101915050611b10565b507ff33d908c4a8b532fe64df20b726f11405c11b9772d31b66f5eef6887a43c3fde8989898989604051611de09594939291906144b0565b60405180910390a150505f815f0160086101000a81548160ff0219169083151502179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d282604051611e349190614538565b60405180910390a150505050505050565b5f5f611e4f612585565b9050805f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b611e82612c91565b5f611e8b612158565b905080600b015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f206040518060600160405290815f82015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282018054611f9090613a63565b80601f0160208091040260200160405190810160405280929190818152602001828054611fbc90613a63565b80156120075780601f10611fde57610100808354040283529160200191612007565b820191905f5260205f20905b815481529060010190602001808311611fea57829003601f168201915b505050505081525050915050919050565b6120206120d1565b5f612029612585565b905081815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff1661208b611286565b73ffffffffffffffffffffffffffffffffffffffff167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a35050565b6120d961251c565b73ffffffffffffffffffffffffffffffffffffffff166120f7611286565b73ffffffffffffffffffffffffffffffffffffffff16146121565761211a61251c565b6040517f118cdaa700000000000000000000000000000000000000000000000000000000815260040161214d9190613173565b60405180910390fd5b565b5f7f827176a45e1aad1f3a6539fee60c06126c40427b4849e7301bf2cf0f1f8e9500905090565b60605f600161218d846125ac565b0190505f8167ffffffffffffffff8111156121ab576121aa612f39565b5b6040519080825280601f01601f1916602001820160405280156121dd5781602001600182028036833780820191505090505b5090505f82602001820190505b60011561223e578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a858161223357612232613b01565b5b0494505f85036121ea575b819350505050919050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614806122f657507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166122dd6126fd565b73ffffffffffffffffffffffffffffffffffffffff1614155b1561232d576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b6123376120d1565b50565b8173ffffffffffffffffffffffffffffffffffffffff166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa9250505080156123a257506040513d601f19601f8201168201806040525081019061239f919061457b565b60015b6123e357816040517f4c9c8ce30000000000000000000000000000000000000000000000000000000081526004016123da9190613173565b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b811461244957806040517faa1d49a400000000000000000000000000000000000000000000000000000000815260040161244091906130cf565b60405180910390fd5b6124538383612750565b505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff16146124dd576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f6124e8612585565b9050805f015f6101000a81549073ffffffffffffffffffffffffffffffffffffffff0219169055612518826127c2565b5050565b5f33905090565b5f7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300905090565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b612579612893565b612582816128d3565b50565b5f7f237e158222e3e6968b72b9db0d8043aacf074ad9f650f0d1606b4d82ee432c00905090565b5f5f5f90507a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008310612608577a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083816125fe576125fd613b01565b5b0492506040810190505b6d04ee2d6d415b85acef81000000008310612645576d04ee2d6d415b85acef8100000000838161263b5761263a613b01565b5b0492506020810190505b662386f26fc10000831061267457662386f26fc10000838161266a57612669613b01565b5b0492506010810190505b6305f5e100831061269d576305f5e100838161269357612692613b01565b5b0492506008810190505b61271083106126c25761271083816126b8576126b7613b01565b5b0492506004810190505b606483106126e557606483816126db576126da613b01565b5b0492506002810190505b600a83106126f4576001810190505b80915050919050565b5f6127297f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b612957565b5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b61275982612960565b8173ffffffffffffffffffffffffffffffffffffffff167fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b60405160405180910390a25f815111156127b5576127af8282612a29565b506127be565b6127bd612aa9565b5b5050565b5f6127cb612523565b90505f815f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905082825f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a3505050565b61289b612ae5565b6128d1576040517fd7e6bcf800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b6128db612893565b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff160361294b575f6040517f1e4fbdf70000000000000000000000000000000000000000000000000000000081526004016129429190613173565b60405180910390fd5b612954816124df565b50565b5f819050919050565b5f8173ffffffffffffffffffffffffffffffffffffffff163b036129bb57806040517f4c9c8ce30000000000000000000000000000000000000000000000000000000081526004016129b29190613173565b60405180910390fd5b806129e77f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b612957565b5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60605f5f8473ffffffffffffffffffffffffffffffffffffffff1684604051612a5291906145ea565b5f60405180830381855af49150503d805f8114612a8a576040519150601f19603f3d011682016040523d82523d5f602084013e612a8f565b606091505b5091509150612a9f858383612b03565b9250505092915050565b5f341115612ae3576040517fb398979f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f612aee61254a565b5f0160089054906101000a900460ff16905090565b606082612b1857612b1382612b90565b612b88565b5f8251148015612b3e57505f8473ffffffffffffffffffffffffffffffffffffffff163b145b15612b8057836040517f9996b315000000000000000000000000000000000000000000000000000000008152600401612b779190613173565b60405180910390fd5b819050612b89565b5b9392505050565b5f81511115612ba25780518082602001fd5b6040517fd6bda27500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b604051806040016040528060608152602001606081525090565b60405180606001604052805f73ffffffffffffffffffffffffffffffffffffffff1681526020015f73ffffffffffffffffffffffffffffffffffffffff168152602001606081525090565b6040518060a001604052805f81526020015f73ffffffffffffffffffffffffffffffffffffffff1681526020015f73ffffffffffffffffffffffffffffffffffffffff16815260200160608152602001606081525090565b60405180606001604052805f73ffffffffffffffffffffffffffffffffffffffff1681526020015f73ffffffffffffffffffffffffffffffffffffffff168152602001606081525090565b5f604051905090565b5f5ffd5b5f5ffd5b5f819050919050565b612cff81612ced565b8114612d09575f5ffd5b50565b5f81359050612d1a81612cf6565b92915050565b5f60208284031215612d3557612d34612ce5565b5b5f612d4284828501612d0c565b91505092915050565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f601f19601f8301169050919050565b5f612d8d82612d4b565b612d978185612d55565b9350612da7818560208601612d65565b612db081612d73565b840191505092915050565b5f6020820190508181035f830152612dd38184612d83565b905092915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f612e0482612ddb565b9050919050565b612e1481612dfa565b8114612e1e575f5ffd5b50565b5f81359050612e2f81612e0b565b92915050565b5f60208284031215612e4a57612e49612ce5565b5b5f612e5784828501612e21565b91505092915050565b612e6981612ced565b82525050565b5f602082019050612e825f830184612e60565b92915050565b5f82825260208201905092915050565b5f612ea282612d4b565b612eac8185612e88565b9350612ebc818560208601612d65565b612ec581612d73565b840191505092915050565b5f604083015f8301518482035f860152612eea8282612e98565b91505060208301518482036020860152612f048282612e98565b9150508091505092915050565b5f6020820190508181035f830152612f298184612ed0565b905092915050565b5f5ffd5b5f5ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b612f6f82612d73565b810181811067ffffffffffffffff82111715612f8e57612f8d612f39565b5b80604052505050565b5f612fa0612cdc565b9050612fac8282612f66565b919050565b5f67ffffffffffffffff821115612fcb57612fca612f39565b5b612fd482612d73565b9050602081019050919050565b828183375f83830152505050565b5f613001612ffc84612fb1565b612f97565b90508281526020810184848401111561301d5761301c612f35565b5b613028848285612fe1565b509392505050565b5f82601f83011261304457613043612f31565b5b8135613054848260208601612fef565b91505092915050565b5f5f6040838503121561307357613072612ce5565b5b5f61308085828601612e21565b925050602083013567ffffffffffffffff8111156130a1576130a0612ce9565b5b6130ad85828601613030565b9150509250929050565b5f819050919050565b6130c9816130b7565b82525050565b5f6020820190506130e25f8301846130c0565b92915050565b6130f181612dfa565b82525050565b5f606083015f83015161310c5f8601826130e8565b50602083015161311f60208601826130e8565b50604083015184820360408601526131378282612e98565b9150508091505092915050565b5f6020820190508181035f83015261315c81846130f7565b905092915050565b61316d81612dfa565b82525050565b5f6020820190506131865f830184613164565b92915050565b5f5ffd5b5f60a082840312156131a5576131a461318c565b5b81905092915050565b5f602082840312156131c3576131c2612ce5565b5b5f82013567ffffffffffffffff8111156131e0576131df612ce9565b5b6131ec84828501613190565b91505092915050565b6131fe81612ced565b82525050565b5f60a083015f8301516132195f8601826131f5565b50602083015161322c60208601826130e8565b50604083015161323f60408601826130e8565b50606083015184820360608601526132578282612e98565b915050608083015184820360808601526132718282612e98565b9150508091505092915050565b5f6020820190508181035f8301526132968184613204565b905092915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f6132d283836130e8565b60208301905092915050565b5f602082019050919050565b5f6132f48261329e565b6132fe81856132a8565b9350613309836132b8565b805f5b8381101561333957815161332088826132c7565b975061332b836132de565b92505060018101905061330c565b5085935050505092915050565b5f6020820190508181035f83015261335e81846132ea565b905092915050565b5f5ffd5b5f5ffd5b5f67ffffffffffffffff82111561338857613387612f39565b5b61339182612d73565b9050602081019050919050565b5f6133b06133ab8461336e565b612f97565b9050828152602081018484840111156133cc576133cb612f35565b5b6133d7848285612fe1565b509392505050565b5f82601f8301126133f3576133f2612f31565b5b813561340384826020860161339e565b91505092915050565b5f6040828403121561342157613420613366565b5b61342b6040612f97565b90505f82013567ffffffffffffffff81111561344a5761344961336a565b5b613456848285016133df565b5f83015250602082013567ffffffffffffffff8111156134795761347861336a565b5b613485848285016133df565b60208301525092915050565b5f67ffffffffffffffff8211156134ab576134aa612f39565b5b602082029050602081019050919050565b5f5ffd5b5f606082840312156134d5576134d4613366565b5b6134df6060612f97565b90505f6134ee84828501612e21565b5f83015250602061350184828501612e21565b602083015250604082013567ffffffffffffffff8111156135255761352461336a565b5b613531848285016133df565b60408301525092915050565b5f61354f61354a84613491565b612f97565b90508083825260208201905060208402830185811115613572576135716134bc565b5b835b818110156135b957803567ffffffffffffffff81111561359757613596612f31565b5b8086016135a489826134c0565b85526020850194505050602081019050613574565b5050509392505050565b5f82601f8301126135d7576135d6612f31565b5b81356135e784826020860161353d565b91505092915050565b5f67ffffffffffffffff82111561360a57613609612f39565b5b602082029050602081019050919050565b5f606082840312156136305761362f613366565b5b61363a6060612f97565b90505f61364984828501612e21565b5f83015250602061365c84828501612e21565b602083015250604082013567ffffffffffffffff8111156136805761367f61336a565b5b61368c848285016133df565b60408301525092915050565b5f6136aa6136a5846135f0565b612f97565b905080838252602082019050602084028301858111156136cd576136cc6134bc565b5b835b8181101561371457803567ffffffffffffffff8111156136f2576136f1612f31565b5b8086016136ff898261361b565b855260208501945050506020810190506136cf565b5050509392505050565b5f82601f83011261373257613731612f31565b5b8135613742848260208601613698565b91505092915050565b5f5f5f5f5f60a0868803121561376457613763612ce5565b5b5f61377188828901612e21565b955050602086013567ffffffffffffffff81111561379257613791612ce9565b5b61379e8882890161340c565b94505060406137af88828901612d0c565b935050606086013567ffffffffffffffff8111156137d0576137cf612ce9565b5b6137dc888289016135c3565b925050608086013567ffffffffffffffff8111156137fd576137fc612ce9565b5b6138098882890161371e565b9150509295509295909350565b5f606083015f83015161382b5f8601826130e8565b50602083015161383e60208601826130e8565b50604083015184820360408601526138568282612e98565b9150508091505092915050565b5f6020820190508181035f83015261387b8184613816565b905092915050565b5f6040820190506138965f830185612e60565b6138a36020830184612e60565b9392505050565b5f81905092915050565b5f6138be82612d4b565b6138c881856138aa565b93506138d8818560208601612d65565b80840191505092915050565b7f20760000000000000000000000000000000000000000000000000000000000005f82015250565b5f6139186002836138aa565b9150613923826138e4565b600282019050919050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f6139626001836138aa565b915061396d8261392e565b600182019050919050565b5f61398382876138b4565b915061398e8261390c565b915061399a82866138b4565b91506139a582613956565b91506139b182856138b4565b91506139bc82613956565b91506139c882846138b4565b915081905095945050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f613a0d82612ced565b9150613a1883612ced565b9250828201905080821115613a3057613a2f6139d6565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f6002820490506001821680613a7a57607f821691505b602082108103613a8d57613a8c613a36565b5b50919050565b5f613a9d82612ced565b9150613aa883612ced565b9250828202613ab681612ced565b91508282048414831517613acd57613acc6139d6565b5b5092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f613b3882612ced565b9150613b4383612ced565b925082613b5357613b52613b01565b5b828204905092915050565b5f8135613b6a81612cf6565b80915050919050565b5f815f1b9050919050565b5f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff613ba984613b73565b9350801983169250808416831791505092915050565b5f819050919050565b5f613be2613bdd613bd884612ced565b613bbf565b612ced565b9050919050565b5f819050919050565b613bfb82613bc8565b613c0e613c0782613be9565b8354613b7e565b8255505050565b5f8135613c2181612e0b565b80915050919050565b5f73ffffffffffffffffffffffffffffffffffffffff613c4984613b73565b9350801983169250808416831791505092915050565b5f613c79613c74613c6f84612ddb565b613bbf565b612ddb565b9050919050565b5f613c8a82613c5f565b9050919050565b5f613c9b82613c80565b9050919050565b5f819050919050565b613cb482613c91565b613cc7613cc082613ca2565b8354613c2a565b8255505050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f83356001602003843603038112613cf657613cf5613cce565b5b80840192508235915067ffffffffffffffff821115613d1857613d17613cd2565b5b602083019250600182023603831315613d3457613d33613cd6565b5b509250929050565b5f82905092915050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f60088302613da27fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82613d67565b613dac8683613d67565b95508019841693508086168417925050509392505050565b613dcd83613bc8565b613de1613dd982613be9565b848454613d73565b825550505050565b5f5f905090565b613df8613de9565b613e03818484613dc4565b505050565b5b81811015613e2657613e1b5f82613df0565b600181019050613e09565b5050565b601f821115613e6b57613e3c81613d46565b613e4584613d58565b81016020851015613e54578190505b613e68613e6085613d58565b830182613e08565b50505b505050565b5f82821c905092915050565b5f613e8b5f1984600802613e70565b1980831691505092915050565b5f613ea38383613e7c565b9150826002028217905092915050565b613ebd8383613d3c565b67ffffffffffffffff811115613ed657613ed5612f39565b5b613ee08254613a63565b613eeb828285613e2a565b5f601f831160018114613f18575f8415613f06578287013590505b613f108582613e98565b865550613f77565b601f198416613f2686613d46565b5f5b82811015613f4d57848901358255600182019150602085019450602081019050613f28565b86831015613f6a5784890135613f66601f891682613e7c565b8355505b6001600288020188555050505b50505050505050565b613f8b838383613eb3565b505050565b5f81015f830180613fa081613b5e565b9050613fac8184613bf2565b505050600181016020830180613fc181613c15565b9050613fcd8184613cab565b505050600281016040830180613fe281613c15565b9050613fee8184613cab565b50505060038101606083016140038185613cda565b61400e818386613f80565b5050505060048101608083016140248185613cda565b61402f818386613f80565b505050505050565b6140418282613f90565b5050565b5f6140536020840184612d0c565b905092915050565b5f6140696020840184612e21565b905092915050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f8335600160200384360303811261409957614098614079565b5b83810192508235915060208301925067ffffffffffffffff8211156140c1576140c0614071565b5b6001820236038313156140d7576140d6614075565b5b509250929050565b5f6140ea8385612e88565b93506140f7838584612fe1565b61410083612d73565b840190509392505050565b5f60a0830161411c5f840184614045565b6141285f8601826131f5565b50614136602084018461405b565b61414360208601826130e8565b50614151604084018461405b565b61415e60408601826130e8565b5061416c606084018461407d565b858303606087015261417f8382846140df565b92505050614190608084018461407d565b85830360808701526141a38382846140df565b925050508091505092915050565b5f6020820190508181035f8301526141c9818461410b565b905092915050565b6141da82612d4b565b67ffffffffffffffff8111156141f3576141f2612f39565b5b6141fd8254613a63565b614208828285613e2a565b5f60209050601f831160018114614239575f8415614227578287015190505b6142318582613e98565b865550614298565b601f19841661424786613d46565b5f5b8281101561426e57848901518255600182019150602085019450602081019050614249565b8683101561428b5784890151614287601f891682613e7c565b8355505b6001600288020188555050505b505050505050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f606083015f8301516142de5f8601826130e8565b5060208301516142f160208601826130e8565b50604083015184820360408601526143098282612e98565b9150508091505092915050565b5f61432183836142c9565b905092915050565b5f602082019050919050565b5f61433f826142a0565b61434981856142aa565b93508360208202850161435b856142ba565b805f5b8581101561439657848403895281516143778582614316565b945061438283614329565b925060208a0199505060018101905061435e565b50829750879550505050505092915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f606083015f8301516143e65f8601826130e8565b5060208301516143f960208601826130e8565b50604083015184820360408601526144118282612e98565b9150508091505092915050565b5f61442983836143d1565b905092915050565b5f602082019050919050565b5f614447826143a8565b61445181856143b2565b935083602082028501614463856143c2565b805f5b8581101561449e578484038952815161447f858261441e565b945061448a83614431565b925060208a01995050600181019050614466565b50829750879550505050505092915050565b5f60a0820190506144c35f830188613164565b81810360208301526144d58187612ed0565b90506144e46040830186612e60565b81810360608301526144f68185614335565b9050818103608083015261450a818461443d565b90509695505050505050565b5f67ffffffffffffffff82169050919050565b61453281614516565b82525050565b5f60208201905061454b5f830184614529565b92915050565b61455a816130b7565b8114614564575f5ffd5b50565b5f8151905061457581614551565b92915050565b5f602082840312156145905761458f612ce5565b5b5f61459d84828501614567565b91505092915050565b5f81519050919050565b5f81905092915050565b5f6145c4826145a6565b6145ce81856145b0565b93506145de818560208601612d65565b80840191505092915050565b5f6145f582846145ba565b91508190509291505056fea2646970667358221220742305e2295ae132c833c9a018fb9ddbe4760bef0426d506482e2e7856c9482064736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10a\x01\xD7W_5`\xE0\x1C\x80cqP\x18\xA6\x11a\x01\x01W\x80c\xC6\xB3\x02M\x11a\0\x94W\x80c\xD9\x81\x89\xA4\x11a\0cW\x80c\xD9\x81\x89\xA4\x14a\x06IW\x80c\xE3\x0C9x\x14a\x06qW\x80c\xEC\xBD\x96\xAB\x14a\x06\x9BW\x80c\xF2\xFD\xE3\x8B\x14a\x06\xD7Wa\x01\xD7V[\x80c\xC6\xB3\x02M\x14a\x05\x95W\x80c\xCBf\x17U\x14a\x05\xBDW\x80c\xCD\xB4\xC2\xB9\x14a\x05\xE5W\x80c\xD5$K\xF1\x14a\x06\rWa\x01\xD7V[\x80c\x8FJ\x7F^\x11a\0\xD0W\x80c\x8FJ\x7F^\x14a\x04\xEFW\x80c\xAD<\xB1\xCC\x14a\x05\x19W\x80c\xBD\xA0\xB9H\x14a\x05CW\x80c\xC6'RX\x14a\x05mWa\x01\xD7V[\x80cqP\x18\xA6\x14a\x04]W\x80cy\xBAP\x97\x14a\x04sW\x80c\x8B\xB0\xA1|\x14a\x04\x89W\x80c\x8D\xA5\xCB[\x14a\x04\xC5Wa\x01\xD7V[\x80cO\x1E\xF2\x86\x11a\x01yW\x80cZ\xB6\xD3\xAB\x11a\x01HW\x80cZ\xB6\xD3\xAB\x14a\x03\xA7W\x80cg\x99\xEFR\x14a\x03\xE3W\x80cl\x88\xEBC\x14a\x04\rW\x80cp\xCC\x9A<\x14a\x045Wa\x01\xD7V[\x80cO\x1E\xF2\x86\x14a\x02\xFDW\x80cR\xD1\x90-\x14a\x03\x19W\x80cT\xD3\xF6u\x14a\x03CW\x80cUK\xAB<\x14a\x03\x7FWa\x01\xD7V[\x80cG\xCDK>\x11a\x01\xB5W\x80cG\xCDK>\x14a\x02UW\x80cH\x14La\x14a\x02\x7FW\x80cI\x04\x13\xAA\x14a\x02\xA9W\x80cI!\xA3\xBD\x14a\x02\xD3Wa\x01\xD7V[\x80c\x02\x19\x15\x0F\x14a\x01\xDBW\x80c\r\x8En,\x14a\x02\x03W\x80c\x19Z\xFD\xE6\x14a\x02-W[__\xFD[4\x80\x15a\x01\xE6W__\xFD[Pa\x02\x01`\x04\x806\x03\x81\x01\x90a\x01\xFC\x91\x90a- V[a\x06\xFFV[\0[4\x80\x15a\x02\x0EW__\xFD[Pa\x02\x17a\x07\xABV[`@Qa\x02$\x91\x90a-\xBBV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x028W__\xFD[Pa\x02S`\x04\x806\x03\x81\x01\x90a\x02N\x91\x90a.5V[a\x08&V[\0[4\x80\x15a\x02`W__\xFD[Pa\x02ia\x08\xC7V[`@Qa\x02v\x91\x90a.oV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\x8AW__\xFD[Pa\x02\x93a\x08\xEAV[`@Qa\x02\xA0\x91\x90a/\x11V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xB4W__\xFD[Pa\x02\xBDa\n1V[`@Qa\x02\xCA\x91\x90a.oV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xDEW__\xFD[Pa\x02\xE7a\n`V[`@Qa\x02\xF4\x91\x90a.oV[`@Q\x80\x91\x03\x90\xF3[a\x03\x17`\x04\x806\x03\x81\x01\x90a\x03\x12\x91\x90a0]V[a\nwV[\0[4\x80\x15a\x03$W__\xFD[Pa\x03-a\n\x96V[`@Qa\x03:\x91\x90a0\xCFV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03NW__\xFD[Pa\x03i`\x04\x806\x03\x81\x01\x90a\x03d\x91\x90a.5V[a\n\xC7V[`@Qa\x03v\x91\x90a1DV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x8AW__\xFD[Pa\x03\xA5`\x04\x806\x03\x81\x01\x90a\x03\xA0\x91\x90a.5V[a\x0CeV[\0[4\x80\x15a\x03\xB2W__\xFD[Pa\x03\xCD`\x04\x806\x03\x81\x01\x90a\x03\xC8\x91\x90a- V[a\rYV[`@Qa\x03\xDA\x91\x90a1sV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xEEW__\xFD[Pa\x03\xF7a\r\xABV[`@Qa\x04\x04\x91\x90a.oV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x18W__\xFD[Pa\x043`\x04\x806\x03\x81\x01\x90a\x04.\x91\x90a.5V[a\r\xDDV[\0[4\x80\x15a\x04@W__\xFD[Pa\x04[`\x04\x806\x03\x81\x01\x90a\x04V\x91\x90a1\xAEV[a\x0EyV[\0[4\x80\x15a\x04hW__\xFD[Pa\x04qa\x0F\xCAV[\0[4\x80\x15a\x04~W__\xFD[Pa\x04\x87a\x0F\xDDV[\0[4\x80\x15a\x04\x94W__\xFD[Pa\x04\xAF`\x04\x806\x03\x81\x01\x90a\x04\xAA\x91\x90a- V[a\x10kV[`@Qa\x04\xBC\x91\x90a2~V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xD0W__\xFD[Pa\x04\xD9a\x12\x86V[`@Qa\x04\xE6\x91\x90a1sV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xFAW__\xFD[Pa\x05\x03a\x12\xBBV[`@Qa\x05\x10\x91\x90a3FV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05$W__\xFD[Pa\x05-a\x13TV[`@Qa\x05:\x91\x90a-\xBBV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05NW__\xFD[Pa\x05Wa\x13\x8DV[`@Qa\x05d\x91\x90a3FV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05xW__\xFD[Pa\x05\x93`\x04\x806\x03\x81\x01\x90a\x05\x8E\x91\x90a.5V[a\x14&V[\0[4\x80\x15a\x05\xA0W__\xFD[Pa\x05\xBB`\x04\x806\x03\x81\x01\x90a\x05\xB6\x91\x90a- V[a\x14\xC2V[\0[4\x80\x15a\x05\xC8W__\xFD[Pa\x05\xE3`\x04\x806\x03\x81\x01\x90a\x05\xDE\x91\x90a.5V[a\x152V[\0[4\x80\x15a\x05\xF0W__\xFD[Pa\x06\x0B`\x04\x806\x03\x81\x01\x90a\x06\x06\x91\x90a.5V[a\x15\xCEV[\0[4\x80\x15a\x06\x18W__\xFD[Pa\x063`\x04\x806\x03\x81\x01\x90a\x06.\x91\x90a- V[a\x16jV[`@Qa\x06@\x91\x90a1sV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06TW__\xFD[Pa\x06o`\x04\x806\x03\x81\x01\x90a\x06j\x91\x90a7KV[a\x16\xBCV[\0[4\x80\x15a\x06|W__\xFD[Pa\x06\x85a\x1EEV[`@Qa\x06\x92\x91\x90a1sV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xA6W__\xFD[Pa\x06\xC1`\x04\x806\x03\x81\x01\x90a\x06\xBC\x91\x90a.5V[a\x1EzV[`@Qa\x06\xCE\x91\x90a8cV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xE2W__\xFD[Pa\x06\xFD`\x04\x806\x03\x81\x01\x90a\x06\xF8\x91\x90a.5V[a \x18V[\0[a\x07\x07a \xD1V[_a\x07\x10a!XV[\x90P\x80`\t\x01\x80T\x90P\x82\x11\x15a\x07gW\x81\x81`\t\x01\x80T\x90P`@Q\x7FHgo\xE0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x07^\x92\x91\x90a8\x83V[`@Q\x80\x91\x03\x90\xFD[\x81\x81`\n\x01\x81\x90UP\x7F\xEAle!\xBCIW1\x08.#\xAD\x12\xC7\xB1 }\x13\xCA\x0B\xD3\x8D\x1DQ\x10\x81\xABV\x89\x17\xCB\x84\x82`@Qa\x07\x9F\x91\x90a.oV[`@Q\x80\x91\x03\x90\xA1PPV[```@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7FHTTPZ\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa\x07\xEC_a!\x7FV[a\x07\xF6`\x01a!\x7FV[a\x07\xFF_a!\x7FV[`@Q` \x01a\x08\x12\x94\x93\x92\x91\x90a9xV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P\x90V[_a\x08/a!XV[\x90P\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x08\xC3W\x81`@Q\x7F j4n\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x08\xBA\x91\x90a1sV[`@Q\x80\x91\x03\x90\xFD[PPV[__a\x08\xD1a!XV[\x90P`\x01\x81`\n\x01Ta\x08\xE4\x91\x90a:\x03V[\x91PP\x90V[a\x08\xF2a+\xD4V[_a\x08\xFBa!XV[\x90P\x80`\x06\x01`@Q\x80`@\x01`@R\x90\x81_\x82\x01\x80Ta\t\x1B\x90a:cV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\tG\x90a:cV[\x80\x15a\t\x92W\x80`\x1F\x10a\tiWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\t\x92V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\tuW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01\x80Ta\t\xAB\x90a:cV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\t\xD7\x90a:cV[\x80\x15a\n\"W\x80`\x1F\x10a\t\xF9Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\n\"V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\n\x05W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x91PP\x90V[__a\n;a!XV[\x90P`\x01\x81`\n\x01T`\x02a\nP\x91\x90a:\x93V[a\nZ\x91\x90a:\x03V[\x91PP\x90V[__a\nja!XV[\x90P\x80`\n\x01T\x91PP\x90V[a\n\x7Fa\"IV[a\n\x88\x82a#/V[a\n\x92\x82\x82a#:V[PPV[_a\n\x9Fa$XV[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x90P\x90V[a\n\xCFa+\xEEV[_a\n\xD8a!XV[\x90P\x80`\x08\x01_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `@Q\x80``\x01`@R\x90\x81_\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01\x80Ta\x0B\xDD\x90a:cV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0C\t\x90a:cV[\x80\x15a\x0CTW\x80`\x1F\x10a\x0C+Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0CTV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0C7W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x91PP\x91\x90PV[a\x0Cma \xD1V[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x0C\xD2W`@Q\x7F5U\xAE\xD1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a\x0C\xDBa!XV[\x90P\x81\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x7F\xA6\x90f\x8C$\xD2w$?\xF6\xFAe\r?\xD6\xE3\xD31\xA9\x9C\xA0\xA8\x85|\x82\xE7\xF8\x94R\xFCf]\x82`@Qa\rM\x91\x90a1sV[`@Q\x80\x91\x03\x90\xA1PPV[__a\rca!XV[\x90P\x80`\x0C\x01\x83\x81T\x81\x10a\r{Wa\rza:\xD4V[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x91\x90PV[__a\r\xB5a!XV[\x90P`\x01`\x02\x82`\x0C\x01\x80T\x90Pa\r\xCD\x91\x90a;.V[a\r\xD7\x91\x90a:\x03V[\x91PP\x90V[_a\r\xE6a!XV[\x90P\x80`\x02\x01_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x0EuW\x81`@Q\x7F*|n\xF6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0El\x91\x90a1sV[`@Q\x80\x91\x03\x90\xFD[PPV[_\x81_\x015\x03a\x0E\xB5W`@Q\x7F\"\xF7?\xEA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a\x0E\xBEa!XV[\x90P\x80`\x05\x01_\x83_\x015\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a\x0F(W\x81_\x015`@Q\x7F\xB1\x82\\^\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0F\x1F\x91\x90a.oV[`@Q\x80\x91\x03\x90\xFD[\x80`\r\x01\x82\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x05\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a\x0F_\x91\x90a@7V[PP`\x01\x81`\x05\x01_\x84_\x015\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xB8 {[\xB7\x91s\n\xE8\xF0SO\xA4\xC7\xBE}\xA4\x9D\xD7]p\x1F\x9Cz\xCFQ\xC9K\x8A\xCE\x96\xB2\x82`@Qa\x0F\xBE\x91\x90aA\xB1V[`@Q\x80\x91\x03\x90\xA1PPV[a\x0F\xD2a \xD1V[a\x0F\xDB_a$\xDFV[V[_a\x0F\xE6a%\x1CV[\x90P\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x10\x07a\x1EEV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x10_W\x80`@Q\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x10V\x91\x90a1sV[`@Q\x80\x91\x03\x90\xFD[a\x10h\x81a$\xDFV[PV[a\x10sa,9V[_a\x10|a!XV[\x90P\x80`\r\x01\x83\x81T\x81\x10a\x10\x94Wa\x10\x93a:\xD4V[[\x90_R` _ \x90`\x05\x02\x01`@Q\x80`\xA0\x01`@R\x90\x81_\x82\x01T\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01\x80Ta\x11n\x90a:cV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x11\x9A\x90a:cV[\x80\x15a\x11\xE5W\x80`\x1F\x10a\x11\xBCWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x11\xE5V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x11\xC8W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x04\x82\x01\x80Ta\x11\xFE\x90a:cV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x12*\x90a:cV[\x80\x15a\x12uW\x80`\x1F\x10a\x12LWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x12uV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x12XW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x91PP\x91\x90PV[__a\x12\x90a%#V[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x90V[``_a\x12\xC6a!XV[\x90P\x80`\x0C\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x13IW` \x02\x82\x01\x91\x90_R` _ \x90[\x81_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x13\0W[PPPPP\x91PP\x90V[`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x81V[``_a\x13\x98a!XV[\x90P\x80`\t\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x14\x1BW` \x02\x82\x01\x91\x90_R` _ \x90[\x81_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x13\xD2W[PPPPP\x91PP\x90V[_a\x14/a!XV[\x90P\x80`\x01\x01_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x14\xBEW\x81`@Q\x7F\xAE\xE8c#\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14\xB5\x91\x90a1sV[`@Q\x80\x91\x03\x90\xFD[PPV[_a\x14\xCBa!XV[\x90P\x80`\x05\x01_\x83\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x15.W\x81`@Q\x7Fm\xF6\xFE\x89\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x15%\x91\x90a.oV[`@Q\x80\x91\x03\x90\xFD[PPV[_a\x15;a!XV[\x90P\x80`\x03\x01_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x15\xCAW\x81`@Q\x7FR\xD7%\xF5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x15\xC1\x91\x90a1sV[`@Q\x80\x91\x03\x90\xFD[PPV[_a\x15\xD7a!XV[\x90P\x80`\x04\x01_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x16fW\x81`@Q\x7F&\xCDu\xDC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x16]\x91\x90a1sV[`@Q\x80\x91\x03\x90\xFD[PPV[__a\x16ta!XV[\x90P\x80`\t\x01\x83\x81T\x81\x10a\x16\x8CWa\x16\x8Ba:\xD4V[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x91\x90PV[`\x02_a\x16\xC7a%JV[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a\x17\x0FWP\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15[\x15a\x17FW`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPa\x17\x9Ba\x17\x96a\x12\x86V[a%qV[_a\x17\xA4a!XV[\x90P\x86\x81`\x06\x01_\x82\x01Q\x81_\x01\x90\x81a\x17\xBE\x91\x90aA\xD1V[P` \x82\x01Q\x81`\x01\x01\x90\x81a\x17\xD4\x91\x90aA\xD1V[P\x90PP\x87\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP_\x85Q\x90P\x80\x87\x11\x15a\x18eW\x86\x81`@Q\x7FHgo\xE0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x18\\\x92\x91\x90a8\x83V[`@Q\x80\x91\x03\x90\xFD[\x86\x82`\n\x01\x81\x90UP__\x90P[\x81\x81\x10\x15a\x1B\nW`\x01\x83`\x01\x01_\x89\x84\x81Q\x81\x10a\x18\x95Wa\x18\x94a:\xD4V[[` \x02` \x01\x01Q_\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x86\x81\x81Q\x81\x10a\x19\x02Wa\x19\x01a:\xD4V[[` \x02` \x01\x01Q\x83`\x08\x01_\x89\x84\x81Q\x81\x10a\x19\"Wa\x19!a:\xD4V[[` \x02` \x01\x01Q_\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x82\x01Q\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP` \x82\x01Q\x81`\x01\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`@\x82\x01Q\x81`\x02\x01\x90\x81a\x1A\x05\x91\x90aA\xD1V[P\x90PP\x82`\t\x01\x87\x82\x81Q\x81\x10a\x1A Wa\x1A\x1Fa:\xD4V[[` \x02` \x01\x01Q_\x01Q\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x83`\x02\x01_\x89\x84\x81Q\x81\x10a\x1A\xA2Wa\x1A\xA1a:\xD4V[[` \x02` \x01\x01Q` \x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x80\x80`\x01\x01\x91PPa\x18sV[P__\x90P[\x85Q\x81\x10\x15a\x1D\xA8W`\x01\x83`\x03\x01_\x88\x84\x81Q\x81\x10a\x1B3Wa\x1B2a:\xD4V[[` \x02` \x01\x01Q_\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x85\x81\x81Q\x81\x10a\x1B\xA0Wa\x1B\x9Fa:\xD4V[[` \x02` \x01\x01Q\x83`\x0B\x01_\x88\x84\x81Q\x81\x10a\x1B\xC0Wa\x1B\xBFa:\xD4V[[` \x02` \x01\x01Q_\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x82\x01Q\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP` \x82\x01Q\x81`\x01\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`@\x82\x01Q\x81`\x02\x01\x90\x81a\x1C\xA3\x91\x90aA\xD1V[P\x90PP\x82`\x0C\x01\x86\x82\x81Q\x81\x10a\x1C\xBEWa\x1C\xBDa:\xD4V[[` \x02` \x01\x01Q_\x01Q\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x83`\x04\x01_\x88\x84\x81Q\x81\x10a\x1D@Wa\x1D?a:\xD4V[[` \x02` \x01\x01Q` \x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x80\x80`\x01\x01\x91PPa\x1B\x10V[P\x7F\xF3=\x90\x8CJ\x8BS/\xE6M\xF2\x0Bro\x11@\\\x11\xB9w-1\xB6o^\xEFh\x87\xA4<?\xDE\x89\x89\x89\x89\x89`@Qa\x1D\xE0\x95\x94\x93\x92\x91\x90aD\xB0V[`@Q\x80\x91\x03\x90\xA1PP_\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x82`@Qa\x1E4\x91\x90aE8V[`@Q\x80\x91\x03\x90\xA1PPPPPPPV[__a\x1EOa%\x85V[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x90V[a\x1E\x82a,\x91V[_a\x1E\x8Ba!XV[\x90P\x80`\x0B\x01_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `@Q\x80``\x01`@R\x90\x81_\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01\x80Ta\x1F\x90\x90a:cV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x1F\xBC\x90a:cV[\x80\x15a \x07W\x80`\x1F\x10a\x1F\xDEWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a \x07V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x1F\xEAW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x91PP\x91\x90PV[a  a \xD1V[_a )a%\x85V[\x90P\x81\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a \x8Ba\x12\x86V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F8\xD1k\x8C\xAC\"\xD9\x9F\xC7\xC1$\xB9\xCD\r\xE2\xD3\xFA\x1F\xAE\xF4 \xBF\xE7\x91\xD8\xC3b\xD7e\xE2'\0`@Q`@Q\x80\x91\x03\x90\xA3PPV[a \xD9a%\x1CV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a \xF7a\x12\x86V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a!VWa!\x1Aa%\x1CV[`@Q\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a!M\x91\x90a1sV[`@Q\x80\x91\x03\x90\xFD[V[_\x7F\x82qv\xA4^\x1A\xAD\x1F:e9\xFE\xE6\x0C\x06\x12l@B{HI\xE70\x1B\xF2\xCF\x0F\x1F\x8E\x95\0\x90P\x90V[``_`\x01a!\x8D\x84a%\xACV[\x01\x90P_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a!\xABWa!\xAAa/9V[[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a!\xDDW\x81` \x01`\x01\x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x90P_\x82` \x01\x82\x01\x90P[`\x01\x15a\">W\x80\x80`\x01\x90\x03\x91PP\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\n\x86\x06\x1A\x81S`\n\x85\x81a\"3Wa\"2a;\x01V[[\x04\x94P_\x85\x03a!\xEAW[\x81\x93PPPP\x91\x90PV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x80a\"\xF6WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\"\xDDa&\xFDV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15a#-W`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[a#7a \xD1V[PV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cR\xD1\x90-`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15a#\xA2WP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a#\x9F\x91\x90aE{V[`\x01[a#\xE3W\x81`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a#\xDA\x91\x90a1sV[`@Q\x80\x91\x03\x90\xFD[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x81\x14a$IW\x80`@Q\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a$@\x91\x90a0\xCFV[`@Q\x80\x91\x03\x90\xFD[a$S\x83\x83a'PV[PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a$\xDDW`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_a$\xE8a%\x85V[\x90P\x80_\x01_a\x01\0\n\x81T\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90Ua%\x18\x82a'\xC2V[PPV[_3\x90P\x90V[_\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0\x90P\x90V[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[a%ya(\x93V[a%\x82\x81a(\xD3V[PV[_\x7F#~\x15\x82\"\xE3\xE6\x96\x8Br\xB9\xDB\r\x80C\xAA\xCF\x07J\xD9\xF6P\xF0\xD1`kM\x82\xEEC,\0\x90P\x90V[___\x90Pz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x10a&\x08Wz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x81a%\xFEWa%\xFDa;\x01V[[\x04\x92P`@\x81\x01\x90P[m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x10a&EWm\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x81a&;Wa&:a;\x01V[[\x04\x92P` \x81\x01\x90P[f#\x86\xF2o\xC1\0\0\x83\x10a&tWf#\x86\xF2o\xC1\0\0\x83\x81a&jWa&ia;\x01V[[\x04\x92P`\x10\x81\x01\x90P[c\x05\xF5\xE1\0\x83\x10a&\x9DWc\x05\xF5\xE1\0\x83\x81a&\x93Wa&\x92a;\x01V[[\x04\x92P`\x08\x81\x01\x90P[a'\x10\x83\x10a&\xC2Wa'\x10\x83\x81a&\xB8Wa&\xB7a;\x01V[[\x04\x92P`\x04\x81\x01\x90P[`d\x83\x10a&\xE5W`d\x83\x81a&\xDBWa&\xDAa;\x01V[[\x04\x92P`\x02\x81\x01\x90P[`\n\x83\x10a&\xF4W`\x01\x81\x01\x90P[\x80\x91PP\x91\x90PV[_a')\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Ba)WV[_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[a'Y\x82a)`V[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;`@Q`@Q\x80\x91\x03\x90\xA2_\x81Q\x11\x15a'\xB5Wa'\xAF\x82\x82a*)V[Pa'\xBEV[a'\xBDa*\xA9V[[PPV[_a'\xCBa%#V[\x90P_\x81_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x82\x82_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPPV[a(\x9Ba*\xE5V[a(\xD1W`@Q\x7F\xD7\xE6\xBC\xF8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[a(\xDBa(\x93V[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a)KW_`@Q\x7F\x1EO\xBD\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a)B\x91\x90a1sV[`@Q\x80\x91\x03\x90\xFD[a)T\x81a$\xDFV[PV[_\x81\x90P\x91\x90PV[_\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x03a)\xBBW\x80`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a)\xB2\x91\x90a1sV[`@Q\x80\x91\x03\x90\xFD[\x80a)\xE7\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Ba)WV[_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[``__\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84`@Qa*R\x91\x90aE\xEAV[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a*\x8AW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a*\x8FV[``\x91P[P\x91P\x91Pa*\x9F\x85\x83\x83a+\x03V[\x92PPP\x92\x91PPV[_4\x11\x15a*\xE3W`@Q\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_a*\xEEa%JV[_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x90P\x90V[``\x82a+\x18Wa+\x13\x82a+\x90V[a+\x88V[_\x82Q\x14\x80\x15a+>WP_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x14[\x15a+\x80W\x83`@Q\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a+w\x91\x90a1sV[`@Q\x80\x91\x03\x90\xFD[\x81\x90Pa+\x89V[[\x93\x92PPPV[_\x81Q\x11\x15a+\xA2W\x80Q\x80\x82` \x01\xFD[`@Q\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Q\x80`@\x01`@R\x80``\x81R` \x01``\x81RP\x90V[`@Q\x80``\x01`@R\x80_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01``\x81RP\x90V[`@Q\x80`\xA0\x01`@R\x80_\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01``\x81R` \x01``\x81RP\x90V[`@Q\x80``\x01`@R\x80_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01``\x81RP\x90V[_`@Q\x90P\x90V[__\xFD[__\xFD[_\x81\x90P\x91\x90PV[a,\xFF\x81a,\xEDV[\x81\x14a-\tW__\xFD[PV[_\x815\x90Pa-\x1A\x81a,\xF6V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a-5Wa-4a,\xE5V[[_a-B\x84\x82\x85\x01a-\x0CV[\x91PP\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x82\x81\x83^_\x83\x83\x01RPPPV[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[_a-\x8D\x82a-KV[a-\x97\x81\x85a-UV[\x93Pa-\xA7\x81\x85` \x86\x01a-eV[a-\xB0\x81a-sV[\x84\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra-\xD3\x81\x84a-\x83V[\x90P\x92\x91PPV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a.\x04\x82a-\xDBV[\x90P\x91\x90PV[a.\x14\x81a-\xFAV[\x81\x14a.\x1EW__\xFD[PV[_\x815\x90Pa./\x81a.\x0BV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a.JWa.Ia,\xE5V[[_a.W\x84\x82\x85\x01a.!V[\x91PP\x92\x91PPV[a.i\x81a,\xEDV[\x82RPPV[_` \x82\x01\x90Pa.\x82_\x83\x01\x84a.`V[\x92\x91PPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_a.\xA2\x82a-KV[a.\xAC\x81\x85a.\x88V[\x93Pa.\xBC\x81\x85` \x86\x01a-eV[a.\xC5\x81a-sV[\x84\x01\x91PP\x92\x91PPV[_`@\x83\x01_\x83\x01Q\x84\x82\x03_\x86\x01Ra.\xEA\x82\x82a.\x98V[\x91PP` \x83\x01Q\x84\x82\x03` \x86\x01Ra/\x04\x82\x82a.\x98V[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra/)\x81\x84a.\xD0V[\x90P\x92\x91PPV[__\xFD[__\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[a/o\x82a-sV[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a/\x8EWa/\x8Da/9V[[\x80`@RPPPV[_a/\xA0a,\xDCV[\x90Pa/\xAC\x82\x82a/fV[\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a/\xCBWa/\xCAa/9V[[a/\xD4\x82a-sV[\x90P` \x81\x01\x90P\x91\x90PV[\x82\x81\x837_\x83\x83\x01RPPPV[_a0\x01a/\xFC\x84a/\xB1V[a/\x97V[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a0\x1DWa0\x1Ca/5V[[a0(\x84\x82\x85a/\xE1V[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a0DWa0Ca/1V[[\x815a0T\x84\x82` \x86\x01a/\xEFV[\x91PP\x92\x91PPV[__`@\x83\x85\x03\x12\x15a0sWa0ra,\xE5V[[_a0\x80\x85\x82\x86\x01a.!V[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a0\xA1Wa0\xA0a,\xE9V[[a0\xAD\x85\x82\x86\x01a00V[\x91PP\x92P\x92\x90PV[_\x81\x90P\x91\x90PV[a0\xC9\x81a0\xB7V[\x82RPPV[_` \x82\x01\x90Pa0\xE2_\x83\x01\x84a0\xC0V[\x92\x91PPV[a0\xF1\x81a-\xFAV[\x82RPPV[_``\x83\x01_\x83\x01Qa1\x0C_\x86\x01\x82a0\xE8V[P` \x83\x01Qa1\x1F` \x86\x01\x82a0\xE8V[P`@\x83\x01Q\x84\x82\x03`@\x86\x01Ra17\x82\x82a.\x98V[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra1\\\x81\x84a0\xF7V[\x90P\x92\x91PPV[a1m\x81a-\xFAV[\x82RPPV[_` \x82\x01\x90Pa1\x86_\x83\x01\x84a1dV[\x92\x91PPV[__\xFD[_`\xA0\x82\x84\x03\x12\x15a1\xA5Wa1\xA4a1\x8CV[[\x81\x90P\x92\x91PPV[_` \x82\x84\x03\x12\x15a1\xC3Wa1\xC2a,\xE5V[[_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a1\xE0Wa1\xDFa,\xE9V[[a1\xEC\x84\x82\x85\x01a1\x90V[\x91PP\x92\x91PPV[a1\xFE\x81a,\xEDV[\x82RPPV[_`\xA0\x83\x01_\x83\x01Qa2\x19_\x86\x01\x82a1\xF5V[P` \x83\x01Qa2,` \x86\x01\x82a0\xE8V[P`@\x83\x01Qa2?`@\x86\x01\x82a0\xE8V[P``\x83\x01Q\x84\x82\x03``\x86\x01Ra2W\x82\x82a.\x98V[\x91PP`\x80\x83\x01Q\x84\x82\x03`\x80\x86\x01Ra2q\x82\x82a.\x98V[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra2\x96\x81\x84a2\x04V[\x90P\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_a2\xD2\x83\x83a0\xE8V[` \x83\x01\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_a2\xF4\x82a2\x9EV[a2\xFE\x81\x85a2\xA8V[\x93Pa3\t\x83a2\xB8V[\x80_[\x83\x81\x10\x15a39W\x81Qa3 \x88\x82a2\xC7V[\x97Pa3+\x83a2\xDEV[\x92PP`\x01\x81\x01\x90Pa3\x0CV[P\x85\x93PPPP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra3^\x81\x84a2\xEAV[\x90P\x92\x91PPV[__\xFD[__\xFD[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a3\x88Wa3\x87a/9V[[a3\x91\x82a-sV[\x90P` \x81\x01\x90P\x91\x90PV[_a3\xB0a3\xAB\x84a3nV[a/\x97V[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a3\xCCWa3\xCBa/5V[[a3\xD7\x84\x82\x85a/\xE1V[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a3\xF3Wa3\xF2a/1V[[\x815a4\x03\x84\x82` \x86\x01a3\x9EV[\x91PP\x92\x91PPV[_`@\x82\x84\x03\x12\x15a4!Wa4 a3fV[[a4+`@a/\x97V[\x90P_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a4JWa4Ia3jV[[a4V\x84\x82\x85\x01a3\xDFV[_\x83\x01RP` \x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a4yWa4xa3jV[[a4\x85\x84\x82\x85\x01a3\xDFV[` \x83\x01RP\x92\x91PPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a4\xABWa4\xAAa/9V[[` \x82\x02\x90P` \x81\x01\x90P\x91\x90PV[__\xFD[_``\x82\x84\x03\x12\x15a4\xD5Wa4\xD4a3fV[[a4\xDF``a/\x97V[\x90P_a4\xEE\x84\x82\x85\x01a.!V[_\x83\x01RP` a5\x01\x84\x82\x85\x01a.!V[` \x83\x01RP`@\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a5%Wa5$a3jV[[a51\x84\x82\x85\x01a3\xDFV[`@\x83\x01RP\x92\x91PPV[_a5Oa5J\x84a4\x91V[a/\x97V[\x90P\x80\x83\x82R` \x82\x01\x90P` \x84\x02\x83\x01\x85\x81\x11\x15a5rWa5qa4\xBCV[[\x83[\x81\x81\x10\x15a5\xB9W\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a5\x97Wa5\x96a/1V[[\x80\x86\x01a5\xA4\x89\x82a4\xC0V[\x85R` \x85\x01\x94PPP` \x81\x01\x90Pa5tV[PPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a5\xD7Wa5\xD6a/1V[[\x815a5\xE7\x84\x82` \x86\x01a5=V[\x91PP\x92\x91PPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a6\nWa6\ta/9V[[` \x82\x02\x90P` \x81\x01\x90P\x91\x90PV[_``\x82\x84\x03\x12\x15a60Wa6/a3fV[[a6:``a/\x97V[\x90P_a6I\x84\x82\x85\x01a.!V[_\x83\x01RP` a6\\\x84\x82\x85\x01a.!V[` \x83\x01RP`@\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a6\x80Wa6\x7Fa3jV[[a6\x8C\x84\x82\x85\x01a3\xDFV[`@\x83\x01RP\x92\x91PPV[_a6\xAAa6\xA5\x84a5\xF0V[a/\x97V[\x90P\x80\x83\x82R` \x82\x01\x90P` \x84\x02\x83\x01\x85\x81\x11\x15a6\xCDWa6\xCCa4\xBCV[[\x83[\x81\x81\x10\x15a7\x14W\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a6\xF2Wa6\xF1a/1V[[\x80\x86\x01a6\xFF\x89\x82a6\x1BV[\x85R` \x85\x01\x94PPP` \x81\x01\x90Pa6\xCFV[PPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a72Wa71a/1V[[\x815a7B\x84\x82` \x86\x01a6\x98V[\x91PP\x92\x91PPV[_____`\xA0\x86\x88\x03\x12\x15a7dWa7ca,\xE5V[[_a7q\x88\x82\x89\x01a.!V[\x95PP` \x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a7\x92Wa7\x91a,\xE9V[[a7\x9E\x88\x82\x89\x01a4\x0CV[\x94PP`@a7\xAF\x88\x82\x89\x01a-\x0CV[\x93PP``\x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a7\xD0Wa7\xCFa,\xE9V[[a7\xDC\x88\x82\x89\x01a5\xC3V[\x92PP`\x80\x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a7\xFDWa7\xFCa,\xE9V[[a8\t\x88\x82\x89\x01a7\x1EV[\x91PP\x92\x95P\x92\x95\x90\x93PV[_``\x83\x01_\x83\x01Qa8+_\x86\x01\x82a0\xE8V[P` \x83\x01Qa8>` \x86\x01\x82a0\xE8V[P`@\x83\x01Q\x84\x82\x03`@\x86\x01Ra8V\x82\x82a.\x98V[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra8{\x81\x84a8\x16V[\x90P\x92\x91PPV[_`@\x82\x01\x90Pa8\x96_\x83\x01\x85a.`V[a8\xA3` \x83\x01\x84a.`V[\x93\x92PPPV[_\x81\x90P\x92\x91PPV[_a8\xBE\x82a-KV[a8\xC8\x81\x85a8\xAAV[\x93Pa8\xD8\x81\x85` \x86\x01a-eV[\x80\x84\x01\x91PP\x92\x91PPV[\x7F v\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a9\x18`\x02\x83a8\xAAV[\x91Pa9#\x82a8\xE4V[`\x02\x82\x01\x90P\x91\x90PV[\x7F.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a9b`\x01\x83a8\xAAV[\x91Pa9m\x82a9.V[`\x01\x82\x01\x90P\x91\x90PV[_a9\x83\x82\x87a8\xB4V[\x91Pa9\x8E\x82a9\x0CV[\x91Pa9\x9A\x82\x86a8\xB4V[\x91Pa9\xA5\x82a9VV[\x91Pa9\xB1\x82\x85a8\xB4V[\x91Pa9\xBC\x82a9VV[\x91Pa9\xC8\x82\x84a8\xB4V[\x91P\x81\x90P\x95\x94PPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_a:\r\x82a,\xEDV[\x91Pa:\x18\x83a,\xEDV[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15a:0Wa:/a9\xD6V[[\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\"`\x04R`$_\xFD[_`\x02\x82\x04\x90P`\x01\x82\x16\x80a:zW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a:\x8DWa:\x8Ca:6V[[P\x91\x90PV[_a:\x9D\x82a,\xEDV[\x91Pa:\xA8\x83a,\xEDV[\x92P\x82\x82\x02a:\xB6\x81a,\xEDV[\x91P\x82\x82\x04\x84\x14\x83\x15\x17a:\xCDWa:\xCCa9\xD6V[[P\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_a;8\x82a,\xEDV[\x91Pa;C\x83a,\xEDV[\x92P\x82a;SWa;Ra;\x01V[[\x82\x82\x04\x90P\x92\x91PPV[_\x815a;j\x81a,\xF6V[\x80\x91PP\x91\x90PV[_\x81_\x1B\x90P\x91\x90PV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa;\xA9\x84a;sV[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[_\x81\x90P\x91\x90PV[_a;\xE2a;\xDDa;\xD8\x84a,\xEDV[a;\xBFV[a,\xEDV[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a;\xFB\x82a;\xC8V[a<\x0Ea<\x07\x82a;\xE9V[\x83Ta;~V[\x82UPPPV[_\x815a<!\x81a.\x0BV[\x80\x91PP\x91\x90PV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa<I\x84a;sV[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[_a<ya<ta<o\x84a-\xDBV[a;\xBFV[a-\xDBV[\x90P\x91\x90PV[_a<\x8A\x82a<_V[\x90P\x91\x90PV[_a<\x9B\x82a<\x80V[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a<\xB4\x82a<\x91V[a<\xC7a<\xC0\x82a<\xA2V[\x83Ta<*V[\x82UPPPV[__\xFD[__\xFD[__\xFD[__\x835`\x01` \x03\x846\x03\x03\x81\x12a<\xF6Wa<\xF5a<\xCEV[[\x80\x84\x01\x92P\x825\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a=\x18Wa=\x17a<\xD2V[[` \x83\x01\x92P`\x01\x82\x026\x03\x83\x13\x15a=4Wa=3a<\xD6V[[P\x92P\x92\x90PV[_\x82\x90P\x92\x91PPV[_\x81\x90P\x81_R` _ \x90P\x91\x90PV[_` `\x1F\x83\x01\x04\x90P\x91\x90PV[_\x82\x82\x1B\x90P\x92\x91PPV[_`\x08\x83\x02a=\xA2\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82a=gV[a=\xAC\x86\x83a=gV[\x95P\x80\x19\x84\x16\x93P\x80\x86\x16\x84\x17\x92PPP\x93\x92PPPV[a=\xCD\x83a;\xC8V[a=\xE1a=\xD9\x82a;\xE9V[\x84\x84Ta=sV[\x82UPPPPV[__\x90P\x90V[a=\xF8a=\xE9V[a>\x03\x81\x84\x84a=\xC4V[PPPV[[\x81\x81\x10\x15a>&Wa>\x1B_\x82a=\xF0V[`\x01\x81\x01\x90Pa>\tV[PPV[`\x1F\x82\x11\x15a>kWa><\x81a=FV[a>E\x84a=XV[\x81\x01` \x85\x10\x15a>TW\x81\x90P[a>ha>`\x85a=XV[\x83\x01\x82a>\x08V[PP[PPPV[_\x82\x82\x1C\x90P\x92\x91PPV[_a>\x8B_\x19\x84`\x08\x02a>pV[\x19\x80\x83\x16\x91PP\x92\x91PPV[_a>\xA3\x83\x83a>|V[\x91P\x82`\x02\x02\x82\x17\x90P\x92\x91PPV[a>\xBD\x83\x83a=<V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a>\xD6Wa>\xD5a/9V[[a>\xE0\x82Ta:cV[a>\xEB\x82\x82\x85a>*V[_`\x1F\x83\x11`\x01\x81\x14a?\x18W_\x84\x15a?\x06W\x82\x87\x015\x90P[a?\x10\x85\x82a>\x98V[\x86UPa?wV[`\x1F\x19\x84\x16a?&\x86a=FV[_[\x82\x81\x10\x15a?MW\x84\x89\x015\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Pa?(V[\x86\x83\x10\x15a?jW\x84\x89\x015a?f`\x1F\x89\x16\x82a>|V[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPPV[a?\x8B\x83\x83\x83a>\xB3V[PPPV[_\x81\x01_\x83\x01\x80a?\xA0\x81a;^V[\x90Pa?\xAC\x81\x84a;\xF2V[PPP`\x01\x81\x01` \x83\x01\x80a?\xC1\x81a<\x15V[\x90Pa?\xCD\x81\x84a<\xABV[PPP`\x02\x81\x01`@\x83\x01\x80a?\xE2\x81a<\x15V[\x90Pa?\xEE\x81\x84a<\xABV[PPP`\x03\x81\x01``\x83\x01a@\x03\x81\x85a<\xDAV[a@\x0E\x81\x83\x86a?\x80V[PPPP`\x04\x81\x01`\x80\x83\x01a@$\x81\x85a<\xDAV[a@/\x81\x83\x86a?\x80V[PPPPPPV[a@A\x82\x82a?\x90V[PPV[_a@S` \x84\x01\x84a-\x0CV[\x90P\x92\x91PPV[_a@i` \x84\x01\x84a.!V[\x90P\x92\x91PPV[__\xFD[__\xFD[__\xFD[__\x835`\x01` \x03\x846\x03\x03\x81\x12a@\x99Wa@\x98a@yV[[\x83\x81\x01\x92P\x825\x91P` \x83\x01\x92Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a@\xC1Wa@\xC0a@qV[[`\x01\x82\x026\x03\x83\x13\x15a@\xD7Wa@\xD6a@uV[[P\x92P\x92\x90PV[_a@\xEA\x83\x85a.\x88V[\x93Pa@\xF7\x83\x85\x84a/\xE1V[aA\0\x83a-sV[\x84\x01\x90P\x93\x92PPPV[_`\xA0\x83\x01aA\x1C_\x84\x01\x84a@EV[aA(_\x86\x01\x82a1\xF5V[PaA6` \x84\x01\x84a@[V[aAC` \x86\x01\x82a0\xE8V[PaAQ`@\x84\x01\x84a@[V[aA^`@\x86\x01\x82a0\xE8V[PaAl``\x84\x01\x84a@}V[\x85\x83\x03``\x87\x01RaA\x7F\x83\x82\x84a@\xDFV[\x92PPPaA\x90`\x80\x84\x01\x84a@}V[\x85\x83\x03`\x80\x87\x01RaA\xA3\x83\x82\x84a@\xDFV[\x92PPP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01RaA\xC9\x81\x84aA\x0BV[\x90P\x92\x91PPV[aA\xDA\x82a-KV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15aA\xF3WaA\xF2a/9V[[aA\xFD\x82Ta:cV[aB\x08\x82\x82\x85a>*V[_` \x90P`\x1F\x83\x11`\x01\x81\x14aB9W_\x84\x15aB'W\x82\x87\x01Q\x90P[aB1\x85\x82a>\x98V[\x86UPaB\x98V[`\x1F\x19\x84\x16aBG\x86a=FV[_[\x82\x81\x10\x15aBnW\x84\x89\x01Q\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90PaBIV[\x86\x83\x10\x15aB\x8BW\x84\x89\x01QaB\x87`\x1F\x89\x16\x82a>|V[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_``\x83\x01_\x83\x01QaB\xDE_\x86\x01\x82a0\xE8V[P` \x83\x01QaB\xF1` \x86\x01\x82a0\xE8V[P`@\x83\x01Q\x84\x82\x03`@\x86\x01RaC\t\x82\x82a.\x98V[\x91PP\x80\x91PP\x92\x91PPV[_aC!\x83\x83aB\xC9V[\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_aC?\x82aB\xA0V[aCI\x81\x85aB\xAAV[\x93P\x83` \x82\x02\x85\x01aC[\x85aB\xBAV[\x80_[\x85\x81\x10\x15aC\x96W\x84\x84\x03\x89R\x81QaCw\x85\x82aC\x16V[\x94PaC\x82\x83aC)V[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90PaC^V[P\x82\x97P\x87\x95PPPPPP\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_``\x83\x01_\x83\x01QaC\xE6_\x86\x01\x82a0\xE8V[P` \x83\x01QaC\xF9` \x86\x01\x82a0\xE8V[P`@\x83\x01Q\x84\x82\x03`@\x86\x01RaD\x11\x82\x82a.\x98V[\x91PP\x80\x91PP\x92\x91PPV[_aD)\x83\x83aC\xD1V[\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_aDG\x82aC\xA8V[aDQ\x81\x85aC\xB2V[\x93P\x83` \x82\x02\x85\x01aDc\x85aC\xC2V[\x80_[\x85\x81\x10\x15aD\x9EW\x84\x84\x03\x89R\x81QaD\x7F\x85\x82aD\x1EV[\x94PaD\x8A\x83aD1V[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90PaDfV[P\x82\x97P\x87\x95PPPPPP\x92\x91PPV[_`\xA0\x82\x01\x90PaD\xC3_\x83\x01\x88a1dV[\x81\x81\x03` \x83\x01RaD\xD5\x81\x87a.\xD0V[\x90PaD\xE4`@\x83\x01\x86a.`V[\x81\x81\x03``\x83\x01RaD\xF6\x81\x85aC5V[\x90P\x81\x81\x03`\x80\x83\x01RaE\n\x81\x84aD=V[\x90P\x96\x95PPPPPPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[aE2\x81aE\x16V[\x82RPPV[_` \x82\x01\x90PaEK_\x83\x01\x84aE)V[\x92\x91PPV[aEZ\x81a0\xB7V[\x81\x14aEdW__\xFD[PV[_\x81Q\x90PaEu\x81aEQV[\x92\x91PPV[_` \x82\x84\x03\x12\x15aE\x90WaE\x8Fa,\xE5V[[_aE\x9D\x84\x82\x85\x01aEgV[\x91PP\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x81\x90P\x92\x91PPV[_aE\xC4\x82aE\xA6V[aE\xCE\x81\x85aE\xB0V[\x93PaE\xDE\x81\x85` \x86\x01a-eV[\x80\x84\x01\x91PP\x92\x91PPV[_aE\xF5\x82\x84aE\xBAV[\x91P\x81\x90P\x92\x91PPV\xFE\xA2dipfsX\"\x12 t#\x05\xE2)Z\xE12\xC83\xC9\xA0\x18\xFB\x9D\xDB\xE4v\x0B\xEF\x04&\xD5\x06H..xV\xC9H dsolcC\0\x08\x1C\x003",
    );
    /**```solidity
struct Coprocessor { address txSenderAddress; address signerAddress; string s3BucketUrl; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Coprocessor {
        #[allow(missing_docs)]
        pub txSenderAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub signerAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub s3BucketUrl: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::String,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::String,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Coprocessor> for UnderlyingRustTuple<'_> {
            fn from(value: Coprocessor) -> Self {
                (value.txSenderAddress, value.signerAddress, value.s3BucketUrl)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Coprocessor {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    txSenderAddress: tuple.0,
                    signerAddress: tuple.1,
                    s3BucketUrl: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Coprocessor {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Coprocessor {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.txSenderAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signerAddress,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.s3BucketUrl,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Coprocessor {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Coprocessor {
            const NAME: &'static str = "Coprocessor";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Coprocessor(address txSenderAddress,address signerAddress,string s3BucketUrl)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.txSenderAddress,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.signerAddress,
                        )
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.s3BucketUrl,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Coprocessor {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.txSenderAddress,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.signerAddress,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.s3BucketUrl,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.txSenderAddress,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.signerAddress,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.s3BucketUrl,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct KmsNode { address txSenderAddress; address signerAddress; string ipAddress; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KmsNode {
        #[allow(missing_docs)]
        pub txSenderAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub signerAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub ipAddress: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::String,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::String,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KmsNode> for UnderlyingRustTuple<'_> {
            fn from(value: KmsNode) -> Self {
                (value.txSenderAddress, value.signerAddress, value.ipAddress)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for KmsNode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    txSenderAddress: tuple.0,
                    signerAddress: tuple.1,
                    ipAddress: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for KmsNode {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for KmsNode {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.txSenderAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signerAddress,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.ipAddress,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for KmsNode {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for KmsNode {
            const NAME: &'static str = "KmsNode";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "KmsNode(address txSenderAddress,address signerAddress,string ipAddress)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.txSenderAddress,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.signerAddress,
                        )
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.ipAddress,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for KmsNode {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.txSenderAddress,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.signerAddress,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.ipAddress,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.txSenderAddress,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.signerAddress,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.ipAddress,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct Network { uint256 chainId; address httpzExecutor; address aclAddress; string name; string website; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Network {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub httpzExecutor: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub aclAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub name: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub website: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::String,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::String,
            alloy::sol_types::private::String,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Network> for UnderlyingRustTuple<'_> {
            fn from(value: Network) -> Self {
                (
                    value.chainId,
                    value.httpzExecutor,
                    value.aclAddress,
                    value.name,
                    value.website,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Network {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    chainId: tuple.0,
                    httpzExecutor: tuple.1,
                    aclAddress: tuple.2,
                    name: tuple.3,
                    website: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Network {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Network {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.httpzExecutor,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.aclAddress,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.website,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Network {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Network {
            const NAME: &'static str = "Network";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Network(uint256 chainId,address httpzExecutor,address aclAddress,string name,string website)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainId)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.httpzExecutor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.aclAddress,
                        )
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.name,
                        )
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.website,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Network {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainId,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.httpzExecutor,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.aclAddress,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.name,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.website,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainId,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.httpzExecutor,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.aclAddress,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.name,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.website,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ProtocolMetadata { string name; string website; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ProtocolMetadata {
        #[allow(missing_docs)]
        pub name: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub website: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::String,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::String,
            alloy::sol_types::private::String,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ProtocolMetadata> for UnderlyingRustTuple<'_> {
            fn from(value: ProtocolMetadata) -> Self {
                (value.name, value.website)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ProtocolMetadata {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    name: tuple.0,
                    website: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ProtocolMetadata {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ProtocolMetadata {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.website,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ProtocolMetadata {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ProtocolMetadata {
            const NAME: &'static str = "ProtocolMetadata";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ProtocolMetadata(string name,string website)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.name,
                        )
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.website,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ProtocolMetadata {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.name,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.website,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.name,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.website,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Custom error with signature `AddressEmptyCode(address)` and selector `0x9996b315`.
```solidity
error AddressEmptyCode(address target);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AddressEmptyCode {
        #[allow(missing_docs)]
        pub target: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AddressEmptyCode> for UnderlyingRustTuple<'_> {
            fn from(value: AddressEmptyCode) -> Self {
                (value.target,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AddressEmptyCode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { target: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AddressEmptyCode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AddressEmptyCode(address)";
            const SELECTOR: [u8; 4] = [153u8, 150u8, 179u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC1967InvalidImplementation(address)` and selector `0x4c9c8ce3`.
```solidity
error ERC1967InvalidImplementation(address implementation);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967InvalidImplementation {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967InvalidImplementation>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967InvalidImplementation) -> Self {
                (value.implementation,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC1967InvalidImplementation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { implementation: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967InvalidImplementation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967InvalidImplementation(address)";
            const SELECTOR: [u8; 4] = [76u8, 156u8, 140u8, 227u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC1967NonPayable()` and selector `0xb398979f`.
```solidity
error ERC1967NonPayable();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967NonPayable {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967NonPayable> for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967NonPayable) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC1967NonPayable {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967NonPayable {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967NonPayable()";
            const SELECTOR: [u8; 4] = [179u8, 152u8, 151u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `FailedCall()` and selector `0xd6bda275`.
```solidity
error FailedCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FailedCall {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedCall> for UnderlyingRustTuple<'_> {
            fn from(value: FailedCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FailedCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedCall()";
            const SELECTOR: [u8; 4] = [214u8, 189u8, 162u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidInitialization()` and selector `0xf92ee8a9`.
```solidity
error InvalidInitialization();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidInitialization {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidInitialization> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidInitialization) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidInitialization {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidInitialization {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidInitialization()";
            const SELECTOR: [u8; 4] = [249u8, 46u8, 232u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidNullChainId()` and selector `0x22f73fea`.
```solidity
error InvalidNullChainId();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidNullChainId {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidNullChainId> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidNullChainId) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidNullChainId {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidNullChainId {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidNullChainId()";
            const SELECTOR: [u8; 4] = [34u8, 247u8, 63u8, 234u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidNullPauser()` and selector `0x3555aed1`.
```solidity
error InvalidNullPauser();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidNullPauser {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidNullPauser> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidNullPauser) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidNullPauser {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidNullPauser {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidNullPauser()";
            const SELECTOR: [u8; 4] = [53u8, 85u8, 174u8, 209u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `KmsThresholdTooHigh(uint256,uint256)` and selector `0x48676fe0`.
```solidity
error KmsThresholdTooHigh(uint256 threshold, uint256 nParties);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KmsThresholdTooHigh {
        #[allow(missing_docs)]
        pub threshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nParties: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KmsThresholdTooHigh> for UnderlyingRustTuple<'_> {
            fn from(value: KmsThresholdTooHigh) -> Self {
                (value.threshold, value.nParties)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for KmsThresholdTooHigh {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    threshold: tuple.0,
                    nParties: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for KmsThresholdTooHigh {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "KmsThresholdTooHigh(uint256,uint256)";
            const SELECTOR: [u8; 4] = [72u8, 103u8, 111u8, 224u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.threshold),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nParties),
                )
            }
        }
    };
    /**Custom error with signature `NetworkAlreadyRegistered(uint256)` and selector `0xb1825c5e`.
```solidity
error NetworkAlreadyRegistered(uint256 chainId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NetworkAlreadyRegistered {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NetworkAlreadyRegistered>
        for UnderlyingRustTuple<'_> {
            fn from(value: NetworkAlreadyRegistered) -> Self {
                (value.chainId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for NetworkAlreadyRegistered {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { chainId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NetworkAlreadyRegistered {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NetworkAlreadyRegistered(uint256)";
            const SELECTOR: [u8; 4] = [177u8, 130u8, 92u8, 94u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                )
            }
        }
    };
    /**Custom error with signature `NetworkNotRegistered(uint256)` and selector `0x6df6fe89`.
```solidity
error NetworkNotRegistered(uint256 chainId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NetworkNotRegistered {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NetworkNotRegistered> for UnderlyingRustTuple<'_> {
            fn from(value: NetworkNotRegistered) -> Self {
                (value.chainId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NetworkNotRegistered {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { chainId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NetworkNotRegistered {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NetworkNotRegistered(uint256)";
            const SELECTOR: [u8; 4] = [109u8, 246u8, 254u8, 137u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                )
            }
        }
    };
    /**Custom error with signature `NotCoprocessorSigner(address)` and selector `0x26cd75dc`.
```solidity
error NotCoprocessorSigner(address signerAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotCoprocessorSigner {
        #[allow(missing_docs)]
        pub signerAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotCoprocessorSigner> for UnderlyingRustTuple<'_> {
            fn from(value: NotCoprocessorSigner) -> Self {
                (value.signerAddress,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotCoprocessorSigner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { signerAddress: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotCoprocessorSigner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotCoprocessorSigner(address)";
            const SELECTOR: [u8; 4] = [38u8, 205u8, 117u8, 220u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signerAddress,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `NotCoprocessorTxSender(address)` and selector `0x52d725f5`.
```solidity
error NotCoprocessorTxSender(address txSenderAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotCoprocessorTxSender {
        #[allow(missing_docs)]
        pub txSenderAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotCoprocessorTxSender> for UnderlyingRustTuple<'_> {
            fn from(value: NotCoprocessorTxSender) -> Self {
                (value.txSenderAddress,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotCoprocessorTxSender {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { txSenderAddress: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotCoprocessorTxSender {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotCoprocessorTxSender(address)";
            const SELECTOR: [u8; 4] = [82u8, 215u8, 37u8, 245u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.txSenderAddress,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `NotInitializing()` and selector `0xd7e6bcf8`.
```solidity
error NotInitializing();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotInitializing {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotInitializing> for UnderlyingRustTuple<'_> {
            fn from(value: NotInitializing) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotInitializing {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotInitializing {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotInitializing()";
            const SELECTOR: [u8; 4] = [215u8, 230u8, 188u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `NotKmsSigner(address)` and selector `0x2a7c6ef6`.
```solidity
error NotKmsSigner(address signerAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotKmsSigner {
        #[allow(missing_docs)]
        pub signerAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotKmsSigner> for UnderlyingRustTuple<'_> {
            fn from(value: NotKmsSigner) -> Self {
                (value.signerAddress,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotKmsSigner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { signerAddress: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotKmsSigner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotKmsSigner(address)";
            const SELECTOR: [u8; 4] = [42u8, 124u8, 110u8, 246u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signerAddress,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `NotKmsTxSender(address)` and selector `0xaee86323`.
```solidity
error NotKmsTxSender(address txSenderAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotKmsTxSender {
        #[allow(missing_docs)]
        pub txSenderAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotKmsTxSender> for UnderlyingRustTuple<'_> {
            fn from(value: NotKmsTxSender) -> Self {
                (value.txSenderAddress,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotKmsTxSender {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { txSenderAddress: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotKmsTxSender {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotKmsTxSender(address)";
            const SELECTOR: [u8; 4] = [174u8, 232u8, 99u8, 35u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.txSenderAddress,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `NotPauser(address)` and selector `0x206a346e`.
```solidity
error NotPauser(address pauserAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotPauser {
        #[allow(missing_docs)]
        pub pauserAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotPauser> for UnderlyingRustTuple<'_> {
            fn from(value: NotPauser) -> Self {
                (value.pauserAddress,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotPauser {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { pauserAddress: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotPauser {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotPauser(address)";
            const SELECTOR: [u8; 4] = [32u8, 106u8, 52u8, 110u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.pauserAddress,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `OwnableInvalidOwner(address)` and selector `0x1e4fbdf7`.
```solidity
error OwnableInvalidOwner(address owner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OwnableInvalidOwner {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OwnableInvalidOwner> for UnderlyingRustTuple<'_> {
            fn from(value: OwnableInvalidOwner) -> Self {
                (value.owner,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OwnableInvalidOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { owner: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OwnableInvalidOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OwnableInvalidOwner(address)";
            const SELECTOR: [u8; 4] = [30u8, 79u8, 189u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `OwnableUnauthorizedAccount(address)` and selector `0x118cdaa7`.
```solidity
error OwnableUnauthorizedAccount(address account);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OwnableUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OwnableUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: OwnableUnauthorizedAccount) -> Self {
                (value.account,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for OwnableUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { account: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OwnableUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OwnableUnauthorizedAccount(address)";
            const SELECTOR: [u8; 4] = [17u8, 140u8, 218u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `UUPSUnauthorizedCallContext()` and selector `0xe07c8dba`.
```solidity
error UUPSUnauthorizedCallContext();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnauthorizedCallContext {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnauthorizedCallContext>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnauthorizedCallContext) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnauthorizedCallContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnauthorizedCallContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnauthorizedCallContext()";
            const SELECTOR: [u8; 4] = [224u8, 124u8, 141u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `UUPSUnsupportedProxiableUUID(bytes32)` and selector `0xaa1d49a4`.
```solidity
error UUPSUnsupportedProxiableUUID(bytes32 slot);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnsupportedProxiableUUID {
        #[allow(missing_docs)]
        pub slot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnsupportedProxiableUUID>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnsupportedProxiableUUID) -> Self {
                (value.slot,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnsupportedProxiableUUID {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { slot: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnsupportedProxiableUUID {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnsupportedProxiableUUID(bytes32)";
            const SELECTOR: [u8; 4] = [170u8, 29u8, 73u8, 164u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
        }
    };
    /**Event with signature `AddNetwork((uint256,address,address,string,string))` and selector `0xb8207b5bb791730ae8f0534fa4c7be7da49dd75d701f9c7acf51c94b8ace96b2`.
```solidity
event AddNetwork(Network network);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct AddNetwork {
        #[allow(missing_docs)]
        pub network: <Network as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for AddNetwork {
            type DataTuple<'a> = (Network,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "AddNetwork((uint256,address,address,string,string))";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                184u8,
                32u8,
                123u8,
                91u8,
                183u8,
                145u8,
                115u8,
                10u8,
                232u8,
                240u8,
                83u8,
                79u8,
                164u8,
                199u8,
                190u8,
                125u8,
                164u8,
                157u8,
                215u8,
                93u8,
                112u8,
                31u8,
                156u8,
                122u8,
                207u8,
                81u8,
                201u8,
                75u8,
                138u8,
                206u8,
                150u8,
                178u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { network: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (<Network as alloy_sol_types::SolType>::tokenize(&self.network),)
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for AddNetwork {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&AddNetwork> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &AddNetwork) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Initialization(address,(string,string),uint256,(address,address,string)[],(address,address,string)[])` and selector `0xf33d908c4a8b532fe64df20b726f11405c11b9772d31b66f5eef6887a43c3fde`.
```solidity
event Initialization(address pauser, ProtocolMetadata metadata, uint256 kmsThreshold, KmsNode[] kmsNodes, Coprocessor[] coprocessors);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialization {
        #[allow(missing_docs)]
        pub pauser: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub metadata: <ProtocolMetadata as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub kmsThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub kmsNodes: alloy::sol_types::private::Vec<
            <KmsNode as alloy::sol_types::SolType>::RustType,
        >,
        #[allow(missing_docs)]
        pub coprocessors: alloy::sol_types::private::Vec<
            <Coprocessor as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialization {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                ProtocolMetadata,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<KmsNode>,
                alloy::sol_types::sol_data::Array<Coprocessor>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialization(address,(string,string),uint256,(address,address,string)[],(address,address,string)[])";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                243u8,
                61u8,
                144u8,
                140u8,
                74u8,
                139u8,
                83u8,
                47u8,
                230u8,
                77u8,
                242u8,
                11u8,
                114u8,
                111u8,
                17u8,
                64u8,
                92u8,
                17u8,
                185u8,
                119u8,
                45u8,
                49u8,
                182u8,
                111u8,
                94u8,
                239u8,
                104u8,
                135u8,
                164u8,
                60u8,
                63u8,
                222u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    pauser: data.0,
                    metadata: data.1,
                    kmsThreshold: data.2,
                    kmsNodes: data.3,
                    coprocessors: data.4,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.pauser,
                    ),
                    <ProtocolMetadata as alloy_sol_types::SolType>::tokenize(
                        &self.metadata,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.kmsThreshold),
                    <alloy::sol_types::sol_data::Array<
                        KmsNode,
                    > as alloy_sol_types::SolType>::tokenize(&self.kmsNodes),
                    <alloy::sol_types::sol_data::Array<
                        Coprocessor,
                    > as alloy_sol_types::SolType>::tokenize(&self.coprocessors),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialization {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialization> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialization) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Initialized(uint64)` and selector `0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2`.
```solidity
event Initialized(uint64 version);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                199u8,
                245u8,
                5u8,
                178u8,
                243u8,
                113u8,
                174u8,
                33u8,
                117u8,
                238u8,
                73u8,
                19u8,
                244u8,
                73u8,
                158u8,
                31u8,
                38u8,
                51u8,
                167u8,
                181u8,
                147u8,
                99u8,
                33u8,
                238u8,
                209u8,
                205u8,
                174u8,
                182u8,
                17u8,
                81u8,
                129u8,
                210u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.version),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OwnershipTransferStarted(address,address)` and selector `0x38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e22700`.
```solidity
event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferStarted {
        #[allow(missing_docs)]
        pub previousOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferStarted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferStarted(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                56u8,
                209u8,
                107u8,
                140u8,
                172u8,
                34u8,
                217u8,
                159u8,
                199u8,
                193u8,
                36u8,
                185u8,
                205u8,
                13u8,
                226u8,
                211u8,
                250u8,
                31u8,
                174u8,
                244u8,
                32u8,
                191u8,
                231u8,
                145u8,
                216u8,
                195u8,
                98u8,
                215u8,
                101u8,
                226u8,
                39u8,
                0u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferStarted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferStarted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &OwnershipTransferStarted,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
```solidity
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub previousOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8,
                224u8,
                7u8,
                156u8,
                83u8,
                22u8,
                89u8,
                20u8,
                19u8,
                68u8,
                205u8,
                31u8,
                208u8,
                164u8,
                242u8,
                132u8,
                25u8,
                73u8,
                127u8,
                151u8,
                34u8,
                163u8,
                218u8,
                175u8,
                227u8,
                180u8,
                24u8,
                111u8,
                107u8,
                100u8,
                87u8,
                224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `UpdateKmsThreshold(uint256)` and selector `0xea6c6521bc495731082e23ad12c7b1207d13ca0bd38d1d511081ab568917cb84`.
```solidity
event UpdateKmsThreshold(uint256 newKmsThreshold);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct UpdateKmsThreshold {
        #[allow(missing_docs)]
        pub newKmsThreshold: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for UpdateKmsThreshold {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "UpdateKmsThreshold(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                234u8,
                108u8,
                101u8,
                33u8,
                188u8,
                73u8,
                87u8,
                49u8,
                8u8,
                46u8,
                35u8,
                173u8,
                18u8,
                199u8,
                177u8,
                32u8,
                125u8,
                19u8,
                202u8,
                11u8,
                211u8,
                141u8,
                29u8,
                81u8,
                16u8,
                129u8,
                171u8,
                86u8,
                137u8,
                23u8,
                203u8,
                132u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { newKmsThreshold: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newKmsThreshold),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for UpdateKmsThreshold {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&UpdateKmsThreshold> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &UpdateKmsThreshold) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `UpdatePauser(address)` and selector `0xa690668c24d277243ff6fa650d3fd6e3d331a99ca0a8857c82e7f89452fc665d`.
```solidity
event UpdatePauser(address newPauser);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct UpdatePauser {
        #[allow(missing_docs)]
        pub newPauser: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for UpdatePauser {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "UpdatePauser(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                166u8,
                144u8,
                102u8,
                140u8,
                36u8,
                210u8,
                119u8,
                36u8,
                63u8,
                246u8,
                250u8,
                101u8,
                13u8,
                63u8,
                214u8,
                227u8,
                211u8,
                49u8,
                169u8,
                156u8,
                160u8,
                168u8,
                133u8,
                124u8,
                130u8,
                231u8,
                248u8,
                148u8,
                82u8,
                252u8,
                102u8,
                93u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { newPauser: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newPauser,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for UpdatePauser {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&UpdatePauser> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &UpdatePauser) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Upgraded(address)` and selector `0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b`.
```solidity
event Upgraded(address indexed implementation);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Upgraded {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Upgraded {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Upgraded(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                188u8,
                124u8,
                215u8,
                90u8,
                32u8,
                238u8,
                39u8,
                253u8,
                154u8,
                222u8,
                186u8,
                179u8,
                32u8,
                65u8,
                247u8,
                85u8,
                33u8,
                77u8,
                188u8,
                107u8,
                255u8,
                169u8,
                12u8,
                192u8,
                34u8,
                91u8,
                57u8,
                218u8,
                46u8,
                92u8,
                45u8,
                59u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { implementation: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.implementation.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.implementation,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Upgraded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Upgraded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Upgraded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {}
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Function with signature `UPGRADE_INTERFACE_VERSION()` and selector `0xad3cb1cc`.
```solidity
function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONCall {}
    ///Container type for the return parameters of the [`UPGRADE_INTERFACE_VERSION()`](UPGRADE_INTERFACE_VERSIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for UPGRADE_INTERFACE_VERSIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = UPGRADE_INTERFACE_VERSIONReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UPGRADE_INTERFACE_VERSION()";
            const SELECTOR: [u8; 4] = [173u8, 60u8, 177u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `acceptOwnership()` and selector `0x79ba5097`.
```solidity
function acceptOwnership() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct acceptOwnershipCall {}
    ///Container type for the return parameters of the [`acceptOwnership()`](acceptOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct acceptOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<acceptOwnershipCall> for UnderlyingRustTuple<'_> {
                fn from(value: acceptOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for acceptOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<acceptOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: acceptOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for acceptOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for acceptOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = acceptOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "acceptOwnership()";
            const SELECTOR: [u8; 4] = [121u8, 186u8, 80u8, 151u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `addNetwork((uint256,address,address,string,string))` and selector `0x70cc9a3c`.
```solidity
function addNetwork(Network memory network) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addNetworkCall {
        #[allow(missing_docs)]
        pub network: <Network as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`addNetwork((uint256,address,address,string,string))`](addNetworkCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addNetworkReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Network,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Network as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addNetworkCall> for UnderlyingRustTuple<'_> {
                fn from(value: addNetworkCall) -> Self {
                    (value.network,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addNetworkCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { network: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addNetworkReturn> for UnderlyingRustTuple<'_> {
                fn from(value: addNetworkReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addNetworkReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addNetworkCall {
            type Parameters<'a> = (Network,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addNetworkReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addNetwork((uint256,address,address,string,string))";
            const SELECTOR: [u8; 4] = [112u8, 204u8, 154u8, 60u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<Network as alloy_sol_types::SolType>::tokenize(&self.network),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `checkIsCoprocessorSigner(address)` and selector `0xcdb4c2b9`.
```solidity
function checkIsCoprocessorSigner(address signerAddress) external view;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsCoprocessorSignerCall {
        #[allow(missing_docs)]
        pub signerAddress: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkIsCoprocessorSigner(address)`](checkIsCoprocessorSignerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsCoprocessorSignerReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsCoprocessorSignerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsCoprocessorSignerCall) -> Self {
                    (value.signerAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsCoprocessorSignerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { signerAddress: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsCoprocessorSignerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsCoprocessorSignerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsCoprocessorSignerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkIsCoprocessorSignerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkIsCoprocessorSignerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkIsCoprocessorSigner(address)";
            const SELECTOR: [u8; 4] = [205u8, 180u8, 194u8, 185u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signerAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `checkIsCoprocessorTxSender(address)` and selector `0xcb661755`.
```solidity
function checkIsCoprocessorTxSender(address txSenderAddress) external view;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsCoprocessorTxSenderCall {
        #[allow(missing_docs)]
        pub txSenderAddress: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkIsCoprocessorTxSender(address)`](checkIsCoprocessorTxSenderCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsCoprocessorTxSenderReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsCoprocessorTxSenderCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsCoprocessorTxSenderCall) -> Self {
                    (value.txSenderAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsCoprocessorTxSenderCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { txSenderAddress: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsCoprocessorTxSenderReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsCoprocessorTxSenderReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsCoprocessorTxSenderReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkIsCoprocessorTxSenderCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkIsCoprocessorTxSenderReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkIsCoprocessorTxSender(address)";
            const SELECTOR: [u8; 4] = [203u8, 102u8, 23u8, 85u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.txSenderAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `checkIsKmsSigner(address)` and selector `0x6c88eb43`.
```solidity
function checkIsKmsSigner(address signerAddress) external view;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsKmsSignerCall {
        #[allow(missing_docs)]
        pub signerAddress: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkIsKmsSigner(address)`](checkIsKmsSignerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsKmsSignerReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsKmsSignerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsKmsSignerCall) -> Self {
                    (value.signerAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsKmsSignerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { signerAddress: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsKmsSignerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsKmsSignerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsKmsSignerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkIsKmsSignerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkIsKmsSignerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkIsKmsSigner(address)";
            const SELECTOR: [u8; 4] = [108u8, 136u8, 235u8, 67u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signerAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `checkIsKmsTxSender(address)` and selector `0xc6275258`.
```solidity
function checkIsKmsTxSender(address txSenderAddress) external view;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsKmsTxSenderCall {
        #[allow(missing_docs)]
        pub txSenderAddress: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkIsKmsTxSender(address)`](checkIsKmsTxSenderCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsKmsTxSenderReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsKmsTxSenderCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsKmsTxSenderCall) -> Self {
                    (value.txSenderAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsKmsTxSenderCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { txSenderAddress: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsKmsTxSenderReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsKmsTxSenderReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsKmsTxSenderReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkIsKmsTxSenderCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkIsKmsTxSenderReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkIsKmsTxSender(address)";
            const SELECTOR: [u8; 4] = [198u8, 39u8, 82u8, 88u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.txSenderAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `checkIsPauser(address)` and selector `0x195afde6`.
```solidity
function checkIsPauser(address pauserAddress) external view;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsPauserCall {
        #[allow(missing_docs)]
        pub pauserAddress: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkIsPauser(address)`](checkIsPauserCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsPauserReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsPauserCall> for UnderlyingRustTuple<'_> {
                fn from(value: checkIsPauserCall) -> Self {
                    (value.pauserAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for checkIsPauserCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { pauserAddress: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsPauserReturn> for UnderlyingRustTuple<'_> {
                fn from(value: checkIsPauserReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for checkIsPauserReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkIsPauserCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkIsPauserReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkIsPauser(address)";
            const SELECTOR: [u8; 4] = [25u8, 90u8, 253u8, 230u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.pauserAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `checkNetworkIsRegistered(uint256)` and selector `0xc6b3024d`.
```solidity
function checkNetworkIsRegistered(uint256 chainId) external view;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkNetworkIsRegisteredCall {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`checkNetworkIsRegistered(uint256)`](checkNetworkIsRegisteredCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkNetworkIsRegisteredReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkNetworkIsRegisteredCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkNetworkIsRegisteredCall) -> Self {
                    (value.chainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkNetworkIsRegisteredCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { chainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkNetworkIsRegisteredReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkNetworkIsRegisteredReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkNetworkIsRegisteredReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkNetworkIsRegisteredCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkNetworkIsRegisteredReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkNetworkIsRegistered(uint256)";
            const SELECTOR: [u8; 4] = [198u8, 179u8, 2u8, 77u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `coprocessorTxSenderAddresses(uint256)` and selector `0x5ab6d3ab`.
```solidity
function coprocessorTxSenderAddresses(uint256 index) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct coprocessorTxSenderAddressesCall {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`coprocessorTxSenderAddresses(uint256)`](coprocessorTxSenderAddressesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct coprocessorTxSenderAddressesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<coprocessorTxSenderAddressesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: coprocessorTxSenderAddressesCall) -> Self {
                    (value.index,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for coprocessorTxSenderAddressesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { index: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<coprocessorTxSenderAddressesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: coprocessorTxSenderAddressesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for coprocessorTxSenderAddressesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for coprocessorTxSenderAddressesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = coprocessorTxSenderAddressesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "coprocessorTxSenderAddresses(uint256)";
            const SELECTOR: [u8; 4] = [90u8, 182u8, 211u8, 171u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `coprocessors(address)` and selector `0xecbd96ab`.
```solidity
function coprocessors(address coprocessorTxSenderAddress) external view returns (Coprocessor memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct coprocessorsCall {
        #[allow(missing_docs)]
        pub coprocessorTxSenderAddress: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`coprocessors(address)`](coprocessorsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct coprocessorsReturn {
        #[allow(missing_docs)]
        pub _0: <Coprocessor as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<coprocessorsCall> for UnderlyingRustTuple<'_> {
                fn from(value: coprocessorsCall) -> Self {
                    (value.coprocessorTxSenderAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for coprocessorsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        coprocessorTxSenderAddress: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Coprocessor,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Coprocessor as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<coprocessorsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: coprocessorsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for coprocessorsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for coprocessorsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = coprocessorsReturn;
            type ReturnTuple<'a> = (Coprocessor,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "coprocessors(address)";
            const SELECTOR: [u8; 4] = [236u8, 189u8, 150u8, 171u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.coprocessorTxSenderAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getAllCoprocessorTxSenderAddresses()` and selector `0x8f4a7f5e`.
```solidity
function getAllCoprocessorTxSenderAddresses() external view returns (address[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAllCoprocessorTxSenderAddressesCall {}
    ///Container type for the return parameters of the [`getAllCoprocessorTxSenderAddresses()`](getAllCoprocessorTxSenderAddressesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAllCoprocessorTxSenderAddressesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAllCoprocessorTxSenderAddressesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAllCoprocessorTxSenderAddressesCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAllCoprocessorTxSenderAddressesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAllCoprocessorTxSenderAddressesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAllCoprocessorTxSenderAddressesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAllCoprocessorTxSenderAddressesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAllCoprocessorTxSenderAddressesCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getAllCoprocessorTxSenderAddressesReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAllCoprocessorTxSenderAddresses()";
            const SELECTOR: [u8; 4] = [143u8, 74u8, 127u8, 94u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getAllKmsTxSenderAddresses()` and selector `0xbda0b948`.
```solidity
function getAllKmsTxSenderAddresses() external view returns (address[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAllKmsTxSenderAddressesCall {}
    ///Container type for the return parameters of the [`getAllKmsTxSenderAddresses()`](getAllKmsTxSenderAddressesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAllKmsTxSenderAddressesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAllKmsTxSenderAddressesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAllKmsTxSenderAddressesCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAllKmsTxSenderAddressesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAllKmsTxSenderAddressesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAllKmsTxSenderAddressesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAllKmsTxSenderAddressesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAllKmsTxSenderAddressesCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getAllKmsTxSenderAddressesReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAllKmsTxSenderAddresses()";
            const SELECTOR: [u8; 4] = [189u8, 160u8, 185u8, 72u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getCoprocessorMajorityThreshold()` and selector `0x6799ef52`.
```solidity
function getCoprocessorMajorityThreshold() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCoprocessorMajorityThresholdCall {}
    ///Container type for the return parameters of the [`getCoprocessorMajorityThreshold()`](getCoprocessorMajorityThresholdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCoprocessorMajorityThresholdReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCoprocessorMajorityThresholdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCoprocessorMajorityThresholdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCoprocessorMajorityThresholdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCoprocessorMajorityThresholdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCoprocessorMajorityThresholdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCoprocessorMajorityThresholdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCoprocessorMajorityThresholdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCoprocessorMajorityThresholdReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCoprocessorMajorityThreshold()";
            const SELECTOR: [u8; 4] = [103u8, 153u8, 239u8, 82u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getKmsMajorityThreshold()` and selector `0x47cd4b3e`.
```solidity
function getKmsMajorityThreshold() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsMajorityThresholdCall {}
    ///Container type for the return parameters of the [`getKmsMajorityThreshold()`](getKmsMajorityThresholdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsMajorityThresholdReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsMajorityThresholdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsMajorityThresholdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsMajorityThresholdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsMajorityThresholdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsMajorityThresholdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsMajorityThresholdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsMajorityThresholdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsMajorityThresholdReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsMajorityThreshold()";
            const SELECTOR: [u8; 4] = [71u8, 205u8, 75u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getKmsReconstructionThreshold()` and selector `0x490413aa`.
```solidity
function getKmsReconstructionThreshold() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsReconstructionThresholdCall {}
    ///Container type for the return parameters of the [`getKmsReconstructionThreshold()`](getKmsReconstructionThresholdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsReconstructionThresholdReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsReconstructionThresholdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsReconstructionThresholdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsReconstructionThresholdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsReconstructionThresholdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsReconstructionThresholdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsReconstructionThresholdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsReconstructionThresholdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsReconstructionThresholdReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsReconstructionThreshold()";
            const SELECTOR: [u8; 4] = [73u8, 4u8, 19u8, 170u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getKmsThreshold()` and selector `0x4921a3bd`.
```solidity
function getKmsThreshold() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsThresholdCall {}
    ///Container type for the return parameters of the [`getKmsThreshold()`](getKmsThresholdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsThresholdReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsThresholdCall> for UnderlyingRustTuple<'_> {
                fn from(value: getKmsThresholdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getKmsThresholdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsThresholdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsThresholdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsThresholdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsThresholdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsThresholdReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsThreshold()";
            const SELECTOR: [u8; 4] = [73u8, 33u8, 163u8, 189u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getProtocolMetadata()` and selector `0x48144c61`.
```solidity
function getProtocolMetadata() external view returns (ProtocolMetadata memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getProtocolMetadataCall {}
    ///Container type for the return parameters of the [`getProtocolMetadata()`](getProtocolMetadataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getProtocolMetadataReturn {
        #[allow(missing_docs)]
        pub _0: <ProtocolMetadata as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getProtocolMetadataCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getProtocolMetadataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getProtocolMetadataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ProtocolMetadata,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ProtocolMetadata as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getProtocolMetadataReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getProtocolMetadataReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getProtocolMetadataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getProtocolMetadataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getProtocolMetadataReturn;
            type ReturnTuple<'a> = (ProtocolMetadata,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getProtocolMetadata()";
            const SELECTOR: [u8; 4] = [72u8, 20u8, 76u8, 97u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getVersion()` and selector `0x0d8e6e2c`.
```solidity
function getVersion() external pure returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVersionCall {}
    ///Container type for the return parameters of the [`getVersion()`](getVersionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVersionReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVersionCall> for UnderlyingRustTuple<'_> {
                fn from(value: getVersionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVersionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVersionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getVersionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVersionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getVersionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getVersionReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getVersion()";
            const SELECTOR: [u8; 4] = [13u8, 142u8, 110u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `initialize(address,(string,string),uint256,(address,address,string)[],(address,address,string)[])` and selector `0xd98189a4`.
```solidity
function initialize(address initialPauser, ProtocolMetadata memory initialMetadata, uint256 initialKmsThreshold, KmsNode[] memory initialKmsNodes, Coprocessor[] memory initialCoprocessors) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeCall {
        #[allow(missing_docs)]
        pub initialPauser: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub initialMetadata: <ProtocolMetadata as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub initialKmsThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub initialKmsNodes: alloy::sol_types::private::Vec<
            <KmsNode as alloy::sol_types::SolType>::RustType,
        >,
        #[allow(missing_docs)]
        pub initialCoprocessors: alloy::sol_types::private::Vec<
            <Coprocessor as alloy::sol_types::SolType>::RustType,
        >,
    }
    ///Container type for the return parameters of the [`initialize(address,(string,string),uint256,(address,address,string)[],(address,address,string)[])`](initializeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                ProtocolMetadata,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<KmsNode>,
                alloy::sol_types::sol_data::Array<Coprocessor>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                <ProtocolMetadata as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Vec<
                    <KmsNode as alloy::sol_types::SolType>::RustType,
                >,
                alloy::sol_types::private::Vec<
                    <Coprocessor as alloy::sol_types::SolType>::RustType,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeCall> for UnderlyingRustTuple<'_> {
                fn from(value: initializeCall) -> Self {
                    (
                        value.initialPauser,
                        value.initialMetadata,
                        value.initialKmsThreshold,
                        value.initialKmsNodes,
                        value.initialCoprocessors,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        initialPauser: tuple.0,
                        initialMetadata: tuple.1,
                        initialKmsThreshold: tuple.2,
                        initialKmsNodes: tuple.3,
                        initialCoprocessors: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: initializeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                ProtocolMetadata,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<KmsNode>,
                alloy::sol_types::sol_data::Array<Coprocessor>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initialize(address,(string,string),uint256,(address,address,string)[],(address,address,string)[])";
            const SELECTOR: [u8; 4] = [217u8, 129u8, 137u8, 164u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.initialPauser,
                    ),
                    <ProtocolMetadata as alloy_sol_types::SolType>::tokenize(
                        &self.initialMetadata,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.initialKmsThreshold),
                    <alloy::sol_types::sol_data::Array<
                        KmsNode,
                    > as alloy_sol_types::SolType>::tokenize(&self.initialKmsNodes),
                    <alloy::sol_types::sol_data::Array<
                        Coprocessor,
                    > as alloy_sol_types::SolType>::tokenize(&self.initialCoprocessors),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `kmsNodes(address)` and selector `0x54d3f675`.
```solidity
function kmsNodes(address kmsTxSenderAddress) external view returns (KmsNode memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct kmsNodesCall {
        #[allow(missing_docs)]
        pub kmsTxSenderAddress: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`kmsNodes(address)`](kmsNodesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct kmsNodesReturn {
        #[allow(missing_docs)]
        pub _0: <KmsNode as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<kmsNodesCall> for UnderlyingRustTuple<'_> {
                fn from(value: kmsNodesCall) -> Self {
                    (value.kmsTxSenderAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for kmsNodesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        kmsTxSenderAddress: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (KmsNode,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <KmsNode as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<kmsNodesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: kmsNodesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for kmsNodesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for kmsNodesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = kmsNodesReturn;
            type ReturnTuple<'a> = (KmsNode,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "kmsNodes(address)";
            const SELECTOR: [u8; 4] = [84u8, 211u8, 246u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.kmsTxSenderAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `kmsTxSenderAddresses(uint256)` and selector `0xd5244bf1`.
```solidity
function kmsTxSenderAddresses(uint256 index) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct kmsTxSenderAddressesCall {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`kmsTxSenderAddresses(uint256)`](kmsTxSenderAddressesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct kmsTxSenderAddressesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<kmsTxSenderAddressesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: kmsTxSenderAddressesCall) -> Self {
                    (value.index,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for kmsTxSenderAddressesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { index: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<kmsTxSenderAddressesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: kmsTxSenderAddressesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for kmsTxSenderAddressesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for kmsTxSenderAddressesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = kmsTxSenderAddressesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "kmsTxSenderAddresses(uint256)";
            const SELECTOR: [u8; 4] = [213u8, 36u8, 75u8, 241u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `networks(uint256)` and selector `0x8bb0a17c`.
```solidity
function networks(uint256 index) external view returns (Network memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct networksCall {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`networks(uint256)`](networksCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct networksReturn {
        #[allow(missing_docs)]
        pub _0: <Network as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<networksCall> for UnderlyingRustTuple<'_> {
                fn from(value: networksCall) -> Self {
                    (value.index,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for networksCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { index: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Network,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Network as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<networksReturn> for UnderlyingRustTuple<'_> {
                fn from(value: networksReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for networksReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for networksCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = networksReturn;
            type ReturnTuple<'a> = (Network,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "networks(uint256)";
            const SELECTOR: [u8; 4] = [139u8, 176u8, 161u8, 124u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall {}
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ownerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pendingOwner()` and selector `0xe30c3978`.
```solidity
function pendingOwner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingOwnerCall {}
    ///Container type for the return parameters of the [`pendingOwner()`](pendingOwnerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingOwnerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingOwnerCall> for UnderlyingRustTuple<'_> {
                fn from(value: pendingOwnerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pendingOwnerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingOwnerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pendingOwnerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pendingOwnerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pendingOwnerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pendingOwnerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pendingOwner()";
            const SELECTOR: [u8; 4] = [227u8, 12u8, 57u8, 120u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `proxiableUUID()` and selector `0x52d1902d`.
```solidity
function proxiableUUID() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDCall {}
    ///Container type for the return parameters of the [`proxiableUUID()`](proxiableUUIDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDCall> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proxiableUUIDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = proxiableUUIDReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "proxiableUUID()";
            const SELECTOR: [u8; 4] = [82u8, 209u8, 144u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceOwnership()` and selector `0x715018a6`.
```solidity
function renounceOwnership() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall {}
    ///Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address newOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `updateKmsThreshold(uint256)` and selector `0x0219150f`.
```solidity
function updateKmsThreshold(uint256 newKmsThreshold) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateKmsThresholdCall {
        #[allow(missing_docs)]
        pub newKmsThreshold: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`updateKmsThreshold(uint256)`](updateKmsThresholdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateKmsThresholdReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateKmsThresholdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateKmsThresholdCall) -> Self {
                    (value.newKmsThreshold,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateKmsThresholdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newKmsThreshold: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateKmsThresholdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateKmsThresholdReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateKmsThresholdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateKmsThresholdCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateKmsThresholdReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateKmsThreshold(uint256)";
            const SELECTOR: [u8; 4] = [2u8, 25u8, 21u8, 15u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newKmsThreshold),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `updatePauser(address)` and selector `0x554bab3c`.
```solidity
function updatePauser(address newPauser) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updatePauserCall {
        #[allow(missing_docs)]
        pub newPauser: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`updatePauser(address)`](updatePauserCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updatePauserReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updatePauserCall> for UnderlyingRustTuple<'_> {
                fn from(value: updatePauserCall) -> Self {
                    (value.newPauser,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updatePauserCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newPauser: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updatePauserReturn> for UnderlyingRustTuple<'_> {
                fn from(value: updatePauserReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updatePauserReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updatePauserCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updatePauserReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updatePauser(address)";
            const SELECTOR: [u8; 4] = [85u8, 75u8, 171u8, 60u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newPauser,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `upgradeToAndCall(address,bytes)` and selector `0x4f1ef286`.
```solidity
function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallCall {
        #[allow(missing_docs)]
        pub newImplementation: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`upgradeToAndCall(address,bytes)`](upgradeToAndCallCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallCall) -> Self {
                    (value.newImplementation, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newImplementation: tuple.0,
                        data: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for upgradeToAndCallCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = upgradeToAndCallReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "upgradeToAndCall(address,bytes)";
            const SELECTOR: [u8; 4] = [79u8, 30u8, 242u8, 134u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newImplementation,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`HTTPZ`](self) function calls.
    pub enum HTTPZCalls {
        #[allow(missing_docs)]
        UPGRADE_INTERFACE_VERSION(UPGRADE_INTERFACE_VERSIONCall),
        #[allow(missing_docs)]
        acceptOwnership(acceptOwnershipCall),
        #[allow(missing_docs)]
        addNetwork(addNetworkCall),
        #[allow(missing_docs)]
        checkIsCoprocessorSigner(checkIsCoprocessorSignerCall),
        #[allow(missing_docs)]
        checkIsCoprocessorTxSender(checkIsCoprocessorTxSenderCall),
        #[allow(missing_docs)]
        checkIsKmsSigner(checkIsKmsSignerCall),
        #[allow(missing_docs)]
        checkIsKmsTxSender(checkIsKmsTxSenderCall),
        #[allow(missing_docs)]
        checkIsPauser(checkIsPauserCall),
        #[allow(missing_docs)]
        checkNetworkIsRegistered(checkNetworkIsRegisteredCall),
        #[allow(missing_docs)]
        coprocessorTxSenderAddresses(coprocessorTxSenderAddressesCall),
        #[allow(missing_docs)]
        coprocessors(coprocessorsCall),
        #[allow(missing_docs)]
        getAllCoprocessorTxSenderAddresses(getAllCoprocessorTxSenderAddressesCall),
        #[allow(missing_docs)]
        getAllKmsTxSenderAddresses(getAllKmsTxSenderAddressesCall),
        #[allow(missing_docs)]
        getCoprocessorMajorityThreshold(getCoprocessorMajorityThresholdCall),
        #[allow(missing_docs)]
        getKmsMajorityThreshold(getKmsMajorityThresholdCall),
        #[allow(missing_docs)]
        getKmsReconstructionThreshold(getKmsReconstructionThresholdCall),
        #[allow(missing_docs)]
        getKmsThreshold(getKmsThresholdCall),
        #[allow(missing_docs)]
        getProtocolMetadata(getProtocolMetadataCall),
        #[allow(missing_docs)]
        getVersion(getVersionCall),
        #[allow(missing_docs)]
        initialize(initializeCall),
        #[allow(missing_docs)]
        kmsNodes(kmsNodesCall),
        #[allow(missing_docs)]
        kmsTxSenderAddresses(kmsTxSenderAddressesCall),
        #[allow(missing_docs)]
        networks(networksCall),
        #[allow(missing_docs)]
        owner(ownerCall),
        #[allow(missing_docs)]
        pendingOwner(pendingOwnerCall),
        #[allow(missing_docs)]
        proxiableUUID(proxiableUUIDCall),
        #[allow(missing_docs)]
        renounceOwnership(renounceOwnershipCall),
        #[allow(missing_docs)]
        transferOwnership(transferOwnershipCall),
        #[allow(missing_docs)]
        updateKmsThreshold(updateKmsThresholdCall),
        #[allow(missing_docs)]
        updatePauser(updatePauserCall),
        #[allow(missing_docs)]
        upgradeToAndCall(upgradeToAndCallCall),
    }
    #[automatically_derived]
    impl HTTPZCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [2u8, 25u8, 21u8, 15u8],
            [13u8, 142u8, 110u8, 44u8],
            [25u8, 90u8, 253u8, 230u8],
            [71u8, 205u8, 75u8, 62u8],
            [72u8, 20u8, 76u8, 97u8],
            [73u8, 4u8, 19u8, 170u8],
            [73u8, 33u8, 163u8, 189u8],
            [79u8, 30u8, 242u8, 134u8],
            [82u8, 209u8, 144u8, 45u8],
            [84u8, 211u8, 246u8, 117u8],
            [85u8, 75u8, 171u8, 60u8],
            [90u8, 182u8, 211u8, 171u8],
            [103u8, 153u8, 239u8, 82u8],
            [108u8, 136u8, 235u8, 67u8],
            [112u8, 204u8, 154u8, 60u8],
            [113u8, 80u8, 24u8, 166u8],
            [121u8, 186u8, 80u8, 151u8],
            [139u8, 176u8, 161u8, 124u8],
            [141u8, 165u8, 203u8, 91u8],
            [143u8, 74u8, 127u8, 94u8],
            [173u8, 60u8, 177u8, 204u8],
            [189u8, 160u8, 185u8, 72u8],
            [198u8, 39u8, 82u8, 88u8],
            [198u8, 179u8, 2u8, 77u8],
            [203u8, 102u8, 23u8, 85u8],
            [205u8, 180u8, 194u8, 185u8],
            [213u8, 36u8, 75u8, 241u8],
            [217u8, 129u8, 137u8, 164u8],
            [227u8, 12u8, 57u8, 120u8],
            [236u8, 189u8, 150u8, 171u8],
            [242u8, 253u8, 227u8, 139u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for HTTPZCalls {
        const NAME: &'static str = "HTTPZCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 31usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(_) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::acceptOwnership(_) => {
                    <acceptOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::addNetwork(_) => {
                    <addNetworkCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkIsCoprocessorSigner(_) => {
                    <checkIsCoprocessorSignerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkIsCoprocessorTxSender(_) => {
                    <checkIsCoprocessorTxSenderCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkIsKmsSigner(_) => {
                    <checkIsKmsSignerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkIsKmsTxSender(_) => {
                    <checkIsKmsTxSenderCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkIsPauser(_) => {
                    <checkIsPauserCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkNetworkIsRegistered(_) => {
                    <checkNetworkIsRegisteredCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::coprocessorTxSenderAddresses(_) => {
                    <coprocessorTxSenderAddressesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::coprocessors(_) => {
                    <coprocessorsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAllCoprocessorTxSenderAddresses(_) => {
                    <getAllCoprocessorTxSenderAddressesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAllKmsTxSenderAddresses(_) => {
                    <getAllKmsTxSenderAddressesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCoprocessorMajorityThreshold(_) => {
                    <getCoprocessorMajorityThresholdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsMajorityThreshold(_) => {
                    <getKmsMajorityThresholdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsReconstructionThreshold(_) => {
                    <getKmsReconstructionThresholdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsThreshold(_) => {
                    <getKmsThresholdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getProtocolMetadata(_) => {
                    <getProtocolMetadataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getVersion(_) => {
                    <getVersionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initialize(_) => {
                    <initializeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::kmsNodes(_) => <kmsNodesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::kmsTxSenderAddresses(_) => {
                    <kmsTxSenderAddressesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::networks(_) => <networksCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pendingOwner(_) => {
                    <pendingOwnerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::proxiableUUID(_) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceOwnership(_) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateKmsThreshold(_) => {
                    <updateKmsThresholdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updatePauser(_) => {
                    <updatePauserCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::upgradeToAndCall(_) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<HTTPZCalls>] = &[
                {
                    fn updateKmsThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <updateKmsThresholdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::updateKmsThreshold)
                    }
                    updateKmsThreshold
                },
                {
                    fn getVersion(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <getVersionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::getVersion)
                    }
                    getVersion
                },
                {
                    fn checkIsPauser(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <checkIsPauserCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::checkIsPauser)
                    }
                    checkIsPauser
                },
                {
                    fn getKmsMajorityThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <getKmsMajorityThresholdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::getKmsMajorityThreshold)
                    }
                    getKmsMajorityThreshold
                },
                {
                    fn getProtocolMetadata(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <getProtocolMetadataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::getProtocolMetadata)
                    }
                    getProtocolMetadata
                },
                {
                    fn getKmsReconstructionThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <getKmsReconstructionThresholdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::getKmsReconstructionThreshold)
                    }
                    getKmsReconstructionThreshold
                },
                {
                    fn getKmsThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <getKmsThresholdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::getKmsThreshold)
                    }
                    getKmsThreshold
                },
                {
                    fn upgradeToAndCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::upgradeToAndCall)
                    }
                    upgradeToAndCall
                },
                {
                    fn proxiableUUID(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::proxiableUUID)
                    }
                    proxiableUUID
                },
                {
                    fn kmsNodes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <kmsNodesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::kmsNodes)
                    }
                    kmsNodes
                },
                {
                    fn updatePauser(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <updatePauserCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::updatePauser)
                    }
                    updatePauser
                },
                {
                    fn coprocessorTxSenderAddresses(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <coprocessorTxSenderAddressesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::coprocessorTxSenderAddresses)
                    }
                    coprocessorTxSenderAddresses
                },
                {
                    fn getCoprocessorMajorityThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <getCoprocessorMajorityThresholdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::getCoprocessorMajorityThreshold)
                    }
                    getCoprocessorMajorityThreshold
                },
                {
                    fn checkIsKmsSigner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <checkIsKmsSignerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::checkIsKmsSigner)
                    }
                    checkIsKmsSigner
                },
                {
                    fn addNetwork(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <addNetworkCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::addNetwork)
                    }
                    addNetwork
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn acceptOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <acceptOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::acceptOwnership)
                    }
                    acceptOwnership
                },
                {
                    fn networks(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <networksCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::networks)
                    }
                    networks
                },
                {
                    fn owner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::owner)
                    }
                    owner
                },
                {
                    fn getAllCoprocessorTxSenderAddresses(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <getAllCoprocessorTxSenderAddressesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::getAllCoprocessorTxSenderAddresses)
                    }
                    getAllCoprocessorTxSenderAddresses
                },
                {
                    fn UPGRADE_INTERFACE_VERSION(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::UPGRADE_INTERFACE_VERSION)
                    }
                    UPGRADE_INTERFACE_VERSION
                },
                {
                    fn getAllKmsTxSenderAddresses(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <getAllKmsTxSenderAddressesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::getAllKmsTxSenderAddresses)
                    }
                    getAllKmsTxSenderAddresses
                },
                {
                    fn checkIsKmsTxSender(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <checkIsKmsTxSenderCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::checkIsKmsTxSender)
                    }
                    checkIsKmsTxSender
                },
                {
                    fn checkNetworkIsRegistered(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <checkNetworkIsRegisteredCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::checkNetworkIsRegistered)
                    }
                    checkNetworkIsRegistered
                },
                {
                    fn checkIsCoprocessorTxSender(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <checkIsCoprocessorTxSenderCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::checkIsCoprocessorTxSender)
                    }
                    checkIsCoprocessorTxSender
                },
                {
                    fn checkIsCoprocessorSigner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <checkIsCoprocessorSignerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::checkIsCoprocessorSigner)
                    }
                    checkIsCoprocessorSigner
                },
                {
                    fn kmsTxSenderAddresses(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <kmsTxSenderAddressesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::kmsTxSenderAddresses)
                    }
                    kmsTxSenderAddresses
                },
                {
                    fn initialize(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::initialize)
                    }
                    initialize
                },
                {
                    fn pendingOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <pendingOwnerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::pendingOwner)
                    }
                    pendingOwner
                },
                {
                    fn coprocessors(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <coprocessorsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::coprocessors)
                    }
                    coprocessors
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::transferOwnership)
                    }
                    transferOwnership
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::acceptOwnership(inner) => {
                    <acceptOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::addNetwork(inner) => {
                    <addNetworkCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::checkIsCoprocessorSigner(inner) => {
                    <checkIsCoprocessorSignerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkIsCoprocessorTxSender(inner) => {
                    <checkIsCoprocessorTxSenderCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkIsKmsSigner(inner) => {
                    <checkIsKmsSignerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkIsKmsTxSender(inner) => {
                    <checkIsKmsTxSenderCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkIsPauser(inner) => {
                    <checkIsPauserCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkNetworkIsRegistered(inner) => {
                    <checkNetworkIsRegisteredCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::coprocessorTxSenderAddresses(inner) => {
                    <coprocessorTxSenderAddressesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::coprocessors(inner) => {
                    <coprocessorsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAllCoprocessorTxSenderAddresses(inner) => {
                    <getAllCoprocessorTxSenderAddressesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAllKmsTxSenderAddresses(inner) => {
                    <getAllKmsTxSenderAddressesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCoprocessorMajorityThreshold(inner) => {
                    <getCoprocessorMajorityThresholdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKmsMajorityThreshold(inner) => {
                    <getKmsMajorityThresholdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKmsReconstructionThreshold(inner) => {
                    <getKmsReconstructionThresholdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKmsThreshold(inner) => {
                    <getKmsThresholdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getProtocolMetadata(inner) => {
                    <getProtocolMetadataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getVersion(inner) => {
                    <getVersionCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::kmsNodes(inner) => {
                    <kmsNodesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::kmsTxSenderAddresses(inner) => {
                    <kmsTxSenderAddressesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::networks(inner) => {
                    <networksCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pendingOwner(inner) => {
                    <pendingOwnerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateKmsThreshold(inner) => {
                    <updateKmsThresholdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updatePauser(inner) => {
                    <updatePauserCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::acceptOwnership(inner) => {
                    <acceptOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::addNetwork(inner) => {
                    <addNetworkCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkIsCoprocessorSigner(inner) => {
                    <checkIsCoprocessorSignerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkIsCoprocessorTxSender(inner) => {
                    <checkIsCoprocessorTxSenderCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkIsKmsSigner(inner) => {
                    <checkIsKmsSignerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkIsKmsTxSender(inner) => {
                    <checkIsKmsTxSenderCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkIsPauser(inner) => {
                    <checkIsPauserCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkNetworkIsRegistered(inner) => {
                    <checkNetworkIsRegisteredCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::coprocessorTxSenderAddresses(inner) => {
                    <coprocessorTxSenderAddressesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::coprocessors(inner) => {
                    <coprocessorsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAllCoprocessorTxSenderAddresses(inner) => {
                    <getAllCoprocessorTxSenderAddressesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAllKmsTxSenderAddresses(inner) => {
                    <getAllKmsTxSenderAddressesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCoprocessorMajorityThreshold(inner) => {
                    <getCoprocessorMajorityThresholdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsMajorityThreshold(inner) => {
                    <getKmsMajorityThresholdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsReconstructionThreshold(inner) => {
                    <getKmsReconstructionThresholdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsThreshold(inner) => {
                    <getKmsThresholdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getProtocolMetadata(inner) => {
                    <getProtocolMetadataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getVersion(inner) => {
                    <getVersionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::kmsNodes(inner) => {
                    <kmsNodesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::kmsTxSenderAddresses(inner) => {
                    <kmsTxSenderAddressesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::networks(inner) => {
                    <networksCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pendingOwner(inner) => {
                    <pendingOwnerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateKmsThreshold(inner) => {
                    <updateKmsThresholdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updatePauser(inner) => {
                    <updatePauserCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`HTTPZ`](self) custom errors.
    pub enum HTTPZErrors {
        #[allow(missing_docs)]
        AddressEmptyCode(AddressEmptyCode),
        #[allow(missing_docs)]
        ERC1967InvalidImplementation(ERC1967InvalidImplementation),
        #[allow(missing_docs)]
        ERC1967NonPayable(ERC1967NonPayable),
        #[allow(missing_docs)]
        FailedCall(FailedCall),
        #[allow(missing_docs)]
        InvalidInitialization(InvalidInitialization),
        #[allow(missing_docs)]
        InvalidNullChainId(InvalidNullChainId),
        #[allow(missing_docs)]
        InvalidNullPauser(InvalidNullPauser),
        #[allow(missing_docs)]
        KmsThresholdTooHigh(KmsThresholdTooHigh),
        #[allow(missing_docs)]
        NetworkAlreadyRegistered(NetworkAlreadyRegistered),
        #[allow(missing_docs)]
        NetworkNotRegistered(NetworkNotRegistered),
        #[allow(missing_docs)]
        NotCoprocessorSigner(NotCoprocessorSigner),
        #[allow(missing_docs)]
        NotCoprocessorTxSender(NotCoprocessorTxSender),
        #[allow(missing_docs)]
        NotInitializing(NotInitializing),
        #[allow(missing_docs)]
        NotKmsSigner(NotKmsSigner),
        #[allow(missing_docs)]
        NotKmsTxSender(NotKmsTxSender),
        #[allow(missing_docs)]
        NotPauser(NotPauser),
        #[allow(missing_docs)]
        OwnableInvalidOwner(OwnableInvalidOwner),
        #[allow(missing_docs)]
        OwnableUnauthorizedAccount(OwnableUnauthorizedAccount),
        #[allow(missing_docs)]
        UUPSUnauthorizedCallContext(UUPSUnauthorizedCallContext),
        #[allow(missing_docs)]
        UUPSUnsupportedProxiableUUID(UUPSUnsupportedProxiableUUID),
    }
    #[automatically_derived]
    impl HTTPZErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [17u8, 140u8, 218u8, 167u8],
            [30u8, 79u8, 189u8, 247u8],
            [32u8, 106u8, 52u8, 110u8],
            [34u8, 247u8, 63u8, 234u8],
            [38u8, 205u8, 117u8, 220u8],
            [42u8, 124u8, 110u8, 246u8],
            [53u8, 85u8, 174u8, 209u8],
            [72u8, 103u8, 111u8, 224u8],
            [76u8, 156u8, 140u8, 227u8],
            [82u8, 215u8, 37u8, 245u8],
            [109u8, 246u8, 254u8, 137u8],
            [153u8, 150u8, 179u8, 21u8],
            [170u8, 29u8, 73u8, 164u8],
            [174u8, 232u8, 99u8, 35u8],
            [177u8, 130u8, 92u8, 94u8],
            [179u8, 152u8, 151u8, 159u8],
            [214u8, 189u8, 162u8, 117u8],
            [215u8, 230u8, 188u8, 248u8],
            [224u8, 124u8, 141u8, 186u8],
            [249u8, 46u8, 232u8, 169u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for HTTPZErrors {
        const NAME: &'static str = "HTTPZErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 20usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AddressEmptyCode(_) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967InvalidImplementation(_) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967NonPayable(_) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FailedCall(_) => {
                    <FailedCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidInitialization(_) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidNullChainId(_) => {
                    <InvalidNullChainId as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidNullPauser(_) => {
                    <InvalidNullPauser as alloy_sol_types::SolError>::SELECTOR
                }
                Self::KmsThresholdTooHigh(_) => {
                    <KmsThresholdTooHigh as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NetworkAlreadyRegistered(_) => {
                    <NetworkAlreadyRegistered as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NetworkNotRegistered(_) => {
                    <NetworkNotRegistered as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotCoprocessorSigner(_) => {
                    <NotCoprocessorSigner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotCoprocessorTxSender(_) => {
                    <NotCoprocessorTxSender as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotInitializing(_) => {
                    <NotInitializing as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotKmsSigner(_) => {
                    <NotKmsSigner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotKmsTxSender(_) => {
                    <NotKmsTxSender as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotPauser(_) => <NotPauser as alloy_sol_types::SolError>::SELECTOR,
                Self::OwnableInvalidOwner(_) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OwnableUnauthorizedAccount(_) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnauthorizedCallContext(_) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnsupportedProxiableUUID(_) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<HTTPZErrors>] = &[
                {
                    fn OwnableUnauthorizedAccount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::OwnableUnauthorizedAccount)
                    }
                    OwnableUnauthorizedAccount
                },
                {
                    fn OwnableInvalidOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::OwnableInvalidOwner)
                    }
                    OwnableInvalidOwner
                },
                {
                    fn NotPauser(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <NotPauser as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::NotPauser)
                    }
                    NotPauser
                },
                {
                    fn InvalidNullChainId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <InvalidNullChainId as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::InvalidNullChainId)
                    }
                    InvalidNullChainId
                },
                {
                    fn NotCoprocessorSigner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <NotCoprocessorSigner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::NotCoprocessorSigner)
                    }
                    NotCoprocessorSigner
                },
                {
                    fn NotKmsSigner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <NotKmsSigner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::NotKmsSigner)
                    }
                    NotKmsSigner
                },
                {
                    fn InvalidNullPauser(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <InvalidNullPauser as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::InvalidNullPauser)
                    }
                    InvalidNullPauser
                },
                {
                    fn KmsThresholdTooHigh(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <KmsThresholdTooHigh as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::KmsThresholdTooHigh)
                    }
                    KmsThresholdTooHigh
                },
                {
                    fn ERC1967InvalidImplementation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::ERC1967InvalidImplementation)
                    }
                    ERC1967InvalidImplementation
                },
                {
                    fn NotCoprocessorTxSender(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <NotCoprocessorTxSender as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::NotCoprocessorTxSender)
                    }
                    NotCoprocessorTxSender
                },
                {
                    fn NetworkNotRegistered(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <NetworkNotRegistered as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::NetworkNotRegistered)
                    }
                    NetworkNotRegistered
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn UUPSUnsupportedProxiableUUID(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::UUPSUnsupportedProxiableUUID)
                    }
                    UUPSUnsupportedProxiableUUID
                },
                {
                    fn NotKmsTxSender(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <NotKmsTxSender as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::NotKmsTxSender)
                    }
                    NotKmsTxSender
                },
                {
                    fn NetworkAlreadyRegistered(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <NetworkAlreadyRegistered as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::NetworkAlreadyRegistered)
                    }
                    NetworkAlreadyRegistered
                },
                {
                    fn ERC1967NonPayable(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <ERC1967NonPayable as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::ERC1967NonPayable)
                    }
                    ERC1967NonPayable
                },
                {
                    fn FailedCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn UUPSUnauthorizedCallContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::UUPSUnauthorizedCallContext)
                    }
                    UUPSUnauthorizedCallContext
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::InvalidInitialization)
                    }
                    InvalidInitialization
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidNullChainId(inner) => {
                    <InvalidNullChainId as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidNullPauser(inner) => {
                    <InvalidNullPauser as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::KmsThresholdTooHigh(inner) => {
                    <KmsThresholdTooHigh as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NetworkAlreadyRegistered(inner) => {
                    <NetworkAlreadyRegistered as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NetworkNotRegistered(inner) => {
                    <NetworkNotRegistered as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotCoprocessorSigner(inner) => {
                    <NotCoprocessorSigner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotCoprocessorTxSender(inner) => {
                    <NotCoprocessorTxSender as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotKmsSigner(inner) => {
                    <NotKmsSigner as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NotKmsTxSender(inner) => {
                    <NotKmsTxSender as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotPauser(inner) => {
                    <NotPauser as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::OwnableInvalidOwner(inner) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OwnableUnauthorizedAccount(inner) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidNullChainId(inner) => {
                    <InvalidNullChainId as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidNullPauser(inner) => {
                    <InvalidNullPauser as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::KmsThresholdTooHigh(inner) => {
                    <KmsThresholdTooHigh as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NetworkAlreadyRegistered(inner) => {
                    <NetworkAlreadyRegistered as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NetworkNotRegistered(inner) => {
                    <NetworkNotRegistered as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotCoprocessorSigner(inner) => {
                    <NotCoprocessorSigner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotCoprocessorTxSender(inner) => {
                    <NotCoprocessorTxSender as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotKmsSigner(inner) => {
                    <NotKmsSigner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotKmsTxSender(inner) => {
                    <NotKmsTxSender as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotPauser(inner) => {
                    <NotPauser as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::OwnableInvalidOwner(inner) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OwnableUnauthorizedAccount(inner) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`HTTPZ`](self) events.
    pub enum HTTPZEvents {
        #[allow(missing_docs)]
        AddNetwork(AddNetwork),
        #[allow(missing_docs)]
        Initialization(Initialization),
        #[allow(missing_docs)]
        Initialized(Initialized),
        #[allow(missing_docs)]
        OwnershipTransferStarted(OwnershipTransferStarted),
        #[allow(missing_docs)]
        OwnershipTransferred(OwnershipTransferred),
        #[allow(missing_docs)]
        UpdateKmsThreshold(UpdateKmsThreshold),
        #[allow(missing_docs)]
        UpdatePauser(UpdatePauser),
        #[allow(missing_docs)]
        Upgraded(Upgraded),
    }
    #[automatically_derived]
    impl HTTPZEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                56u8,
                209u8,
                107u8,
                140u8,
                172u8,
                34u8,
                217u8,
                159u8,
                199u8,
                193u8,
                36u8,
                185u8,
                205u8,
                13u8,
                226u8,
                211u8,
                250u8,
                31u8,
                174u8,
                244u8,
                32u8,
                191u8,
                231u8,
                145u8,
                216u8,
                195u8,
                98u8,
                215u8,
                101u8,
                226u8,
                39u8,
                0u8,
            ],
            [
                139u8,
                224u8,
                7u8,
                156u8,
                83u8,
                22u8,
                89u8,
                20u8,
                19u8,
                68u8,
                205u8,
                31u8,
                208u8,
                164u8,
                242u8,
                132u8,
                25u8,
                73u8,
                127u8,
                151u8,
                34u8,
                163u8,
                218u8,
                175u8,
                227u8,
                180u8,
                24u8,
                111u8,
                107u8,
                100u8,
                87u8,
                224u8,
            ],
            [
                166u8,
                144u8,
                102u8,
                140u8,
                36u8,
                210u8,
                119u8,
                36u8,
                63u8,
                246u8,
                250u8,
                101u8,
                13u8,
                63u8,
                214u8,
                227u8,
                211u8,
                49u8,
                169u8,
                156u8,
                160u8,
                168u8,
                133u8,
                124u8,
                130u8,
                231u8,
                248u8,
                148u8,
                82u8,
                252u8,
                102u8,
                93u8,
            ],
            [
                184u8,
                32u8,
                123u8,
                91u8,
                183u8,
                145u8,
                115u8,
                10u8,
                232u8,
                240u8,
                83u8,
                79u8,
                164u8,
                199u8,
                190u8,
                125u8,
                164u8,
                157u8,
                215u8,
                93u8,
                112u8,
                31u8,
                156u8,
                122u8,
                207u8,
                81u8,
                201u8,
                75u8,
                138u8,
                206u8,
                150u8,
                178u8,
            ],
            [
                188u8,
                124u8,
                215u8,
                90u8,
                32u8,
                238u8,
                39u8,
                253u8,
                154u8,
                222u8,
                186u8,
                179u8,
                32u8,
                65u8,
                247u8,
                85u8,
                33u8,
                77u8,
                188u8,
                107u8,
                255u8,
                169u8,
                12u8,
                192u8,
                34u8,
                91u8,
                57u8,
                218u8,
                46u8,
                92u8,
                45u8,
                59u8,
            ],
            [
                199u8,
                245u8,
                5u8,
                178u8,
                243u8,
                113u8,
                174u8,
                33u8,
                117u8,
                238u8,
                73u8,
                19u8,
                244u8,
                73u8,
                158u8,
                31u8,
                38u8,
                51u8,
                167u8,
                181u8,
                147u8,
                99u8,
                33u8,
                238u8,
                209u8,
                205u8,
                174u8,
                182u8,
                17u8,
                81u8,
                129u8,
                210u8,
            ],
            [
                234u8,
                108u8,
                101u8,
                33u8,
                188u8,
                73u8,
                87u8,
                49u8,
                8u8,
                46u8,
                35u8,
                173u8,
                18u8,
                199u8,
                177u8,
                32u8,
                125u8,
                19u8,
                202u8,
                11u8,
                211u8,
                141u8,
                29u8,
                81u8,
                16u8,
                129u8,
                171u8,
                86u8,
                137u8,
                23u8,
                203u8,
                132u8,
            ],
            [
                243u8,
                61u8,
                144u8,
                140u8,
                74u8,
                139u8,
                83u8,
                47u8,
                230u8,
                77u8,
                242u8,
                11u8,
                114u8,
                111u8,
                17u8,
                64u8,
                92u8,
                17u8,
                185u8,
                119u8,
                45u8,
                49u8,
                182u8,
                111u8,
                94u8,
                239u8,
                104u8,
                135u8,
                164u8,
                60u8,
                63u8,
                222u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for HTTPZEvents {
        const NAME: &'static str = "HTTPZEvents";
        const COUNT: usize = 8usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<AddNetwork as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <AddNetwork as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::AddNetwork)
                }
                Some(<Initialization as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialization as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Initialization)
                }
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Initialized)
                }
                Some(
                    <OwnershipTransferStarted as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferStarted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OwnershipTransferStarted)
                }
                Some(
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OwnershipTransferred)
                }
                Some(
                    <UpdateKmsThreshold as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <UpdateKmsThreshold as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::UpdateKmsThreshold)
                }
                Some(<UpdatePauser as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <UpdatePauser as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::UpdatePauser)
                }
                Some(<Upgraded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Upgraded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Upgraded)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for HTTPZEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AddNetwork(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialization(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::UpdateKmsThreshold(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::UpdatePauser(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AddNetwork(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialization(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::UpdateKmsThreshold(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::UpdatePauser(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`HTTPZ`](self) contract instance.

See the [wrapper's documentation](`HTTPZInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> HTTPZInstance<T, P, N> {
        HTTPZInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<HTTPZInstance<T, P, N>>,
    > {
        HTTPZInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        HTTPZInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`HTTPZ`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`HTTPZ`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct HTTPZInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for HTTPZInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("HTTPZInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > HTTPZInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`HTTPZ`](self) contract instance.

See the [wrapper's documentation](`HTTPZInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<HTTPZInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> HTTPZInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> HTTPZInstance<T, P, N> {
            HTTPZInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > HTTPZInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`UPGRADE_INTERFACE_VERSION`] function.
        pub fn UPGRADE_INTERFACE_VERSION(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, UPGRADE_INTERFACE_VERSIONCall, N> {
            self.call_builder(&UPGRADE_INTERFACE_VERSIONCall {})
        }
        ///Creates a new call builder for the [`acceptOwnership`] function.
        pub fn acceptOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, acceptOwnershipCall, N> {
            self.call_builder(&acceptOwnershipCall {})
        }
        ///Creates a new call builder for the [`addNetwork`] function.
        pub fn addNetwork(
            &self,
            network: <Network as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, addNetworkCall, N> {
            self.call_builder(&addNetworkCall { network })
        }
        ///Creates a new call builder for the [`checkIsCoprocessorSigner`] function.
        pub fn checkIsCoprocessorSigner(
            &self,
            signerAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkIsCoprocessorSignerCall, N> {
            self.call_builder(
                &checkIsCoprocessorSignerCall {
                    signerAddress,
                },
            )
        }
        ///Creates a new call builder for the [`checkIsCoprocessorTxSender`] function.
        pub fn checkIsCoprocessorTxSender(
            &self,
            txSenderAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkIsCoprocessorTxSenderCall, N> {
            self.call_builder(
                &checkIsCoprocessorTxSenderCall {
                    txSenderAddress,
                },
            )
        }
        ///Creates a new call builder for the [`checkIsKmsSigner`] function.
        pub fn checkIsKmsSigner(
            &self,
            signerAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkIsKmsSignerCall, N> {
            self.call_builder(
                &checkIsKmsSignerCall {
                    signerAddress,
                },
            )
        }
        ///Creates a new call builder for the [`checkIsKmsTxSender`] function.
        pub fn checkIsKmsTxSender(
            &self,
            txSenderAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkIsKmsTxSenderCall, N> {
            self.call_builder(
                &checkIsKmsTxSenderCall {
                    txSenderAddress,
                },
            )
        }
        ///Creates a new call builder for the [`checkIsPauser`] function.
        pub fn checkIsPauser(
            &self,
            pauserAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkIsPauserCall, N> {
            self.call_builder(&checkIsPauserCall { pauserAddress })
        }
        ///Creates a new call builder for the [`checkNetworkIsRegistered`] function.
        pub fn checkNetworkIsRegistered(
            &self,
            chainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkNetworkIsRegisteredCall, N> {
            self.call_builder(
                &checkNetworkIsRegisteredCall {
                    chainId,
                },
            )
        }
        ///Creates a new call builder for the [`coprocessorTxSenderAddresses`] function.
        pub fn coprocessorTxSenderAddresses(
            &self,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, coprocessorTxSenderAddressesCall, N> {
            self.call_builder(
                &coprocessorTxSenderAddressesCall {
                    index,
                },
            )
        }
        ///Creates a new call builder for the [`coprocessors`] function.
        pub fn coprocessors(
            &self,
            coprocessorTxSenderAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, coprocessorsCall, N> {
            self.call_builder(
                &coprocessorsCall {
                    coprocessorTxSenderAddress,
                },
            )
        }
        ///Creates a new call builder for the [`getAllCoprocessorTxSenderAddresses`] function.
        pub fn getAllCoprocessorTxSenderAddresses(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            getAllCoprocessorTxSenderAddressesCall,
            N,
        > {
            self.call_builder(
                &getAllCoprocessorTxSenderAddressesCall {
                },
            )
        }
        ///Creates a new call builder for the [`getAllKmsTxSenderAddresses`] function.
        pub fn getAllKmsTxSenderAddresses(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getAllKmsTxSenderAddressesCall, N> {
            self.call_builder(&getAllKmsTxSenderAddressesCall {})
        }
        ///Creates a new call builder for the [`getCoprocessorMajorityThreshold`] function.
        pub fn getCoprocessorMajorityThreshold(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            getCoprocessorMajorityThresholdCall,
            N,
        > {
            self.call_builder(
                &getCoprocessorMajorityThresholdCall {
                },
            )
        }
        ///Creates a new call builder for the [`getKmsMajorityThreshold`] function.
        pub fn getKmsMajorityThreshold(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getKmsMajorityThresholdCall, N> {
            self.call_builder(&getKmsMajorityThresholdCall {})
        }
        ///Creates a new call builder for the [`getKmsReconstructionThreshold`] function.
        pub fn getKmsReconstructionThreshold(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            getKmsReconstructionThresholdCall,
            N,
        > {
            self.call_builder(
                &getKmsReconstructionThresholdCall {
                },
            )
        }
        ///Creates a new call builder for the [`getKmsThreshold`] function.
        pub fn getKmsThreshold(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getKmsThresholdCall, N> {
            self.call_builder(&getKmsThresholdCall {})
        }
        ///Creates a new call builder for the [`getProtocolMetadata`] function.
        pub fn getProtocolMetadata(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getProtocolMetadataCall, N> {
            self.call_builder(&getProtocolMetadataCall {})
        }
        ///Creates a new call builder for the [`getVersion`] function.
        pub fn getVersion(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getVersionCall, N> {
            self.call_builder(&getVersionCall {})
        }
        ///Creates a new call builder for the [`initialize`] function.
        pub fn initialize(
            &self,
            initialPauser: alloy::sol_types::private::Address,
            initialMetadata: <ProtocolMetadata as alloy::sol_types::SolType>::RustType,
            initialKmsThreshold: alloy::sol_types::private::primitives::aliases::U256,
            initialKmsNodes: alloy::sol_types::private::Vec<
                <KmsNode as alloy::sol_types::SolType>::RustType,
            >,
            initialCoprocessors: alloy::sol_types::private::Vec<
                <Coprocessor as alloy::sol_types::SolType>::RustType,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, initializeCall, N> {
            self.call_builder(
                &initializeCall {
                    initialPauser,
                    initialMetadata,
                    initialKmsThreshold,
                    initialKmsNodes,
                    initialCoprocessors,
                },
            )
        }
        ///Creates a new call builder for the [`kmsNodes`] function.
        pub fn kmsNodes(
            &self,
            kmsTxSenderAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, kmsNodesCall, N> {
            self.call_builder(&kmsNodesCall { kmsTxSenderAddress })
        }
        ///Creates a new call builder for the [`kmsTxSenderAddresses`] function.
        pub fn kmsTxSenderAddresses(
            &self,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, kmsTxSenderAddressesCall, N> {
            self.call_builder(&kmsTxSenderAddressesCall { index })
        }
        ///Creates a new call builder for the [`networks`] function.
        pub fn networks(
            &self,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, networksCall, N> {
            self.call_builder(&networksCall { index })
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<T, &P, ownerCall, N> {
            self.call_builder(&ownerCall {})
        }
        ///Creates a new call builder for the [`pendingOwner`] function.
        pub fn pendingOwner(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, pendingOwnerCall, N> {
            self.call_builder(&pendingOwnerCall {})
        }
        ///Creates a new call builder for the [`proxiableUUID`] function.
        pub fn proxiableUUID(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, proxiableUUIDCall, N> {
            self.call_builder(&proxiableUUIDCall {})
        }
        ///Creates a new call builder for the [`renounceOwnership`] function.
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall {})
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
        ///Creates a new call builder for the [`updateKmsThreshold`] function.
        pub fn updateKmsThreshold(
            &self,
            newKmsThreshold: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, updateKmsThresholdCall, N> {
            self.call_builder(
                &updateKmsThresholdCall {
                    newKmsThreshold,
                },
            )
        }
        ///Creates a new call builder for the [`updatePauser`] function.
        pub fn updatePauser(
            &self,
            newPauser: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, updatePauserCall, N> {
            self.call_builder(&updatePauserCall { newPauser })
        }
        ///Creates a new call builder for the [`upgradeToAndCall`] function.
        pub fn upgradeToAndCall(
            &self,
            newImplementation: alloy::sol_types::private::Address,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, upgradeToAndCallCall, N> {
            self.call_builder(
                &upgradeToAndCallCall {
                    newImplementation,
                    data,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > HTTPZInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`AddNetwork`] event.
        pub fn AddNetwork_filter(&self) -> alloy_contract::Event<T, &P, AddNetwork, N> {
            self.event_filter::<AddNetwork>()
        }
        ///Creates a new event filter for the [`Initialization`] event.
        pub fn Initialization_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, Initialization, N> {
            self.event_filter::<Initialization>()
        }
        ///Creates a new event filter for the [`Initialized`] event.
        pub fn Initialized_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        ///Creates a new event filter for the [`OwnershipTransferStarted`] event.
        pub fn OwnershipTransferStarted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipTransferStarted, N> {
            self.event_filter::<OwnershipTransferStarted>()
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        ///Creates a new event filter for the [`UpdateKmsThreshold`] event.
        pub fn UpdateKmsThreshold_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, UpdateKmsThreshold, N> {
            self.event_filter::<UpdateKmsThreshold>()
        }
        ///Creates a new event filter for the [`UpdatePauser`] event.
        pub fn UpdatePauser_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, UpdatePauser, N> {
            self.event_filter::<UpdatePauser>()
        }
        ///Creates a new event filter for the [`Upgraded`] event.
        pub fn Upgraded_filter(&self) -> alloy_contract::Event<T, &P, Upgraded, N> {
            self.event_filter::<Upgraded>()
        }
    }
}
