/**

Generated by the following Solidity interface...
```solidity
interface HTTPZ {
    struct Coprocessor {
        address txSenderAddress;
        address signerAddress;
        string s3BucketUrl;
    }
    struct KmsNode {
        address txSenderAddress;
        address signerAddress;
        string ipAddress;
    }
    struct Network {
        uint256 chainId;
        address httpzExecutor;
        address aclAddress;
        string name;
        string website;
    }
    struct ProtocolMetadata {
        string name;
        string website;
    }

    error AddressEmptyCode(address target);
    error ERC1967InvalidImplementation(address implementation);
    error ERC1967NonPayable();
    error FailedCall();
    error InvalidInitialization();
    error InvalidNullChainId();
    error KmsThresholdTooHigh(uint256 threshold, uint256 nParties);
    error NetworkAlreadyRegistered(uint256 chainId);
    error NetworkNotRegistered(uint256 chainId);
    error NotCoprocessorSigner(address signerAddress);
    error NotCoprocessorTxSender(address txSenderAddress);
    error NotInitializing();
    error NotKmsSigner(address signerAddress);
    error NotKmsTxSender(address txSenderAddress);
    error NotPauser(address pauserAddress);
    error OwnableInvalidOwner(address owner);
    error OwnableUnauthorizedAccount(address account);
    error UUPSUnauthorizedCallContext();
    error UUPSUnsupportedProxiableUUID(bytes32 slot);

    event AddNetwork(Network network);
    event Initialization(address pauser, ProtocolMetadata metadata, uint256 kmsThreshold, KmsNode[] kmsNodes, Coprocessor[] coprocessors);
    event Initialized(uint64 version);
    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event UpdateKmsThreshold(uint256 newKmsThreshold);
    event Upgraded(address indexed implementation);

    constructor();

    function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
    function acceptOwnership() external;
    function addNetwork(Network memory network) external;
    function checkIsCoprocessorSigner(address signerAddress) external view;
    function checkIsCoprocessorTxSender(address txSenderAddress) external view;
    function checkIsKmsSigner(address signerAddress) external view;
    function checkIsKmsTxSender(address txSenderAddress) external view;
    function checkIsPauser(address pauserAddress) external view;
    function checkNetworkIsRegistered(uint256 chainId) external view;
    function coprocessorTxSenderAddresses(uint256 index) external view returns (address);
    function coprocessors(address coprocessorTxSenderAddress) external view returns (Coprocessor memory);
    function getAllCoprocessorTxSenderAddresses() external view returns (address[] memory);
    function getAllKmsTxSenderAddresses() external view returns (address[] memory);
    function getCoprocessorMajorityThreshold() external view returns (uint256);
    function getKmsMajorityThreshold() external view returns (uint256);
    function getKmsReconstructionThreshold() external view returns (uint256);
    function getKmsThreshold() external view returns (uint256);
    function getProtocolMetadata() external view returns (ProtocolMetadata memory);
    function getVersion() external pure returns (string memory);
    function initialize(address initialPauser, ProtocolMetadata memory initialMetadata, uint256 initialKmsThreshold, KmsNode[] memory initialKmsNodes, Coprocessor[] memory initialCoprocessors) external;
    function kmsNodes(address kmsTxSenderAddress) external view returns (KmsNode memory);
    function kmsTxSenderAddresses(uint256 index) external view returns (address);
    function networks(uint256 index) external view returns (Network memory);
    function owner() external view returns (address);
    function pendingOwner() external view returns (address);
    function proxiableUUID() external view returns (bytes32);
    function renounceOwnership() external;
    function transferOwnership(address newOwner) external;
    function updateKmsThreshold(uint256 newKmsThreshold) external;
    function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "UPGRADE_INTERFACE_VERSION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "acceptOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "addNetwork",
    "inputs": [
      {
        "name": "network",
        "type": "tuple",
        "internalType": "struct Network",
        "components": [
          {
            "name": "chainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "httpzExecutor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "aclAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "website",
            "type": "string",
            "internalType": "string"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkIsCoprocessorSigner",
    "inputs": [
      {
        "name": "signerAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "checkIsCoprocessorTxSender",
    "inputs": [
      {
        "name": "txSenderAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "checkIsKmsSigner",
    "inputs": [
      {
        "name": "signerAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "checkIsKmsTxSender",
    "inputs": [
      {
        "name": "txSenderAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "checkIsPauser",
    "inputs": [
      {
        "name": "pauserAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "checkNetworkIsRegistered",
    "inputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "coprocessorTxSenderAddresses",
    "inputs": [
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "coprocessors",
    "inputs": [
      {
        "name": "coprocessorTxSenderAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct Coprocessor",
        "components": [
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "s3BucketUrl",
            "type": "string",
            "internalType": "string"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAllCoprocessorTxSenderAddresses",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAllKmsTxSenderAddresses",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCoprocessorMajorityThreshold",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsMajorityThreshold",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsReconstructionThreshold",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKmsThreshold",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getProtocolMetadata",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct ProtocolMetadata",
        "components": [
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "website",
            "type": "string",
            "internalType": "string"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getVersion",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "initialize",
    "inputs": [
      {
        "name": "initialPauser",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "initialMetadata",
        "type": "tuple",
        "internalType": "struct ProtocolMetadata",
        "components": [
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "website",
            "type": "string",
            "internalType": "string"
          }
        ]
      },
      {
        "name": "initialKmsThreshold",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "initialKmsNodes",
        "type": "tuple[]",
        "internalType": "struct KmsNode[]",
        "components": [
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "ipAddress",
            "type": "string",
            "internalType": "string"
          }
        ]
      },
      {
        "name": "initialCoprocessors",
        "type": "tuple[]",
        "internalType": "struct Coprocessor[]",
        "components": [
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "s3BucketUrl",
            "type": "string",
            "internalType": "string"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "kmsNodes",
    "inputs": [
      {
        "name": "kmsTxSenderAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct KmsNode",
        "components": [
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "ipAddress",
            "type": "string",
            "internalType": "string"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "kmsTxSenderAddresses",
    "inputs": [
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "networks",
    "inputs": [
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct Network",
        "components": [
          {
            "name": "chainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "httpzExecutor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "aclAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "website",
            "type": "string",
            "internalType": "string"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pendingOwner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "proxiableUUID",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateKmsThreshold",
    "inputs": [
      {
        "name": "newKmsThreshold",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "upgradeToAndCall",
    "inputs": [
      {
        "name": "newImplementation",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "event",
    "name": "AddNetwork",
    "inputs": [
      {
        "name": "network",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct Network",
        "components": [
          {
            "name": "chainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "httpzExecutor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "aclAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "website",
            "type": "string",
            "internalType": "string"
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialization",
    "inputs": [
      {
        "name": "pauser",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "metadata",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct ProtocolMetadata",
        "components": [
          {
            "name": "name",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "website",
            "type": "string",
            "internalType": "string"
          }
        ]
      },
      {
        "name": "kmsThreshold",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "kmsNodes",
        "type": "tuple[]",
        "indexed": false,
        "internalType": "struct KmsNode[]",
        "components": [
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "ipAddress",
            "type": "string",
            "internalType": "string"
          }
        ]
      },
      {
        "name": "coprocessors",
        "type": "tuple[]",
        "indexed": false,
        "internalType": "struct Coprocessor[]",
        "components": [
          {
            "name": "txSenderAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "signerAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "s3BucketUrl",
            "type": "string",
            "internalType": "string"
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      {
        "name": "version",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferStarted",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "UpdateKmsThreshold",
    "inputs": [
      {
        "name": "newKmsThreshold",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Upgraded",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AddressEmptyCode",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1967InvalidImplementation",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1967NonPayable",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FailedCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidInitialization",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidNullChainId",
    "inputs": []
  },
  {
    "type": "error",
    "name": "KmsThresholdTooHigh",
    "inputs": [
      {
        "name": "threshold",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nParties",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "NetworkAlreadyRegistered",
    "inputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "NetworkNotRegistered",
    "inputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotCoprocessorSigner",
    "inputs": [
      {
        "name": "signerAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotCoprocessorTxSender",
    "inputs": [
      {
        "name": "txSenderAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotInitializing",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotKmsSigner",
    "inputs": [
      {
        "name": "signerAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotKmsTxSender",
    "inputs": [
      {
        "name": "txSenderAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotPauser",
    "inputs": [
      {
        "name": "pauserAddress",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "OwnableInvalidOwner",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "OwnableUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "UUPSUnauthorizedCallContext",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UUPSUnsupportedProxiableUUID",
    "inputs": [
      {
        "name": "slot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod HTTPZ {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a06040523073ffffffffffffffffffffffffffffffffffffffff1660809073ffffffffffffffffffffffffffffffffffffffff16815250348015610042575f5ffd5b5061005161005660201b60201c565b6101b6565b5f61006561015460201b60201c565b9050805f0160089054906101000a900460ff16156100af576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b67ffffffffffffffff8016815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff16146101515767ffffffffffffffff815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d267ffffffffffffffff604051610148919061019d565b60405180910390a15b50565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b5f67ffffffffffffffff82169050919050565b6101978161017b565b82525050565b5f6020820190506101b05f83018461018e565b92915050565b60805161450f6101dc5f395f8181612124015281816121790152612333015261450f5ff3fe6080604052600436106101cc575f3560e01c806379ba5097116100f6578063c6b3024d11610094578063d98189a411610063578063d98189a414610616578063e30c39781461063e578063ecbd96ab14610668578063f2fde38b146106a4576101cc565b8063c6b3024d14610562578063cb6617551461058a578063cdb4c2b9146105b2578063d5244bf1146105da576101cc565b80638f4a7f5e116100d05780638f4a7f5e146104bc578063ad3cb1cc146104e6578063bda0b94814610510578063c62752581461053a576101cc565b806379ba5097146104405780638bb0a17c146104565780638da5cb5b14610492576101cc565b80634f1ef2861161016e5780636799ef521161013d5780636799ef52146103b05780636c88eb43146103da57806370cc9a3c14610402578063715018a61461042a576101cc565b80634f1ef286146102f257806352d1902d1461030e57806354d3f675146103385780635ab6d3ab14610374576101cc565b806347cd4b3e116101aa57806347cd4b3e1461024a57806348144c6114610274578063490413aa1461029e5780634921a3bd146102c8576101cc565b80630219150f146101d05780630d8e6e2c146101f8578063195afde614610222575b5f5ffd5b3480156101db575f5ffd5b506101f660048036038101906101f19190612bf9565b6106cc565b005b348015610203575f5ffd5b5061020c610778565b6040516102199190612c94565b60405180910390f35b34801561022d575f5ffd5b5061024860048036038101906102439190612d0e565b6107f3565b005b348015610255575f5ffd5b5061025e610894565b60405161026b9190612d48565b60405180910390f35b34801561027f575f5ffd5b506102886108b7565b6040516102959190612dea565b60405180910390f35b3480156102a9575f5ffd5b506102b26109fe565b6040516102bf9190612d48565b60405180910390f35b3480156102d3575f5ffd5b506102dc610a2d565b6040516102e99190612d48565b60405180910390f35b61030c60048036038101906103079190612f36565b610a44565b005b348015610319575f5ffd5b50610322610a63565b60405161032f9190612fa8565b60405180910390f35b348015610343575f5ffd5b5061035e60048036038101906103599190612d0e565b610a94565b60405161036b919061301d565b60405180910390f35b34801561037f575f5ffd5b5061039a60048036038101906103959190612bf9565b610c32565b6040516103a7919061304c565b60405180910390f35b3480156103bb575f5ffd5b506103c4610c84565b6040516103d19190612d48565b60405180910390f35b3480156103e5575f5ffd5b5061040060048036038101906103fb9190612d0e565b610cb6565b005b34801561040d575f5ffd5b5061042860048036038101906104239190613087565b610d52565b005b348015610435575f5ffd5b5061043e610ea3565b005b34801561044b575f5ffd5b50610454610eb6565b005b348015610461575f5ffd5b5061047c60048036038101906104779190612bf9565b610f44565b6040516104899190613157565b60405180910390f35b34801561049d575f5ffd5b506104a661115f565b6040516104b3919061304c565b60405180910390f35b3480156104c7575f5ffd5b506104d0611194565b6040516104dd919061321f565b60405180910390f35b3480156104f1575f5ffd5b506104fa61122d565b6040516105079190612c94565b60405180910390f35b34801561051b575f5ffd5b50610524611266565b604051610531919061321f565b60405180910390f35b348015610545575f5ffd5b50610560600480360381019061055b9190612d0e565b6112ff565b005b34801561056d575f5ffd5b5061058860048036038101906105839190612bf9565b61139b565b005b348015610595575f5ffd5b506105b060048036038101906105ab9190612d0e565b61140b565b005b3480156105bd575f5ffd5b506105d860048036038101906105d39190612d0e565b6114a7565b005b3480156105e5575f5ffd5b5061060060048036038101906105fb9190612bf9565b611543565b60405161060d919061304c565b60405180910390f35b348015610621575f5ffd5b5061063c60048036038101906106379190613624565b611595565b005b348015610649575f5ffd5b50610652611d1e565b60405161065f919061304c565b60405180910390f35b348015610673575f5ffd5b5061068e60048036038101906106899190612d0e565b611d53565b60405161069b919061373c565b60405180910390f35b3480156106af575f5ffd5b506106ca60048036038101906106c59190612d0e565b611ef1565b005b6106d4611faa565b5f6106dd612031565b90508060090180549050821115610734578181600901805490506040517f48676fe000000000000000000000000000000000000000000000000000000000815260040161072b92919061375c565b60405180910390fd5b8181600a01819055507fea6c6521bc495731082e23ad12c7b1207d13ca0bd38d1d511081ab568917cb848260405161076c9190612d48565b60405180910390a15050565b60606040518060400160405280600581526020017f485454505a0000000000000000000000000000000000000000000000000000008152506107b95f612058565b6107c36001612058565b6107cc5f612058565b6040516020016107df9493929190613851565b604051602081830303815290604052905090565b5f6107fc612031565b90508173ffffffffffffffffffffffffffffffffffffffff16815f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161461089057816040517f206a346e000000000000000000000000000000000000000000000000000000008152600401610887919061304c565b60405180910390fd5b5050565b5f5f61089e612031565b9050600181600a01546108b191906138dc565b91505090565b6108bf612aad565b5f6108c8612031565b9050806006016040518060400160405290815f820180546108e89061393c565b80601f01602080910402602001604051908101604052809291908181526020018280546109149061393c565b801561095f5780601f106109365761010080835404028352916020019161095f565b820191905f5260205f20905b81548152906001019060200180831161094257829003601f168201915b505050505081526020016001820180546109789061393c565b80601f01602080910402602001604051908101604052809291908181526020018280546109a49061393c565b80156109ef5780601f106109c6576101008083540402835291602001916109ef565b820191905f5260205f20905b8154815290600101906020018083116109d257829003601f168201915b50505050508152505091505090565b5f5f610a08612031565b9050600181600a01546002610a1d919061396c565b610a2791906138dc565b91505090565b5f5f610a37612031565b905080600a015491505090565b610a4c612122565b610a5582612208565b610a5f8282612213565b5050565b5f610a6c612331565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b905090565b610a9c612ac7565b5f610aa5612031565b9050806008015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f206040518060600160405290815f82015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282018054610baa9061393c565b80601f0160208091040260200160405190810160405280929190818152602001828054610bd69061393c565b8015610c215780601f10610bf857610100808354040283529160200191610c21565b820191905f5260205f20905b815481529060010190602001808311610c0457829003601f168201915b505050505081525050915050919050565b5f5f610c3c612031565b905080600c018381548110610c5457610c536139ad565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16915050919050565b5f5f610c8e612031565b90506001600282600c0180549050610ca69190613a07565b610cb091906138dc565b91505090565b5f610cbf612031565b9050806002015f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff16610d4e57816040517f2a7c6ef6000000000000000000000000000000000000000000000000000000008152600401610d45919061304c565b60405180910390fd5b5050565b5f815f013503610d8e576040517f22f73fea00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f610d97612031565b9050806005015f835f013581526020019081526020015f205f9054906101000a900460ff1615610e0157815f01356040517fb1825c5e000000000000000000000000000000000000000000000000000000008152600401610df89190612d48565b60405180910390fd5b80600d0182908060018154018082558091505060019003905f5260205f2090600502015f909190919091508181610e389190613f10565b50506001816005015f845f013581526020019081526020015f205f6101000a81548160ff0219169083151502179055507fb8207b5bb791730ae8f0534fa4c7be7da49dd75d701f9c7acf51c94b8ace96b282604051610e97919061408a565b60405180910390a15050565b610eab611faa565b610eb45f6123b8565b565b5f610ebf6123f5565b90508073ffffffffffffffffffffffffffffffffffffffff16610ee0611d1e565b73ffffffffffffffffffffffffffffffffffffffff1614610f3857806040517f118cdaa7000000000000000000000000000000000000000000000000000000008152600401610f2f919061304c565b60405180910390fd5b610f41816123b8565b50565b610f4c612b12565b5f610f55612031565b905080600d018381548110610f6d57610f6c6139ad565b5b905f5260205f2090600502016040518060a00160405290815f8201548152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020016003820180546110479061393c565b80601f01602080910402602001604051908101604052809291908181526020018280546110739061393c565b80156110be5780601f10611095576101008083540402835291602001916110be565b820191905f5260205f20905b8154815290600101906020018083116110a157829003601f168201915b505050505081526020016004820180546110d79061393c565b80601f01602080910402602001604051908101604052809291908181526020018280546111039061393c565b801561114e5780601f106111255761010080835404028352916020019161114e565b820191905f5260205f20905b81548152906001019060200180831161113157829003601f168201915b505050505081525050915050919050565b5f5f6111696123fc565b9050805f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b60605f61119f612031565b905080600c0180548060200260200160405190810160405280929190818152602001828054801561122257602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190600101908083116111d9575b505050505091505090565b6040518060400160405280600581526020017f352e302e3000000000000000000000000000000000000000000000000000000081525081565b60605f611271612031565b9050806009018054806020026020016040519081016040528092919081815260200182805480156112f457602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190600101908083116112ab575b505050505091505090565b5f611308612031565b9050806001015f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff1661139757816040517faee8632300000000000000000000000000000000000000000000000000000000815260040161138e919061304c565b60405180910390fd5b5050565b5f6113a4612031565b9050806005015f8381526020019081526020015f205f9054906101000a900460ff1661140757816040517f6df6fe890000000000000000000000000000000000000000000000000000000081526004016113fe9190612d48565b60405180910390fd5b5050565b5f611414612031565b9050806003015f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff166114a357816040517f52d725f500000000000000000000000000000000000000000000000000000000815260040161149a919061304c565b60405180910390fd5b5050565b5f6114b0612031565b9050806004015f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff1661153f57816040517f26cd75dc000000000000000000000000000000000000000000000000000000008152600401611536919061304c565b60405180910390fd5b5050565b5f5f61154d612031565b9050806009018381548110611565576115646139ad565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16915050919050565b60025f6115a0612423565b9050805f0160089054906101000a900460ff16806115e857508167ffffffffffffffff16815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff1610155b1561161f576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055506001815f0160086101000a81548160ff02191690831515021790555061167461166f61115f565b61244a565b5f61167d612031565b905086816006015f820151815f01908161169791906140aa565b5060208201518160010190816116ad91906140aa565b5090505087815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505f855190508087111561173e5786816040517f48676fe000000000000000000000000000000000000000000000000000000000815260040161173592919061375c565b60405180910390fd5b8682600a01819055505f5f90505b818110156119e3576001836001015f89848151811061176e5761176d6139ad565b5b60200260200101515f015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff0219169083151502179055508681815181106117db576117da6139ad565b5b6020026020010151836008015f8984815181106117fb576117fa6139ad565b5b60200260200101515f015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f820151815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506020820151816001015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060408201518160020190816118de91906140aa565b50905050826009018782815181106118f9576118f86139ad565b5b60200260200101515f0151908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506001836002015f89848151811061197b5761197a6139ad565b5b60200260200101516020015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550808060010191505061174c565b505f5f90505b8551811015611c81576001836003015f888481518110611a0c57611a0b6139ad565b5b60200260200101515f015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550858181518110611a7957611a786139ad565b5b602002602001015183600b015f888481518110611a9957611a986139ad565b5b60200260200101515f015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f820151815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506020820151816001015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506040820151816002019081611b7c91906140aa565b5090505082600c01868281518110611b9757611b966139ad565b5b60200260200101515f0151908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506001836004015f888481518110611c1957611c186139ad565b5b60200260200101516020015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff02191690831515021790555080806001019150506119e9565b507ff33d908c4a8b532fe64df20b726f11405c11b9772d31b66f5eef6887a43c3fde8989898989604051611cb9959493929190614389565b60405180910390a150505f815f0160086101000a81548160ff0219169083151502179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d282604051611d0d9190614411565b60405180910390a150505050505050565b5f5f611d2861245e565b9050805f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b611d5b612b6a565b5f611d64612031565b905080600b015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f206040518060600160405290815f82015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282018054611e699061393c565b80601f0160208091040260200160405190810160405280929190818152602001828054611e959061393c565b8015611ee05780601f10611eb757610100808354040283529160200191611ee0565b820191905f5260205f20905b815481529060010190602001808311611ec357829003601f168201915b505050505081525050915050919050565b611ef9611faa565b5f611f0261245e565b905081815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff16611f6461115f565b73ffffffffffffffffffffffffffffffffffffffff167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a35050565b611fb26123f5565b73ffffffffffffffffffffffffffffffffffffffff16611fd061115f565b73ffffffffffffffffffffffffffffffffffffffff161461202f57611ff36123f5565b6040517f118cdaa7000000000000000000000000000000000000000000000000000000008152600401612026919061304c565b60405180910390fd5b565b5f7f827176a45e1aad1f3a6539fee60c06126c40427b4849e7301bf2cf0f1f8e9500905090565b60605f600161206684612485565b0190505f8167ffffffffffffffff81111561208457612083612e12565b5b6040519080825280601f01601f1916602001820160405280156120b65781602001600182028036833780820191505090505b5090505f82602001820190505b600115612117578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a858161210c5761210b6139da565b5b0494505f85036120c3575b819350505050919050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614806121cf57507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166121b66125d6565b73ffffffffffffffffffffffffffffffffffffffff1614155b15612206576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b612210611faa565b50565b8173ffffffffffffffffffffffffffffffffffffffff166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa92505050801561227b57506040513d601f19601f820116820180604052508101906122789190614454565b60015b6122bc57816040517f4c9c8ce30000000000000000000000000000000000000000000000000000000081526004016122b3919061304c565b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b811461232257806040517faa1d49a40000000000000000000000000000000000000000000000000000000081526004016123199190612fa8565b60405180910390fd5b61232c8383612629565b505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff16146123b6576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f6123c161245e565b9050805f015f6101000a81549073ffffffffffffffffffffffffffffffffffffffff02191690556123f18261269b565b5050565b5f33905090565b5f7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300905090565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b61245261276c565b61245b816127ac565b50565b5f7f237e158222e3e6968b72b9db0d8043aacf074ad9f650f0d1606b4d82ee432c00905090565b5f5f5f90507a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083106124e1577a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083816124d7576124d66139da565b5b0492506040810190505b6d04ee2d6d415b85acef8100000000831061251e576d04ee2d6d415b85acef81000000008381612514576125136139da565b5b0492506020810190505b662386f26fc10000831061254d57662386f26fc100008381612543576125426139da565b5b0492506010810190505b6305f5e1008310612576576305f5e100838161256c5761256b6139da565b5b0492506008810190505b612710831061259b576127108381612591576125906139da565b5b0492506004810190505b606483106125be57606483816125b4576125b36139da565b5b0492506002810190505b600a83106125cd576001810190505b80915050919050565b5f6126027f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b612830565b5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b61263282612839565b8173ffffffffffffffffffffffffffffffffffffffff167fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b60405160405180910390a25f8151111561268e576126888282612902565b50612697565b612696612982565b5b5050565b5f6126a46123fc565b90505f815f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905082825f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a3505050565b6127746129be565b6127aa576040517fd7e6bcf800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b6127b461276c565b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603612824575f6040517f1e4fbdf700000000000000000000000000000000000000000000000000000000815260040161281b919061304c565b60405180910390fd5b61282d816123b8565b50565b5f819050919050565b5f8173ffffffffffffffffffffffffffffffffffffffff163b0361289457806040517f4c9c8ce300000000000000000000000000000000000000000000000000000000815260040161288b919061304c565b60405180910390fd5b806128c07f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b612830565b5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60605f5f8473ffffffffffffffffffffffffffffffffffffffff168460405161292b91906144c3565b5f60405180830381855af49150503d805f8114612963576040519150601f19603f3d011682016040523d82523d5f602084013e612968565b606091505b50915091506129788583836129dc565b9250505092915050565b5f3411156129bc576040517fb398979f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f6129c7612423565b5f0160089054906101000a900460ff16905090565b6060826129f1576129ec82612a69565b612a61565b5f8251148015612a1757505f8473ffffffffffffffffffffffffffffffffffffffff163b145b15612a5957836040517f9996b315000000000000000000000000000000000000000000000000000000008152600401612a50919061304c565b60405180910390fd5b819050612a62565b5b9392505050565b5f81511115612a7b5780518082602001fd5b6040517fd6bda27500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b604051806040016040528060608152602001606081525090565b60405180606001604052805f73ffffffffffffffffffffffffffffffffffffffff1681526020015f73ffffffffffffffffffffffffffffffffffffffff168152602001606081525090565b6040518060a001604052805f81526020015f73ffffffffffffffffffffffffffffffffffffffff1681526020015f73ffffffffffffffffffffffffffffffffffffffff16815260200160608152602001606081525090565b60405180606001604052805f73ffffffffffffffffffffffffffffffffffffffff1681526020015f73ffffffffffffffffffffffffffffffffffffffff168152602001606081525090565b5f604051905090565b5f5ffd5b5f5ffd5b5f819050919050565b612bd881612bc6565b8114612be2575f5ffd5b50565b5f81359050612bf381612bcf565b92915050565b5f60208284031215612c0e57612c0d612bbe565b5b5f612c1b84828501612be5565b91505092915050565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f601f19601f8301169050919050565b5f612c6682612c24565b612c708185612c2e565b9350612c80818560208601612c3e565b612c8981612c4c565b840191505092915050565b5f6020820190508181035f830152612cac8184612c5c565b905092915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f612cdd82612cb4565b9050919050565b612ced81612cd3565b8114612cf7575f5ffd5b50565b5f81359050612d0881612ce4565b92915050565b5f60208284031215612d2357612d22612bbe565b5b5f612d3084828501612cfa565b91505092915050565b612d4281612bc6565b82525050565b5f602082019050612d5b5f830184612d39565b92915050565b5f82825260208201905092915050565b5f612d7b82612c24565b612d858185612d61565b9350612d95818560208601612c3e565b612d9e81612c4c565b840191505092915050565b5f604083015f8301518482035f860152612dc38282612d71565b91505060208301518482036020860152612ddd8282612d71565b9150508091505092915050565b5f6020820190508181035f830152612e028184612da9565b905092915050565b5f5ffd5b5f5ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b612e4882612c4c565b810181811067ffffffffffffffff82111715612e6757612e66612e12565b5b80604052505050565b5f612e79612bb5565b9050612e858282612e3f565b919050565b5f67ffffffffffffffff821115612ea457612ea3612e12565b5b612ead82612c4c565b9050602081019050919050565b828183375f83830152505050565b5f612eda612ed584612e8a565b612e70565b905082815260208101848484011115612ef657612ef5612e0e565b5b612f01848285612eba565b509392505050565b5f82601f830112612f1d57612f1c612e0a565b5b8135612f2d848260208601612ec8565b91505092915050565b5f5f60408385031215612f4c57612f4b612bbe565b5b5f612f5985828601612cfa565b925050602083013567ffffffffffffffff811115612f7a57612f79612bc2565b5b612f8685828601612f09565b9150509250929050565b5f819050919050565b612fa281612f90565b82525050565b5f602082019050612fbb5f830184612f99565b92915050565b612fca81612cd3565b82525050565b5f606083015f830151612fe55f860182612fc1565b506020830151612ff86020860182612fc1565b50604083015184820360408601526130108282612d71565b9150508091505092915050565b5f6020820190508181035f8301526130358184612fd0565b905092915050565b61304681612cd3565b82525050565b5f60208201905061305f5f83018461303d565b92915050565b5f5ffd5b5f60a0828403121561307e5761307d613065565b5b81905092915050565b5f6020828403121561309c5761309b612bbe565b5b5f82013567ffffffffffffffff8111156130b9576130b8612bc2565b5b6130c584828501613069565b91505092915050565b6130d781612bc6565b82525050565b5f60a083015f8301516130f25f8601826130ce565b5060208301516131056020860182612fc1565b5060408301516131186040860182612fc1565b50606083015184820360608601526131308282612d71565b9150506080830151848203608086015261314a8282612d71565b9150508091505092915050565b5f6020820190508181035f83015261316f81846130dd565b905092915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f6131ab8383612fc1565b60208301905092915050565b5f602082019050919050565b5f6131cd82613177565b6131d78185613181565b93506131e283613191565b805f5b838110156132125781516131f988826131a0565b9750613204836131b7565b9250506001810190506131e5565b5085935050505092915050565b5f6020820190508181035f83015261323781846131c3565b905092915050565b5f5ffd5b5f5ffd5b5f67ffffffffffffffff82111561326157613260612e12565b5b61326a82612c4c565b9050602081019050919050565b5f61328961328484613247565b612e70565b9050828152602081018484840111156132a5576132a4612e0e565b5b6132b0848285612eba565b509392505050565b5f82601f8301126132cc576132cb612e0a565b5b81356132dc848260208601613277565b91505092915050565b5f604082840312156132fa576132f961323f565b5b6133046040612e70565b90505f82013567ffffffffffffffff81111561332357613322613243565b5b61332f848285016132b8565b5f83015250602082013567ffffffffffffffff81111561335257613351613243565b5b61335e848285016132b8565b60208301525092915050565b5f67ffffffffffffffff82111561338457613383612e12565b5b602082029050602081019050919050565b5f5ffd5b5f606082840312156133ae576133ad61323f565b5b6133b86060612e70565b90505f6133c784828501612cfa565b5f8301525060206133da84828501612cfa565b602083015250604082013567ffffffffffffffff8111156133fe576133fd613243565b5b61340a848285016132b8565b60408301525092915050565b5f6134286134238461336a565b612e70565b9050808382526020820190506020840283018581111561344b5761344a613395565b5b835b8181101561349257803567ffffffffffffffff8111156134705761346f612e0a565b5b80860161347d8982613399565b8552602085019450505060208101905061344d565b5050509392505050565b5f82601f8301126134b0576134af612e0a565b5b81356134c0848260208601613416565b91505092915050565b5f67ffffffffffffffff8211156134e3576134e2612e12565b5b602082029050602081019050919050565b5f606082840312156135095761350861323f565b5b6135136060612e70565b90505f61352284828501612cfa565b5f83015250602061353584828501612cfa565b602083015250604082013567ffffffffffffffff81111561355957613558613243565b5b613565848285016132b8565b60408301525092915050565b5f61358361357e846134c9565b612e70565b905080838252602082019050602084028301858111156135a6576135a5613395565b5b835b818110156135ed57803567ffffffffffffffff8111156135cb576135ca612e0a565b5b8086016135d889826134f4565b855260208501945050506020810190506135a8565b5050509392505050565b5f82601f83011261360b5761360a612e0a565b5b813561361b848260208601613571565b91505092915050565b5f5f5f5f5f60a0868803121561363d5761363c612bbe565b5b5f61364a88828901612cfa565b955050602086013567ffffffffffffffff81111561366b5761366a612bc2565b5b613677888289016132e5565b945050604061368888828901612be5565b935050606086013567ffffffffffffffff8111156136a9576136a8612bc2565b5b6136b58882890161349c565b925050608086013567ffffffffffffffff8111156136d6576136d5612bc2565b5b6136e2888289016135f7565b9150509295509295909350565b5f606083015f8301516137045f860182612fc1565b5060208301516137176020860182612fc1565b506040830151848203604086015261372f8282612d71565b9150508091505092915050565b5f6020820190508181035f83015261375481846136ef565b905092915050565b5f60408201905061376f5f830185612d39565b61377c6020830184612d39565b9392505050565b5f81905092915050565b5f61379782612c24565b6137a18185613783565b93506137b1818560208601612c3e565b80840191505092915050565b7f20760000000000000000000000000000000000000000000000000000000000005f82015250565b5f6137f1600283613783565b91506137fc826137bd565b600282019050919050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f61383b600183613783565b915061384682613807565b600182019050919050565b5f61385c828761378d565b9150613867826137e5565b9150613873828661378d565b915061387e8261382f565b915061388a828561378d565b91506138958261382f565b91506138a1828461378d565b915081905095945050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6138e682612bc6565b91506138f183612bc6565b9250828201905080821115613909576139086138af565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f600282049050600182168061395357607f821691505b6020821081036139665761396561390f565b5b50919050565b5f61397682612bc6565b915061398183612bc6565b925082820261398f81612bc6565b915082820484148315176139a6576139a56138af565b5b5092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f613a1182612bc6565b9150613a1c83612bc6565b925082613a2c57613a2b6139da565b5b828204905092915050565b5f8135613a4381612bcf565b80915050919050565b5f815f1b9050919050565b5f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff613a8284613a4c565b9350801983169250808416831791505092915050565b5f819050919050565b5f613abb613ab6613ab184612bc6565b613a98565b612bc6565b9050919050565b5f819050919050565b613ad482613aa1565b613ae7613ae082613ac2565b8354613a57565b8255505050565b5f8135613afa81612ce4565b80915050919050565b5f73ffffffffffffffffffffffffffffffffffffffff613b2284613a4c565b9350801983169250808416831791505092915050565b5f613b52613b4d613b4884612cb4565b613a98565b612cb4565b9050919050565b5f613b6382613b38565b9050919050565b5f613b7482613b59565b9050919050565b5f819050919050565b613b8d82613b6a565b613ba0613b9982613b7b565b8354613b03565b8255505050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f83356001602003843603038112613bcf57613bce613ba7565b5b80840192508235915067ffffffffffffffff821115613bf157613bf0613bab565b5b602083019250600182023603831315613c0d57613c0c613baf565b5b509250929050565b5f82905092915050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f60088302613c7b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82613c40565b613c858683613c40565b95508019841693508086168417925050509392505050565b613ca683613aa1565b613cba613cb282613ac2565b848454613c4c565b825550505050565b5f5f905090565b613cd1613cc2565b613cdc818484613c9d565b505050565b5b81811015613cff57613cf45f82613cc9565b600181019050613ce2565b5050565b601f821115613d4457613d1581613c1f565b613d1e84613c31565b81016020851015613d2d578190505b613d41613d3985613c31565b830182613ce1565b50505b505050565b5f82821c905092915050565b5f613d645f1984600802613d49565b1980831691505092915050565b5f613d7c8383613d55565b9150826002028217905092915050565b613d968383613c15565b67ffffffffffffffff811115613daf57613dae612e12565b5b613db9825461393c565b613dc4828285613d03565b5f601f831160018114613df1575f8415613ddf578287013590505b613de98582613d71565b865550613e50565b601f198416613dff86613c1f565b5f5b82811015613e2657848901358255600182019150602085019450602081019050613e01565b86831015613e435784890135613e3f601f891682613d55565b8355505b6001600288020188555050505b50505050505050565b613e64838383613d8c565b505050565b5f81015f830180613e7981613a37565b9050613e858184613acb565b505050600181016020830180613e9a81613aee565b9050613ea68184613b84565b505050600281016040830180613ebb81613aee565b9050613ec78184613b84565b5050506003810160608301613edc8185613bb3565b613ee7818386613e59565b505050506004810160808301613efd8185613bb3565b613f08818386613e59565b505050505050565b613f1a8282613e69565b5050565b5f613f2c6020840184612be5565b905092915050565b5f613f426020840184612cfa565b905092915050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f83356001602003843603038112613f7257613f71613f52565b5b83810192508235915060208301925067ffffffffffffffff821115613f9a57613f99613f4a565b5b600182023603831315613fb057613faf613f4e565b5b509250929050565b5f613fc38385612d61565b9350613fd0838584612eba565b613fd983612c4c565b840190509392505050565b5f60a08301613ff55f840184613f1e565b6140015f8601826130ce565b5061400f6020840184613f34565b61401c6020860182612fc1565b5061402a6040840184613f34565b6140376040860182612fc1565b506140456060840184613f56565b8583036060870152614058838284613fb8565b925050506140696080840184613f56565b858303608087015261407c838284613fb8565b925050508091505092915050565b5f6020820190508181035f8301526140a28184613fe4565b905092915050565b6140b382612c24565b67ffffffffffffffff8111156140cc576140cb612e12565b5b6140d6825461393c565b6140e1828285613d03565b5f60209050601f831160018114614112575f8415614100578287015190505b61410a8582613d71565b865550614171565b601f19841661412086613c1f565b5f5b8281101561414757848901518255600182019150602085019450602081019050614122565b868310156141645784890151614160601f891682613d55565b8355505b6001600288020188555050505b505050505050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f606083015f8301516141b75f860182612fc1565b5060208301516141ca6020860182612fc1565b50604083015184820360408601526141e28282612d71565b9150508091505092915050565b5f6141fa83836141a2565b905092915050565b5f602082019050919050565b5f61421882614179565b6142228185614183565b93508360208202850161423485614193565b805f5b8581101561426f578484038952815161425085826141ef565b945061425b83614202565b925060208a01995050600181019050614237565b50829750879550505050505092915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f606083015f8301516142bf5f860182612fc1565b5060208301516142d26020860182612fc1565b50604083015184820360408601526142ea8282612d71565b9150508091505092915050565b5f61430283836142aa565b905092915050565b5f602082019050919050565b5f61432082614281565b61432a818561428b565b93508360208202850161433c8561429b565b805f5b85811015614377578484038952815161435885826142f7565b94506143638361430a565b925060208a0199505060018101905061433f565b50829750879550505050505092915050565b5f60a08201905061439c5f83018861303d565b81810360208301526143ae8187612da9565b90506143bd6040830186612d39565b81810360608301526143cf818561420e565b905081810360808301526143e38184614316565b90509695505050505050565b5f67ffffffffffffffff82169050919050565b61440b816143ef565b82525050565b5f6020820190506144245f830184614402565b92915050565b61443381612f90565b811461443d575f5ffd5b50565b5f8151905061444e8161442a565b92915050565b5f6020828403121561446957614468612bbe565b5b5f61447684828501614440565b91505092915050565b5f81519050919050565b5f81905092915050565b5f61449d8261447f565b6144a78185614489565b93506144b7818560208601612c3e565b80840191505092915050565b5f6144ce8284614493565b91508190509291505056fea2646970667358221220191e24d471de6c007be3fe5b9fa0c7acb7c790d11ca2569be4b5bb6450bfd2ad64736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0`@R0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x80\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP4\x80\x15a\0BW__\xFD[Pa\0Qa\0V` \x1B` \x1CV[a\x01\xB6V[_a\0ea\x01T` \x1B` \x1CV[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a\0\xAFW`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x01QWg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@Qa\x01H\x91\x90a\x01\x9DV[`@Q\x80\x91\x03\x90\xA1[PV[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a\x01\x97\x81a\x01{V[\x82RPPV[_` \x82\x01\x90Pa\x01\xB0_\x83\x01\x84a\x01\x8EV[\x92\x91PPV[`\x80QaE\x0Fa\x01\xDC_9_\x81\x81a!$\x01R\x81\x81a!y\x01Ra#3\x01RaE\x0F_\xF3\xFE`\x80`@R`\x046\x10a\x01\xCCW_5`\xE0\x1C\x80cy\xBAP\x97\x11a\0\xF6W\x80c\xC6\xB3\x02M\x11a\0\x94W\x80c\xD9\x81\x89\xA4\x11a\0cW\x80c\xD9\x81\x89\xA4\x14a\x06\x16W\x80c\xE3\x0C9x\x14a\x06>W\x80c\xEC\xBD\x96\xAB\x14a\x06hW\x80c\xF2\xFD\xE3\x8B\x14a\x06\xA4Wa\x01\xCCV[\x80c\xC6\xB3\x02M\x14a\x05bW\x80c\xCBf\x17U\x14a\x05\x8AW\x80c\xCD\xB4\xC2\xB9\x14a\x05\xB2W\x80c\xD5$K\xF1\x14a\x05\xDAWa\x01\xCCV[\x80c\x8FJ\x7F^\x11a\0\xD0W\x80c\x8FJ\x7F^\x14a\x04\xBCW\x80c\xAD<\xB1\xCC\x14a\x04\xE6W\x80c\xBD\xA0\xB9H\x14a\x05\x10W\x80c\xC6'RX\x14a\x05:Wa\x01\xCCV[\x80cy\xBAP\x97\x14a\x04@W\x80c\x8B\xB0\xA1|\x14a\x04VW\x80c\x8D\xA5\xCB[\x14a\x04\x92Wa\x01\xCCV[\x80cO\x1E\xF2\x86\x11a\x01nW\x80cg\x99\xEFR\x11a\x01=W\x80cg\x99\xEFR\x14a\x03\xB0W\x80cl\x88\xEBC\x14a\x03\xDAW\x80cp\xCC\x9A<\x14a\x04\x02W\x80cqP\x18\xA6\x14a\x04*Wa\x01\xCCV[\x80cO\x1E\xF2\x86\x14a\x02\xF2W\x80cR\xD1\x90-\x14a\x03\x0EW\x80cT\xD3\xF6u\x14a\x038W\x80cZ\xB6\xD3\xAB\x14a\x03tWa\x01\xCCV[\x80cG\xCDK>\x11a\x01\xAAW\x80cG\xCDK>\x14a\x02JW\x80cH\x14La\x14a\x02tW\x80cI\x04\x13\xAA\x14a\x02\x9EW\x80cI!\xA3\xBD\x14a\x02\xC8Wa\x01\xCCV[\x80c\x02\x19\x15\x0F\x14a\x01\xD0W\x80c\r\x8En,\x14a\x01\xF8W\x80c\x19Z\xFD\xE6\x14a\x02\"W[__\xFD[4\x80\x15a\x01\xDBW__\xFD[Pa\x01\xF6`\x04\x806\x03\x81\x01\x90a\x01\xF1\x91\x90a+\xF9V[a\x06\xCCV[\0[4\x80\x15a\x02\x03W__\xFD[Pa\x02\x0Ca\x07xV[`@Qa\x02\x19\x91\x90a,\x94V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02-W__\xFD[Pa\x02H`\x04\x806\x03\x81\x01\x90a\x02C\x91\x90a-\x0EV[a\x07\xF3V[\0[4\x80\x15a\x02UW__\xFD[Pa\x02^a\x08\x94V[`@Qa\x02k\x91\x90a-HV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\x7FW__\xFD[Pa\x02\x88a\x08\xB7V[`@Qa\x02\x95\x91\x90a-\xEAV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xA9W__\xFD[Pa\x02\xB2a\t\xFEV[`@Qa\x02\xBF\x91\x90a-HV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xD3W__\xFD[Pa\x02\xDCa\n-V[`@Qa\x02\xE9\x91\x90a-HV[`@Q\x80\x91\x03\x90\xF3[a\x03\x0C`\x04\x806\x03\x81\x01\x90a\x03\x07\x91\x90a/6V[a\nDV[\0[4\x80\x15a\x03\x19W__\xFD[Pa\x03\"a\ncV[`@Qa\x03/\x91\x90a/\xA8V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03CW__\xFD[Pa\x03^`\x04\x806\x03\x81\x01\x90a\x03Y\x91\x90a-\x0EV[a\n\x94V[`@Qa\x03k\x91\x90a0\x1DV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x7FW__\xFD[Pa\x03\x9A`\x04\x806\x03\x81\x01\x90a\x03\x95\x91\x90a+\xF9V[a\x0C2V[`@Qa\x03\xA7\x91\x90a0LV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xBBW__\xFD[Pa\x03\xC4a\x0C\x84V[`@Qa\x03\xD1\x91\x90a-HV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xE5W__\xFD[Pa\x04\0`\x04\x806\x03\x81\x01\x90a\x03\xFB\x91\x90a-\x0EV[a\x0C\xB6V[\0[4\x80\x15a\x04\rW__\xFD[Pa\x04(`\x04\x806\x03\x81\x01\x90a\x04#\x91\x90a0\x87V[a\rRV[\0[4\x80\x15a\x045W__\xFD[Pa\x04>a\x0E\xA3V[\0[4\x80\x15a\x04KW__\xFD[Pa\x04Ta\x0E\xB6V[\0[4\x80\x15a\x04aW__\xFD[Pa\x04|`\x04\x806\x03\x81\x01\x90a\x04w\x91\x90a+\xF9V[a\x0FDV[`@Qa\x04\x89\x91\x90a1WV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x9DW__\xFD[Pa\x04\xA6a\x11_V[`@Qa\x04\xB3\x91\x90a0LV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xC7W__\xFD[Pa\x04\xD0a\x11\x94V[`@Qa\x04\xDD\x91\x90a2\x1FV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xF1W__\xFD[Pa\x04\xFAa\x12-V[`@Qa\x05\x07\x91\x90a,\x94V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\x1BW__\xFD[Pa\x05$a\x12fV[`@Qa\x051\x91\x90a2\x1FV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05EW__\xFD[Pa\x05``\x04\x806\x03\x81\x01\x90a\x05[\x91\x90a-\x0EV[a\x12\xFFV[\0[4\x80\x15a\x05mW__\xFD[Pa\x05\x88`\x04\x806\x03\x81\x01\x90a\x05\x83\x91\x90a+\xF9V[a\x13\x9BV[\0[4\x80\x15a\x05\x95W__\xFD[Pa\x05\xB0`\x04\x806\x03\x81\x01\x90a\x05\xAB\x91\x90a-\x0EV[a\x14\x0BV[\0[4\x80\x15a\x05\xBDW__\xFD[Pa\x05\xD8`\x04\x806\x03\x81\x01\x90a\x05\xD3\x91\x90a-\x0EV[a\x14\xA7V[\0[4\x80\x15a\x05\xE5W__\xFD[Pa\x06\0`\x04\x806\x03\x81\x01\x90a\x05\xFB\x91\x90a+\xF9V[a\x15CV[`@Qa\x06\r\x91\x90a0LV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06!W__\xFD[Pa\x06<`\x04\x806\x03\x81\x01\x90a\x067\x91\x90a6$V[a\x15\x95V[\0[4\x80\x15a\x06IW__\xFD[Pa\x06Ra\x1D\x1EV[`@Qa\x06_\x91\x90a0LV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06sW__\xFD[Pa\x06\x8E`\x04\x806\x03\x81\x01\x90a\x06\x89\x91\x90a-\x0EV[a\x1DSV[`@Qa\x06\x9B\x91\x90a7<V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xAFW__\xFD[Pa\x06\xCA`\x04\x806\x03\x81\x01\x90a\x06\xC5\x91\x90a-\x0EV[a\x1E\xF1V[\0[a\x06\xD4a\x1F\xAAV[_a\x06\xDDa 1V[\x90P\x80`\t\x01\x80T\x90P\x82\x11\x15a\x074W\x81\x81`\t\x01\x80T\x90P`@Q\x7FHgo\xE0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x07+\x92\x91\x90a7\\V[`@Q\x80\x91\x03\x90\xFD[\x81\x81`\n\x01\x81\x90UP\x7F\xEAle!\xBCIW1\x08.#\xAD\x12\xC7\xB1 }\x13\xCA\x0B\xD3\x8D\x1DQ\x10\x81\xABV\x89\x17\xCB\x84\x82`@Qa\x07l\x91\x90a-HV[`@Q\x80\x91\x03\x90\xA1PPV[```@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7FHTTPZ\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa\x07\xB9_a XV[a\x07\xC3`\x01a XV[a\x07\xCC_a XV[`@Q` \x01a\x07\xDF\x94\x93\x92\x91\x90a8QV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P\x90V[_a\x07\xFCa 1V[\x90P\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x08\x90W\x81`@Q\x7F j4n\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x08\x87\x91\x90a0LV[`@Q\x80\x91\x03\x90\xFD[PPV[__a\x08\x9Ea 1V[\x90P`\x01\x81`\n\x01Ta\x08\xB1\x91\x90a8\xDCV[\x91PP\x90V[a\x08\xBFa*\xADV[_a\x08\xC8a 1V[\x90P\x80`\x06\x01`@Q\x80`@\x01`@R\x90\x81_\x82\x01\x80Ta\x08\xE8\x90a9<V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\t\x14\x90a9<V[\x80\x15a\t_W\x80`\x1F\x10a\t6Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\t_V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\tBW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01\x80Ta\tx\x90a9<V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\t\xA4\x90a9<V[\x80\x15a\t\xEFW\x80`\x1F\x10a\t\xC6Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\t\xEFV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\t\xD2W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x91PP\x90V[__a\n\x08a 1V[\x90P`\x01\x81`\n\x01T`\x02a\n\x1D\x91\x90a9lV[a\n'\x91\x90a8\xDCV[\x91PP\x90V[__a\n7a 1V[\x90P\x80`\n\x01T\x91PP\x90V[a\nLa!\"V[a\nU\x82a\"\x08V[a\n_\x82\x82a\"\x13V[PPV[_a\nla#1V[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x90P\x90V[a\n\x9Ca*\xC7V[_a\n\xA5a 1V[\x90P\x80`\x08\x01_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `@Q\x80``\x01`@R\x90\x81_\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01\x80Ta\x0B\xAA\x90a9<V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0B\xD6\x90a9<V[\x80\x15a\x0C!W\x80`\x1F\x10a\x0B\xF8Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0C!V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0C\x04W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x91PP\x91\x90PV[__a\x0C<a 1V[\x90P\x80`\x0C\x01\x83\x81T\x81\x10a\x0CTWa\x0CSa9\xADV[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x91\x90PV[__a\x0C\x8Ea 1V[\x90P`\x01`\x02\x82`\x0C\x01\x80T\x90Pa\x0C\xA6\x91\x90a:\x07V[a\x0C\xB0\x91\x90a8\xDCV[\x91PP\x90V[_a\x0C\xBFa 1V[\x90P\x80`\x02\x01_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\rNW\x81`@Q\x7F*|n\xF6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\rE\x91\x90a0LV[`@Q\x80\x91\x03\x90\xFD[PPV[_\x81_\x015\x03a\r\x8EW`@Q\x7F\"\xF7?\xEA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a\r\x97a 1V[\x90P\x80`\x05\x01_\x83_\x015\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a\x0E\x01W\x81_\x015`@Q\x7F\xB1\x82\\^\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\r\xF8\x91\x90a-HV[`@Q\x80\x91\x03\x90\xFD[\x80`\r\x01\x82\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x05\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a\x0E8\x91\x90a?\x10V[PP`\x01\x81`\x05\x01_\x84_\x015\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xB8 {[\xB7\x91s\n\xE8\xF0SO\xA4\xC7\xBE}\xA4\x9D\xD7]p\x1F\x9Cz\xCFQ\xC9K\x8A\xCE\x96\xB2\x82`@Qa\x0E\x97\x91\x90a@\x8AV[`@Q\x80\x91\x03\x90\xA1PPV[a\x0E\xABa\x1F\xAAV[a\x0E\xB4_a#\xB8V[V[_a\x0E\xBFa#\xF5V[\x90P\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x0E\xE0a\x1D\x1EV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x0F8W\x80`@Q\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0F/\x91\x90a0LV[`@Q\x80\x91\x03\x90\xFD[a\x0FA\x81a#\xB8V[PV[a\x0FLa+\x12V[_a\x0FUa 1V[\x90P\x80`\r\x01\x83\x81T\x81\x10a\x0FmWa\x0Fla9\xADV[[\x90_R` _ \x90`\x05\x02\x01`@Q\x80`\xA0\x01`@R\x90\x81_\x82\x01T\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01\x80Ta\x10G\x90a9<V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x10s\x90a9<V[\x80\x15a\x10\xBEW\x80`\x1F\x10a\x10\x95Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x10\xBEV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x10\xA1W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x04\x82\x01\x80Ta\x10\xD7\x90a9<V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x11\x03\x90a9<V[\x80\x15a\x11NW\x80`\x1F\x10a\x11%Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x11NV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x111W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x91PP\x91\x90PV[__a\x11ia#\xFCV[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x90V[``_a\x11\x9Fa 1V[\x90P\x80`\x0C\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x12\"W` \x02\x82\x01\x91\x90_R` _ \x90[\x81_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x11\xD9W[PPPPP\x91PP\x90V[`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x81V[``_a\x12qa 1V[\x90P\x80`\t\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x12\xF4W` \x02\x82\x01\x91\x90_R` _ \x90[\x81_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x12\xABW[PPPPP\x91PP\x90V[_a\x13\x08a 1V[\x90P\x80`\x01\x01_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x13\x97W\x81`@Q\x7F\xAE\xE8c#\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\x8E\x91\x90a0LV[`@Q\x80\x91\x03\x90\xFD[PPV[_a\x13\xA4a 1V[\x90P\x80`\x05\x01_\x83\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x14\x07W\x81`@Q\x7Fm\xF6\xFE\x89\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\xFE\x91\x90a-HV[`@Q\x80\x91\x03\x90\xFD[PPV[_a\x14\x14a 1V[\x90P\x80`\x03\x01_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x14\xA3W\x81`@Q\x7FR\xD7%\xF5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14\x9A\x91\x90a0LV[`@Q\x80\x91\x03\x90\xFD[PPV[_a\x14\xB0a 1V[\x90P\x80`\x04\x01_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x15?W\x81`@Q\x7F&\xCDu\xDC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x156\x91\x90a0LV[`@Q\x80\x91\x03\x90\xFD[PPV[__a\x15Ma 1V[\x90P\x80`\t\x01\x83\x81T\x81\x10a\x15eWa\x15da9\xADV[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x91\x90PV[`\x02_a\x15\xA0a$#V[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a\x15\xE8WP\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15[\x15a\x16\x1FW`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPa\x16ta\x16oa\x11_V[a$JV[_a\x16}a 1V[\x90P\x86\x81`\x06\x01_\x82\x01Q\x81_\x01\x90\x81a\x16\x97\x91\x90a@\xAAV[P` \x82\x01Q\x81`\x01\x01\x90\x81a\x16\xAD\x91\x90a@\xAAV[P\x90PP\x87\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP_\x85Q\x90P\x80\x87\x11\x15a\x17>W\x86\x81`@Q\x7FHgo\xE0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x175\x92\x91\x90a7\\V[`@Q\x80\x91\x03\x90\xFD[\x86\x82`\n\x01\x81\x90UP__\x90P[\x81\x81\x10\x15a\x19\xE3W`\x01\x83`\x01\x01_\x89\x84\x81Q\x81\x10a\x17nWa\x17ma9\xADV[[` \x02` \x01\x01Q_\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x86\x81\x81Q\x81\x10a\x17\xDBWa\x17\xDAa9\xADV[[` \x02` \x01\x01Q\x83`\x08\x01_\x89\x84\x81Q\x81\x10a\x17\xFBWa\x17\xFAa9\xADV[[` \x02` \x01\x01Q_\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x82\x01Q\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP` \x82\x01Q\x81`\x01\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`@\x82\x01Q\x81`\x02\x01\x90\x81a\x18\xDE\x91\x90a@\xAAV[P\x90PP\x82`\t\x01\x87\x82\x81Q\x81\x10a\x18\xF9Wa\x18\xF8a9\xADV[[` \x02` \x01\x01Q_\x01Q\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x83`\x02\x01_\x89\x84\x81Q\x81\x10a\x19{Wa\x19za9\xADV[[` \x02` \x01\x01Q` \x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x80\x80`\x01\x01\x91PPa\x17LV[P__\x90P[\x85Q\x81\x10\x15a\x1C\x81W`\x01\x83`\x03\x01_\x88\x84\x81Q\x81\x10a\x1A\x0CWa\x1A\x0Ba9\xADV[[` \x02` \x01\x01Q_\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x85\x81\x81Q\x81\x10a\x1AyWa\x1Axa9\xADV[[` \x02` \x01\x01Q\x83`\x0B\x01_\x88\x84\x81Q\x81\x10a\x1A\x99Wa\x1A\x98a9\xADV[[` \x02` \x01\x01Q_\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x82\x01Q\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP` \x82\x01Q\x81`\x01\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`@\x82\x01Q\x81`\x02\x01\x90\x81a\x1B|\x91\x90a@\xAAV[P\x90PP\x82`\x0C\x01\x86\x82\x81Q\x81\x10a\x1B\x97Wa\x1B\x96a9\xADV[[` \x02` \x01\x01Q_\x01Q\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x83`\x04\x01_\x88\x84\x81Q\x81\x10a\x1C\x19Wa\x1C\x18a9\xADV[[` \x02` \x01\x01Q` \x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x80\x80`\x01\x01\x91PPa\x19\xE9V[P\x7F\xF3=\x90\x8CJ\x8BS/\xE6M\xF2\x0Bro\x11@\\\x11\xB9w-1\xB6o^\xEFh\x87\xA4<?\xDE\x89\x89\x89\x89\x89`@Qa\x1C\xB9\x95\x94\x93\x92\x91\x90aC\x89V[`@Q\x80\x91\x03\x90\xA1PP_\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x82`@Qa\x1D\r\x91\x90aD\x11V[`@Q\x80\x91\x03\x90\xA1PPPPPPPV[__a\x1D(a$^V[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x90V[a\x1D[a+jV[_a\x1Dda 1V[\x90P\x80`\x0B\x01_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `@Q\x80``\x01`@R\x90\x81_\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01\x80Ta\x1Ei\x90a9<V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x1E\x95\x90a9<V[\x80\x15a\x1E\xE0W\x80`\x1F\x10a\x1E\xB7Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x1E\xE0V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x1E\xC3W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x91PP\x91\x90PV[a\x1E\xF9a\x1F\xAAV[_a\x1F\x02a$^V[\x90P\x81\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1Fda\x11_V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F8\xD1k\x8C\xAC\"\xD9\x9F\xC7\xC1$\xB9\xCD\r\xE2\xD3\xFA\x1F\xAE\xF4 \xBF\xE7\x91\xD8\xC3b\xD7e\xE2'\0`@Q`@Q\x80\x91\x03\x90\xA3PPV[a\x1F\xB2a#\xF5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1F\xD0a\x11_V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a /Wa\x1F\xF3a#\xF5V[`@Q\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a &\x91\x90a0LV[`@Q\x80\x91\x03\x90\xFD[V[_\x7F\x82qv\xA4^\x1A\xAD\x1F:e9\xFE\xE6\x0C\x06\x12l@B{HI\xE70\x1B\xF2\xCF\x0F\x1F\x8E\x95\0\x90P\x90V[``_`\x01a f\x84a$\x85V[\x01\x90P_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a \x84Wa \x83a.\x12V[[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a \xB6W\x81` \x01`\x01\x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x90P_\x82` \x01\x82\x01\x90P[`\x01\x15a!\x17W\x80\x80`\x01\x90\x03\x91PP\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\n\x86\x06\x1A\x81S`\n\x85\x81a!\x0CWa!\x0Ba9\xDAV[[\x04\x94P_\x85\x03a \xC3W[\x81\x93PPPP\x91\x90PV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x80a!\xCFWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a!\xB6a%\xD6V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15a\"\x06W`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[a\"\x10a\x1F\xAAV[PV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cR\xD1\x90-`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15a\"{WP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\"x\x91\x90aDTV[`\x01[a\"\xBCW\x81`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\"\xB3\x91\x90a0LV[`@Q\x80\x91\x03\x90\xFD[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x81\x14a#\"W\x80`@Q\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a#\x19\x91\x90a/\xA8V[`@Q\x80\x91\x03\x90\xFD[a#,\x83\x83a&)V[PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a#\xB6W`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_a#\xC1a$^V[\x90P\x80_\x01_a\x01\0\n\x81T\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90Ua#\xF1\x82a&\x9BV[PPV[_3\x90P\x90V[_\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0\x90P\x90V[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[a$Ra'lV[a$[\x81a'\xACV[PV[_\x7F#~\x15\x82\"\xE3\xE6\x96\x8Br\xB9\xDB\r\x80C\xAA\xCF\x07J\xD9\xF6P\xF0\xD1`kM\x82\xEEC,\0\x90P\x90V[___\x90Pz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x10a$\xE1Wz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x81a$\xD7Wa$\xD6a9\xDAV[[\x04\x92P`@\x81\x01\x90P[m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x10a%\x1EWm\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x81a%\x14Wa%\x13a9\xDAV[[\x04\x92P` \x81\x01\x90P[f#\x86\xF2o\xC1\0\0\x83\x10a%MWf#\x86\xF2o\xC1\0\0\x83\x81a%CWa%Ba9\xDAV[[\x04\x92P`\x10\x81\x01\x90P[c\x05\xF5\xE1\0\x83\x10a%vWc\x05\xF5\xE1\0\x83\x81a%lWa%ka9\xDAV[[\x04\x92P`\x08\x81\x01\x90P[a'\x10\x83\x10a%\x9BWa'\x10\x83\x81a%\x91Wa%\x90a9\xDAV[[\x04\x92P`\x04\x81\x01\x90P[`d\x83\x10a%\xBEW`d\x83\x81a%\xB4Wa%\xB3a9\xDAV[[\x04\x92P`\x02\x81\x01\x90P[`\n\x83\x10a%\xCDW`\x01\x81\x01\x90P[\x80\x91PP\x91\x90PV[_a&\x02\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Ba(0V[_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[a&2\x82a(9V[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;`@Q`@Q\x80\x91\x03\x90\xA2_\x81Q\x11\x15a&\x8EWa&\x88\x82\x82a)\x02V[Pa&\x97V[a&\x96a)\x82V[[PPV[_a&\xA4a#\xFCV[\x90P_\x81_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x82\x82_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPPV[a'ta)\xBEV[a'\xAAW`@Q\x7F\xD7\xE6\xBC\xF8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[a'\xB4a'lV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a($W_`@Q\x7F\x1EO\xBD\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a(\x1B\x91\x90a0LV[`@Q\x80\x91\x03\x90\xFD[a(-\x81a#\xB8V[PV[_\x81\x90P\x91\x90PV[_\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x03a(\x94W\x80`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a(\x8B\x91\x90a0LV[`@Q\x80\x91\x03\x90\xFD[\x80a(\xC0\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Ba(0V[_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[``__\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84`@Qa)+\x91\x90aD\xC3V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a)cW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a)hV[``\x91P[P\x91P\x91Pa)x\x85\x83\x83a)\xDCV[\x92PPP\x92\x91PPV[_4\x11\x15a)\xBCW`@Q\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_a)\xC7a$#V[_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x90P\x90V[``\x82a)\xF1Wa)\xEC\x82a*iV[a*aV[_\x82Q\x14\x80\x15a*\x17WP_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x14[\x15a*YW\x83`@Q\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a*P\x91\x90a0LV[`@Q\x80\x91\x03\x90\xFD[\x81\x90Pa*bV[[\x93\x92PPPV[_\x81Q\x11\x15a*{W\x80Q\x80\x82` \x01\xFD[`@Q\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Q\x80`@\x01`@R\x80``\x81R` \x01``\x81RP\x90V[`@Q\x80``\x01`@R\x80_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01``\x81RP\x90V[`@Q\x80`\xA0\x01`@R\x80_\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01``\x81R` \x01``\x81RP\x90V[`@Q\x80``\x01`@R\x80_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01``\x81RP\x90V[_`@Q\x90P\x90V[__\xFD[__\xFD[_\x81\x90P\x91\x90PV[a+\xD8\x81a+\xC6V[\x81\x14a+\xE2W__\xFD[PV[_\x815\x90Pa+\xF3\x81a+\xCFV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a,\x0EWa,\ra+\xBEV[[_a,\x1B\x84\x82\x85\x01a+\xE5V[\x91PP\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x82\x81\x83^_\x83\x83\x01RPPPV[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[_a,f\x82a,$V[a,p\x81\x85a,.V[\x93Pa,\x80\x81\x85` \x86\x01a,>V[a,\x89\x81a,LV[\x84\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra,\xAC\x81\x84a,\\V[\x90P\x92\x91PPV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a,\xDD\x82a,\xB4V[\x90P\x91\x90PV[a,\xED\x81a,\xD3V[\x81\x14a,\xF7W__\xFD[PV[_\x815\x90Pa-\x08\x81a,\xE4V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a-#Wa-\"a+\xBEV[[_a-0\x84\x82\x85\x01a,\xFAV[\x91PP\x92\x91PPV[a-B\x81a+\xC6V[\x82RPPV[_` \x82\x01\x90Pa-[_\x83\x01\x84a-9V[\x92\x91PPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_a-{\x82a,$V[a-\x85\x81\x85a-aV[\x93Pa-\x95\x81\x85` \x86\x01a,>V[a-\x9E\x81a,LV[\x84\x01\x91PP\x92\x91PPV[_`@\x83\x01_\x83\x01Q\x84\x82\x03_\x86\x01Ra-\xC3\x82\x82a-qV[\x91PP` \x83\x01Q\x84\x82\x03` \x86\x01Ra-\xDD\x82\x82a-qV[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra.\x02\x81\x84a-\xA9V[\x90P\x92\x91PPV[__\xFD[__\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[a.H\x82a,LV[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a.gWa.fa.\x12V[[\x80`@RPPPV[_a.ya+\xB5V[\x90Pa.\x85\x82\x82a.?V[\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a.\xA4Wa.\xA3a.\x12V[[a.\xAD\x82a,LV[\x90P` \x81\x01\x90P\x91\x90PV[\x82\x81\x837_\x83\x83\x01RPPPV[_a.\xDAa.\xD5\x84a.\x8AV[a.pV[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a.\xF6Wa.\xF5a.\x0EV[[a/\x01\x84\x82\x85a.\xBAV[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a/\x1DWa/\x1Ca.\nV[[\x815a/-\x84\x82` \x86\x01a.\xC8V[\x91PP\x92\x91PPV[__`@\x83\x85\x03\x12\x15a/LWa/Ka+\xBEV[[_a/Y\x85\x82\x86\x01a,\xFAV[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a/zWa/ya+\xC2V[[a/\x86\x85\x82\x86\x01a/\tV[\x91PP\x92P\x92\x90PV[_\x81\x90P\x91\x90PV[a/\xA2\x81a/\x90V[\x82RPPV[_` \x82\x01\x90Pa/\xBB_\x83\x01\x84a/\x99V[\x92\x91PPV[a/\xCA\x81a,\xD3V[\x82RPPV[_``\x83\x01_\x83\x01Qa/\xE5_\x86\x01\x82a/\xC1V[P` \x83\x01Qa/\xF8` \x86\x01\x82a/\xC1V[P`@\x83\x01Q\x84\x82\x03`@\x86\x01Ra0\x10\x82\x82a-qV[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra05\x81\x84a/\xD0V[\x90P\x92\x91PPV[a0F\x81a,\xD3V[\x82RPPV[_` \x82\x01\x90Pa0__\x83\x01\x84a0=V[\x92\x91PPV[__\xFD[_`\xA0\x82\x84\x03\x12\x15a0~Wa0}a0eV[[\x81\x90P\x92\x91PPV[_` \x82\x84\x03\x12\x15a0\x9CWa0\x9Ba+\xBEV[[_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a0\xB9Wa0\xB8a+\xC2V[[a0\xC5\x84\x82\x85\x01a0iV[\x91PP\x92\x91PPV[a0\xD7\x81a+\xC6V[\x82RPPV[_`\xA0\x83\x01_\x83\x01Qa0\xF2_\x86\x01\x82a0\xCEV[P` \x83\x01Qa1\x05` \x86\x01\x82a/\xC1V[P`@\x83\x01Qa1\x18`@\x86\x01\x82a/\xC1V[P``\x83\x01Q\x84\x82\x03``\x86\x01Ra10\x82\x82a-qV[\x91PP`\x80\x83\x01Q\x84\x82\x03`\x80\x86\x01Ra1J\x82\x82a-qV[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra1o\x81\x84a0\xDDV[\x90P\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_a1\xAB\x83\x83a/\xC1V[` \x83\x01\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_a1\xCD\x82a1wV[a1\xD7\x81\x85a1\x81V[\x93Pa1\xE2\x83a1\x91V[\x80_[\x83\x81\x10\x15a2\x12W\x81Qa1\xF9\x88\x82a1\xA0V[\x97Pa2\x04\x83a1\xB7V[\x92PP`\x01\x81\x01\x90Pa1\xE5V[P\x85\x93PPPP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra27\x81\x84a1\xC3V[\x90P\x92\x91PPV[__\xFD[__\xFD[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a2aWa2`a.\x12V[[a2j\x82a,LV[\x90P` \x81\x01\x90P\x91\x90PV[_a2\x89a2\x84\x84a2GV[a.pV[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a2\xA5Wa2\xA4a.\x0EV[[a2\xB0\x84\x82\x85a.\xBAV[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a2\xCCWa2\xCBa.\nV[[\x815a2\xDC\x84\x82` \x86\x01a2wV[\x91PP\x92\x91PPV[_`@\x82\x84\x03\x12\x15a2\xFAWa2\xF9a2?V[[a3\x04`@a.pV[\x90P_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a3#Wa3\"a2CV[[a3/\x84\x82\x85\x01a2\xB8V[_\x83\x01RP` \x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a3RWa3Qa2CV[[a3^\x84\x82\x85\x01a2\xB8V[` \x83\x01RP\x92\x91PPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a3\x84Wa3\x83a.\x12V[[` \x82\x02\x90P` \x81\x01\x90P\x91\x90PV[__\xFD[_``\x82\x84\x03\x12\x15a3\xAEWa3\xADa2?V[[a3\xB8``a.pV[\x90P_a3\xC7\x84\x82\x85\x01a,\xFAV[_\x83\x01RP` a3\xDA\x84\x82\x85\x01a,\xFAV[` \x83\x01RP`@\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a3\xFEWa3\xFDa2CV[[a4\n\x84\x82\x85\x01a2\xB8V[`@\x83\x01RP\x92\x91PPV[_a4(a4#\x84a3jV[a.pV[\x90P\x80\x83\x82R` \x82\x01\x90P` \x84\x02\x83\x01\x85\x81\x11\x15a4KWa4Ja3\x95V[[\x83[\x81\x81\x10\x15a4\x92W\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a4pWa4oa.\nV[[\x80\x86\x01a4}\x89\x82a3\x99V[\x85R` \x85\x01\x94PPP` \x81\x01\x90Pa4MV[PPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a4\xB0Wa4\xAFa.\nV[[\x815a4\xC0\x84\x82` \x86\x01a4\x16V[\x91PP\x92\x91PPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a4\xE3Wa4\xE2a.\x12V[[` \x82\x02\x90P` \x81\x01\x90P\x91\x90PV[_``\x82\x84\x03\x12\x15a5\tWa5\x08a2?V[[a5\x13``a.pV[\x90P_a5\"\x84\x82\x85\x01a,\xFAV[_\x83\x01RP` a55\x84\x82\x85\x01a,\xFAV[` \x83\x01RP`@\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a5YWa5Xa2CV[[a5e\x84\x82\x85\x01a2\xB8V[`@\x83\x01RP\x92\x91PPV[_a5\x83a5~\x84a4\xC9V[a.pV[\x90P\x80\x83\x82R` \x82\x01\x90P` \x84\x02\x83\x01\x85\x81\x11\x15a5\xA6Wa5\xA5a3\x95V[[\x83[\x81\x81\x10\x15a5\xEDW\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a5\xCBWa5\xCAa.\nV[[\x80\x86\x01a5\xD8\x89\x82a4\xF4V[\x85R` \x85\x01\x94PPP` \x81\x01\x90Pa5\xA8V[PPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a6\x0BWa6\na.\nV[[\x815a6\x1B\x84\x82` \x86\x01a5qV[\x91PP\x92\x91PPV[_____`\xA0\x86\x88\x03\x12\x15a6=Wa6<a+\xBEV[[_a6J\x88\x82\x89\x01a,\xFAV[\x95PP` \x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a6kWa6ja+\xC2V[[a6w\x88\x82\x89\x01a2\xE5V[\x94PP`@a6\x88\x88\x82\x89\x01a+\xE5V[\x93PP``\x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a6\xA9Wa6\xA8a+\xC2V[[a6\xB5\x88\x82\x89\x01a4\x9CV[\x92PP`\x80\x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a6\xD6Wa6\xD5a+\xC2V[[a6\xE2\x88\x82\x89\x01a5\xF7V[\x91PP\x92\x95P\x92\x95\x90\x93PV[_``\x83\x01_\x83\x01Qa7\x04_\x86\x01\x82a/\xC1V[P` \x83\x01Qa7\x17` \x86\x01\x82a/\xC1V[P`@\x83\x01Q\x84\x82\x03`@\x86\x01Ra7/\x82\x82a-qV[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra7T\x81\x84a6\xEFV[\x90P\x92\x91PPV[_`@\x82\x01\x90Pa7o_\x83\x01\x85a-9V[a7|` \x83\x01\x84a-9V[\x93\x92PPPV[_\x81\x90P\x92\x91PPV[_a7\x97\x82a,$V[a7\xA1\x81\x85a7\x83V[\x93Pa7\xB1\x81\x85` \x86\x01a,>V[\x80\x84\x01\x91PP\x92\x91PPV[\x7F v\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a7\xF1`\x02\x83a7\x83V[\x91Pa7\xFC\x82a7\xBDV[`\x02\x82\x01\x90P\x91\x90PV[\x7F.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a8;`\x01\x83a7\x83V[\x91Pa8F\x82a8\x07V[`\x01\x82\x01\x90P\x91\x90PV[_a8\\\x82\x87a7\x8DV[\x91Pa8g\x82a7\xE5V[\x91Pa8s\x82\x86a7\x8DV[\x91Pa8~\x82a8/V[\x91Pa8\x8A\x82\x85a7\x8DV[\x91Pa8\x95\x82a8/V[\x91Pa8\xA1\x82\x84a7\x8DV[\x91P\x81\x90P\x95\x94PPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_a8\xE6\x82a+\xC6V[\x91Pa8\xF1\x83a+\xC6V[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15a9\tWa9\x08a8\xAFV[[\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\"`\x04R`$_\xFD[_`\x02\x82\x04\x90P`\x01\x82\x16\x80a9SW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a9fWa9ea9\x0FV[[P\x91\x90PV[_a9v\x82a+\xC6V[\x91Pa9\x81\x83a+\xC6V[\x92P\x82\x82\x02a9\x8F\x81a+\xC6V[\x91P\x82\x82\x04\x84\x14\x83\x15\x17a9\xA6Wa9\xA5a8\xAFV[[P\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_a:\x11\x82a+\xC6V[\x91Pa:\x1C\x83a+\xC6V[\x92P\x82a:,Wa:+a9\xDAV[[\x82\x82\x04\x90P\x92\x91PPV[_\x815a:C\x81a+\xCFV[\x80\x91PP\x91\x90PV[_\x81_\x1B\x90P\x91\x90PV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa:\x82\x84a:LV[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[_\x81\x90P\x91\x90PV[_a:\xBBa:\xB6a:\xB1\x84a+\xC6V[a:\x98V[a+\xC6V[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a:\xD4\x82a:\xA1V[a:\xE7a:\xE0\x82a:\xC2V[\x83Ta:WV[\x82UPPPV[_\x815a:\xFA\x81a,\xE4V[\x80\x91PP\x91\x90PV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa;\"\x84a:LV[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[_a;Ra;Ma;H\x84a,\xB4V[a:\x98V[a,\xB4V[\x90P\x91\x90PV[_a;c\x82a;8V[\x90P\x91\x90PV[_a;t\x82a;YV[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a;\x8D\x82a;jV[a;\xA0a;\x99\x82a;{V[\x83Ta;\x03V[\x82UPPPV[__\xFD[__\xFD[__\xFD[__\x835`\x01` \x03\x846\x03\x03\x81\x12a;\xCFWa;\xCEa;\xA7V[[\x80\x84\x01\x92P\x825\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a;\xF1Wa;\xF0a;\xABV[[` \x83\x01\x92P`\x01\x82\x026\x03\x83\x13\x15a<\rWa<\x0Ca;\xAFV[[P\x92P\x92\x90PV[_\x82\x90P\x92\x91PPV[_\x81\x90P\x81_R` _ \x90P\x91\x90PV[_` `\x1F\x83\x01\x04\x90P\x91\x90PV[_\x82\x82\x1B\x90P\x92\x91PPV[_`\x08\x83\x02a<{\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82a<@V[a<\x85\x86\x83a<@V[\x95P\x80\x19\x84\x16\x93P\x80\x86\x16\x84\x17\x92PPP\x93\x92PPPV[a<\xA6\x83a:\xA1V[a<\xBAa<\xB2\x82a:\xC2V[\x84\x84Ta<LV[\x82UPPPPV[__\x90P\x90V[a<\xD1a<\xC2V[a<\xDC\x81\x84\x84a<\x9DV[PPPV[[\x81\x81\x10\x15a<\xFFWa<\xF4_\x82a<\xC9V[`\x01\x81\x01\x90Pa<\xE2V[PPV[`\x1F\x82\x11\x15a=DWa=\x15\x81a<\x1FV[a=\x1E\x84a<1V[\x81\x01` \x85\x10\x15a=-W\x81\x90P[a=Aa=9\x85a<1V[\x83\x01\x82a<\xE1V[PP[PPPV[_\x82\x82\x1C\x90P\x92\x91PPV[_a=d_\x19\x84`\x08\x02a=IV[\x19\x80\x83\x16\x91PP\x92\x91PPV[_a=|\x83\x83a=UV[\x91P\x82`\x02\x02\x82\x17\x90P\x92\x91PPV[a=\x96\x83\x83a<\x15V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a=\xAFWa=\xAEa.\x12V[[a=\xB9\x82Ta9<V[a=\xC4\x82\x82\x85a=\x03V[_`\x1F\x83\x11`\x01\x81\x14a=\xF1W_\x84\x15a=\xDFW\x82\x87\x015\x90P[a=\xE9\x85\x82a=qV[\x86UPa>PV[`\x1F\x19\x84\x16a=\xFF\x86a<\x1FV[_[\x82\x81\x10\x15a>&W\x84\x89\x015\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Pa>\x01V[\x86\x83\x10\x15a>CW\x84\x89\x015a>?`\x1F\x89\x16\x82a=UV[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPPV[a>d\x83\x83\x83a=\x8CV[PPPV[_\x81\x01_\x83\x01\x80a>y\x81a:7V[\x90Pa>\x85\x81\x84a:\xCBV[PPP`\x01\x81\x01` \x83\x01\x80a>\x9A\x81a:\xEEV[\x90Pa>\xA6\x81\x84a;\x84V[PPP`\x02\x81\x01`@\x83\x01\x80a>\xBB\x81a:\xEEV[\x90Pa>\xC7\x81\x84a;\x84V[PPP`\x03\x81\x01``\x83\x01a>\xDC\x81\x85a;\xB3V[a>\xE7\x81\x83\x86a>YV[PPPP`\x04\x81\x01`\x80\x83\x01a>\xFD\x81\x85a;\xB3V[a?\x08\x81\x83\x86a>YV[PPPPPPV[a?\x1A\x82\x82a>iV[PPV[_a?,` \x84\x01\x84a+\xE5V[\x90P\x92\x91PPV[_a?B` \x84\x01\x84a,\xFAV[\x90P\x92\x91PPV[__\xFD[__\xFD[__\xFD[__\x835`\x01` \x03\x846\x03\x03\x81\x12a?rWa?qa?RV[[\x83\x81\x01\x92P\x825\x91P` \x83\x01\x92Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a?\x9AWa?\x99a?JV[[`\x01\x82\x026\x03\x83\x13\x15a?\xB0Wa?\xAFa?NV[[P\x92P\x92\x90PV[_a?\xC3\x83\x85a-aV[\x93Pa?\xD0\x83\x85\x84a.\xBAV[a?\xD9\x83a,LV[\x84\x01\x90P\x93\x92PPPV[_`\xA0\x83\x01a?\xF5_\x84\x01\x84a?\x1EV[a@\x01_\x86\x01\x82a0\xCEV[Pa@\x0F` \x84\x01\x84a?4V[a@\x1C` \x86\x01\x82a/\xC1V[Pa@*`@\x84\x01\x84a?4V[a@7`@\x86\x01\x82a/\xC1V[Pa@E``\x84\x01\x84a?VV[\x85\x83\x03``\x87\x01Ra@X\x83\x82\x84a?\xB8V[\x92PPPa@i`\x80\x84\x01\x84a?VV[\x85\x83\x03`\x80\x87\x01Ra@|\x83\x82\x84a?\xB8V[\x92PPP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra@\xA2\x81\x84a?\xE4V[\x90P\x92\x91PPV[a@\xB3\x82a,$V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a@\xCCWa@\xCBa.\x12V[[a@\xD6\x82Ta9<V[a@\xE1\x82\x82\x85a=\x03V[_` \x90P`\x1F\x83\x11`\x01\x81\x14aA\x12W_\x84\x15aA\0W\x82\x87\x01Q\x90P[aA\n\x85\x82a=qV[\x86UPaAqV[`\x1F\x19\x84\x16aA \x86a<\x1FV[_[\x82\x81\x10\x15aAGW\x84\x89\x01Q\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90PaA\"V[\x86\x83\x10\x15aAdW\x84\x89\x01QaA``\x1F\x89\x16\x82a=UV[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_``\x83\x01_\x83\x01QaA\xB7_\x86\x01\x82a/\xC1V[P` \x83\x01QaA\xCA` \x86\x01\x82a/\xC1V[P`@\x83\x01Q\x84\x82\x03`@\x86\x01RaA\xE2\x82\x82a-qV[\x91PP\x80\x91PP\x92\x91PPV[_aA\xFA\x83\x83aA\xA2V[\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_aB\x18\x82aAyV[aB\"\x81\x85aA\x83V[\x93P\x83` \x82\x02\x85\x01aB4\x85aA\x93V[\x80_[\x85\x81\x10\x15aBoW\x84\x84\x03\x89R\x81QaBP\x85\x82aA\xEFV[\x94PaB[\x83aB\x02V[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90PaB7V[P\x82\x97P\x87\x95PPPPPP\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_``\x83\x01_\x83\x01QaB\xBF_\x86\x01\x82a/\xC1V[P` \x83\x01QaB\xD2` \x86\x01\x82a/\xC1V[P`@\x83\x01Q\x84\x82\x03`@\x86\x01RaB\xEA\x82\x82a-qV[\x91PP\x80\x91PP\x92\x91PPV[_aC\x02\x83\x83aB\xAAV[\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_aC \x82aB\x81V[aC*\x81\x85aB\x8BV[\x93P\x83` \x82\x02\x85\x01aC<\x85aB\x9BV[\x80_[\x85\x81\x10\x15aCwW\x84\x84\x03\x89R\x81QaCX\x85\x82aB\xF7V[\x94PaCc\x83aC\nV[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90PaC?V[P\x82\x97P\x87\x95PPPPPP\x92\x91PPV[_`\xA0\x82\x01\x90PaC\x9C_\x83\x01\x88a0=V[\x81\x81\x03` \x83\x01RaC\xAE\x81\x87a-\xA9V[\x90PaC\xBD`@\x83\x01\x86a-9V[\x81\x81\x03``\x83\x01RaC\xCF\x81\x85aB\x0EV[\x90P\x81\x81\x03`\x80\x83\x01RaC\xE3\x81\x84aC\x16V[\x90P\x96\x95PPPPPPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[aD\x0B\x81aC\xEFV[\x82RPPV[_` \x82\x01\x90PaD$_\x83\x01\x84aD\x02V[\x92\x91PPV[aD3\x81a/\x90V[\x81\x14aD=W__\xFD[PV[_\x81Q\x90PaDN\x81aD*V[\x92\x91PPV[_` \x82\x84\x03\x12\x15aDiWaDha+\xBEV[[_aDv\x84\x82\x85\x01aD@V[\x91PP\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x81\x90P\x92\x91PPV[_aD\x9D\x82aD\x7FV[aD\xA7\x81\x85aD\x89V[\x93PaD\xB7\x81\x85` \x86\x01a,>V[\x80\x84\x01\x91PP\x92\x91PPV[_aD\xCE\x82\x84aD\x93V[\x91P\x81\x90P\x92\x91PPV\xFE\xA2dipfsX\"\x12 \x19\x1E$\xD4q\xDEl\0{\xE3\xFE[\x9F\xA0\xC7\xAC\xB7\xC7\x90\xD1\x1C\xA2V\x9B\xE4\xB5\xBBdP\xBF\xD2\xADdsolcC\0\x08\x1C\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x6080604052600436106101cc575f3560e01c806379ba5097116100f6578063c6b3024d11610094578063d98189a411610063578063d98189a414610616578063e30c39781461063e578063ecbd96ab14610668578063f2fde38b146106a4576101cc565b8063c6b3024d14610562578063cb6617551461058a578063cdb4c2b9146105b2578063d5244bf1146105da576101cc565b80638f4a7f5e116100d05780638f4a7f5e146104bc578063ad3cb1cc146104e6578063bda0b94814610510578063c62752581461053a576101cc565b806379ba5097146104405780638bb0a17c146104565780638da5cb5b14610492576101cc565b80634f1ef2861161016e5780636799ef521161013d5780636799ef52146103b05780636c88eb43146103da57806370cc9a3c14610402578063715018a61461042a576101cc565b80634f1ef286146102f257806352d1902d1461030e57806354d3f675146103385780635ab6d3ab14610374576101cc565b806347cd4b3e116101aa57806347cd4b3e1461024a57806348144c6114610274578063490413aa1461029e5780634921a3bd146102c8576101cc565b80630219150f146101d05780630d8e6e2c146101f8578063195afde614610222575b5f5ffd5b3480156101db575f5ffd5b506101f660048036038101906101f19190612bf9565b6106cc565b005b348015610203575f5ffd5b5061020c610778565b6040516102199190612c94565b60405180910390f35b34801561022d575f5ffd5b5061024860048036038101906102439190612d0e565b6107f3565b005b348015610255575f5ffd5b5061025e610894565b60405161026b9190612d48565b60405180910390f35b34801561027f575f5ffd5b506102886108b7565b6040516102959190612dea565b60405180910390f35b3480156102a9575f5ffd5b506102b26109fe565b6040516102bf9190612d48565b60405180910390f35b3480156102d3575f5ffd5b506102dc610a2d565b6040516102e99190612d48565b60405180910390f35b61030c60048036038101906103079190612f36565b610a44565b005b348015610319575f5ffd5b50610322610a63565b60405161032f9190612fa8565b60405180910390f35b348015610343575f5ffd5b5061035e60048036038101906103599190612d0e565b610a94565b60405161036b919061301d565b60405180910390f35b34801561037f575f5ffd5b5061039a60048036038101906103959190612bf9565b610c32565b6040516103a7919061304c565b60405180910390f35b3480156103bb575f5ffd5b506103c4610c84565b6040516103d19190612d48565b60405180910390f35b3480156103e5575f5ffd5b5061040060048036038101906103fb9190612d0e565b610cb6565b005b34801561040d575f5ffd5b5061042860048036038101906104239190613087565b610d52565b005b348015610435575f5ffd5b5061043e610ea3565b005b34801561044b575f5ffd5b50610454610eb6565b005b348015610461575f5ffd5b5061047c60048036038101906104779190612bf9565b610f44565b6040516104899190613157565b60405180910390f35b34801561049d575f5ffd5b506104a661115f565b6040516104b3919061304c565b60405180910390f35b3480156104c7575f5ffd5b506104d0611194565b6040516104dd919061321f565b60405180910390f35b3480156104f1575f5ffd5b506104fa61122d565b6040516105079190612c94565b60405180910390f35b34801561051b575f5ffd5b50610524611266565b604051610531919061321f565b60405180910390f35b348015610545575f5ffd5b50610560600480360381019061055b9190612d0e565b6112ff565b005b34801561056d575f5ffd5b5061058860048036038101906105839190612bf9565b61139b565b005b348015610595575f5ffd5b506105b060048036038101906105ab9190612d0e565b61140b565b005b3480156105bd575f5ffd5b506105d860048036038101906105d39190612d0e565b6114a7565b005b3480156105e5575f5ffd5b5061060060048036038101906105fb9190612bf9565b611543565b60405161060d919061304c565b60405180910390f35b348015610621575f5ffd5b5061063c60048036038101906106379190613624565b611595565b005b348015610649575f5ffd5b50610652611d1e565b60405161065f919061304c565b60405180910390f35b348015610673575f5ffd5b5061068e60048036038101906106899190612d0e565b611d53565b60405161069b919061373c565b60405180910390f35b3480156106af575f5ffd5b506106ca60048036038101906106c59190612d0e565b611ef1565b005b6106d4611faa565b5f6106dd612031565b90508060090180549050821115610734578181600901805490506040517f48676fe000000000000000000000000000000000000000000000000000000000815260040161072b92919061375c565b60405180910390fd5b8181600a01819055507fea6c6521bc495731082e23ad12c7b1207d13ca0bd38d1d511081ab568917cb848260405161076c9190612d48565b60405180910390a15050565b60606040518060400160405280600581526020017f485454505a0000000000000000000000000000000000000000000000000000008152506107b95f612058565b6107c36001612058565b6107cc5f612058565b6040516020016107df9493929190613851565b604051602081830303815290604052905090565b5f6107fc612031565b90508173ffffffffffffffffffffffffffffffffffffffff16815f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161461089057816040517f206a346e000000000000000000000000000000000000000000000000000000008152600401610887919061304c565b60405180910390fd5b5050565b5f5f61089e612031565b9050600181600a01546108b191906138dc565b91505090565b6108bf612aad565b5f6108c8612031565b9050806006016040518060400160405290815f820180546108e89061393c565b80601f01602080910402602001604051908101604052809291908181526020018280546109149061393c565b801561095f5780601f106109365761010080835404028352916020019161095f565b820191905f5260205f20905b81548152906001019060200180831161094257829003601f168201915b505050505081526020016001820180546109789061393c565b80601f01602080910402602001604051908101604052809291908181526020018280546109a49061393c565b80156109ef5780601f106109c6576101008083540402835291602001916109ef565b820191905f5260205f20905b8154815290600101906020018083116109d257829003601f168201915b50505050508152505091505090565b5f5f610a08612031565b9050600181600a01546002610a1d919061396c565b610a2791906138dc565b91505090565b5f5f610a37612031565b905080600a015491505090565b610a4c612122565b610a5582612208565b610a5f8282612213565b5050565b5f610a6c612331565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b905090565b610a9c612ac7565b5f610aa5612031565b9050806008015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f206040518060600160405290815f82015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282018054610baa9061393c565b80601f0160208091040260200160405190810160405280929190818152602001828054610bd69061393c565b8015610c215780601f10610bf857610100808354040283529160200191610c21565b820191905f5260205f20905b815481529060010190602001808311610c0457829003601f168201915b505050505081525050915050919050565b5f5f610c3c612031565b905080600c018381548110610c5457610c536139ad565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16915050919050565b5f5f610c8e612031565b90506001600282600c0180549050610ca69190613a07565b610cb091906138dc565b91505090565b5f610cbf612031565b9050806002015f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff16610d4e57816040517f2a7c6ef6000000000000000000000000000000000000000000000000000000008152600401610d45919061304c565b60405180910390fd5b5050565b5f815f013503610d8e576040517f22f73fea00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f610d97612031565b9050806005015f835f013581526020019081526020015f205f9054906101000a900460ff1615610e0157815f01356040517fb1825c5e000000000000000000000000000000000000000000000000000000008152600401610df89190612d48565b60405180910390fd5b80600d0182908060018154018082558091505060019003905f5260205f2090600502015f909190919091508181610e389190613f10565b50506001816005015f845f013581526020019081526020015f205f6101000a81548160ff0219169083151502179055507fb8207b5bb791730ae8f0534fa4c7be7da49dd75d701f9c7acf51c94b8ace96b282604051610e97919061408a565b60405180910390a15050565b610eab611faa565b610eb45f6123b8565b565b5f610ebf6123f5565b90508073ffffffffffffffffffffffffffffffffffffffff16610ee0611d1e565b73ffffffffffffffffffffffffffffffffffffffff1614610f3857806040517f118cdaa7000000000000000000000000000000000000000000000000000000008152600401610f2f919061304c565b60405180910390fd5b610f41816123b8565b50565b610f4c612b12565b5f610f55612031565b905080600d018381548110610f6d57610f6c6139ad565b5b905f5260205f2090600502016040518060a00160405290815f8201548152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020016003820180546110479061393c565b80601f01602080910402602001604051908101604052809291908181526020018280546110739061393c565b80156110be5780601f10611095576101008083540402835291602001916110be565b820191905f5260205f20905b8154815290600101906020018083116110a157829003601f168201915b505050505081526020016004820180546110d79061393c565b80601f01602080910402602001604051908101604052809291908181526020018280546111039061393c565b801561114e5780601f106111255761010080835404028352916020019161114e565b820191905f5260205f20905b81548152906001019060200180831161113157829003601f168201915b505050505081525050915050919050565b5f5f6111696123fc565b9050805f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b60605f61119f612031565b905080600c0180548060200260200160405190810160405280929190818152602001828054801561122257602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190600101908083116111d9575b505050505091505090565b6040518060400160405280600581526020017f352e302e3000000000000000000000000000000000000000000000000000000081525081565b60605f611271612031565b9050806009018054806020026020016040519081016040528092919081815260200182805480156112f457602002820191905f5260205f20905b815f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190600101908083116112ab575b505050505091505090565b5f611308612031565b9050806001015f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff1661139757816040517faee8632300000000000000000000000000000000000000000000000000000000815260040161138e919061304c565b60405180910390fd5b5050565b5f6113a4612031565b9050806005015f8381526020019081526020015f205f9054906101000a900460ff1661140757816040517f6df6fe890000000000000000000000000000000000000000000000000000000081526004016113fe9190612d48565b60405180910390fd5b5050565b5f611414612031565b9050806003015f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff166114a357816040517f52d725f500000000000000000000000000000000000000000000000000000000815260040161149a919061304c565b60405180910390fd5b5050565b5f6114b0612031565b9050806004015f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f9054906101000a900460ff1661153f57816040517f26cd75dc000000000000000000000000000000000000000000000000000000008152600401611536919061304c565b60405180910390fd5b5050565b5f5f61154d612031565b9050806009018381548110611565576115646139ad565b5b905f5260205f20015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16915050919050565b60025f6115a0612423565b9050805f0160089054906101000a900460ff16806115e857508167ffffffffffffffff16815f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff1610155b1561161f576040517ff92ee8a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81815f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055506001815f0160086101000a81548160ff02191690831515021790555061167461166f61115f565b61244a565b5f61167d612031565b905086816006015f820151815f01908161169791906140aa565b5060208201518160010190816116ad91906140aa565b5090505087815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505f855190508087111561173e5786816040517f48676fe000000000000000000000000000000000000000000000000000000000815260040161173592919061375c565b60405180910390fd5b8682600a01819055505f5f90505b818110156119e3576001836001015f89848151811061176e5761176d6139ad565b5b60200260200101515f015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff0219169083151502179055508681815181106117db576117da6139ad565b5b6020026020010151836008015f8984815181106117fb576117fa6139ad565b5b60200260200101515f015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f820151815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506020820151816001015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060408201518160020190816118de91906140aa565b50905050826009018782815181106118f9576118f86139ad565b5b60200260200101515f0151908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506001836002015f89848151811061197b5761197a6139ad565b5b60200260200101516020015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550808060010191505061174c565b505f5f90505b8551811015611c81576001836003015f888481518110611a0c57611a0b6139ad565b5b60200260200101515f015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff021916908315150217905550858181518110611a7957611a786139ad565b5b602002602001015183600b015f888481518110611a9957611a986139ad565b5b60200260200101515f015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f820151815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506020820151816001015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506040820151816002019081611b7c91906140aa565b5090505082600c01868281518110611b9757611b966139ad565b5b60200260200101515f0151908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506001836004015f888481518110611c1957611c186139ad565b5b60200260200101516020015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f6101000a81548160ff02191690831515021790555080806001019150506119e9565b507ff33d908c4a8b532fe64df20b726f11405c11b9772d31b66f5eef6887a43c3fde8989898989604051611cb9959493929190614389565b60405180910390a150505f815f0160086101000a81548160ff0219169083151502179055507fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d282604051611d0d9190614411565b60405180910390a150505050505050565b5f5f611d2861245e565b9050805f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505090565b611d5b612b6a565b5f611d64612031565b905080600b015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f206040518060600160405290815f82015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600182015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001600282018054611e699061393c565b80601f0160208091040260200160405190810160405280929190818152602001828054611e959061393c565b8015611ee05780601f10611eb757610100808354040283529160200191611ee0565b820191905f5260205f20905b815481529060010190602001808311611ec357829003601f168201915b505050505081525050915050919050565b611ef9611faa565b5f611f0261245e565b905081815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff16611f6461115f565b73ffffffffffffffffffffffffffffffffffffffff167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a35050565b611fb26123f5565b73ffffffffffffffffffffffffffffffffffffffff16611fd061115f565b73ffffffffffffffffffffffffffffffffffffffff161461202f57611ff36123f5565b6040517f118cdaa7000000000000000000000000000000000000000000000000000000008152600401612026919061304c565b60405180910390fd5b565b5f7f827176a45e1aad1f3a6539fee60c06126c40427b4849e7301bf2cf0f1f8e9500905090565b60605f600161206684612485565b0190505f8167ffffffffffffffff81111561208457612083612e12565b5b6040519080825280601f01601f1916602001820160405280156120b65781602001600182028036833780820191505090505b5090505f82602001820190505b600115612117578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a858161210c5761210b6139da565b5b0494505f85036120c3575b819350505050919050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614806121cf57507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166121b66125d6565b73ffffffffffffffffffffffffffffffffffffffff1614155b15612206576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b612210611faa565b50565b8173ffffffffffffffffffffffffffffffffffffffff166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa92505050801561227b57506040513d601f19601f820116820180604052508101906122789190614454565b60015b6122bc57816040517f4c9c8ce30000000000000000000000000000000000000000000000000000000081526004016122b3919061304c565b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b811461232257806040517faa1d49a40000000000000000000000000000000000000000000000000000000081526004016123199190612fa8565b60405180910390fd5b61232c8383612629565b505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff16146123b6576040517fe07c8dba00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f6123c161245e565b9050805f015f6101000a81549073ffffffffffffffffffffffffffffffffffffffff02191690556123f18261269b565b5050565b5f33905090565b5f7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300905090565b5f7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00905090565b61245261276c565b61245b816127ac565b50565b5f7f237e158222e3e6968b72b9db0d8043aacf074ad9f650f0d1606b4d82ee432c00905090565b5f5f5f90507a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083106124e1577a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083816124d7576124d66139da565b5b0492506040810190505b6d04ee2d6d415b85acef8100000000831061251e576d04ee2d6d415b85acef81000000008381612514576125136139da565b5b0492506020810190505b662386f26fc10000831061254d57662386f26fc100008381612543576125426139da565b5b0492506010810190505b6305f5e1008310612576576305f5e100838161256c5761256b6139da565b5b0492506008810190505b612710831061259b576127108381612591576125906139da565b5b0492506004810190505b606483106125be57606483816125b4576125b36139da565b5b0492506002810190505b600a83106125cd576001810190505b80915050919050565b5f6126027f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b612830565b5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b61263282612839565b8173ffffffffffffffffffffffffffffffffffffffff167fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b60405160405180910390a25f8151111561268e576126888282612902565b50612697565b612696612982565b5b5050565b5f6126a46123fc565b90505f815f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905082825f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a3505050565b6127746129be565b6127aa576040517fd7e6bcf800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b6127b461276c565b5f73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603612824575f6040517f1e4fbdf700000000000000000000000000000000000000000000000000000000815260040161281b919061304c565b60405180910390fd5b61282d816123b8565b50565b5f819050919050565b5f8173ffffffffffffffffffffffffffffffffffffffff163b0361289457806040517f4c9c8ce300000000000000000000000000000000000000000000000000000000815260040161288b919061304c565b60405180910390fd5b806128c07f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5f1b612830565b5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60605f5f8473ffffffffffffffffffffffffffffffffffffffff168460405161292b91906144c3565b5f60405180830381855af49150503d805f8114612963576040519150601f19603f3d011682016040523d82523d5f602084013e612968565b606091505b50915091506129788583836129dc565b9250505092915050565b5f3411156129bc576040517fb398979f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b565b5f6129c7612423565b5f0160089054906101000a900460ff16905090565b6060826129f1576129ec82612a69565b612a61565b5f8251148015612a1757505f8473ffffffffffffffffffffffffffffffffffffffff163b145b15612a5957836040517f9996b315000000000000000000000000000000000000000000000000000000008152600401612a50919061304c565b60405180910390fd5b819050612a62565b5b9392505050565b5f81511115612a7b5780518082602001fd5b6040517fd6bda27500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b604051806040016040528060608152602001606081525090565b60405180606001604052805f73ffffffffffffffffffffffffffffffffffffffff1681526020015f73ffffffffffffffffffffffffffffffffffffffff168152602001606081525090565b6040518060a001604052805f81526020015f73ffffffffffffffffffffffffffffffffffffffff1681526020015f73ffffffffffffffffffffffffffffffffffffffff16815260200160608152602001606081525090565b60405180606001604052805f73ffffffffffffffffffffffffffffffffffffffff1681526020015f73ffffffffffffffffffffffffffffffffffffffff168152602001606081525090565b5f604051905090565b5f5ffd5b5f5ffd5b5f819050919050565b612bd881612bc6565b8114612be2575f5ffd5b50565b5f81359050612bf381612bcf565b92915050565b5f60208284031215612c0e57612c0d612bbe565b5b5f612c1b84828501612be5565b91505092915050565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f601f19601f8301169050919050565b5f612c6682612c24565b612c708185612c2e565b9350612c80818560208601612c3e565b612c8981612c4c565b840191505092915050565b5f6020820190508181035f830152612cac8184612c5c565b905092915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f612cdd82612cb4565b9050919050565b612ced81612cd3565b8114612cf7575f5ffd5b50565b5f81359050612d0881612ce4565b92915050565b5f60208284031215612d2357612d22612bbe565b5b5f612d3084828501612cfa565b91505092915050565b612d4281612bc6565b82525050565b5f602082019050612d5b5f830184612d39565b92915050565b5f82825260208201905092915050565b5f612d7b82612c24565b612d858185612d61565b9350612d95818560208601612c3e565b612d9e81612c4c565b840191505092915050565b5f604083015f8301518482035f860152612dc38282612d71565b91505060208301518482036020860152612ddd8282612d71565b9150508091505092915050565b5f6020820190508181035f830152612e028184612da9565b905092915050565b5f5ffd5b5f5ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b612e4882612c4c565b810181811067ffffffffffffffff82111715612e6757612e66612e12565b5b80604052505050565b5f612e79612bb5565b9050612e858282612e3f565b919050565b5f67ffffffffffffffff821115612ea457612ea3612e12565b5b612ead82612c4c565b9050602081019050919050565b828183375f83830152505050565b5f612eda612ed584612e8a565b612e70565b905082815260208101848484011115612ef657612ef5612e0e565b5b612f01848285612eba565b509392505050565b5f82601f830112612f1d57612f1c612e0a565b5b8135612f2d848260208601612ec8565b91505092915050565b5f5f60408385031215612f4c57612f4b612bbe565b5b5f612f5985828601612cfa565b925050602083013567ffffffffffffffff811115612f7a57612f79612bc2565b5b612f8685828601612f09565b9150509250929050565b5f819050919050565b612fa281612f90565b82525050565b5f602082019050612fbb5f830184612f99565b92915050565b612fca81612cd3565b82525050565b5f606083015f830151612fe55f860182612fc1565b506020830151612ff86020860182612fc1565b50604083015184820360408601526130108282612d71565b9150508091505092915050565b5f6020820190508181035f8301526130358184612fd0565b905092915050565b61304681612cd3565b82525050565b5f60208201905061305f5f83018461303d565b92915050565b5f5ffd5b5f60a0828403121561307e5761307d613065565b5b81905092915050565b5f6020828403121561309c5761309b612bbe565b5b5f82013567ffffffffffffffff8111156130b9576130b8612bc2565b5b6130c584828501613069565b91505092915050565b6130d781612bc6565b82525050565b5f60a083015f8301516130f25f8601826130ce565b5060208301516131056020860182612fc1565b5060408301516131186040860182612fc1565b50606083015184820360608601526131308282612d71565b9150506080830151848203608086015261314a8282612d71565b9150508091505092915050565b5f6020820190508181035f83015261316f81846130dd565b905092915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f6131ab8383612fc1565b60208301905092915050565b5f602082019050919050565b5f6131cd82613177565b6131d78185613181565b93506131e283613191565b805f5b838110156132125781516131f988826131a0565b9750613204836131b7565b9250506001810190506131e5565b5085935050505092915050565b5f6020820190508181035f83015261323781846131c3565b905092915050565b5f5ffd5b5f5ffd5b5f67ffffffffffffffff82111561326157613260612e12565b5b61326a82612c4c565b9050602081019050919050565b5f61328961328484613247565b612e70565b9050828152602081018484840111156132a5576132a4612e0e565b5b6132b0848285612eba565b509392505050565b5f82601f8301126132cc576132cb612e0a565b5b81356132dc848260208601613277565b91505092915050565b5f604082840312156132fa576132f961323f565b5b6133046040612e70565b90505f82013567ffffffffffffffff81111561332357613322613243565b5b61332f848285016132b8565b5f83015250602082013567ffffffffffffffff81111561335257613351613243565b5b61335e848285016132b8565b60208301525092915050565b5f67ffffffffffffffff82111561338457613383612e12565b5b602082029050602081019050919050565b5f5ffd5b5f606082840312156133ae576133ad61323f565b5b6133b86060612e70565b90505f6133c784828501612cfa565b5f8301525060206133da84828501612cfa565b602083015250604082013567ffffffffffffffff8111156133fe576133fd613243565b5b61340a848285016132b8565b60408301525092915050565b5f6134286134238461336a565b612e70565b9050808382526020820190506020840283018581111561344b5761344a613395565b5b835b8181101561349257803567ffffffffffffffff8111156134705761346f612e0a565b5b80860161347d8982613399565b8552602085019450505060208101905061344d565b5050509392505050565b5f82601f8301126134b0576134af612e0a565b5b81356134c0848260208601613416565b91505092915050565b5f67ffffffffffffffff8211156134e3576134e2612e12565b5b602082029050602081019050919050565b5f606082840312156135095761350861323f565b5b6135136060612e70565b90505f61352284828501612cfa565b5f83015250602061353584828501612cfa565b602083015250604082013567ffffffffffffffff81111561355957613558613243565b5b613565848285016132b8565b60408301525092915050565b5f61358361357e846134c9565b612e70565b905080838252602082019050602084028301858111156135a6576135a5613395565b5b835b818110156135ed57803567ffffffffffffffff8111156135cb576135ca612e0a565b5b8086016135d889826134f4565b855260208501945050506020810190506135a8565b5050509392505050565b5f82601f83011261360b5761360a612e0a565b5b813561361b848260208601613571565b91505092915050565b5f5f5f5f5f60a0868803121561363d5761363c612bbe565b5b5f61364a88828901612cfa565b955050602086013567ffffffffffffffff81111561366b5761366a612bc2565b5b613677888289016132e5565b945050604061368888828901612be5565b935050606086013567ffffffffffffffff8111156136a9576136a8612bc2565b5b6136b58882890161349c565b925050608086013567ffffffffffffffff8111156136d6576136d5612bc2565b5b6136e2888289016135f7565b9150509295509295909350565b5f606083015f8301516137045f860182612fc1565b5060208301516137176020860182612fc1565b506040830151848203604086015261372f8282612d71565b9150508091505092915050565b5f6020820190508181035f83015261375481846136ef565b905092915050565b5f60408201905061376f5f830185612d39565b61377c6020830184612d39565b9392505050565b5f81905092915050565b5f61379782612c24565b6137a18185613783565b93506137b1818560208601612c3e565b80840191505092915050565b7f20760000000000000000000000000000000000000000000000000000000000005f82015250565b5f6137f1600283613783565b91506137fc826137bd565b600282019050919050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f61383b600183613783565b915061384682613807565b600182019050919050565b5f61385c828761378d565b9150613867826137e5565b9150613873828661378d565b915061387e8261382f565b915061388a828561378d565b91506138958261382f565b91506138a1828461378d565b915081905095945050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6138e682612bc6565b91506138f183612bc6565b9250828201905080821115613909576139086138af565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f600282049050600182168061395357607f821691505b6020821081036139665761396561390f565b5b50919050565b5f61397682612bc6565b915061398183612bc6565b925082820261398f81612bc6565b915082820484148315176139a6576139a56138af565b5b5092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f613a1182612bc6565b9150613a1c83612bc6565b925082613a2c57613a2b6139da565b5b828204905092915050565b5f8135613a4381612bcf565b80915050919050565b5f815f1b9050919050565b5f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff613a8284613a4c565b9350801983169250808416831791505092915050565b5f819050919050565b5f613abb613ab6613ab184612bc6565b613a98565b612bc6565b9050919050565b5f819050919050565b613ad482613aa1565b613ae7613ae082613ac2565b8354613a57565b8255505050565b5f8135613afa81612ce4565b80915050919050565b5f73ffffffffffffffffffffffffffffffffffffffff613b2284613a4c565b9350801983169250808416831791505092915050565b5f613b52613b4d613b4884612cb4565b613a98565b612cb4565b9050919050565b5f613b6382613b38565b9050919050565b5f613b7482613b59565b9050919050565b5f819050919050565b613b8d82613b6a565b613ba0613b9982613b7b565b8354613b03565b8255505050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f83356001602003843603038112613bcf57613bce613ba7565b5b80840192508235915067ffffffffffffffff821115613bf157613bf0613bab565b5b602083019250600182023603831315613c0d57613c0c613baf565b5b509250929050565b5f82905092915050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f60088302613c7b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82613c40565b613c858683613c40565b95508019841693508086168417925050509392505050565b613ca683613aa1565b613cba613cb282613ac2565b848454613c4c565b825550505050565b5f5f905090565b613cd1613cc2565b613cdc818484613c9d565b505050565b5b81811015613cff57613cf45f82613cc9565b600181019050613ce2565b5050565b601f821115613d4457613d1581613c1f565b613d1e84613c31565b81016020851015613d2d578190505b613d41613d3985613c31565b830182613ce1565b50505b505050565b5f82821c905092915050565b5f613d645f1984600802613d49565b1980831691505092915050565b5f613d7c8383613d55565b9150826002028217905092915050565b613d968383613c15565b67ffffffffffffffff811115613daf57613dae612e12565b5b613db9825461393c565b613dc4828285613d03565b5f601f831160018114613df1575f8415613ddf578287013590505b613de98582613d71565b865550613e50565b601f198416613dff86613c1f565b5f5b82811015613e2657848901358255600182019150602085019450602081019050613e01565b86831015613e435784890135613e3f601f891682613d55565b8355505b6001600288020188555050505b50505050505050565b613e64838383613d8c565b505050565b5f81015f830180613e7981613a37565b9050613e858184613acb565b505050600181016020830180613e9a81613aee565b9050613ea68184613b84565b505050600281016040830180613ebb81613aee565b9050613ec78184613b84565b5050506003810160608301613edc8185613bb3565b613ee7818386613e59565b505050506004810160808301613efd8185613bb3565b613f08818386613e59565b505050505050565b613f1a8282613e69565b5050565b5f613f2c6020840184612be5565b905092915050565b5f613f426020840184612cfa565b905092915050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f83356001602003843603038112613f7257613f71613f52565b5b83810192508235915060208301925067ffffffffffffffff821115613f9a57613f99613f4a565b5b600182023603831315613fb057613faf613f4e565b5b509250929050565b5f613fc38385612d61565b9350613fd0838584612eba565b613fd983612c4c565b840190509392505050565b5f60a08301613ff55f840184613f1e565b6140015f8601826130ce565b5061400f6020840184613f34565b61401c6020860182612fc1565b5061402a6040840184613f34565b6140376040860182612fc1565b506140456060840184613f56565b8583036060870152614058838284613fb8565b925050506140696080840184613f56565b858303608087015261407c838284613fb8565b925050508091505092915050565b5f6020820190508181035f8301526140a28184613fe4565b905092915050565b6140b382612c24565b67ffffffffffffffff8111156140cc576140cb612e12565b5b6140d6825461393c565b6140e1828285613d03565b5f60209050601f831160018114614112575f8415614100578287015190505b61410a8582613d71565b865550614171565b601f19841661412086613c1f565b5f5b8281101561414757848901518255600182019150602085019450602081019050614122565b868310156141645784890151614160601f891682613d55565b8355505b6001600288020188555050505b505050505050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f606083015f8301516141b75f860182612fc1565b5060208301516141ca6020860182612fc1565b50604083015184820360408601526141e28282612d71565b9150508091505092915050565b5f6141fa83836141a2565b905092915050565b5f602082019050919050565b5f61421882614179565b6142228185614183565b93508360208202850161423485614193565b805f5b8581101561426f578484038952815161425085826141ef565b945061425b83614202565b925060208a01995050600181019050614237565b50829750879550505050505092915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f606083015f8301516142bf5f860182612fc1565b5060208301516142d26020860182612fc1565b50604083015184820360408601526142ea8282612d71565b9150508091505092915050565b5f61430283836142aa565b905092915050565b5f602082019050919050565b5f61432082614281565b61432a818561428b565b93508360208202850161433c8561429b565b805f5b85811015614377578484038952815161435885826142f7565b94506143638361430a565b925060208a0199505060018101905061433f565b50829750879550505050505092915050565b5f60a08201905061439c5f83018861303d565b81810360208301526143ae8187612da9565b90506143bd6040830186612d39565b81810360608301526143cf818561420e565b905081810360808301526143e38184614316565b90509695505050505050565b5f67ffffffffffffffff82169050919050565b61440b816143ef565b82525050565b5f6020820190506144245f830184614402565b92915050565b61443381612f90565b811461443d575f5ffd5b50565b5f8151905061444e8161442a565b92915050565b5f6020828403121561446957614468612bbe565b5b5f61447684828501614440565b91505092915050565b5f81519050919050565b5f81905092915050565b5f61449d8261447f565b6144a78185614489565b93506144b7818560208601612c3e565b80840191505092915050565b5f6144ce8284614493565b91508190509291505056fea2646970667358221220191e24d471de6c007be3fe5b9fa0c7acb7c790d11ca2569be4b5bb6450bfd2ad64736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10a\x01\xCCW_5`\xE0\x1C\x80cy\xBAP\x97\x11a\0\xF6W\x80c\xC6\xB3\x02M\x11a\0\x94W\x80c\xD9\x81\x89\xA4\x11a\0cW\x80c\xD9\x81\x89\xA4\x14a\x06\x16W\x80c\xE3\x0C9x\x14a\x06>W\x80c\xEC\xBD\x96\xAB\x14a\x06hW\x80c\xF2\xFD\xE3\x8B\x14a\x06\xA4Wa\x01\xCCV[\x80c\xC6\xB3\x02M\x14a\x05bW\x80c\xCBf\x17U\x14a\x05\x8AW\x80c\xCD\xB4\xC2\xB9\x14a\x05\xB2W\x80c\xD5$K\xF1\x14a\x05\xDAWa\x01\xCCV[\x80c\x8FJ\x7F^\x11a\0\xD0W\x80c\x8FJ\x7F^\x14a\x04\xBCW\x80c\xAD<\xB1\xCC\x14a\x04\xE6W\x80c\xBD\xA0\xB9H\x14a\x05\x10W\x80c\xC6'RX\x14a\x05:Wa\x01\xCCV[\x80cy\xBAP\x97\x14a\x04@W\x80c\x8B\xB0\xA1|\x14a\x04VW\x80c\x8D\xA5\xCB[\x14a\x04\x92Wa\x01\xCCV[\x80cO\x1E\xF2\x86\x11a\x01nW\x80cg\x99\xEFR\x11a\x01=W\x80cg\x99\xEFR\x14a\x03\xB0W\x80cl\x88\xEBC\x14a\x03\xDAW\x80cp\xCC\x9A<\x14a\x04\x02W\x80cqP\x18\xA6\x14a\x04*Wa\x01\xCCV[\x80cO\x1E\xF2\x86\x14a\x02\xF2W\x80cR\xD1\x90-\x14a\x03\x0EW\x80cT\xD3\xF6u\x14a\x038W\x80cZ\xB6\xD3\xAB\x14a\x03tWa\x01\xCCV[\x80cG\xCDK>\x11a\x01\xAAW\x80cG\xCDK>\x14a\x02JW\x80cH\x14La\x14a\x02tW\x80cI\x04\x13\xAA\x14a\x02\x9EW\x80cI!\xA3\xBD\x14a\x02\xC8Wa\x01\xCCV[\x80c\x02\x19\x15\x0F\x14a\x01\xD0W\x80c\r\x8En,\x14a\x01\xF8W\x80c\x19Z\xFD\xE6\x14a\x02\"W[__\xFD[4\x80\x15a\x01\xDBW__\xFD[Pa\x01\xF6`\x04\x806\x03\x81\x01\x90a\x01\xF1\x91\x90a+\xF9V[a\x06\xCCV[\0[4\x80\x15a\x02\x03W__\xFD[Pa\x02\x0Ca\x07xV[`@Qa\x02\x19\x91\x90a,\x94V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02-W__\xFD[Pa\x02H`\x04\x806\x03\x81\x01\x90a\x02C\x91\x90a-\x0EV[a\x07\xF3V[\0[4\x80\x15a\x02UW__\xFD[Pa\x02^a\x08\x94V[`@Qa\x02k\x91\x90a-HV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\x7FW__\xFD[Pa\x02\x88a\x08\xB7V[`@Qa\x02\x95\x91\x90a-\xEAV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xA9W__\xFD[Pa\x02\xB2a\t\xFEV[`@Qa\x02\xBF\x91\x90a-HV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x02\xD3W__\xFD[Pa\x02\xDCa\n-V[`@Qa\x02\xE9\x91\x90a-HV[`@Q\x80\x91\x03\x90\xF3[a\x03\x0C`\x04\x806\x03\x81\x01\x90a\x03\x07\x91\x90a/6V[a\nDV[\0[4\x80\x15a\x03\x19W__\xFD[Pa\x03\"a\ncV[`@Qa\x03/\x91\x90a/\xA8V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03CW__\xFD[Pa\x03^`\x04\x806\x03\x81\x01\x90a\x03Y\x91\x90a-\x0EV[a\n\x94V[`@Qa\x03k\x91\x90a0\x1DV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\x7FW__\xFD[Pa\x03\x9A`\x04\x806\x03\x81\x01\x90a\x03\x95\x91\x90a+\xF9V[a\x0C2V[`@Qa\x03\xA7\x91\x90a0LV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xBBW__\xFD[Pa\x03\xC4a\x0C\x84V[`@Qa\x03\xD1\x91\x90a-HV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x03\xE5W__\xFD[Pa\x04\0`\x04\x806\x03\x81\x01\x90a\x03\xFB\x91\x90a-\x0EV[a\x0C\xB6V[\0[4\x80\x15a\x04\rW__\xFD[Pa\x04(`\x04\x806\x03\x81\x01\x90a\x04#\x91\x90a0\x87V[a\rRV[\0[4\x80\x15a\x045W__\xFD[Pa\x04>a\x0E\xA3V[\0[4\x80\x15a\x04KW__\xFD[Pa\x04Ta\x0E\xB6V[\0[4\x80\x15a\x04aW__\xFD[Pa\x04|`\x04\x806\x03\x81\x01\x90a\x04w\x91\x90a+\xF9V[a\x0FDV[`@Qa\x04\x89\x91\x90a1WV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\x9DW__\xFD[Pa\x04\xA6a\x11_V[`@Qa\x04\xB3\x91\x90a0LV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xC7W__\xFD[Pa\x04\xD0a\x11\x94V[`@Qa\x04\xDD\x91\x90a2\x1FV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x04\xF1W__\xFD[Pa\x04\xFAa\x12-V[`@Qa\x05\x07\x91\x90a,\x94V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05\x1BW__\xFD[Pa\x05$a\x12fV[`@Qa\x051\x91\x90a2\x1FV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x05EW__\xFD[Pa\x05``\x04\x806\x03\x81\x01\x90a\x05[\x91\x90a-\x0EV[a\x12\xFFV[\0[4\x80\x15a\x05mW__\xFD[Pa\x05\x88`\x04\x806\x03\x81\x01\x90a\x05\x83\x91\x90a+\xF9V[a\x13\x9BV[\0[4\x80\x15a\x05\x95W__\xFD[Pa\x05\xB0`\x04\x806\x03\x81\x01\x90a\x05\xAB\x91\x90a-\x0EV[a\x14\x0BV[\0[4\x80\x15a\x05\xBDW__\xFD[Pa\x05\xD8`\x04\x806\x03\x81\x01\x90a\x05\xD3\x91\x90a-\x0EV[a\x14\xA7V[\0[4\x80\x15a\x05\xE5W__\xFD[Pa\x06\0`\x04\x806\x03\x81\x01\x90a\x05\xFB\x91\x90a+\xF9V[a\x15CV[`@Qa\x06\r\x91\x90a0LV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06!W__\xFD[Pa\x06<`\x04\x806\x03\x81\x01\x90a\x067\x91\x90a6$V[a\x15\x95V[\0[4\x80\x15a\x06IW__\xFD[Pa\x06Ra\x1D\x1EV[`@Qa\x06_\x91\x90a0LV[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06sW__\xFD[Pa\x06\x8E`\x04\x806\x03\x81\x01\x90a\x06\x89\x91\x90a-\x0EV[a\x1DSV[`@Qa\x06\x9B\x91\x90a7<V[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x06\xAFW__\xFD[Pa\x06\xCA`\x04\x806\x03\x81\x01\x90a\x06\xC5\x91\x90a-\x0EV[a\x1E\xF1V[\0[a\x06\xD4a\x1F\xAAV[_a\x06\xDDa 1V[\x90P\x80`\t\x01\x80T\x90P\x82\x11\x15a\x074W\x81\x81`\t\x01\x80T\x90P`@Q\x7FHgo\xE0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x07+\x92\x91\x90a7\\V[`@Q\x80\x91\x03\x90\xFD[\x81\x81`\n\x01\x81\x90UP\x7F\xEAle!\xBCIW1\x08.#\xAD\x12\xC7\xB1 }\x13\xCA\x0B\xD3\x8D\x1DQ\x10\x81\xABV\x89\x17\xCB\x84\x82`@Qa\x07l\x91\x90a-HV[`@Q\x80\x91\x03\x90\xA1PPV[```@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7FHTTPZ\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa\x07\xB9_a XV[a\x07\xC3`\x01a XV[a\x07\xCC_a XV[`@Q` \x01a\x07\xDF\x94\x93\x92\x91\x90a8QV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P\x90V[_a\x07\xFCa 1V[\x90P\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x08\x90W\x81`@Q\x7F j4n\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x08\x87\x91\x90a0LV[`@Q\x80\x91\x03\x90\xFD[PPV[__a\x08\x9Ea 1V[\x90P`\x01\x81`\n\x01Ta\x08\xB1\x91\x90a8\xDCV[\x91PP\x90V[a\x08\xBFa*\xADV[_a\x08\xC8a 1V[\x90P\x80`\x06\x01`@Q\x80`@\x01`@R\x90\x81_\x82\x01\x80Ta\x08\xE8\x90a9<V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\t\x14\x90a9<V[\x80\x15a\t_W\x80`\x1F\x10a\t6Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\t_V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\tBW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x01\x82\x01\x80Ta\tx\x90a9<V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\t\xA4\x90a9<V[\x80\x15a\t\xEFW\x80`\x1F\x10a\t\xC6Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\t\xEFV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\t\xD2W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x91PP\x90V[__a\n\x08a 1V[\x90P`\x01\x81`\n\x01T`\x02a\n\x1D\x91\x90a9lV[a\n'\x91\x90a8\xDCV[\x91PP\x90V[__a\n7a 1V[\x90P\x80`\n\x01T\x91PP\x90V[a\nLa!\"V[a\nU\x82a\"\x08V[a\n_\x82\x82a\"\x13V[PPV[_a\nla#1V[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x90P\x90V[a\n\x9Ca*\xC7V[_a\n\xA5a 1V[\x90P\x80`\x08\x01_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `@Q\x80``\x01`@R\x90\x81_\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01\x80Ta\x0B\xAA\x90a9<V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0B\xD6\x90a9<V[\x80\x15a\x0C!W\x80`\x1F\x10a\x0B\xF8Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0C!V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0C\x04W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x91PP\x91\x90PV[__a\x0C<a 1V[\x90P\x80`\x0C\x01\x83\x81T\x81\x10a\x0CTWa\x0CSa9\xADV[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x91\x90PV[__a\x0C\x8Ea 1V[\x90P`\x01`\x02\x82`\x0C\x01\x80T\x90Pa\x0C\xA6\x91\x90a:\x07V[a\x0C\xB0\x91\x90a8\xDCV[\x91PP\x90V[_a\x0C\xBFa 1V[\x90P\x80`\x02\x01_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\rNW\x81`@Q\x7F*|n\xF6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\rE\x91\x90a0LV[`@Q\x80\x91\x03\x90\xFD[PPV[_\x81_\x015\x03a\r\x8EW`@Q\x7F\"\xF7?\xEA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a\r\x97a 1V[\x90P\x80`\x05\x01_\x83_\x015\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x15a\x0E\x01W\x81_\x015`@Q\x7F\xB1\x82\\^\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\r\xF8\x91\x90a-HV[`@Q\x80\x91\x03\x90\xFD[\x80`\r\x01\x82\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\x05\x02\x01_\x90\x91\x90\x91\x90\x91P\x81\x81a\x0E8\x91\x90a?\x10V[PP`\x01\x81`\x05\x01_\x84_\x015\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xB8 {[\xB7\x91s\n\xE8\xF0SO\xA4\xC7\xBE}\xA4\x9D\xD7]p\x1F\x9Cz\xCFQ\xC9K\x8A\xCE\x96\xB2\x82`@Qa\x0E\x97\x91\x90a@\x8AV[`@Q\x80\x91\x03\x90\xA1PPV[a\x0E\xABa\x1F\xAAV[a\x0E\xB4_a#\xB8V[V[_a\x0E\xBFa#\xF5V[\x90P\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x0E\xE0a\x1D\x1EV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x0F8W\x80`@Q\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x0F/\x91\x90a0LV[`@Q\x80\x91\x03\x90\xFD[a\x0FA\x81a#\xB8V[PV[a\x0FLa+\x12V[_a\x0FUa 1V[\x90P\x80`\r\x01\x83\x81T\x81\x10a\x0FmWa\x0Fla9\xADV[[\x90_R` _ \x90`\x05\x02\x01`@Q\x80`\xA0\x01`@R\x90\x81_\x82\x01T\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x03\x82\x01\x80Ta\x10G\x90a9<V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x10s\x90a9<V[\x80\x15a\x10\xBEW\x80`\x1F\x10a\x10\x95Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x10\xBEV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x10\xA1W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01`\x04\x82\x01\x80Ta\x10\xD7\x90a9<V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x11\x03\x90a9<V[\x80\x15a\x11NW\x80`\x1F\x10a\x11%Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x11NV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x111W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x91PP\x91\x90PV[__a\x11ia#\xFCV[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x90V[``_a\x11\x9Fa 1V[\x90P\x80`\x0C\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x12\"W` \x02\x82\x01\x91\x90_R` _ \x90[\x81_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x11\xD9W[PPPPP\x91PP\x90V[`@Q\x80`@\x01`@R\x80`\x05\x81R` \x01\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP\x81V[``_a\x12qa 1V[\x90P\x80`\t\x01\x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80T\x80\x15a\x12\xF4W` \x02\x82\x01\x91\x90_R` _ \x90[\x81_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x12\xABW[PPPPP\x91PP\x90V[_a\x13\x08a 1V[\x90P\x80`\x01\x01_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x13\x97W\x81`@Q\x7F\xAE\xE8c#\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\x8E\x91\x90a0LV[`@Q\x80\x91\x03\x90\xFD[PPV[_a\x13\xA4a 1V[\x90P\x80`\x05\x01_\x83\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x14\x07W\x81`@Q\x7Fm\xF6\xFE\x89\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x13\xFE\x91\x90a-HV[`@Q\x80\x91\x03\x90\xFD[PPV[_a\x14\x14a 1V[\x90P\x80`\x03\x01_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x14\xA3W\x81`@Q\x7FR\xD7%\xF5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14\x9A\x91\x90a0LV[`@Q\x80\x91\x03\x90\xFD[PPV[_a\x14\xB0a 1V[\x90P\x80`\x04\x01_\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x90T\x90a\x01\0\n\x90\x04`\xFF\x16a\x15?W\x81`@Q\x7F&\xCDu\xDC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x156\x91\x90a0LV[`@Q\x80\x91\x03\x90\xFD[PPV[__a\x15Ma 1V[\x90P\x80`\t\x01\x83\x81T\x81\x10a\x15eWa\x15da9\xADV[[\x90_R` _ \x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x91\x90PV[`\x02_a\x15\xA0a$#V[\x90P\x80_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x80a\x15\xE8WP\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15[\x15a\x16\x1FW`@Q\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x81_\x01_a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UPa\x16ta\x16oa\x11_V[a$JV[_a\x16}a 1V[\x90P\x86\x81`\x06\x01_\x82\x01Q\x81_\x01\x90\x81a\x16\x97\x91\x90a@\xAAV[P` \x82\x01Q\x81`\x01\x01\x90\x81a\x16\xAD\x91\x90a@\xAAV[P\x90PP\x87\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP_\x85Q\x90P\x80\x87\x11\x15a\x17>W\x86\x81`@Q\x7FHgo\xE0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x175\x92\x91\x90a7\\V[`@Q\x80\x91\x03\x90\xFD[\x86\x82`\n\x01\x81\x90UP__\x90P[\x81\x81\x10\x15a\x19\xE3W`\x01\x83`\x01\x01_\x89\x84\x81Q\x81\x10a\x17nWa\x17ma9\xADV[[` \x02` \x01\x01Q_\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x86\x81\x81Q\x81\x10a\x17\xDBWa\x17\xDAa9\xADV[[` \x02` \x01\x01Q\x83`\x08\x01_\x89\x84\x81Q\x81\x10a\x17\xFBWa\x17\xFAa9\xADV[[` \x02` \x01\x01Q_\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x82\x01Q\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP` \x82\x01Q\x81`\x01\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`@\x82\x01Q\x81`\x02\x01\x90\x81a\x18\xDE\x91\x90a@\xAAV[P\x90PP\x82`\t\x01\x87\x82\x81Q\x81\x10a\x18\xF9Wa\x18\xF8a9\xADV[[` \x02` \x01\x01Q_\x01Q\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x83`\x02\x01_\x89\x84\x81Q\x81\x10a\x19{Wa\x19za9\xADV[[` \x02` \x01\x01Q` \x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x80\x80`\x01\x01\x91PPa\x17LV[P__\x90P[\x85Q\x81\x10\x15a\x1C\x81W`\x01\x83`\x03\x01_\x88\x84\x81Q\x81\x10a\x1A\x0CWa\x1A\x0Ba9\xADV[[` \x02` \x01\x01Q_\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x85\x81\x81Q\x81\x10a\x1AyWa\x1Axa9\xADV[[` \x02` \x01\x01Q\x83`\x0B\x01_\x88\x84\x81Q\x81\x10a\x1A\x99Wa\x1A\x98a9\xADV[[` \x02` \x01\x01Q_\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _\x82\x01Q\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP` \x82\x01Q\x81`\x01\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`@\x82\x01Q\x81`\x02\x01\x90\x81a\x1B|\x91\x90a@\xAAV[P\x90PP\x82`\x0C\x01\x86\x82\x81Q\x81\x10a\x1B\x97Wa\x1B\x96a9\xADV[[` \x02` \x01\x01Q_\x01Q\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\x01\x83`\x04\x01_\x88\x84\x81Q\x81\x10a\x1C\x19Wa\x1C\x18a9\xADV[[` \x02` \x01\x01Q` \x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x80\x80`\x01\x01\x91PPa\x19\xE9V[P\x7F\xF3=\x90\x8CJ\x8BS/\xE6M\xF2\x0Bro\x11@\\\x11\xB9w-1\xB6o^\xEFh\x87\xA4<?\xDE\x89\x89\x89\x89\x89`@Qa\x1C\xB9\x95\x94\x93\x92\x91\x90aC\x89V[`@Q\x80\x91\x03\x90\xA1PP_\x81_\x01`\x08a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x82`@Qa\x1D\r\x91\x90aD\x11V[`@Q\x80\x91\x03\x90\xA1PPPPPPPV[__a\x1D(a$^V[\x90P\x80_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91PP\x90V[a\x1D[a+jV[_a\x1Dda 1V[\x90P\x80`\x0B\x01_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ `@Q\x80``\x01`@R\x90\x81_\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01`\x02\x82\x01\x80Ta\x1Ei\x90a9<V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x1E\x95\x90a9<V[\x80\x15a\x1E\xE0W\x80`\x1F\x10a\x1E\xB7Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x1E\xE0V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x1E\xC3W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81RPP\x91PP\x91\x90PV[a\x1E\xF9a\x1F\xAAV[_a\x1F\x02a$^V[\x90P\x81\x81_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1Fda\x11_V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F8\xD1k\x8C\xAC\"\xD9\x9F\xC7\xC1$\xB9\xCD\r\xE2\xD3\xFA\x1F\xAE\xF4 \xBF\xE7\x91\xD8\xC3b\xD7e\xE2'\0`@Q`@Q\x80\x91\x03\x90\xA3PPV[a\x1F\xB2a#\xF5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1F\xD0a\x11_V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a /Wa\x1F\xF3a#\xF5V[`@Q\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a &\x91\x90a0LV[`@Q\x80\x91\x03\x90\xFD[V[_\x7F\x82qv\xA4^\x1A\xAD\x1F:e9\xFE\xE6\x0C\x06\x12l@B{HI\xE70\x1B\xF2\xCF\x0F\x1F\x8E\x95\0\x90P\x90V[``_`\x01a f\x84a$\x85V[\x01\x90P_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a \x84Wa \x83a.\x12V[[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a \xB6W\x81` \x01`\x01\x82\x02\x806\x837\x80\x82\x01\x91PP\x90P[P\x90P_\x82` \x01\x82\x01\x90P[`\x01\x15a!\x17W\x80\x80`\x01\x90\x03\x91PP\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\n\x86\x06\x1A\x81S`\n\x85\x81a!\x0CWa!\x0Ba9\xDAV[[\x04\x94P_\x85\x03a \xC3W[\x81\x93PPPP\x91\x90PV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x80a!\xCFWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a!\xB6a%\xD6V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15a\"\x06W`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[a\"\x10a\x1F\xAAV[PV[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16cR\xD1\x90-`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x92PPP\x80\x15a\"{WP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\"x\x91\x90aDTV[`\x01[a\"\xBCW\x81`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\"\xB3\x91\x90a0LV[`@Q\x80\x91\x03\x90\xFD[\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1B\x81\x14a#\"W\x80`@Q\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a#\x19\x91\x90a/\xA8V[`@Q\x80\x91\x03\x90\xFD[a#,\x83\x83a&)V[PPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x160s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a#\xB6W`@Q\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_a#\xC1a$^V[\x90P\x80_\x01_a\x01\0\n\x81T\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90Ua#\xF1\x82a&\x9BV[PPV[_3\x90P\x90V[_\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0\x90P\x90V[_\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\x90P\x90V[a$Ra'lV[a$[\x81a'\xACV[PV[_\x7F#~\x15\x82\"\xE3\xE6\x96\x8Br\xB9\xDB\r\x80C\xAA\xCF\x07J\xD9\xF6P\xF0\xD1`kM\x82\xEEC,\0\x90P\x90V[___\x90Pz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x10a$\xE1Wz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x83\x81a$\xD7Wa$\xD6a9\xDAV[[\x04\x92P`@\x81\x01\x90P[m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x10a%\x1EWm\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0\x83\x81a%\x14Wa%\x13a9\xDAV[[\x04\x92P` \x81\x01\x90P[f#\x86\xF2o\xC1\0\0\x83\x10a%MWf#\x86\xF2o\xC1\0\0\x83\x81a%CWa%Ba9\xDAV[[\x04\x92P`\x10\x81\x01\x90P[c\x05\xF5\xE1\0\x83\x10a%vWc\x05\xF5\xE1\0\x83\x81a%lWa%ka9\xDAV[[\x04\x92P`\x08\x81\x01\x90P[a'\x10\x83\x10a%\x9BWa'\x10\x83\x81a%\x91Wa%\x90a9\xDAV[[\x04\x92P`\x04\x81\x01\x90P[`d\x83\x10a%\xBEW`d\x83\x81a%\xB4Wa%\xB3a9\xDAV[[\x04\x92P`\x02\x81\x01\x90P[`\n\x83\x10a%\xCDW`\x01\x81\x01\x90P[\x80\x91PP\x91\x90PV[_a&\x02\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Ba(0V[_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90V[a&2\x82a(9V[\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;`@Q`@Q\x80\x91\x03\x90\xA2_\x81Q\x11\x15a&\x8EWa&\x88\x82\x82a)\x02V[Pa&\x97V[a&\x96a)\x82V[[PPV[_a&\xA4a#\xFCV[\x90P_\x81_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x82\x82_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3PPPV[a'ta)\xBEV[a'\xAAW`@Q\x7F\xD7\xE6\xBC\xF8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[a'\xB4a'lV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a($W_`@Q\x7F\x1EO\xBD\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a(\x1B\x91\x90a0LV[`@Q\x80\x91\x03\x90\xFD[a(-\x81a#\xB8V[PV[_\x81\x90P\x91\x90PV[_\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x03a(\x94W\x80`@Q\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a(\x8B\x91\x90a0LV[`@Q\x80\x91\x03\x90\xFD[\x80a(\xC0\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC_\x1Ba(0V[_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[``__\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84`@Qa)+\x91\x90aD\xC3V[_`@Q\x80\x83\x03\x81\x85Z\xF4\x91PP=\x80_\x81\x14a)cW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a)hV[``\x91P[P\x91P\x91Pa)x\x85\x83\x83a)\xDCV[\x92PPP\x92\x91PPV[_4\x11\x15a)\xBCW`@Q\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[V[_a)\xC7a$#V[_\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x90P\x90V[``\x82a)\xF1Wa)\xEC\x82a*iV[a*aV[_\x82Q\x14\x80\x15a*\x17WP_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16;\x14[\x15a*YW\x83`@Q\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a*P\x91\x90a0LV[`@Q\x80\x91\x03\x90\xFD[\x81\x90Pa*bV[[\x93\x92PPPV[_\x81Q\x11\x15a*{W\x80Q\x80\x82` \x01\xFD[`@Q\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Q\x80`@\x01`@R\x80``\x81R` \x01``\x81RP\x90V[`@Q\x80``\x01`@R\x80_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01``\x81RP\x90V[`@Q\x80`\xA0\x01`@R\x80_\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01``\x81R` \x01``\x81RP\x90V[`@Q\x80``\x01`@R\x80_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01``\x81RP\x90V[_`@Q\x90P\x90V[__\xFD[__\xFD[_\x81\x90P\x91\x90PV[a+\xD8\x81a+\xC6V[\x81\x14a+\xE2W__\xFD[PV[_\x815\x90Pa+\xF3\x81a+\xCFV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a,\x0EWa,\ra+\xBEV[[_a,\x1B\x84\x82\x85\x01a+\xE5V[\x91PP\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x82\x81\x83^_\x83\x83\x01RPPPV[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[_a,f\x82a,$V[a,p\x81\x85a,.V[\x93Pa,\x80\x81\x85` \x86\x01a,>V[a,\x89\x81a,LV[\x84\x01\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra,\xAC\x81\x84a,\\V[\x90P\x92\x91PPV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a,\xDD\x82a,\xB4V[\x90P\x91\x90PV[a,\xED\x81a,\xD3V[\x81\x14a,\xF7W__\xFD[PV[_\x815\x90Pa-\x08\x81a,\xE4V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a-#Wa-\"a+\xBEV[[_a-0\x84\x82\x85\x01a,\xFAV[\x91PP\x92\x91PPV[a-B\x81a+\xC6V[\x82RPPV[_` \x82\x01\x90Pa-[_\x83\x01\x84a-9V[\x92\x91PPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_a-{\x82a,$V[a-\x85\x81\x85a-aV[\x93Pa-\x95\x81\x85` \x86\x01a,>V[a-\x9E\x81a,LV[\x84\x01\x91PP\x92\x91PPV[_`@\x83\x01_\x83\x01Q\x84\x82\x03_\x86\x01Ra-\xC3\x82\x82a-qV[\x91PP` \x83\x01Q\x84\x82\x03` \x86\x01Ra-\xDD\x82\x82a-qV[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra.\x02\x81\x84a-\xA9V[\x90P\x92\x91PPV[__\xFD[__\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[a.H\x82a,LV[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a.gWa.fa.\x12V[[\x80`@RPPPV[_a.ya+\xB5V[\x90Pa.\x85\x82\x82a.?V[\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a.\xA4Wa.\xA3a.\x12V[[a.\xAD\x82a,LV[\x90P` \x81\x01\x90P\x91\x90PV[\x82\x81\x837_\x83\x83\x01RPPPV[_a.\xDAa.\xD5\x84a.\x8AV[a.pV[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a.\xF6Wa.\xF5a.\x0EV[[a/\x01\x84\x82\x85a.\xBAV[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a/\x1DWa/\x1Ca.\nV[[\x815a/-\x84\x82` \x86\x01a.\xC8V[\x91PP\x92\x91PPV[__`@\x83\x85\x03\x12\x15a/LWa/Ka+\xBEV[[_a/Y\x85\x82\x86\x01a,\xFAV[\x92PP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a/zWa/ya+\xC2V[[a/\x86\x85\x82\x86\x01a/\tV[\x91PP\x92P\x92\x90PV[_\x81\x90P\x91\x90PV[a/\xA2\x81a/\x90V[\x82RPPV[_` \x82\x01\x90Pa/\xBB_\x83\x01\x84a/\x99V[\x92\x91PPV[a/\xCA\x81a,\xD3V[\x82RPPV[_``\x83\x01_\x83\x01Qa/\xE5_\x86\x01\x82a/\xC1V[P` \x83\x01Qa/\xF8` \x86\x01\x82a/\xC1V[P`@\x83\x01Q\x84\x82\x03`@\x86\x01Ra0\x10\x82\x82a-qV[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra05\x81\x84a/\xD0V[\x90P\x92\x91PPV[a0F\x81a,\xD3V[\x82RPPV[_` \x82\x01\x90Pa0__\x83\x01\x84a0=V[\x92\x91PPV[__\xFD[_`\xA0\x82\x84\x03\x12\x15a0~Wa0}a0eV[[\x81\x90P\x92\x91PPV[_` \x82\x84\x03\x12\x15a0\x9CWa0\x9Ba+\xBEV[[_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a0\xB9Wa0\xB8a+\xC2V[[a0\xC5\x84\x82\x85\x01a0iV[\x91PP\x92\x91PPV[a0\xD7\x81a+\xC6V[\x82RPPV[_`\xA0\x83\x01_\x83\x01Qa0\xF2_\x86\x01\x82a0\xCEV[P` \x83\x01Qa1\x05` \x86\x01\x82a/\xC1V[P`@\x83\x01Qa1\x18`@\x86\x01\x82a/\xC1V[P``\x83\x01Q\x84\x82\x03``\x86\x01Ra10\x82\x82a-qV[\x91PP`\x80\x83\x01Q\x84\x82\x03`\x80\x86\x01Ra1J\x82\x82a-qV[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra1o\x81\x84a0\xDDV[\x90P\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_a1\xAB\x83\x83a/\xC1V[` \x83\x01\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_a1\xCD\x82a1wV[a1\xD7\x81\x85a1\x81V[\x93Pa1\xE2\x83a1\x91V[\x80_[\x83\x81\x10\x15a2\x12W\x81Qa1\xF9\x88\x82a1\xA0V[\x97Pa2\x04\x83a1\xB7V[\x92PP`\x01\x81\x01\x90Pa1\xE5V[P\x85\x93PPPP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra27\x81\x84a1\xC3V[\x90P\x92\x91PPV[__\xFD[__\xFD[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a2aWa2`a.\x12V[[a2j\x82a,LV[\x90P` \x81\x01\x90P\x91\x90PV[_a2\x89a2\x84\x84a2GV[a.pV[\x90P\x82\x81R` \x81\x01\x84\x84\x84\x01\x11\x15a2\xA5Wa2\xA4a.\x0EV[[a2\xB0\x84\x82\x85a.\xBAV[P\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a2\xCCWa2\xCBa.\nV[[\x815a2\xDC\x84\x82` \x86\x01a2wV[\x91PP\x92\x91PPV[_`@\x82\x84\x03\x12\x15a2\xFAWa2\xF9a2?V[[a3\x04`@a.pV[\x90P_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a3#Wa3\"a2CV[[a3/\x84\x82\x85\x01a2\xB8V[_\x83\x01RP` \x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a3RWa3Qa2CV[[a3^\x84\x82\x85\x01a2\xB8V[` \x83\x01RP\x92\x91PPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a3\x84Wa3\x83a.\x12V[[` \x82\x02\x90P` \x81\x01\x90P\x91\x90PV[__\xFD[_``\x82\x84\x03\x12\x15a3\xAEWa3\xADa2?V[[a3\xB8``a.pV[\x90P_a3\xC7\x84\x82\x85\x01a,\xFAV[_\x83\x01RP` a3\xDA\x84\x82\x85\x01a,\xFAV[` \x83\x01RP`@\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a3\xFEWa3\xFDa2CV[[a4\n\x84\x82\x85\x01a2\xB8V[`@\x83\x01RP\x92\x91PPV[_a4(a4#\x84a3jV[a.pV[\x90P\x80\x83\x82R` \x82\x01\x90P` \x84\x02\x83\x01\x85\x81\x11\x15a4KWa4Ja3\x95V[[\x83[\x81\x81\x10\x15a4\x92W\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a4pWa4oa.\nV[[\x80\x86\x01a4}\x89\x82a3\x99V[\x85R` \x85\x01\x94PPP` \x81\x01\x90Pa4MV[PPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a4\xB0Wa4\xAFa.\nV[[\x815a4\xC0\x84\x82` \x86\x01a4\x16V[\x91PP\x92\x91PPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a4\xE3Wa4\xE2a.\x12V[[` \x82\x02\x90P` \x81\x01\x90P\x91\x90PV[_``\x82\x84\x03\x12\x15a5\tWa5\x08a2?V[[a5\x13``a.pV[\x90P_a5\"\x84\x82\x85\x01a,\xFAV[_\x83\x01RP` a55\x84\x82\x85\x01a,\xFAV[` \x83\x01RP`@\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a5YWa5Xa2CV[[a5e\x84\x82\x85\x01a2\xB8V[`@\x83\x01RP\x92\x91PPV[_a5\x83a5~\x84a4\xC9V[a.pV[\x90P\x80\x83\x82R` \x82\x01\x90P` \x84\x02\x83\x01\x85\x81\x11\x15a5\xA6Wa5\xA5a3\x95V[[\x83[\x81\x81\x10\x15a5\xEDW\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a5\xCBWa5\xCAa.\nV[[\x80\x86\x01a5\xD8\x89\x82a4\xF4V[\x85R` \x85\x01\x94PPP` \x81\x01\x90Pa5\xA8V[PPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a6\x0BWa6\na.\nV[[\x815a6\x1B\x84\x82` \x86\x01a5qV[\x91PP\x92\x91PPV[_____`\xA0\x86\x88\x03\x12\x15a6=Wa6<a+\xBEV[[_a6J\x88\x82\x89\x01a,\xFAV[\x95PP` \x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a6kWa6ja+\xC2V[[a6w\x88\x82\x89\x01a2\xE5V[\x94PP`@a6\x88\x88\x82\x89\x01a+\xE5V[\x93PP``\x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a6\xA9Wa6\xA8a+\xC2V[[a6\xB5\x88\x82\x89\x01a4\x9CV[\x92PP`\x80\x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a6\xD6Wa6\xD5a+\xC2V[[a6\xE2\x88\x82\x89\x01a5\xF7V[\x91PP\x92\x95P\x92\x95\x90\x93PV[_``\x83\x01_\x83\x01Qa7\x04_\x86\x01\x82a/\xC1V[P` \x83\x01Qa7\x17` \x86\x01\x82a/\xC1V[P`@\x83\x01Q\x84\x82\x03`@\x86\x01Ra7/\x82\x82a-qV[\x91PP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra7T\x81\x84a6\xEFV[\x90P\x92\x91PPV[_`@\x82\x01\x90Pa7o_\x83\x01\x85a-9V[a7|` \x83\x01\x84a-9V[\x93\x92PPPV[_\x81\x90P\x92\x91PPV[_a7\x97\x82a,$V[a7\xA1\x81\x85a7\x83V[\x93Pa7\xB1\x81\x85` \x86\x01a,>V[\x80\x84\x01\x91PP\x92\x91PPV[\x7F v\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a7\xF1`\x02\x83a7\x83V[\x91Pa7\xFC\x82a7\xBDV[`\x02\x82\x01\x90P\x91\x90PV[\x7F.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a8;`\x01\x83a7\x83V[\x91Pa8F\x82a8\x07V[`\x01\x82\x01\x90P\x91\x90PV[_a8\\\x82\x87a7\x8DV[\x91Pa8g\x82a7\xE5V[\x91Pa8s\x82\x86a7\x8DV[\x91Pa8~\x82a8/V[\x91Pa8\x8A\x82\x85a7\x8DV[\x91Pa8\x95\x82a8/V[\x91Pa8\xA1\x82\x84a7\x8DV[\x91P\x81\x90P\x95\x94PPPPPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_a8\xE6\x82a+\xC6V[\x91Pa8\xF1\x83a+\xC6V[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15a9\tWa9\x08a8\xAFV[[\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\"`\x04R`$_\xFD[_`\x02\x82\x04\x90P`\x01\x82\x16\x80a9SW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a9fWa9ea9\x0FV[[P\x91\x90PV[_a9v\x82a+\xC6V[\x91Pa9\x81\x83a+\xC6V[\x92P\x82\x82\x02a9\x8F\x81a+\xC6V[\x91P\x82\x82\x04\x84\x14\x83\x15\x17a9\xA6Wa9\xA5a8\xAFV[[P\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_a:\x11\x82a+\xC6V[\x91Pa:\x1C\x83a+\xC6V[\x92P\x82a:,Wa:+a9\xDAV[[\x82\x82\x04\x90P\x92\x91PPV[_\x815a:C\x81a+\xCFV[\x80\x91PP\x91\x90PV[_\x81_\x1B\x90P\x91\x90PV[_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa:\x82\x84a:LV[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[_\x81\x90P\x91\x90PV[_a:\xBBa:\xB6a:\xB1\x84a+\xC6V[a:\x98V[a+\xC6V[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a:\xD4\x82a:\xA1V[a:\xE7a:\xE0\x82a:\xC2V[\x83Ta:WV[\x82UPPPV[_\x815a:\xFA\x81a,\xE4V[\x80\x91PP\x91\x90PV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa;\"\x84a:LV[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[_a;Ra;Ma;H\x84a,\xB4V[a:\x98V[a,\xB4V[\x90P\x91\x90PV[_a;c\x82a;8V[\x90P\x91\x90PV[_a;t\x82a;YV[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a;\x8D\x82a;jV[a;\xA0a;\x99\x82a;{V[\x83Ta;\x03V[\x82UPPPV[__\xFD[__\xFD[__\xFD[__\x835`\x01` \x03\x846\x03\x03\x81\x12a;\xCFWa;\xCEa;\xA7V[[\x80\x84\x01\x92P\x825\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a;\xF1Wa;\xF0a;\xABV[[` \x83\x01\x92P`\x01\x82\x026\x03\x83\x13\x15a<\rWa<\x0Ca;\xAFV[[P\x92P\x92\x90PV[_\x82\x90P\x92\x91PPV[_\x81\x90P\x81_R` _ \x90P\x91\x90PV[_` `\x1F\x83\x01\x04\x90P\x91\x90PV[_\x82\x82\x1B\x90P\x92\x91PPV[_`\x08\x83\x02a<{\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82a<@V[a<\x85\x86\x83a<@V[\x95P\x80\x19\x84\x16\x93P\x80\x86\x16\x84\x17\x92PPP\x93\x92PPPV[a<\xA6\x83a:\xA1V[a<\xBAa<\xB2\x82a:\xC2V[\x84\x84Ta<LV[\x82UPPPPV[__\x90P\x90V[a<\xD1a<\xC2V[a<\xDC\x81\x84\x84a<\x9DV[PPPV[[\x81\x81\x10\x15a<\xFFWa<\xF4_\x82a<\xC9V[`\x01\x81\x01\x90Pa<\xE2V[PPV[`\x1F\x82\x11\x15a=DWa=\x15\x81a<\x1FV[a=\x1E\x84a<1V[\x81\x01` \x85\x10\x15a=-W\x81\x90P[a=Aa=9\x85a<1V[\x83\x01\x82a<\xE1V[PP[PPPV[_\x82\x82\x1C\x90P\x92\x91PPV[_a=d_\x19\x84`\x08\x02a=IV[\x19\x80\x83\x16\x91PP\x92\x91PPV[_a=|\x83\x83a=UV[\x91P\x82`\x02\x02\x82\x17\x90P\x92\x91PPV[a=\x96\x83\x83a<\x15V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a=\xAFWa=\xAEa.\x12V[[a=\xB9\x82Ta9<V[a=\xC4\x82\x82\x85a=\x03V[_`\x1F\x83\x11`\x01\x81\x14a=\xF1W_\x84\x15a=\xDFW\x82\x87\x015\x90P[a=\xE9\x85\x82a=qV[\x86UPa>PV[`\x1F\x19\x84\x16a=\xFF\x86a<\x1FV[_[\x82\x81\x10\x15a>&W\x84\x89\x015\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Pa>\x01V[\x86\x83\x10\x15a>CW\x84\x89\x015a>?`\x1F\x89\x16\x82a=UV[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPPV[a>d\x83\x83\x83a=\x8CV[PPPV[_\x81\x01_\x83\x01\x80a>y\x81a:7V[\x90Pa>\x85\x81\x84a:\xCBV[PPP`\x01\x81\x01` \x83\x01\x80a>\x9A\x81a:\xEEV[\x90Pa>\xA6\x81\x84a;\x84V[PPP`\x02\x81\x01`@\x83\x01\x80a>\xBB\x81a:\xEEV[\x90Pa>\xC7\x81\x84a;\x84V[PPP`\x03\x81\x01``\x83\x01a>\xDC\x81\x85a;\xB3V[a>\xE7\x81\x83\x86a>YV[PPPP`\x04\x81\x01`\x80\x83\x01a>\xFD\x81\x85a;\xB3V[a?\x08\x81\x83\x86a>YV[PPPPPPV[a?\x1A\x82\x82a>iV[PPV[_a?,` \x84\x01\x84a+\xE5V[\x90P\x92\x91PPV[_a?B` \x84\x01\x84a,\xFAV[\x90P\x92\x91PPV[__\xFD[__\xFD[__\xFD[__\x835`\x01` \x03\x846\x03\x03\x81\x12a?rWa?qa?RV[[\x83\x81\x01\x92P\x825\x91P` \x83\x01\x92Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a?\x9AWa?\x99a?JV[[`\x01\x82\x026\x03\x83\x13\x15a?\xB0Wa?\xAFa?NV[[P\x92P\x92\x90PV[_a?\xC3\x83\x85a-aV[\x93Pa?\xD0\x83\x85\x84a.\xBAV[a?\xD9\x83a,LV[\x84\x01\x90P\x93\x92PPPV[_`\xA0\x83\x01a?\xF5_\x84\x01\x84a?\x1EV[a@\x01_\x86\x01\x82a0\xCEV[Pa@\x0F` \x84\x01\x84a?4V[a@\x1C` \x86\x01\x82a/\xC1V[Pa@*`@\x84\x01\x84a?4V[a@7`@\x86\x01\x82a/\xC1V[Pa@E``\x84\x01\x84a?VV[\x85\x83\x03``\x87\x01Ra@X\x83\x82\x84a?\xB8V[\x92PPPa@i`\x80\x84\x01\x84a?VV[\x85\x83\x03`\x80\x87\x01Ra@|\x83\x82\x84a?\xB8V[\x92PPP\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra@\xA2\x81\x84a?\xE4V[\x90P\x92\x91PPV[a@\xB3\x82a,$V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a@\xCCWa@\xCBa.\x12V[[a@\xD6\x82Ta9<V[a@\xE1\x82\x82\x85a=\x03V[_` \x90P`\x1F\x83\x11`\x01\x81\x14aA\x12W_\x84\x15aA\0W\x82\x87\x01Q\x90P[aA\n\x85\x82a=qV[\x86UPaAqV[`\x1F\x19\x84\x16aA \x86a<\x1FV[_[\x82\x81\x10\x15aAGW\x84\x89\x01Q\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90PaA\"V[\x86\x83\x10\x15aAdW\x84\x89\x01QaA``\x1F\x89\x16\x82a=UV[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_``\x83\x01_\x83\x01QaA\xB7_\x86\x01\x82a/\xC1V[P` \x83\x01QaA\xCA` \x86\x01\x82a/\xC1V[P`@\x83\x01Q\x84\x82\x03`@\x86\x01RaA\xE2\x82\x82a-qV[\x91PP\x80\x91PP\x92\x91PPV[_aA\xFA\x83\x83aA\xA2V[\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_aB\x18\x82aAyV[aB\"\x81\x85aA\x83V[\x93P\x83` \x82\x02\x85\x01aB4\x85aA\x93V[\x80_[\x85\x81\x10\x15aBoW\x84\x84\x03\x89R\x81QaBP\x85\x82aA\xEFV[\x94PaB[\x83aB\x02V[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90PaB7V[P\x82\x97P\x87\x95PPPPPP\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_``\x83\x01_\x83\x01QaB\xBF_\x86\x01\x82a/\xC1V[P` \x83\x01QaB\xD2` \x86\x01\x82a/\xC1V[P`@\x83\x01Q\x84\x82\x03`@\x86\x01RaB\xEA\x82\x82a-qV[\x91PP\x80\x91PP\x92\x91PPV[_aC\x02\x83\x83aB\xAAV[\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_aC \x82aB\x81V[aC*\x81\x85aB\x8BV[\x93P\x83` \x82\x02\x85\x01aC<\x85aB\x9BV[\x80_[\x85\x81\x10\x15aCwW\x84\x84\x03\x89R\x81QaCX\x85\x82aB\xF7V[\x94PaCc\x83aC\nV[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90PaC?V[P\x82\x97P\x87\x95PPPPPP\x92\x91PPV[_`\xA0\x82\x01\x90PaC\x9C_\x83\x01\x88a0=V[\x81\x81\x03` \x83\x01RaC\xAE\x81\x87a-\xA9V[\x90PaC\xBD`@\x83\x01\x86a-9V[\x81\x81\x03``\x83\x01RaC\xCF\x81\x85aB\x0EV[\x90P\x81\x81\x03`\x80\x83\x01RaC\xE3\x81\x84aC\x16V[\x90P\x96\x95PPPPPPV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[aD\x0B\x81aC\xEFV[\x82RPPV[_` \x82\x01\x90PaD$_\x83\x01\x84aD\x02V[\x92\x91PPV[aD3\x81a/\x90V[\x81\x14aD=W__\xFD[PV[_\x81Q\x90PaDN\x81aD*V[\x92\x91PPV[_` \x82\x84\x03\x12\x15aDiWaDha+\xBEV[[_aDv\x84\x82\x85\x01aD@V[\x91PP\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x81\x90P\x92\x91PPV[_aD\x9D\x82aD\x7FV[aD\xA7\x81\x85aD\x89V[\x93PaD\xB7\x81\x85` \x86\x01a,>V[\x80\x84\x01\x91PP\x92\x91PPV[_aD\xCE\x82\x84aD\x93V[\x91P\x81\x90P\x92\x91PPV\xFE\xA2dipfsX\"\x12 \x19\x1E$\xD4q\xDEl\0{\xE3\xFE[\x9F\xA0\xC7\xAC\xB7\xC7\x90\xD1\x1C\xA2V\x9B\xE4\xB5\xBBdP\xBF\xD2\xADdsolcC\0\x08\x1C\x003",
    );
    /**```solidity
struct Coprocessor { address txSenderAddress; address signerAddress; string s3BucketUrl; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Coprocessor {
        #[allow(missing_docs)]
        pub txSenderAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub signerAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub s3BucketUrl: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::String,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::String,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Coprocessor> for UnderlyingRustTuple<'_> {
            fn from(value: Coprocessor) -> Self {
                (value.txSenderAddress, value.signerAddress, value.s3BucketUrl)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Coprocessor {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    txSenderAddress: tuple.0,
                    signerAddress: tuple.1,
                    s3BucketUrl: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Coprocessor {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Coprocessor {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.txSenderAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signerAddress,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.s3BucketUrl,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Coprocessor {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Coprocessor {
            const NAME: &'static str = "Coprocessor";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Coprocessor(address txSenderAddress,address signerAddress,string s3BucketUrl)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.txSenderAddress,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.signerAddress,
                        )
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.s3BucketUrl,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Coprocessor {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.txSenderAddress,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.signerAddress,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.s3BucketUrl,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.txSenderAddress,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.signerAddress,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.s3BucketUrl,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct KmsNode { address txSenderAddress; address signerAddress; string ipAddress; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KmsNode {
        #[allow(missing_docs)]
        pub txSenderAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub signerAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub ipAddress: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::String,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::String,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KmsNode> for UnderlyingRustTuple<'_> {
            fn from(value: KmsNode) -> Self {
                (value.txSenderAddress, value.signerAddress, value.ipAddress)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for KmsNode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    txSenderAddress: tuple.0,
                    signerAddress: tuple.1,
                    ipAddress: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for KmsNode {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for KmsNode {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.txSenderAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signerAddress,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.ipAddress,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for KmsNode {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for KmsNode {
            const NAME: &'static str = "KmsNode";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "KmsNode(address txSenderAddress,address signerAddress,string ipAddress)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.txSenderAddress,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.signerAddress,
                        )
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.ipAddress,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for KmsNode {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.txSenderAddress,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.signerAddress,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.ipAddress,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.txSenderAddress,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.signerAddress,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.ipAddress,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct Network { uint256 chainId; address httpzExecutor; address aclAddress; string name; string website; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Network {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub httpzExecutor: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub aclAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub name: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub website: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::String,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::String,
            alloy::sol_types::private::String,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Network> for UnderlyingRustTuple<'_> {
            fn from(value: Network) -> Self {
                (
                    value.chainId,
                    value.httpzExecutor,
                    value.aclAddress,
                    value.name,
                    value.website,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Network {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    chainId: tuple.0,
                    httpzExecutor: tuple.1,
                    aclAddress: tuple.2,
                    name: tuple.3,
                    website: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Network {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Network {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.httpzExecutor,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.aclAddress,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.website,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Network {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Network {
            const NAME: &'static str = "Network";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Network(uint256 chainId,address httpzExecutor,address aclAddress,string name,string website)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainId)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.httpzExecutor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.aclAddress,
                        )
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.name,
                        )
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.website,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Network {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainId,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.httpzExecutor,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.aclAddress,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.name,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.website,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainId,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.httpzExecutor,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.aclAddress,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.name,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.website,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ProtocolMetadata { string name; string website; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ProtocolMetadata {
        #[allow(missing_docs)]
        pub name: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub website: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::String,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::String,
            alloy::sol_types::private::String,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ProtocolMetadata> for UnderlyingRustTuple<'_> {
            fn from(value: ProtocolMetadata) -> Self {
                (value.name, value.website)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ProtocolMetadata {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    name: tuple.0,
                    website: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ProtocolMetadata {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ProtocolMetadata {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.website,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ProtocolMetadata {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ProtocolMetadata {
            const NAME: &'static str = "ProtocolMetadata";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ProtocolMetadata(string name,string website)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.name,
                        )
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.website,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ProtocolMetadata {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.name,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.website,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.name,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.website,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Custom error with signature `AddressEmptyCode(address)` and selector `0x9996b315`.
```solidity
error AddressEmptyCode(address target);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AddressEmptyCode {
        #[allow(missing_docs)]
        pub target: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AddressEmptyCode> for UnderlyingRustTuple<'_> {
            fn from(value: AddressEmptyCode) -> Self {
                (value.target,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AddressEmptyCode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { target: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AddressEmptyCode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AddressEmptyCode(address)";
            const SELECTOR: [u8; 4] = [153u8, 150u8, 179u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC1967InvalidImplementation(address)` and selector `0x4c9c8ce3`.
```solidity
error ERC1967InvalidImplementation(address implementation);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967InvalidImplementation {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967InvalidImplementation>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967InvalidImplementation) -> Self {
                (value.implementation,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC1967InvalidImplementation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { implementation: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967InvalidImplementation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967InvalidImplementation(address)";
            const SELECTOR: [u8; 4] = [76u8, 156u8, 140u8, 227u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC1967NonPayable()` and selector `0xb398979f`.
```solidity
error ERC1967NonPayable();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967NonPayable {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967NonPayable> for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967NonPayable) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC1967NonPayable {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967NonPayable {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967NonPayable()";
            const SELECTOR: [u8; 4] = [179u8, 152u8, 151u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `FailedCall()` and selector `0xd6bda275`.
```solidity
error FailedCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FailedCall {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedCall> for UnderlyingRustTuple<'_> {
            fn from(value: FailedCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FailedCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedCall()";
            const SELECTOR: [u8; 4] = [214u8, 189u8, 162u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidInitialization()` and selector `0xf92ee8a9`.
```solidity
error InvalidInitialization();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidInitialization {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidInitialization> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidInitialization) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidInitialization {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidInitialization {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidInitialization()";
            const SELECTOR: [u8; 4] = [249u8, 46u8, 232u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidNullChainId()` and selector `0x22f73fea`.
```solidity
error InvalidNullChainId();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidNullChainId {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidNullChainId> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidNullChainId) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidNullChainId {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidNullChainId {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidNullChainId()";
            const SELECTOR: [u8; 4] = [34u8, 247u8, 63u8, 234u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `KmsThresholdTooHigh(uint256,uint256)` and selector `0x48676fe0`.
```solidity
error KmsThresholdTooHigh(uint256 threshold, uint256 nParties);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KmsThresholdTooHigh {
        #[allow(missing_docs)]
        pub threshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nParties: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KmsThresholdTooHigh> for UnderlyingRustTuple<'_> {
            fn from(value: KmsThresholdTooHigh) -> Self {
                (value.threshold, value.nParties)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for KmsThresholdTooHigh {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    threshold: tuple.0,
                    nParties: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for KmsThresholdTooHigh {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "KmsThresholdTooHigh(uint256,uint256)";
            const SELECTOR: [u8; 4] = [72u8, 103u8, 111u8, 224u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.threshold),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nParties),
                )
            }
        }
    };
    /**Custom error with signature `NetworkAlreadyRegistered(uint256)` and selector `0xb1825c5e`.
```solidity
error NetworkAlreadyRegistered(uint256 chainId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NetworkAlreadyRegistered {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NetworkAlreadyRegistered>
        for UnderlyingRustTuple<'_> {
            fn from(value: NetworkAlreadyRegistered) -> Self {
                (value.chainId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for NetworkAlreadyRegistered {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { chainId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NetworkAlreadyRegistered {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NetworkAlreadyRegistered(uint256)";
            const SELECTOR: [u8; 4] = [177u8, 130u8, 92u8, 94u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                )
            }
        }
    };
    /**Custom error with signature `NetworkNotRegistered(uint256)` and selector `0x6df6fe89`.
```solidity
error NetworkNotRegistered(uint256 chainId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NetworkNotRegistered {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NetworkNotRegistered> for UnderlyingRustTuple<'_> {
            fn from(value: NetworkNotRegistered) -> Self {
                (value.chainId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NetworkNotRegistered {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { chainId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NetworkNotRegistered {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NetworkNotRegistered(uint256)";
            const SELECTOR: [u8; 4] = [109u8, 246u8, 254u8, 137u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                )
            }
        }
    };
    /**Custom error with signature `NotCoprocessorSigner(address)` and selector `0x26cd75dc`.
```solidity
error NotCoprocessorSigner(address signerAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotCoprocessorSigner {
        #[allow(missing_docs)]
        pub signerAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotCoprocessorSigner> for UnderlyingRustTuple<'_> {
            fn from(value: NotCoprocessorSigner) -> Self {
                (value.signerAddress,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotCoprocessorSigner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { signerAddress: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotCoprocessorSigner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotCoprocessorSigner(address)";
            const SELECTOR: [u8; 4] = [38u8, 205u8, 117u8, 220u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signerAddress,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `NotCoprocessorTxSender(address)` and selector `0x52d725f5`.
```solidity
error NotCoprocessorTxSender(address txSenderAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotCoprocessorTxSender {
        #[allow(missing_docs)]
        pub txSenderAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotCoprocessorTxSender> for UnderlyingRustTuple<'_> {
            fn from(value: NotCoprocessorTxSender) -> Self {
                (value.txSenderAddress,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotCoprocessorTxSender {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { txSenderAddress: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotCoprocessorTxSender {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotCoprocessorTxSender(address)";
            const SELECTOR: [u8; 4] = [82u8, 215u8, 37u8, 245u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.txSenderAddress,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `NotInitializing()` and selector `0xd7e6bcf8`.
```solidity
error NotInitializing();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotInitializing {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotInitializing> for UnderlyingRustTuple<'_> {
            fn from(value: NotInitializing) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotInitializing {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotInitializing {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotInitializing()";
            const SELECTOR: [u8; 4] = [215u8, 230u8, 188u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `NotKmsSigner(address)` and selector `0x2a7c6ef6`.
```solidity
error NotKmsSigner(address signerAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotKmsSigner {
        #[allow(missing_docs)]
        pub signerAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotKmsSigner> for UnderlyingRustTuple<'_> {
            fn from(value: NotKmsSigner) -> Self {
                (value.signerAddress,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotKmsSigner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { signerAddress: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotKmsSigner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotKmsSigner(address)";
            const SELECTOR: [u8; 4] = [42u8, 124u8, 110u8, 246u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signerAddress,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `NotKmsTxSender(address)` and selector `0xaee86323`.
```solidity
error NotKmsTxSender(address txSenderAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotKmsTxSender {
        #[allow(missing_docs)]
        pub txSenderAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotKmsTxSender> for UnderlyingRustTuple<'_> {
            fn from(value: NotKmsTxSender) -> Self {
                (value.txSenderAddress,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotKmsTxSender {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { txSenderAddress: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotKmsTxSender {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotKmsTxSender(address)";
            const SELECTOR: [u8; 4] = [174u8, 232u8, 99u8, 35u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.txSenderAddress,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `NotPauser(address)` and selector `0x206a346e`.
```solidity
error NotPauser(address pauserAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotPauser {
        #[allow(missing_docs)]
        pub pauserAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotPauser> for UnderlyingRustTuple<'_> {
            fn from(value: NotPauser) -> Self {
                (value.pauserAddress,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotPauser {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { pauserAddress: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotPauser {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotPauser(address)";
            const SELECTOR: [u8; 4] = [32u8, 106u8, 52u8, 110u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.pauserAddress,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `OwnableInvalidOwner(address)` and selector `0x1e4fbdf7`.
```solidity
error OwnableInvalidOwner(address owner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OwnableInvalidOwner {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OwnableInvalidOwner> for UnderlyingRustTuple<'_> {
            fn from(value: OwnableInvalidOwner) -> Self {
                (value.owner,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OwnableInvalidOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { owner: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OwnableInvalidOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OwnableInvalidOwner(address)";
            const SELECTOR: [u8; 4] = [30u8, 79u8, 189u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `OwnableUnauthorizedAccount(address)` and selector `0x118cdaa7`.
```solidity
error OwnableUnauthorizedAccount(address account);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OwnableUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OwnableUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: OwnableUnauthorizedAccount) -> Self {
                (value.account,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for OwnableUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { account: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OwnableUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OwnableUnauthorizedAccount(address)";
            const SELECTOR: [u8; 4] = [17u8, 140u8, 218u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `UUPSUnauthorizedCallContext()` and selector `0xe07c8dba`.
```solidity
error UUPSUnauthorizedCallContext();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnauthorizedCallContext {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnauthorizedCallContext>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnauthorizedCallContext) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnauthorizedCallContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnauthorizedCallContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnauthorizedCallContext()";
            const SELECTOR: [u8; 4] = [224u8, 124u8, 141u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `UUPSUnsupportedProxiableUUID(bytes32)` and selector `0xaa1d49a4`.
```solidity
error UUPSUnsupportedProxiableUUID(bytes32 slot);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnsupportedProxiableUUID {
        #[allow(missing_docs)]
        pub slot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnsupportedProxiableUUID>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnsupportedProxiableUUID) -> Self {
                (value.slot,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnsupportedProxiableUUID {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { slot: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnsupportedProxiableUUID {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnsupportedProxiableUUID(bytes32)";
            const SELECTOR: [u8; 4] = [170u8, 29u8, 73u8, 164u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
        }
    };
    /**Event with signature `AddNetwork((uint256,address,address,string,string))` and selector `0xb8207b5bb791730ae8f0534fa4c7be7da49dd75d701f9c7acf51c94b8ace96b2`.
```solidity
event AddNetwork(Network network);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct AddNetwork {
        #[allow(missing_docs)]
        pub network: <Network as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for AddNetwork {
            type DataTuple<'a> = (Network,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "AddNetwork((uint256,address,address,string,string))";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                184u8,
                32u8,
                123u8,
                91u8,
                183u8,
                145u8,
                115u8,
                10u8,
                232u8,
                240u8,
                83u8,
                79u8,
                164u8,
                199u8,
                190u8,
                125u8,
                164u8,
                157u8,
                215u8,
                93u8,
                112u8,
                31u8,
                156u8,
                122u8,
                207u8,
                81u8,
                201u8,
                75u8,
                138u8,
                206u8,
                150u8,
                178u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { network: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (<Network as alloy_sol_types::SolType>::tokenize(&self.network),)
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for AddNetwork {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&AddNetwork> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &AddNetwork) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Initialization(address,(string,string),uint256,(address,address,string)[],(address,address,string)[])` and selector `0xf33d908c4a8b532fe64df20b726f11405c11b9772d31b66f5eef6887a43c3fde`.
```solidity
event Initialization(address pauser, ProtocolMetadata metadata, uint256 kmsThreshold, KmsNode[] kmsNodes, Coprocessor[] coprocessors);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialization {
        #[allow(missing_docs)]
        pub pauser: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub metadata: <ProtocolMetadata as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub kmsThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub kmsNodes: alloy::sol_types::private::Vec<
            <KmsNode as alloy::sol_types::SolType>::RustType,
        >,
        #[allow(missing_docs)]
        pub coprocessors: alloy::sol_types::private::Vec<
            <Coprocessor as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialization {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                ProtocolMetadata,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<KmsNode>,
                alloy::sol_types::sol_data::Array<Coprocessor>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialization(address,(string,string),uint256,(address,address,string)[],(address,address,string)[])";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                243u8,
                61u8,
                144u8,
                140u8,
                74u8,
                139u8,
                83u8,
                47u8,
                230u8,
                77u8,
                242u8,
                11u8,
                114u8,
                111u8,
                17u8,
                64u8,
                92u8,
                17u8,
                185u8,
                119u8,
                45u8,
                49u8,
                182u8,
                111u8,
                94u8,
                239u8,
                104u8,
                135u8,
                164u8,
                60u8,
                63u8,
                222u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    pauser: data.0,
                    metadata: data.1,
                    kmsThreshold: data.2,
                    kmsNodes: data.3,
                    coprocessors: data.4,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.pauser,
                    ),
                    <ProtocolMetadata as alloy_sol_types::SolType>::tokenize(
                        &self.metadata,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.kmsThreshold),
                    <alloy::sol_types::sol_data::Array<
                        KmsNode,
                    > as alloy_sol_types::SolType>::tokenize(&self.kmsNodes),
                    <alloy::sol_types::sol_data::Array<
                        Coprocessor,
                    > as alloy_sol_types::SolType>::tokenize(&self.coprocessors),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialization {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialization> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialization) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Initialized(uint64)` and selector `0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2`.
```solidity
event Initialized(uint64 version);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                199u8,
                245u8,
                5u8,
                178u8,
                243u8,
                113u8,
                174u8,
                33u8,
                117u8,
                238u8,
                73u8,
                19u8,
                244u8,
                73u8,
                158u8,
                31u8,
                38u8,
                51u8,
                167u8,
                181u8,
                147u8,
                99u8,
                33u8,
                238u8,
                209u8,
                205u8,
                174u8,
                182u8,
                17u8,
                81u8,
                129u8,
                210u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.version),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OwnershipTransferStarted(address,address)` and selector `0x38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e22700`.
```solidity
event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferStarted {
        #[allow(missing_docs)]
        pub previousOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferStarted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferStarted(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                56u8,
                209u8,
                107u8,
                140u8,
                172u8,
                34u8,
                217u8,
                159u8,
                199u8,
                193u8,
                36u8,
                185u8,
                205u8,
                13u8,
                226u8,
                211u8,
                250u8,
                31u8,
                174u8,
                244u8,
                32u8,
                191u8,
                231u8,
                145u8,
                216u8,
                195u8,
                98u8,
                215u8,
                101u8,
                226u8,
                39u8,
                0u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferStarted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferStarted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &OwnershipTransferStarted,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
```solidity
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub previousOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8,
                224u8,
                7u8,
                156u8,
                83u8,
                22u8,
                89u8,
                20u8,
                19u8,
                68u8,
                205u8,
                31u8,
                208u8,
                164u8,
                242u8,
                132u8,
                25u8,
                73u8,
                127u8,
                151u8,
                34u8,
                163u8,
                218u8,
                175u8,
                227u8,
                180u8,
                24u8,
                111u8,
                107u8,
                100u8,
                87u8,
                224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `UpdateKmsThreshold(uint256)` and selector `0xea6c6521bc495731082e23ad12c7b1207d13ca0bd38d1d511081ab568917cb84`.
```solidity
event UpdateKmsThreshold(uint256 newKmsThreshold);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct UpdateKmsThreshold {
        #[allow(missing_docs)]
        pub newKmsThreshold: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for UpdateKmsThreshold {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "UpdateKmsThreshold(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                234u8,
                108u8,
                101u8,
                33u8,
                188u8,
                73u8,
                87u8,
                49u8,
                8u8,
                46u8,
                35u8,
                173u8,
                18u8,
                199u8,
                177u8,
                32u8,
                125u8,
                19u8,
                202u8,
                11u8,
                211u8,
                141u8,
                29u8,
                81u8,
                16u8,
                129u8,
                171u8,
                86u8,
                137u8,
                23u8,
                203u8,
                132u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { newKmsThreshold: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newKmsThreshold),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for UpdateKmsThreshold {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&UpdateKmsThreshold> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &UpdateKmsThreshold) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Upgraded(address)` and selector `0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b`.
```solidity
event Upgraded(address indexed implementation);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Upgraded {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Upgraded {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Upgraded(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                188u8,
                124u8,
                215u8,
                90u8,
                32u8,
                238u8,
                39u8,
                253u8,
                154u8,
                222u8,
                186u8,
                179u8,
                32u8,
                65u8,
                247u8,
                85u8,
                33u8,
                77u8,
                188u8,
                107u8,
                255u8,
                169u8,
                12u8,
                192u8,
                34u8,
                91u8,
                57u8,
                218u8,
                46u8,
                92u8,
                45u8,
                59u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { implementation: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.implementation.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.implementation,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Upgraded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Upgraded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Upgraded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {}
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Function with signature `UPGRADE_INTERFACE_VERSION()` and selector `0xad3cb1cc`.
```solidity
function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONCall {}
    ///Container type for the return parameters of the [`UPGRADE_INTERFACE_VERSION()`](UPGRADE_INTERFACE_VERSIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for UPGRADE_INTERFACE_VERSIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = UPGRADE_INTERFACE_VERSIONReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UPGRADE_INTERFACE_VERSION()";
            const SELECTOR: [u8; 4] = [173u8, 60u8, 177u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `acceptOwnership()` and selector `0x79ba5097`.
```solidity
function acceptOwnership() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct acceptOwnershipCall {}
    ///Container type for the return parameters of the [`acceptOwnership()`](acceptOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct acceptOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<acceptOwnershipCall> for UnderlyingRustTuple<'_> {
                fn from(value: acceptOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for acceptOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<acceptOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: acceptOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for acceptOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for acceptOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = acceptOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "acceptOwnership()";
            const SELECTOR: [u8; 4] = [121u8, 186u8, 80u8, 151u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `addNetwork((uint256,address,address,string,string))` and selector `0x70cc9a3c`.
```solidity
function addNetwork(Network memory network) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addNetworkCall {
        #[allow(missing_docs)]
        pub network: <Network as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`addNetwork((uint256,address,address,string,string))`](addNetworkCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addNetworkReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Network,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Network as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addNetworkCall> for UnderlyingRustTuple<'_> {
                fn from(value: addNetworkCall) -> Self {
                    (value.network,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addNetworkCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { network: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addNetworkReturn> for UnderlyingRustTuple<'_> {
                fn from(value: addNetworkReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addNetworkReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addNetworkCall {
            type Parameters<'a> = (Network,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addNetworkReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addNetwork((uint256,address,address,string,string))";
            const SELECTOR: [u8; 4] = [112u8, 204u8, 154u8, 60u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<Network as alloy_sol_types::SolType>::tokenize(&self.network),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `checkIsCoprocessorSigner(address)` and selector `0xcdb4c2b9`.
```solidity
function checkIsCoprocessorSigner(address signerAddress) external view;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsCoprocessorSignerCall {
        #[allow(missing_docs)]
        pub signerAddress: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkIsCoprocessorSigner(address)`](checkIsCoprocessorSignerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsCoprocessorSignerReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsCoprocessorSignerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsCoprocessorSignerCall) -> Self {
                    (value.signerAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsCoprocessorSignerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { signerAddress: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsCoprocessorSignerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsCoprocessorSignerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsCoprocessorSignerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkIsCoprocessorSignerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkIsCoprocessorSignerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkIsCoprocessorSigner(address)";
            const SELECTOR: [u8; 4] = [205u8, 180u8, 194u8, 185u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signerAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `checkIsCoprocessorTxSender(address)` and selector `0xcb661755`.
```solidity
function checkIsCoprocessorTxSender(address txSenderAddress) external view;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsCoprocessorTxSenderCall {
        #[allow(missing_docs)]
        pub txSenderAddress: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkIsCoprocessorTxSender(address)`](checkIsCoprocessorTxSenderCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsCoprocessorTxSenderReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsCoprocessorTxSenderCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsCoprocessorTxSenderCall) -> Self {
                    (value.txSenderAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsCoprocessorTxSenderCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { txSenderAddress: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsCoprocessorTxSenderReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsCoprocessorTxSenderReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsCoprocessorTxSenderReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkIsCoprocessorTxSenderCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkIsCoprocessorTxSenderReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkIsCoprocessorTxSender(address)";
            const SELECTOR: [u8; 4] = [203u8, 102u8, 23u8, 85u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.txSenderAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `checkIsKmsSigner(address)` and selector `0x6c88eb43`.
```solidity
function checkIsKmsSigner(address signerAddress) external view;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsKmsSignerCall {
        #[allow(missing_docs)]
        pub signerAddress: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkIsKmsSigner(address)`](checkIsKmsSignerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsKmsSignerReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsKmsSignerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsKmsSignerCall) -> Self {
                    (value.signerAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsKmsSignerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { signerAddress: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsKmsSignerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsKmsSignerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsKmsSignerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkIsKmsSignerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkIsKmsSignerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkIsKmsSigner(address)";
            const SELECTOR: [u8; 4] = [108u8, 136u8, 235u8, 67u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signerAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `checkIsKmsTxSender(address)` and selector `0xc6275258`.
```solidity
function checkIsKmsTxSender(address txSenderAddress) external view;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsKmsTxSenderCall {
        #[allow(missing_docs)]
        pub txSenderAddress: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkIsKmsTxSender(address)`](checkIsKmsTxSenderCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsKmsTxSenderReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsKmsTxSenderCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsKmsTxSenderCall) -> Self {
                    (value.txSenderAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsKmsTxSenderCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { txSenderAddress: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsKmsTxSenderReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkIsKmsTxSenderReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkIsKmsTxSenderReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkIsKmsTxSenderCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkIsKmsTxSenderReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkIsKmsTxSender(address)";
            const SELECTOR: [u8; 4] = [198u8, 39u8, 82u8, 88u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.txSenderAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `checkIsPauser(address)` and selector `0x195afde6`.
```solidity
function checkIsPauser(address pauserAddress) external view;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsPauserCall {
        #[allow(missing_docs)]
        pub pauserAddress: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`checkIsPauser(address)`](checkIsPauserCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkIsPauserReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsPauserCall> for UnderlyingRustTuple<'_> {
                fn from(value: checkIsPauserCall) -> Self {
                    (value.pauserAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for checkIsPauserCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { pauserAddress: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkIsPauserReturn> for UnderlyingRustTuple<'_> {
                fn from(value: checkIsPauserReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for checkIsPauserReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkIsPauserCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkIsPauserReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkIsPauser(address)";
            const SELECTOR: [u8; 4] = [25u8, 90u8, 253u8, 230u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.pauserAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `checkNetworkIsRegistered(uint256)` and selector `0xc6b3024d`.
```solidity
function checkNetworkIsRegistered(uint256 chainId) external view;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkNetworkIsRegisteredCall {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`checkNetworkIsRegistered(uint256)`](checkNetworkIsRegisteredCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkNetworkIsRegisteredReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkNetworkIsRegisteredCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkNetworkIsRegisteredCall) -> Self {
                    (value.chainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkNetworkIsRegisteredCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { chainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkNetworkIsRegisteredReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: checkNetworkIsRegisteredReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for checkNetworkIsRegisteredReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkNetworkIsRegisteredCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkNetworkIsRegisteredReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkNetworkIsRegistered(uint256)";
            const SELECTOR: [u8; 4] = [198u8, 179u8, 2u8, 77u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `coprocessorTxSenderAddresses(uint256)` and selector `0x5ab6d3ab`.
```solidity
function coprocessorTxSenderAddresses(uint256 index) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct coprocessorTxSenderAddressesCall {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`coprocessorTxSenderAddresses(uint256)`](coprocessorTxSenderAddressesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct coprocessorTxSenderAddressesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<coprocessorTxSenderAddressesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: coprocessorTxSenderAddressesCall) -> Self {
                    (value.index,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for coprocessorTxSenderAddressesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { index: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<coprocessorTxSenderAddressesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: coprocessorTxSenderAddressesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for coprocessorTxSenderAddressesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for coprocessorTxSenderAddressesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = coprocessorTxSenderAddressesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "coprocessorTxSenderAddresses(uint256)";
            const SELECTOR: [u8; 4] = [90u8, 182u8, 211u8, 171u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `coprocessors(address)` and selector `0xecbd96ab`.
```solidity
function coprocessors(address coprocessorTxSenderAddress) external view returns (Coprocessor memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct coprocessorsCall {
        #[allow(missing_docs)]
        pub coprocessorTxSenderAddress: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`coprocessors(address)`](coprocessorsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct coprocessorsReturn {
        #[allow(missing_docs)]
        pub _0: <Coprocessor as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<coprocessorsCall> for UnderlyingRustTuple<'_> {
                fn from(value: coprocessorsCall) -> Self {
                    (value.coprocessorTxSenderAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for coprocessorsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        coprocessorTxSenderAddress: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Coprocessor,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Coprocessor as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<coprocessorsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: coprocessorsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for coprocessorsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for coprocessorsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = coprocessorsReturn;
            type ReturnTuple<'a> = (Coprocessor,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "coprocessors(address)";
            const SELECTOR: [u8; 4] = [236u8, 189u8, 150u8, 171u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.coprocessorTxSenderAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getAllCoprocessorTxSenderAddresses()` and selector `0x8f4a7f5e`.
```solidity
function getAllCoprocessorTxSenderAddresses() external view returns (address[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAllCoprocessorTxSenderAddressesCall {}
    ///Container type for the return parameters of the [`getAllCoprocessorTxSenderAddresses()`](getAllCoprocessorTxSenderAddressesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAllCoprocessorTxSenderAddressesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAllCoprocessorTxSenderAddressesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAllCoprocessorTxSenderAddressesCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAllCoprocessorTxSenderAddressesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAllCoprocessorTxSenderAddressesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAllCoprocessorTxSenderAddressesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAllCoprocessorTxSenderAddressesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAllCoprocessorTxSenderAddressesCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getAllCoprocessorTxSenderAddressesReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAllCoprocessorTxSenderAddresses()";
            const SELECTOR: [u8; 4] = [143u8, 74u8, 127u8, 94u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getAllKmsTxSenderAddresses()` and selector `0xbda0b948`.
```solidity
function getAllKmsTxSenderAddresses() external view returns (address[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAllKmsTxSenderAddressesCall {}
    ///Container type for the return parameters of the [`getAllKmsTxSenderAddresses()`](getAllKmsTxSenderAddressesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAllKmsTxSenderAddressesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAllKmsTxSenderAddressesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAllKmsTxSenderAddressesCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAllKmsTxSenderAddressesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAllKmsTxSenderAddressesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAllKmsTxSenderAddressesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAllKmsTxSenderAddressesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAllKmsTxSenderAddressesCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getAllKmsTxSenderAddressesReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAllKmsTxSenderAddresses()";
            const SELECTOR: [u8; 4] = [189u8, 160u8, 185u8, 72u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getCoprocessorMajorityThreshold()` and selector `0x6799ef52`.
```solidity
function getCoprocessorMajorityThreshold() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCoprocessorMajorityThresholdCall {}
    ///Container type for the return parameters of the [`getCoprocessorMajorityThreshold()`](getCoprocessorMajorityThresholdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCoprocessorMajorityThresholdReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCoprocessorMajorityThresholdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCoprocessorMajorityThresholdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCoprocessorMajorityThresholdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCoprocessorMajorityThresholdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCoprocessorMajorityThresholdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCoprocessorMajorityThresholdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCoprocessorMajorityThresholdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCoprocessorMajorityThresholdReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCoprocessorMajorityThreshold()";
            const SELECTOR: [u8; 4] = [103u8, 153u8, 239u8, 82u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getKmsMajorityThreshold()` and selector `0x47cd4b3e`.
```solidity
function getKmsMajorityThreshold() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsMajorityThresholdCall {}
    ///Container type for the return parameters of the [`getKmsMajorityThreshold()`](getKmsMajorityThresholdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsMajorityThresholdReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsMajorityThresholdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsMajorityThresholdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsMajorityThresholdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsMajorityThresholdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsMajorityThresholdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsMajorityThresholdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsMajorityThresholdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsMajorityThresholdReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsMajorityThreshold()";
            const SELECTOR: [u8; 4] = [71u8, 205u8, 75u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getKmsReconstructionThreshold()` and selector `0x490413aa`.
```solidity
function getKmsReconstructionThreshold() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsReconstructionThresholdCall {}
    ///Container type for the return parameters of the [`getKmsReconstructionThreshold()`](getKmsReconstructionThresholdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsReconstructionThresholdReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsReconstructionThresholdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsReconstructionThresholdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsReconstructionThresholdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsReconstructionThresholdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsReconstructionThresholdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsReconstructionThresholdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsReconstructionThresholdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsReconstructionThresholdReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsReconstructionThreshold()";
            const SELECTOR: [u8; 4] = [73u8, 4u8, 19u8, 170u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getKmsThreshold()` and selector `0x4921a3bd`.
```solidity
function getKmsThreshold() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsThresholdCall {}
    ///Container type for the return parameters of the [`getKmsThreshold()`](getKmsThresholdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getKmsThresholdReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsThresholdCall> for UnderlyingRustTuple<'_> {
                fn from(value: getKmsThresholdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getKmsThresholdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getKmsThresholdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getKmsThresholdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getKmsThresholdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getKmsThresholdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getKmsThresholdReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getKmsThreshold()";
            const SELECTOR: [u8; 4] = [73u8, 33u8, 163u8, 189u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getProtocolMetadata()` and selector `0x48144c61`.
```solidity
function getProtocolMetadata() external view returns (ProtocolMetadata memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getProtocolMetadataCall {}
    ///Container type for the return parameters of the [`getProtocolMetadata()`](getProtocolMetadataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getProtocolMetadataReturn {
        #[allow(missing_docs)]
        pub _0: <ProtocolMetadata as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getProtocolMetadataCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getProtocolMetadataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getProtocolMetadataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ProtocolMetadata,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ProtocolMetadata as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getProtocolMetadataReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getProtocolMetadataReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getProtocolMetadataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getProtocolMetadataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getProtocolMetadataReturn;
            type ReturnTuple<'a> = (ProtocolMetadata,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getProtocolMetadata()";
            const SELECTOR: [u8; 4] = [72u8, 20u8, 76u8, 97u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getVersion()` and selector `0x0d8e6e2c`.
```solidity
function getVersion() external pure returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVersionCall {}
    ///Container type for the return parameters of the [`getVersion()`](getVersionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVersionReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVersionCall> for UnderlyingRustTuple<'_> {
                fn from(value: getVersionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVersionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVersionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getVersionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVersionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getVersionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getVersionReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getVersion()";
            const SELECTOR: [u8; 4] = [13u8, 142u8, 110u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `initialize(address,(string,string),uint256,(address,address,string)[],(address,address,string)[])` and selector `0xd98189a4`.
```solidity
function initialize(address initialPauser, ProtocolMetadata memory initialMetadata, uint256 initialKmsThreshold, KmsNode[] memory initialKmsNodes, Coprocessor[] memory initialCoprocessors) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeCall {
        #[allow(missing_docs)]
        pub initialPauser: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub initialMetadata: <ProtocolMetadata as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub initialKmsThreshold: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub initialKmsNodes: alloy::sol_types::private::Vec<
            <KmsNode as alloy::sol_types::SolType>::RustType,
        >,
        #[allow(missing_docs)]
        pub initialCoprocessors: alloy::sol_types::private::Vec<
            <Coprocessor as alloy::sol_types::SolType>::RustType,
        >,
    }
    ///Container type for the return parameters of the [`initialize(address,(string,string),uint256,(address,address,string)[],(address,address,string)[])`](initializeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                ProtocolMetadata,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<KmsNode>,
                alloy::sol_types::sol_data::Array<Coprocessor>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                <ProtocolMetadata as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Vec<
                    <KmsNode as alloy::sol_types::SolType>::RustType,
                >,
                alloy::sol_types::private::Vec<
                    <Coprocessor as alloy::sol_types::SolType>::RustType,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeCall> for UnderlyingRustTuple<'_> {
                fn from(value: initializeCall) -> Self {
                    (
                        value.initialPauser,
                        value.initialMetadata,
                        value.initialKmsThreshold,
                        value.initialKmsNodes,
                        value.initialCoprocessors,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        initialPauser: tuple.0,
                        initialMetadata: tuple.1,
                        initialKmsThreshold: tuple.2,
                        initialKmsNodes: tuple.3,
                        initialCoprocessors: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: initializeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                ProtocolMetadata,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<KmsNode>,
                alloy::sol_types::sol_data::Array<Coprocessor>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initialize(address,(string,string),uint256,(address,address,string)[],(address,address,string)[])";
            const SELECTOR: [u8; 4] = [217u8, 129u8, 137u8, 164u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.initialPauser,
                    ),
                    <ProtocolMetadata as alloy_sol_types::SolType>::tokenize(
                        &self.initialMetadata,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.initialKmsThreshold),
                    <alloy::sol_types::sol_data::Array<
                        KmsNode,
                    > as alloy_sol_types::SolType>::tokenize(&self.initialKmsNodes),
                    <alloy::sol_types::sol_data::Array<
                        Coprocessor,
                    > as alloy_sol_types::SolType>::tokenize(&self.initialCoprocessors),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `kmsNodes(address)` and selector `0x54d3f675`.
```solidity
function kmsNodes(address kmsTxSenderAddress) external view returns (KmsNode memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct kmsNodesCall {
        #[allow(missing_docs)]
        pub kmsTxSenderAddress: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`kmsNodes(address)`](kmsNodesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct kmsNodesReturn {
        #[allow(missing_docs)]
        pub _0: <KmsNode as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<kmsNodesCall> for UnderlyingRustTuple<'_> {
                fn from(value: kmsNodesCall) -> Self {
                    (value.kmsTxSenderAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for kmsNodesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        kmsTxSenderAddress: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (KmsNode,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <KmsNode as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<kmsNodesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: kmsNodesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for kmsNodesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for kmsNodesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = kmsNodesReturn;
            type ReturnTuple<'a> = (KmsNode,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "kmsNodes(address)";
            const SELECTOR: [u8; 4] = [84u8, 211u8, 246u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.kmsTxSenderAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `kmsTxSenderAddresses(uint256)` and selector `0xd5244bf1`.
```solidity
function kmsTxSenderAddresses(uint256 index) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct kmsTxSenderAddressesCall {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`kmsTxSenderAddresses(uint256)`](kmsTxSenderAddressesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct kmsTxSenderAddressesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<kmsTxSenderAddressesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: kmsTxSenderAddressesCall) -> Self {
                    (value.index,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for kmsTxSenderAddressesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { index: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<kmsTxSenderAddressesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: kmsTxSenderAddressesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for kmsTxSenderAddressesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for kmsTxSenderAddressesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = kmsTxSenderAddressesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "kmsTxSenderAddresses(uint256)";
            const SELECTOR: [u8; 4] = [213u8, 36u8, 75u8, 241u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `networks(uint256)` and selector `0x8bb0a17c`.
```solidity
function networks(uint256 index) external view returns (Network memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct networksCall {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`networks(uint256)`](networksCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct networksReturn {
        #[allow(missing_docs)]
        pub _0: <Network as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<networksCall> for UnderlyingRustTuple<'_> {
                fn from(value: networksCall) -> Self {
                    (value.index,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for networksCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { index: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Network,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Network as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<networksReturn> for UnderlyingRustTuple<'_> {
                fn from(value: networksReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for networksReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for networksCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = networksReturn;
            type ReturnTuple<'a> = (Network,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "networks(uint256)";
            const SELECTOR: [u8; 4] = [139u8, 176u8, 161u8, 124u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall {}
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ownerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pendingOwner()` and selector `0xe30c3978`.
```solidity
function pendingOwner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingOwnerCall {}
    ///Container type for the return parameters of the [`pendingOwner()`](pendingOwnerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingOwnerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingOwnerCall> for UnderlyingRustTuple<'_> {
                fn from(value: pendingOwnerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pendingOwnerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingOwnerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pendingOwnerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pendingOwnerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pendingOwnerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pendingOwnerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pendingOwner()";
            const SELECTOR: [u8; 4] = [227u8, 12u8, 57u8, 120u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `proxiableUUID()` and selector `0x52d1902d`.
```solidity
function proxiableUUID() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDCall {}
    ///Container type for the return parameters of the [`proxiableUUID()`](proxiableUUIDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDCall> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proxiableUUIDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = proxiableUUIDReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "proxiableUUID()";
            const SELECTOR: [u8; 4] = [82u8, 209u8, 144u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceOwnership()` and selector `0x715018a6`.
```solidity
function renounceOwnership() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall {}
    ///Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address newOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `updateKmsThreshold(uint256)` and selector `0x0219150f`.
```solidity
function updateKmsThreshold(uint256 newKmsThreshold) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateKmsThresholdCall {
        #[allow(missing_docs)]
        pub newKmsThreshold: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`updateKmsThreshold(uint256)`](updateKmsThresholdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateKmsThresholdReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateKmsThresholdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateKmsThresholdCall) -> Self {
                    (value.newKmsThreshold,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateKmsThresholdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newKmsThreshold: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateKmsThresholdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateKmsThresholdReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateKmsThresholdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateKmsThresholdCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateKmsThresholdReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateKmsThreshold(uint256)";
            const SELECTOR: [u8; 4] = [2u8, 25u8, 21u8, 15u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newKmsThreshold),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `upgradeToAndCall(address,bytes)` and selector `0x4f1ef286`.
```solidity
function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallCall {
        #[allow(missing_docs)]
        pub newImplementation: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`upgradeToAndCall(address,bytes)`](upgradeToAndCallCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallCall) -> Self {
                    (value.newImplementation, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newImplementation: tuple.0,
                        data: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for upgradeToAndCallCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = upgradeToAndCallReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "upgradeToAndCall(address,bytes)";
            const SELECTOR: [u8; 4] = [79u8, 30u8, 242u8, 134u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newImplementation,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`HTTPZ`](self) function calls.
    pub enum HTTPZCalls {
        #[allow(missing_docs)]
        UPGRADE_INTERFACE_VERSION(UPGRADE_INTERFACE_VERSIONCall),
        #[allow(missing_docs)]
        acceptOwnership(acceptOwnershipCall),
        #[allow(missing_docs)]
        addNetwork(addNetworkCall),
        #[allow(missing_docs)]
        checkIsCoprocessorSigner(checkIsCoprocessorSignerCall),
        #[allow(missing_docs)]
        checkIsCoprocessorTxSender(checkIsCoprocessorTxSenderCall),
        #[allow(missing_docs)]
        checkIsKmsSigner(checkIsKmsSignerCall),
        #[allow(missing_docs)]
        checkIsKmsTxSender(checkIsKmsTxSenderCall),
        #[allow(missing_docs)]
        checkIsPauser(checkIsPauserCall),
        #[allow(missing_docs)]
        checkNetworkIsRegistered(checkNetworkIsRegisteredCall),
        #[allow(missing_docs)]
        coprocessorTxSenderAddresses(coprocessorTxSenderAddressesCall),
        #[allow(missing_docs)]
        coprocessors(coprocessorsCall),
        #[allow(missing_docs)]
        getAllCoprocessorTxSenderAddresses(getAllCoprocessorTxSenderAddressesCall),
        #[allow(missing_docs)]
        getAllKmsTxSenderAddresses(getAllKmsTxSenderAddressesCall),
        #[allow(missing_docs)]
        getCoprocessorMajorityThreshold(getCoprocessorMajorityThresholdCall),
        #[allow(missing_docs)]
        getKmsMajorityThreshold(getKmsMajorityThresholdCall),
        #[allow(missing_docs)]
        getKmsReconstructionThreshold(getKmsReconstructionThresholdCall),
        #[allow(missing_docs)]
        getKmsThreshold(getKmsThresholdCall),
        #[allow(missing_docs)]
        getProtocolMetadata(getProtocolMetadataCall),
        #[allow(missing_docs)]
        getVersion(getVersionCall),
        #[allow(missing_docs)]
        initialize(initializeCall),
        #[allow(missing_docs)]
        kmsNodes(kmsNodesCall),
        #[allow(missing_docs)]
        kmsTxSenderAddresses(kmsTxSenderAddressesCall),
        #[allow(missing_docs)]
        networks(networksCall),
        #[allow(missing_docs)]
        owner(ownerCall),
        #[allow(missing_docs)]
        pendingOwner(pendingOwnerCall),
        #[allow(missing_docs)]
        proxiableUUID(proxiableUUIDCall),
        #[allow(missing_docs)]
        renounceOwnership(renounceOwnershipCall),
        #[allow(missing_docs)]
        transferOwnership(transferOwnershipCall),
        #[allow(missing_docs)]
        updateKmsThreshold(updateKmsThresholdCall),
        #[allow(missing_docs)]
        upgradeToAndCall(upgradeToAndCallCall),
    }
    #[automatically_derived]
    impl HTTPZCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [2u8, 25u8, 21u8, 15u8],
            [13u8, 142u8, 110u8, 44u8],
            [25u8, 90u8, 253u8, 230u8],
            [71u8, 205u8, 75u8, 62u8],
            [72u8, 20u8, 76u8, 97u8],
            [73u8, 4u8, 19u8, 170u8],
            [73u8, 33u8, 163u8, 189u8],
            [79u8, 30u8, 242u8, 134u8],
            [82u8, 209u8, 144u8, 45u8],
            [84u8, 211u8, 246u8, 117u8],
            [90u8, 182u8, 211u8, 171u8],
            [103u8, 153u8, 239u8, 82u8],
            [108u8, 136u8, 235u8, 67u8],
            [112u8, 204u8, 154u8, 60u8],
            [113u8, 80u8, 24u8, 166u8],
            [121u8, 186u8, 80u8, 151u8],
            [139u8, 176u8, 161u8, 124u8],
            [141u8, 165u8, 203u8, 91u8],
            [143u8, 74u8, 127u8, 94u8],
            [173u8, 60u8, 177u8, 204u8],
            [189u8, 160u8, 185u8, 72u8],
            [198u8, 39u8, 82u8, 88u8],
            [198u8, 179u8, 2u8, 77u8],
            [203u8, 102u8, 23u8, 85u8],
            [205u8, 180u8, 194u8, 185u8],
            [213u8, 36u8, 75u8, 241u8],
            [217u8, 129u8, 137u8, 164u8],
            [227u8, 12u8, 57u8, 120u8],
            [236u8, 189u8, 150u8, 171u8],
            [242u8, 253u8, 227u8, 139u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for HTTPZCalls {
        const NAME: &'static str = "HTTPZCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 30usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(_) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::acceptOwnership(_) => {
                    <acceptOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::addNetwork(_) => {
                    <addNetworkCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkIsCoprocessorSigner(_) => {
                    <checkIsCoprocessorSignerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkIsCoprocessorTxSender(_) => {
                    <checkIsCoprocessorTxSenderCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkIsKmsSigner(_) => {
                    <checkIsKmsSignerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkIsKmsTxSender(_) => {
                    <checkIsKmsTxSenderCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkIsPauser(_) => {
                    <checkIsPauserCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkNetworkIsRegistered(_) => {
                    <checkNetworkIsRegisteredCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::coprocessorTxSenderAddresses(_) => {
                    <coprocessorTxSenderAddressesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::coprocessors(_) => {
                    <coprocessorsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAllCoprocessorTxSenderAddresses(_) => {
                    <getAllCoprocessorTxSenderAddressesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAllKmsTxSenderAddresses(_) => {
                    <getAllKmsTxSenderAddressesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCoprocessorMajorityThreshold(_) => {
                    <getCoprocessorMajorityThresholdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsMajorityThreshold(_) => {
                    <getKmsMajorityThresholdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsReconstructionThreshold(_) => {
                    <getKmsReconstructionThresholdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getKmsThreshold(_) => {
                    <getKmsThresholdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getProtocolMetadata(_) => {
                    <getProtocolMetadataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getVersion(_) => {
                    <getVersionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initialize(_) => {
                    <initializeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::kmsNodes(_) => <kmsNodesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::kmsTxSenderAddresses(_) => {
                    <kmsTxSenderAddressesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::networks(_) => <networksCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pendingOwner(_) => {
                    <pendingOwnerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::proxiableUUID(_) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceOwnership(_) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateKmsThreshold(_) => {
                    <updateKmsThresholdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::upgradeToAndCall(_) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<HTTPZCalls>] = &[
                {
                    fn updateKmsThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <updateKmsThresholdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::updateKmsThreshold)
                    }
                    updateKmsThreshold
                },
                {
                    fn getVersion(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <getVersionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::getVersion)
                    }
                    getVersion
                },
                {
                    fn checkIsPauser(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <checkIsPauserCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::checkIsPauser)
                    }
                    checkIsPauser
                },
                {
                    fn getKmsMajorityThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <getKmsMajorityThresholdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::getKmsMajorityThreshold)
                    }
                    getKmsMajorityThreshold
                },
                {
                    fn getProtocolMetadata(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <getProtocolMetadataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::getProtocolMetadata)
                    }
                    getProtocolMetadata
                },
                {
                    fn getKmsReconstructionThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <getKmsReconstructionThresholdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::getKmsReconstructionThreshold)
                    }
                    getKmsReconstructionThreshold
                },
                {
                    fn getKmsThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <getKmsThresholdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::getKmsThreshold)
                    }
                    getKmsThreshold
                },
                {
                    fn upgradeToAndCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::upgradeToAndCall)
                    }
                    upgradeToAndCall
                },
                {
                    fn proxiableUUID(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::proxiableUUID)
                    }
                    proxiableUUID
                },
                {
                    fn kmsNodes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <kmsNodesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::kmsNodes)
                    }
                    kmsNodes
                },
                {
                    fn coprocessorTxSenderAddresses(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <coprocessorTxSenderAddressesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::coprocessorTxSenderAddresses)
                    }
                    coprocessorTxSenderAddresses
                },
                {
                    fn getCoprocessorMajorityThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <getCoprocessorMajorityThresholdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::getCoprocessorMajorityThreshold)
                    }
                    getCoprocessorMajorityThreshold
                },
                {
                    fn checkIsKmsSigner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <checkIsKmsSignerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::checkIsKmsSigner)
                    }
                    checkIsKmsSigner
                },
                {
                    fn addNetwork(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <addNetworkCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::addNetwork)
                    }
                    addNetwork
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn acceptOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <acceptOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::acceptOwnership)
                    }
                    acceptOwnership
                },
                {
                    fn networks(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <networksCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::networks)
                    }
                    networks
                },
                {
                    fn owner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::owner)
                    }
                    owner
                },
                {
                    fn getAllCoprocessorTxSenderAddresses(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <getAllCoprocessorTxSenderAddressesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::getAllCoprocessorTxSenderAddresses)
                    }
                    getAllCoprocessorTxSenderAddresses
                },
                {
                    fn UPGRADE_INTERFACE_VERSION(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::UPGRADE_INTERFACE_VERSION)
                    }
                    UPGRADE_INTERFACE_VERSION
                },
                {
                    fn getAllKmsTxSenderAddresses(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <getAllKmsTxSenderAddressesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::getAllKmsTxSenderAddresses)
                    }
                    getAllKmsTxSenderAddresses
                },
                {
                    fn checkIsKmsTxSender(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <checkIsKmsTxSenderCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::checkIsKmsTxSender)
                    }
                    checkIsKmsTxSender
                },
                {
                    fn checkNetworkIsRegistered(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <checkNetworkIsRegisteredCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::checkNetworkIsRegistered)
                    }
                    checkNetworkIsRegistered
                },
                {
                    fn checkIsCoprocessorTxSender(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <checkIsCoprocessorTxSenderCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::checkIsCoprocessorTxSender)
                    }
                    checkIsCoprocessorTxSender
                },
                {
                    fn checkIsCoprocessorSigner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <checkIsCoprocessorSignerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::checkIsCoprocessorSigner)
                    }
                    checkIsCoprocessorSigner
                },
                {
                    fn kmsTxSenderAddresses(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <kmsTxSenderAddressesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::kmsTxSenderAddresses)
                    }
                    kmsTxSenderAddresses
                },
                {
                    fn initialize(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::initialize)
                    }
                    initialize
                },
                {
                    fn pendingOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <pendingOwnerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::pendingOwner)
                    }
                    pendingOwner
                },
                {
                    fn coprocessors(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <coprocessorsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::coprocessors)
                    }
                    coprocessors
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZCalls::transferOwnership)
                    }
                    transferOwnership
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::acceptOwnership(inner) => {
                    <acceptOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::addNetwork(inner) => {
                    <addNetworkCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::checkIsCoprocessorSigner(inner) => {
                    <checkIsCoprocessorSignerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkIsCoprocessorTxSender(inner) => {
                    <checkIsCoprocessorTxSenderCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkIsKmsSigner(inner) => {
                    <checkIsKmsSignerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkIsKmsTxSender(inner) => {
                    <checkIsKmsTxSenderCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkIsPauser(inner) => {
                    <checkIsPauserCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkNetworkIsRegistered(inner) => {
                    <checkNetworkIsRegisteredCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::coprocessorTxSenderAddresses(inner) => {
                    <coprocessorTxSenderAddressesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::coprocessors(inner) => {
                    <coprocessorsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAllCoprocessorTxSenderAddresses(inner) => {
                    <getAllCoprocessorTxSenderAddressesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAllKmsTxSenderAddresses(inner) => {
                    <getAllKmsTxSenderAddressesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCoprocessorMajorityThreshold(inner) => {
                    <getCoprocessorMajorityThresholdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKmsMajorityThreshold(inner) => {
                    <getKmsMajorityThresholdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKmsReconstructionThreshold(inner) => {
                    <getKmsReconstructionThresholdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getKmsThreshold(inner) => {
                    <getKmsThresholdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getProtocolMetadata(inner) => {
                    <getProtocolMetadataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getVersion(inner) => {
                    <getVersionCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::kmsNodes(inner) => {
                    <kmsNodesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::kmsTxSenderAddresses(inner) => {
                    <kmsTxSenderAddressesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::networks(inner) => {
                    <networksCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pendingOwner(inner) => {
                    <pendingOwnerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateKmsThreshold(inner) => {
                    <updateKmsThresholdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::acceptOwnership(inner) => {
                    <acceptOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::addNetwork(inner) => {
                    <addNetworkCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkIsCoprocessorSigner(inner) => {
                    <checkIsCoprocessorSignerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkIsCoprocessorTxSender(inner) => {
                    <checkIsCoprocessorTxSenderCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkIsKmsSigner(inner) => {
                    <checkIsKmsSignerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkIsKmsTxSender(inner) => {
                    <checkIsKmsTxSenderCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkIsPauser(inner) => {
                    <checkIsPauserCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkNetworkIsRegistered(inner) => {
                    <checkNetworkIsRegisteredCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::coprocessorTxSenderAddresses(inner) => {
                    <coprocessorTxSenderAddressesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::coprocessors(inner) => {
                    <coprocessorsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAllCoprocessorTxSenderAddresses(inner) => {
                    <getAllCoprocessorTxSenderAddressesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAllKmsTxSenderAddresses(inner) => {
                    <getAllKmsTxSenderAddressesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCoprocessorMajorityThreshold(inner) => {
                    <getCoprocessorMajorityThresholdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsMajorityThreshold(inner) => {
                    <getKmsMajorityThresholdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsReconstructionThreshold(inner) => {
                    <getKmsReconstructionThresholdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getKmsThreshold(inner) => {
                    <getKmsThresholdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getProtocolMetadata(inner) => {
                    <getProtocolMetadataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getVersion(inner) => {
                    <getVersionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::kmsNodes(inner) => {
                    <kmsNodesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::kmsTxSenderAddresses(inner) => {
                    <kmsTxSenderAddressesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::networks(inner) => {
                    <networksCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pendingOwner(inner) => {
                    <pendingOwnerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateKmsThreshold(inner) => {
                    <updateKmsThresholdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`HTTPZ`](self) custom errors.
    pub enum HTTPZErrors {
        #[allow(missing_docs)]
        AddressEmptyCode(AddressEmptyCode),
        #[allow(missing_docs)]
        ERC1967InvalidImplementation(ERC1967InvalidImplementation),
        #[allow(missing_docs)]
        ERC1967NonPayable(ERC1967NonPayable),
        #[allow(missing_docs)]
        FailedCall(FailedCall),
        #[allow(missing_docs)]
        InvalidInitialization(InvalidInitialization),
        #[allow(missing_docs)]
        InvalidNullChainId(InvalidNullChainId),
        #[allow(missing_docs)]
        KmsThresholdTooHigh(KmsThresholdTooHigh),
        #[allow(missing_docs)]
        NetworkAlreadyRegistered(NetworkAlreadyRegistered),
        #[allow(missing_docs)]
        NetworkNotRegistered(NetworkNotRegistered),
        #[allow(missing_docs)]
        NotCoprocessorSigner(NotCoprocessorSigner),
        #[allow(missing_docs)]
        NotCoprocessorTxSender(NotCoprocessorTxSender),
        #[allow(missing_docs)]
        NotInitializing(NotInitializing),
        #[allow(missing_docs)]
        NotKmsSigner(NotKmsSigner),
        #[allow(missing_docs)]
        NotKmsTxSender(NotKmsTxSender),
        #[allow(missing_docs)]
        NotPauser(NotPauser),
        #[allow(missing_docs)]
        OwnableInvalidOwner(OwnableInvalidOwner),
        #[allow(missing_docs)]
        OwnableUnauthorizedAccount(OwnableUnauthorizedAccount),
        #[allow(missing_docs)]
        UUPSUnauthorizedCallContext(UUPSUnauthorizedCallContext),
        #[allow(missing_docs)]
        UUPSUnsupportedProxiableUUID(UUPSUnsupportedProxiableUUID),
    }
    #[automatically_derived]
    impl HTTPZErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [17u8, 140u8, 218u8, 167u8],
            [30u8, 79u8, 189u8, 247u8],
            [32u8, 106u8, 52u8, 110u8],
            [34u8, 247u8, 63u8, 234u8],
            [38u8, 205u8, 117u8, 220u8],
            [42u8, 124u8, 110u8, 246u8],
            [72u8, 103u8, 111u8, 224u8],
            [76u8, 156u8, 140u8, 227u8],
            [82u8, 215u8, 37u8, 245u8],
            [109u8, 246u8, 254u8, 137u8],
            [153u8, 150u8, 179u8, 21u8],
            [170u8, 29u8, 73u8, 164u8],
            [174u8, 232u8, 99u8, 35u8],
            [177u8, 130u8, 92u8, 94u8],
            [179u8, 152u8, 151u8, 159u8],
            [214u8, 189u8, 162u8, 117u8],
            [215u8, 230u8, 188u8, 248u8],
            [224u8, 124u8, 141u8, 186u8],
            [249u8, 46u8, 232u8, 169u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for HTTPZErrors {
        const NAME: &'static str = "HTTPZErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 19usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AddressEmptyCode(_) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967InvalidImplementation(_) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967NonPayable(_) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FailedCall(_) => {
                    <FailedCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidInitialization(_) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidNullChainId(_) => {
                    <InvalidNullChainId as alloy_sol_types::SolError>::SELECTOR
                }
                Self::KmsThresholdTooHigh(_) => {
                    <KmsThresholdTooHigh as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NetworkAlreadyRegistered(_) => {
                    <NetworkAlreadyRegistered as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NetworkNotRegistered(_) => {
                    <NetworkNotRegistered as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotCoprocessorSigner(_) => {
                    <NotCoprocessorSigner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotCoprocessorTxSender(_) => {
                    <NotCoprocessorTxSender as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotInitializing(_) => {
                    <NotInitializing as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotKmsSigner(_) => {
                    <NotKmsSigner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotKmsTxSender(_) => {
                    <NotKmsTxSender as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotPauser(_) => <NotPauser as alloy_sol_types::SolError>::SELECTOR,
                Self::OwnableInvalidOwner(_) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OwnableUnauthorizedAccount(_) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnauthorizedCallContext(_) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnsupportedProxiableUUID(_) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<HTTPZErrors>] = &[
                {
                    fn OwnableUnauthorizedAccount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::OwnableUnauthorizedAccount)
                    }
                    OwnableUnauthorizedAccount
                },
                {
                    fn OwnableInvalidOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::OwnableInvalidOwner)
                    }
                    OwnableInvalidOwner
                },
                {
                    fn NotPauser(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <NotPauser as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::NotPauser)
                    }
                    NotPauser
                },
                {
                    fn InvalidNullChainId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <InvalidNullChainId as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::InvalidNullChainId)
                    }
                    InvalidNullChainId
                },
                {
                    fn NotCoprocessorSigner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <NotCoprocessorSigner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::NotCoprocessorSigner)
                    }
                    NotCoprocessorSigner
                },
                {
                    fn NotKmsSigner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <NotKmsSigner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::NotKmsSigner)
                    }
                    NotKmsSigner
                },
                {
                    fn KmsThresholdTooHigh(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <KmsThresholdTooHigh as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::KmsThresholdTooHigh)
                    }
                    KmsThresholdTooHigh
                },
                {
                    fn ERC1967InvalidImplementation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::ERC1967InvalidImplementation)
                    }
                    ERC1967InvalidImplementation
                },
                {
                    fn NotCoprocessorTxSender(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <NotCoprocessorTxSender as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::NotCoprocessorTxSender)
                    }
                    NotCoprocessorTxSender
                },
                {
                    fn NetworkNotRegistered(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <NetworkNotRegistered as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::NetworkNotRegistered)
                    }
                    NetworkNotRegistered
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn UUPSUnsupportedProxiableUUID(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::UUPSUnsupportedProxiableUUID)
                    }
                    UUPSUnsupportedProxiableUUID
                },
                {
                    fn NotKmsTxSender(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <NotKmsTxSender as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::NotKmsTxSender)
                    }
                    NotKmsTxSender
                },
                {
                    fn NetworkAlreadyRegistered(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <NetworkAlreadyRegistered as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::NetworkAlreadyRegistered)
                    }
                    NetworkAlreadyRegistered
                },
                {
                    fn ERC1967NonPayable(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <ERC1967NonPayable as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::ERC1967NonPayable)
                    }
                    ERC1967NonPayable
                },
                {
                    fn FailedCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn UUPSUnauthorizedCallContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::UUPSUnauthorizedCallContext)
                    }
                    UUPSUnauthorizedCallContext
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<HTTPZErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(HTTPZErrors::InvalidInitialization)
                    }
                    InvalidInitialization
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidNullChainId(inner) => {
                    <InvalidNullChainId as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::KmsThresholdTooHigh(inner) => {
                    <KmsThresholdTooHigh as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NetworkAlreadyRegistered(inner) => {
                    <NetworkAlreadyRegistered as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NetworkNotRegistered(inner) => {
                    <NetworkNotRegistered as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotCoprocessorSigner(inner) => {
                    <NotCoprocessorSigner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotCoprocessorTxSender(inner) => {
                    <NotCoprocessorTxSender as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotKmsSigner(inner) => {
                    <NotKmsSigner as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NotKmsTxSender(inner) => {
                    <NotKmsTxSender as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotPauser(inner) => {
                    <NotPauser as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::OwnableInvalidOwner(inner) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OwnableUnauthorizedAccount(inner) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidNullChainId(inner) => {
                    <InvalidNullChainId as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::KmsThresholdTooHigh(inner) => {
                    <KmsThresholdTooHigh as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NetworkAlreadyRegistered(inner) => {
                    <NetworkAlreadyRegistered as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NetworkNotRegistered(inner) => {
                    <NetworkNotRegistered as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotCoprocessorSigner(inner) => {
                    <NotCoprocessorSigner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotCoprocessorTxSender(inner) => {
                    <NotCoprocessorTxSender as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotKmsSigner(inner) => {
                    <NotKmsSigner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotKmsTxSender(inner) => {
                    <NotKmsTxSender as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotPauser(inner) => {
                    <NotPauser as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::OwnableInvalidOwner(inner) => {
                    <OwnableInvalidOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OwnableUnauthorizedAccount(inner) => {
                    <OwnableUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`HTTPZ`](self) events.
    pub enum HTTPZEvents {
        #[allow(missing_docs)]
        AddNetwork(AddNetwork),
        #[allow(missing_docs)]
        Initialization(Initialization),
        #[allow(missing_docs)]
        Initialized(Initialized),
        #[allow(missing_docs)]
        OwnershipTransferStarted(OwnershipTransferStarted),
        #[allow(missing_docs)]
        OwnershipTransferred(OwnershipTransferred),
        #[allow(missing_docs)]
        UpdateKmsThreshold(UpdateKmsThreshold),
        #[allow(missing_docs)]
        Upgraded(Upgraded),
    }
    #[automatically_derived]
    impl HTTPZEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                56u8,
                209u8,
                107u8,
                140u8,
                172u8,
                34u8,
                217u8,
                159u8,
                199u8,
                193u8,
                36u8,
                185u8,
                205u8,
                13u8,
                226u8,
                211u8,
                250u8,
                31u8,
                174u8,
                244u8,
                32u8,
                191u8,
                231u8,
                145u8,
                216u8,
                195u8,
                98u8,
                215u8,
                101u8,
                226u8,
                39u8,
                0u8,
            ],
            [
                139u8,
                224u8,
                7u8,
                156u8,
                83u8,
                22u8,
                89u8,
                20u8,
                19u8,
                68u8,
                205u8,
                31u8,
                208u8,
                164u8,
                242u8,
                132u8,
                25u8,
                73u8,
                127u8,
                151u8,
                34u8,
                163u8,
                218u8,
                175u8,
                227u8,
                180u8,
                24u8,
                111u8,
                107u8,
                100u8,
                87u8,
                224u8,
            ],
            [
                184u8,
                32u8,
                123u8,
                91u8,
                183u8,
                145u8,
                115u8,
                10u8,
                232u8,
                240u8,
                83u8,
                79u8,
                164u8,
                199u8,
                190u8,
                125u8,
                164u8,
                157u8,
                215u8,
                93u8,
                112u8,
                31u8,
                156u8,
                122u8,
                207u8,
                81u8,
                201u8,
                75u8,
                138u8,
                206u8,
                150u8,
                178u8,
            ],
            [
                188u8,
                124u8,
                215u8,
                90u8,
                32u8,
                238u8,
                39u8,
                253u8,
                154u8,
                222u8,
                186u8,
                179u8,
                32u8,
                65u8,
                247u8,
                85u8,
                33u8,
                77u8,
                188u8,
                107u8,
                255u8,
                169u8,
                12u8,
                192u8,
                34u8,
                91u8,
                57u8,
                218u8,
                46u8,
                92u8,
                45u8,
                59u8,
            ],
            [
                199u8,
                245u8,
                5u8,
                178u8,
                243u8,
                113u8,
                174u8,
                33u8,
                117u8,
                238u8,
                73u8,
                19u8,
                244u8,
                73u8,
                158u8,
                31u8,
                38u8,
                51u8,
                167u8,
                181u8,
                147u8,
                99u8,
                33u8,
                238u8,
                209u8,
                205u8,
                174u8,
                182u8,
                17u8,
                81u8,
                129u8,
                210u8,
            ],
            [
                234u8,
                108u8,
                101u8,
                33u8,
                188u8,
                73u8,
                87u8,
                49u8,
                8u8,
                46u8,
                35u8,
                173u8,
                18u8,
                199u8,
                177u8,
                32u8,
                125u8,
                19u8,
                202u8,
                11u8,
                211u8,
                141u8,
                29u8,
                81u8,
                16u8,
                129u8,
                171u8,
                86u8,
                137u8,
                23u8,
                203u8,
                132u8,
            ],
            [
                243u8,
                61u8,
                144u8,
                140u8,
                74u8,
                139u8,
                83u8,
                47u8,
                230u8,
                77u8,
                242u8,
                11u8,
                114u8,
                111u8,
                17u8,
                64u8,
                92u8,
                17u8,
                185u8,
                119u8,
                45u8,
                49u8,
                182u8,
                111u8,
                94u8,
                239u8,
                104u8,
                135u8,
                164u8,
                60u8,
                63u8,
                222u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for HTTPZEvents {
        const NAME: &'static str = "HTTPZEvents";
        const COUNT: usize = 7usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<AddNetwork as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <AddNetwork as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::AddNetwork)
                }
                Some(<Initialization as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialization as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Initialization)
                }
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Initialized)
                }
                Some(
                    <OwnershipTransferStarted as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferStarted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OwnershipTransferStarted)
                }
                Some(
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OwnershipTransferred)
                }
                Some(
                    <UpdateKmsThreshold as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <UpdateKmsThreshold as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::UpdateKmsThreshold)
                }
                Some(<Upgraded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Upgraded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Upgraded)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for HTTPZEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AddNetwork(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialization(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::UpdateKmsThreshold(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AddNetwork(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialization(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::UpdateKmsThreshold(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`HTTPZ`](self) contract instance.

See the [wrapper's documentation](`HTTPZInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> HTTPZInstance<T, P, N> {
        HTTPZInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<HTTPZInstance<T, P, N>>,
    > {
        HTTPZInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        HTTPZInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`HTTPZ`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`HTTPZ`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct HTTPZInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for HTTPZInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("HTTPZInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > HTTPZInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`HTTPZ`](self) contract instance.

See the [wrapper's documentation](`HTTPZInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<HTTPZInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> HTTPZInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> HTTPZInstance<T, P, N> {
            HTTPZInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > HTTPZInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`UPGRADE_INTERFACE_VERSION`] function.
        pub fn UPGRADE_INTERFACE_VERSION(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, UPGRADE_INTERFACE_VERSIONCall, N> {
            self.call_builder(&UPGRADE_INTERFACE_VERSIONCall {})
        }
        ///Creates a new call builder for the [`acceptOwnership`] function.
        pub fn acceptOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, acceptOwnershipCall, N> {
            self.call_builder(&acceptOwnershipCall {})
        }
        ///Creates a new call builder for the [`addNetwork`] function.
        pub fn addNetwork(
            &self,
            network: <Network as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, addNetworkCall, N> {
            self.call_builder(&addNetworkCall { network })
        }
        ///Creates a new call builder for the [`checkIsCoprocessorSigner`] function.
        pub fn checkIsCoprocessorSigner(
            &self,
            signerAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkIsCoprocessorSignerCall, N> {
            self.call_builder(
                &checkIsCoprocessorSignerCall {
                    signerAddress,
                },
            )
        }
        ///Creates a new call builder for the [`checkIsCoprocessorTxSender`] function.
        pub fn checkIsCoprocessorTxSender(
            &self,
            txSenderAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkIsCoprocessorTxSenderCall, N> {
            self.call_builder(
                &checkIsCoprocessorTxSenderCall {
                    txSenderAddress,
                },
            )
        }
        ///Creates a new call builder for the [`checkIsKmsSigner`] function.
        pub fn checkIsKmsSigner(
            &self,
            signerAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkIsKmsSignerCall, N> {
            self.call_builder(
                &checkIsKmsSignerCall {
                    signerAddress,
                },
            )
        }
        ///Creates a new call builder for the [`checkIsKmsTxSender`] function.
        pub fn checkIsKmsTxSender(
            &self,
            txSenderAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkIsKmsTxSenderCall, N> {
            self.call_builder(
                &checkIsKmsTxSenderCall {
                    txSenderAddress,
                },
            )
        }
        ///Creates a new call builder for the [`checkIsPauser`] function.
        pub fn checkIsPauser(
            &self,
            pauserAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkIsPauserCall, N> {
            self.call_builder(&checkIsPauserCall { pauserAddress })
        }
        ///Creates a new call builder for the [`checkNetworkIsRegistered`] function.
        pub fn checkNetworkIsRegistered(
            &self,
            chainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkNetworkIsRegisteredCall, N> {
            self.call_builder(
                &checkNetworkIsRegisteredCall {
                    chainId,
                },
            )
        }
        ///Creates a new call builder for the [`coprocessorTxSenderAddresses`] function.
        pub fn coprocessorTxSenderAddresses(
            &self,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, coprocessorTxSenderAddressesCall, N> {
            self.call_builder(
                &coprocessorTxSenderAddressesCall {
                    index,
                },
            )
        }
        ///Creates a new call builder for the [`coprocessors`] function.
        pub fn coprocessors(
            &self,
            coprocessorTxSenderAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, coprocessorsCall, N> {
            self.call_builder(
                &coprocessorsCall {
                    coprocessorTxSenderAddress,
                },
            )
        }
        ///Creates a new call builder for the [`getAllCoprocessorTxSenderAddresses`] function.
        pub fn getAllCoprocessorTxSenderAddresses(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            getAllCoprocessorTxSenderAddressesCall,
            N,
        > {
            self.call_builder(
                &getAllCoprocessorTxSenderAddressesCall {
                },
            )
        }
        ///Creates a new call builder for the [`getAllKmsTxSenderAddresses`] function.
        pub fn getAllKmsTxSenderAddresses(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getAllKmsTxSenderAddressesCall, N> {
            self.call_builder(&getAllKmsTxSenderAddressesCall {})
        }
        ///Creates a new call builder for the [`getCoprocessorMajorityThreshold`] function.
        pub fn getCoprocessorMajorityThreshold(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            getCoprocessorMajorityThresholdCall,
            N,
        > {
            self.call_builder(
                &getCoprocessorMajorityThresholdCall {
                },
            )
        }
        ///Creates a new call builder for the [`getKmsMajorityThreshold`] function.
        pub fn getKmsMajorityThreshold(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getKmsMajorityThresholdCall, N> {
            self.call_builder(&getKmsMajorityThresholdCall {})
        }
        ///Creates a new call builder for the [`getKmsReconstructionThreshold`] function.
        pub fn getKmsReconstructionThreshold(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            getKmsReconstructionThresholdCall,
            N,
        > {
            self.call_builder(
                &getKmsReconstructionThresholdCall {
                },
            )
        }
        ///Creates a new call builder for the [`getKmsThreshold`] function.
        pub fn getKmsThreshold(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getKmsThresholdCall, N> {
            self.call_builder(&getKmsThresholdCall {})
        }
        ///Creates a new call builder for the [`getProtocolMetadata`] function.
        pub fn getProtocolMetadata(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getProtocolMetadataCall, N> {
            self.call_builder(&getProtocolMetadataCall {})
        }
        ///Creates a new call builder for the [`getVersion`] function.
        pub fn getVersion(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getVersionCall, N> {
            self.call_builder(&getVersionCall {})
        }
        ///Creates a new call builder for the [`initialize`] function.
        pub fn initialize(
            &self,
            initialPauser: alloy::sol_types::private::Address,
            initialMetadata: <ProtocolMetadata as alloy::sol_types::SolType>::RustType,
            initialKmsThreshold: alloy::sol_types::private::primitives::aliases::U256,
            initialKmsNodes: alloy::sol_types::private::Vec<
                <KmsNode as alloy::sol_types::SolType>::RustType,
            >,
            initialCoprocessors: alloy::sol_types::private::Vec<
                <Coprocessor as alloy::sol_types::SolType>::RustType,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, initializeCall, N> {
            self.call_builder(
                &initializeCall {
                    initialPauser,
                    initialMetadata,
                    initialKmsThreshold,
                    initialKmsNodes,
                    initialCoprocessors,
                },
            )
        }
        ///Creates a new call builder for the [`kmsNodes`] function.
        pub fn kmsNodes(
            &self,
            kmsTxSenderAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, kmsNodesCall, N> {
            self.call_builder(&kmsNodesCall { kmsTxSenderAddress })
        }
        ///Creates a new call builder for the [`kmsTxSenderAddresses`] function.
        pub fn kmsTxSenderAddresses(
            &self,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, kmsTxSenderAddressesCall, N> {
            self.call_builder(&kmsTxSenderAddressesCall { index })
        }
        ///Creates a new call builder for the [`networks`] function.
        pub fn networks(
            &self,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, networksCall, N> {
            self.call_builder(&networksCall { index })
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<T, &P, ownerCall, N> {
            self.call_builder(&ownerCall {})
        }
        ///Creates a new call builder for the [`pendingOwner`] function.
        pub fn pendingOwner(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, pendingOwnerCall, N> {
            self.call_builder(&pendingOwnerCall {})
        }
        ///Creates a new call builder for the [`proxiableUUID`] function.
        pub fn proxiableUUID(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, proxiableUUIDCall, N> {
            self.call_builder(&proxiableUUIDCall {})
        }
        ///Creates a new call builder for the [`renounceOwnership`] function.
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall {})
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
        ///Creates a new call builder for the [`updateKmsThreshold`] function.
        pub fn updateKmsThreshold(
            &self,
            newKmsThreshold: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, updateKmsThresholdCall, N> {
            self.call_builder(
                &updateKmsThresholdCall {
                    newKmsThreshold,
                },
            )
        }
        ///Creates a new call builder for the [`upgradeToAndCall`] function.
        pub fn upgradeToAndCall(
            &self,
            newImplementation: alloy::sol_types::private::Address,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, upgradeToAndCallCall, N> {
            self.call_builder(
                &upgradeToAndCallCall {
                    newImplementation,
                    data,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > HTTPZInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`AddNetwork`] event.
        pub fn AddNetwork_filter(&self) -> alloy_contract::Event<T, &P, AddNetwork, N> {
            self.event_filter::<AddNetwork>()
        }
        ///Creates a new event filter for the [`Initialization`] event.
        pub fn Initialization_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, Initialization, N> {
            self.event_filter::<Initialization>()
        }
        ///Creates a new event filter for the [`Initialized`] event.
        pub fn Initialized_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        ///Creates a new event filter for the [`OwnershipTransferStarted`] event.
        pub fn OwnershipTransferStarted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipTransferStarted, N> {
            self.event_filter::<OwnershipTransferStarted>()
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        ///Creates a new event filter for the [`UpdateKmsThreshold`] event.
        pub fn UpdateKmsThreshold_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, UpdateKmsThreshold, N> {
            self.event_filter::<UpdateKmsThreshold>()
        }
        ///Creates a new event filter for the [`Upgraded`] event.
        pub fn Upgraded_filter(&self) -> alloy_contract::Event<T, &P, Upgraded, N> {
            self.event_filter::<Upgraded>()
        }
    }
}
